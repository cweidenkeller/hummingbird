
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/troubling/hummingbird/accountserver/engine.go (77.1%)</option>
				
				<option value="file1">github.com/troubling/hummingbird/accountserver/incoming_rep.go (76.6%)</option>
				
				<option value="file2">github.com/troubling/hummingbird/accountserver/priorityrep.go (0.0%)</option>
				
				<option value="file3">github.com/troubling/hummingbird/accountserver/replicator.go (56.7%)</option>
				
				<option value="file4">github.com/troubling/hummingbird/accountserver/schema.go (59.5%)</option>
				
				<option value="file5">github.com/troubling/hummingbird/accountserver/server.go (60.0%)</option>
				
				<option value="file6">github.com/troubling/hummingbird/accountserver/sqlite_backend.go (65.0%)</option>
				
				<option value="file7">github.com/troubling/hummingbird/client/debug.go (0.0%)</option>
				
				<option value="file8">github.com/troubling/hummingbird/client/directclient.go (0.0%)</option>
				
				<option value="file9">github.com/troubling/hummingbird/client/nodeiter.go (95.5%)</option>
				
				<option value="file10">github.com/troubling/hummingbird/client/objclient.go (0.6%)</option>
				
				<option value="file11">github.com/troubling/hummingbird/client/proxyclient.go (16.9%)</option>
				
				<option value="file12">github.com/troubling/hummingbird/client/tracingclient.go (0.0%)</option>
				
				<option value="file13">github.com/troubling/hummingbird/common/conf/conf.go (86.5%)</option>
				
				<option value="file14">github.com/troubling/hummingbird/common/conf/policy.go (82.5%)</option>
				
				<option value="file15">github.com/troubling/hummingbird/common/conf/syncrealm.go (86.7%)</option>
				
				<option value="file16">github.com/troubling/hummingbird/common/constraints.go (94.3%)</option>
				
				<option value="file17">github.com/troubling/hummingbird/common/expects.go (93.7%)</option>
				
				<option value="file18">github.com/troubling/hummingbird/common/freepool.go (100.0%)</option>
				
				<option value="file19">github.com/troubling/hummingbird/common/fs/atomic_linux.go (66.7%)</option>
				
				<option value="file20">github.com/troubling/hummingbird/common/fs/main.go (90.0%)</option>
				
				<option value="file21">github.com/troubling/hummingbird/common/fs/xattr.go (60.0%)</option>
				
				<option value="file22">github.com/troubling/hummingbird/common/fs/xattr_darwinlinux.go (81.8%)</option>
				
				<option value="file23">github.com/troubling/hummingbird/common/multipart.go (94.4%)</option>
				
				<option value="file24">github.com/troubling/hummingbird/common/pickle/pickle.go (82.1%)</option>
				
				<option value="file25">github.com/troubling/hummingbird/common/pickle/unmarshal.go (81.6%)</option>
				
				<option value="file26">github.com/troubling/hummingbird/common/pickle/unpickle.go (91.7%)</option>
				
				<option value="file27">github.com/troubling/hummingbird/common/ring/builder.go (0.0%)</option>
				
				<option value="file28">github.com/troubling/hummingbird/common/ring/memcachering.go (0.0%)</option>
				
				<option value="file29">github.com/troubling/hummingbird/common/ring/ring.go (38.7%)</option>
				
				<option value="file30">github.com/troubling/hummingbird/common/srv/context.go (75.0%)</option>
				
				<option value="file31">github.com/troubling/hummingbird/common/srv/router.go (94.0%)</option>
				
				<option value="file32">github.com/troubling/hummingbird/common/srv/server.go (34.5%)</option>
				
				<option value="file33">github.com/troubling/hummingbird/common/swiftobject.go (89.4%)</option>
				
				<option value="file34">github.com/troubling/hummingbird/common/test/test.go (21.7%)</option>
				
				<option value="file35">github.com/troubling/hummingbird/common/testutils.go (70.0%)</option>
				
				<option value="file36">github.com/troubling/hummingbird/common/tracing/init.go (0.0%)</option>
				
				<option value="file37">github.com/troubling/hummingbird/common/tracing/log.go (0.0%)</option>
				
				<option value="file38">github.com/troubling/hummingbird/common/tracing/util.go (80.0%)</option>
				
				<option value="file39">github.com/troubling/hummingbird/common/utils.go (70.4%)</option>
				
				<option value="file40">github.com/troubling/hummingbird/containerserver/engine.go (97.3%)</option>
				
				<option value="file41">github.com/troubling/hummingbird/containerserver/incoming_rep.go (74.5%)</option>
				
				<option value="file42">github.com/troubling/hummingbird/containerserver/priorityrep.go (0.0%)</option>
				
				<option value="file43">github.com/troubling/hummingbird/containerserver/replicator.go (67.7%)</option>
				
				<option value="file44">github.com/troubling/hummingbird/containerserver/schema.go (77.3%)</option>
				
				<option value="file45">github.com/troubling/hummingbird/containerserver/server.go (72.5%)</option>
				
				<option value="file46">github.com/troubling/hummingbird/containerserver/sqlite_backend.go (65.3%)</option>
				
				<option value="file47">github.com/troubling/hummingbird/containerserver/update.go (89.4%)</option>
				
				<option value="file48">github.com/troubling/hummingbird/functional/functional.go (0.0%)</option>
				
				<option value="file49">github.com/troubling/hummingbird/middleware/dbgheader.go (33.3%)</option>
				
				<option value="file50">github.com/troubling/hummingbird/middleware/grep.go (100.0%)</option>
				
				<option value="file51">github.com/troubling/hummingbird/middleware/metrics.go (100.0%)</option>
				
				<option value="file52">github.com/troubling/hummingbird/middleware/options.go (0.0%)</option>
				
				<option value="file53">github.com/troubling/hummingbird/middleware/recon.go (32.6%)</option>
				
				<option value="file54">github.com/troubling/hummingbird/middleware/recover.go (55.6%)</option>
				
				<option value="file55">github.com/troubling/hummingbird/middleware/ring.go (0.0%)</option>
				
				<option value="file56">github.com/troubling/hummingbird/middleware/tracing.go (30.8%)</option>
				
				<option value="file57">github.com/troubling/hummingbird/middleware/validaterequest.go (80.0%)</option>
				
				<option value="file58">github.com/troubling/hummingbird/objectserver/auditor.go (73.6%)</option>
				
				<option value="file59">github.com/troubling/hummingbird/objectserver/ecengine.go (33.9%)</option>
				
				<option value="file60">github.com/troubling/hummingbird/objectserver/ecobj.go (33.7%)</option>
				
				<option value="file61">github.com/troubling/hummingbird/objectserver/ecutils.go (31.5%)</option>
				
				<option value="file62">github.com/troubling/hummingbird/objectserver/indexdb.go (60.2%)</option>
				
				<option value="file63">github.com/troubling/hummingbird/objectserver/main.go (60.6%)</option>
				
				<option value="file64">github.com/troubling/hummingbird/objectserver/metadata.go (50.0%)</option>
				
				<option value="file65">github.com/troubling/hummingbird/objectserver/nurserystabilizer.go (31.1%)</option>
				
				<option value="file66">github.com/troubling/hummingbird/objectserver/objengine.go (75.0%)</option>
				
				<option value="file67">github.com/troubling/hummingbird/objectserver/priorityrep.go (42.5%)</option>
				
				<option value="file68">github.com/troubling/hummingbird/objectserver/repconn.go (64.5%)</option>
				
				<option value="file69">github.com/troubling/hummingbird/objectserver/replicator.go (64.3%)</option>
				
				<option value="file70">github.com/troubling/hummingbird/objectserver/repobj.go (60.3%)</option>
				
				<option value="file71">github.com/troubling/hummingbird/objectserver/repobjeng.go (0.5%)</option>
				
				<option value="file72">github.com/troubling/hummingbird/objectserver/repsrv.go (54.0%)</option>
				
				<option value="file73">github.com/troubling/hummingbird/objectserver/swiftbackend.go (79.6%)</option>
				
				<option value="file74">github.com/troubling/hummingbird/objectserver/swiftobjeng.go (81.9%)</option>
				
				<option value="file75">github.com/troubling/hummingbird/objectserver/update.go (93.8%)</option>
				
				<option value="file76">github.com/troubling/hummingbird/objectserver/updater.go (66.0%)</option>
				
				<option value="file77">github.com/troubling/hummingbird/probe/base.go (92.0%)</option>
				
				<option value="file78">github.com/troubling/hummingbird/proxyserver/accounthandlers.go (0.0%)</option>
				
				<option value="file79">github.com/troubling/hummingbird/proxyserver/containerhandlers.go (20.7%)</option>
				
				<option value="file80">github.com/troubling/hummingbird/proxyserver/endpoints.go (65.7%)</option>
				
				<option value="file81">github.com/troubling/hummingbird/proxyserver/main.go (0.0%)</option>
				
				<option value="file82">github.com/troubling/hummingbird/proxyserver/middleware/account_quota.go (68.2%)</option>
				
				<option value="file83">github.com/troubling/hummingbird/proxyserver/middleware/acl.go (100.0%)</option>
				
				<option value="file84">github.com/troubling/hummingbird/proxyserver/middleware/authtoken.go (51.2%)</option>
				
				<option value="file85">github.com/troubling/hummingbird/proxyserver/middleware/bulk.go (7.9%)</option>
				
				<option value="file86">github.com/troubling/hummingbird/proxyserver/middleware/catcherror.go (0.0%)</option>
				
				<option value="file87">github.com/troubling/hummingbird/proxyserver/middleware/container_quota.go (87.5%)</option>
				
				<option value="file88">github.com/troubling/hummingbird/proxyserver/middleware/context.go (26.2%)</option>
				
				<option value="file89">github.com/troubling/hummingbird/proxyserver/middleware/copy.go (81.2%)</option>
				
				<option value="file90">github.com/troubling/hummingbird/proxyserver/middleware/cors.go (42.4%)</option>
				
				<option value="file91">github.com/troubling/hummingbird/proxyserver/middleware/crossdomain.go (100.0%)</option>
				
				<option value="file92">github.com/troubling/hummingbird/proxyserver/middleware/formpost.go (75.4%)</option>
				
				<option value="file93">github.com/troubling/hummingbird/proxyserver/middleware/healthcheck.go (0.0%)</option>
				
				<option value="file94">github.com/troubling/hummingbird/proxyserver/middleware/keystoneauth.go (0.0%)</option>
				
				<option value="file95">github.com/troubling/hummingbird/proxyserver/middleware/largeobject.go (64.3%)</option>
				
				<option value="file96">github.com/troubling/hummingbird/proxyserver/middleware/logging.go (0.0%)</option>
				
				<option value="file97">github.com/troubling/hummingbird/proxyserver/middleware/multirange.go (74.7%)</option>
				
				<option value="file98">github.com/troubling/hummingbird/proxyserver/middleware/pipe_response.go (87.1%)</option>
				
				<option value="file99">github.com/troubling/hummingbird/proxyserver/middleware/ratelimit.go (16.7%)</option>
				
				<option value="file100">github.com/troubling/hummingbird/proxyserver/middleware/s3api.go (0.0%)</option>
				
				<option value="file101">github.com/troubling/hummingbird/proxyserver/middleware/s3auth.go (0.0%)</option>
				
				<option value="file102">github.com/troubling/hummingbird/proxyserver/middleware/staticweb.go (74.4%)</option>
				
				<option value="file103">github.com/troubling/hummingbird/proxyserver/middleware/tempauth.go (55.6%)</option>
				
				<option value="file104">github.com/troubling/hummingbird/proxyserver/middleware/tempurl.go (92.4%)</option>
				
				<option value="file105">github.com/troubling/hummingbird/proxyserver/middleware/versioned_writes.go (71.2%)</option>
				
				<option value="file106">github.com/troubling/hummingbird/proxyserver/objhandlers.go (0.0%)</option>
				
				<option value="file107">github.com/troubling/hummingbird/tools/db.go (10.9%)</option>
				
				<option value="file108">github.com/troubling/hummingbird/tools/dispersion.go (13.8%)</option>
				
				<option value="file109">github.com/troubling/hummingbird/tools/dispersionpopulatecontainers.go (0.0%)</option>
				
				<option value="file110">github.com/troubling/hummingbird/tools/dispersionpopulateobjects.go (61.2%)</option>
				
				<option value="file111">github.com/troubling/hummingbird/tools/dispersionscancontainers.go (0.0%)</option>
				
				<option value="file112">github.com/troubling/hummingbird/tools/dispersionscanobjects.go (0.0%)</option>
				
				<option value="file113">github.com/troubling/hummingbird/tools/main.go (1.8%)</option>
				
				<option value="file114">github.com/troubling/hummingbird/tools/progress.go (0.0%)</option>
				
				<option value="file115">github.com/troubling/hummingbird/tools/quarantinehistory.go (0.0%)</option>
				
				<option value="file116">github.com/troubling/hummingbird/tools/quarantinerepair.go (0.0%)</option>
				
				<option value="file117">github.com/troubling/hummingbird/tools/reconcli.go (28.4%)</option>
				
				<option value="file118">github.com/troubling/hummingbird/tools/replication.go (0.0%)</option>
				
				<option value="file119">github.com/troubling/hummingbird/tools/ring.go (0.0%)</option>
				
				<option value="file120">github.com/troubling/hummingbird/tools/ringmonitor.go (0.0%)</option>
				
				<option value="file121">github.com/troubling/hummingbird/tools/ringscan.go (0.0%)</option>
				
				<option value="file122">github.com/troubling/hummingbird/tools/unmountedmonitor.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">//  Copyright (c) 2016-2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package accountserver

import (
        "container/list"
        "crypto/md5"
        "encoding/xml"
        "fmt"
        "os"
        "path/filepath"
        "sync"
        "time"

        "github.com/troubling/hummingbird/common/fs"
)

var (
        // ErrorNoSuchAccount is returned when a requested account doesn't exist.
        ErrorNoSuchAccount = fmt.Errorf("No such account.")
        // ErrorInvalidMetadata is returned for errors that violate the API metadata constraints.
        ErrorInvalidMetadata = fmt.Errorf("Invalid metadata value")
)

// AccountInfo represents the container_info database record - basic information about the container.
type AccountInfo struct {
        Account         string              `json:"account"`
        CreatedAt       string              `json:"created_at"`
        PutTimestamp    string              `json:"put_timestamp"`
        DeleteTimestamp string              `json:"delete_timestamp"`
        StatusChangedAt string              `json:"status_changed_at"`
        ObjectCount     int64               `json:"count"`
        BytesUsed       int64               `json:"bytes_used"`
        ContainerCount  int64               `json:"container_count"`
        Hash            string              `json:"hash"`
        ID              string              `json:"id"`
        RawMetadata     string              `json:"metadata"`
        Metadata        map[string][]string `json:"-"`
        MaxRow          int64               `json:"max_row"`
        invalid         bool
        updated         time.Time
        // This row isn't populated by GetInfo, it only exists for the times this is
        // serialized during replication.
        Point int64 `json:"point"`
}

type PolicyStat struct {
        StoragePolicyIndex int
        ContainerCount     int64
        ObjectCount        int64
        BytesUsed          int64
}

type policyStats struct {
        list    []*PolicyStat
        invalid bool
        updated time.Time
}

// ContainerListingRecord is the struct used for serializing objects in json and xml account listings.
type ContainerListingRecord struct {
        XMLName      xml.Name `xml:"container" json:"-"`
        Name         string   `xml:"name" json:"name"`
        Bytes        int64    `xml:"bytes" json:"bytes"`
        Count        int64    `xml:"count" json:"count"`
        LastModified string   `xml:"last_modified" json:"last_modified"`
}

// SubdirListingRecord is the struct used for serializing subdirs in json and xml account listings.
type SubdirListingRecord struct {
        XMLName xml.Name `xml:"subdir" json:"-"`
        Name2   string   `xml:"name,attr" json:"-"`
        Name    string   `xml:"name" json:"subdir"`
}

// ContainerRecord represents the object's data in-databaee, it is used by replication.
type ContainerRecord struct {
        Rowid              int64  `json:"ROWID"`
        Name               string `json:"name"`
        PutTimestamp       string `json:"put_timestamp"`
        DeleteTimestamp    string `json:"delete_timestamp"`
        ObjectCount        int64  `json:"object_count"`
        BytesUsed          int64  `json:"bytes_used"`
        Deleted            int    `json:"deleted"`
        StoragePolicyIndex int    `json:"storage_policy_index"`
}

// SyncRecord represents a row in the incoming_sync table.  It is used by replication.
type SyncRecord struct {
        SyncPoint int64  `json:"sync_point"`
        RemoteID  string `json:"remote_id"`
}

// Account is the interface implemented by an account
type Account interface {
        // GetInfo returns the AccountInfo struct for the account.
        GetInfo() (*AccountInfo, error)
        // PolicyStats returns the metrics for various policies in use by the account.
        PolicyStats() ([]*PolicyStat, error)
        // IsDeleted returns true if the account has been deleted.
        IsDeleted() (bool, error)
        // Delete deletes the account.
        Delete(timestamp string) (int, error)
        // ListContainers lists the account's container entries.
        ListContainers(limit int, marker string, endMarker string, prefix string, delimiter string, reverse bool) ([]interface{}, error)
        // GetMetadata returns the account's current metadata.
        GetMetadata() (map[string]string, error)
        // UpdateMetadata applies updates to the account's metadata.
        UpdateMetadata(updates map[string][]string) error
        // PutContainer adds a new container to the account.
        PutContainer(name string, putTimestamp string, deleteTimestamp string, objectCount int64, bytesUsed int64, storagePolicyIndex int) error
        // ID returns a unique identifier for the account.
        ID() string
        // Close frees any resources associated with the account.
        Close() error
        // Ping makes sure the database still has a valid connection.
        Ping() error
}

// ReplicableAccount is an account that also implements the replication API.
type ReplicableAccount interface {
        Account
        // MergeItems merges object records into the account, with an optional remoteId.
        MergeItems(records []*ContainerRecord, remoteID string) error
        // ItemsSince returns count object records with a ROWID greater than start.
        ItemsSince(start int64, count int) ([]*ContainerRecord, error)
        // MergeSyncTable updates the account's incoming sync tables with new data.
        MergeSyncTable(records []*SyncRecord) error
        // SyncTable returns the account's current sync table.
        SyncTable() ([]*SyncRecord, error)
        // SyncRemoteData accepts a remote account's current status information and updates local records accordingly.
        SyncRemoteData(maxRow int64, hash, id, createdAt, putTimestamp, deleteTimestamp, metadata string) (*AccountInfo, error)
        // NewID gives the database a new unique identifier, which is used for incoming_sync entries.
        NewID() error
        // OpenDatabaseFile returns a consistent reader for the underlying database file.
        OpenDatabaseFile() (*os.File, func(), error)
        // CleanupTombstones removes any metadata and object tombstones older than reclaimAge seconds.
        CleanupTombstones(reclaimAge int64) error
        // RingHash returns the account's ring hash.
        RingHash() string
}

// AccountEngine is the interface of an object that creates and returns accounts.
type AccountEngine interface {
        // Get returns an Account, given a vars mapping.
        Get(vars map[string]string) (c Account, err error)
        // Return returns a Account to the engine, where it can close or retain them as it sees fit.
        Return(c Account)
        // Create creates a new account.  Returns true if the accoun t was created and a pointer to the account.
        Create(vars map[string]string, putTimestamp string, metadata map[string][]string) (bool, Account, error)
        // Close releases all cached accounts and any other retained resources.
        Close()

        // GetByHash returns a replicable database given its hash.  This will probably move from this interface once we
        // have replicator-&gt;replicator communication.
        GetByHash(device, hash, partition string) (c ReplicableAccount, err error)
        // Invalidate removes an account hash from the cache entirely.  This will probably also move, since it's only used by replication.
        Invalidate(id string)
}

// My attempts at making this lruEngine reusable have not been successful, so for now it's sqlite-specific and not exported.
type lruEngine struct {
        deviceRoot     string
        hashPathPrefix string
        hashPathSuffix string
        maxSize        int
        cache          map[string]*lruEntry
        used           *list.List
        m              sync.Mutex
}

type lruEntry struct {
        c     Account
        inUse int
        elem  *list.Element
}

func (l *lruEngine) add(c Account) <span class="cov8" title="1">{
        if len(l.cache) &gt;= l.maxSize </span><span class="cov8" title="1">{
                for elem := l.used.Front(); elem != nil; elem = elem.Next() </span><span class="cov8" title="1">{
                        if entry, ok := elem.Value.(*lruEntry); ok &amp;&amp; entry.inUse == 0 </span><span class="cov8" title="1">{
                                l.used.Remove(elem)
                                delete(l.cache, entry.c.ID())
                                entry.c.Close()
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">holder := &amp;lruEntry{c: c, inUse: 1}
        holder.elem = l.used.PushBack(holder)
        l.cache[c.ID()] = holder</span>
}

func (l *lruEngine) accountLocation(vars map[string]string) string <span class="cov8" title="1">{
        h := md5.New()
        fmt.Fprintf(h, "%s/%s%s", l.hashPathPrefix, vars["account"], l.hashPathSuffix)
        hexHash := fmt.Sprintf("%032x", h.Sum(nil))
        suffix := hexHash[29:32]
        return filepath.Join(l.deviceRoot, vars["device"], "accounts", vars["partition"], suffix, hexHash, hexHash+".db")
}</span>

func (l *lruEngine) getbypath(accountFile string) (c Account, err error) <span class="cov8" title="1">{
        if !fs.Exists(accountFile) </span><span class="cov8" title="1">{
                return nil, ErrorNoSuchAccount
        }</span>
        <span class="cov8" title="1">ringHash := filepath.Base(filepath.Dir(accountFile))
        l.m.Lock()
        defer l.m.Unlock()
        if e := l.cache[ringHash]; e != nil </span><span class="cov8" title="1">{
                if err := e.c.Ping(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">e.inUse++
                l.used.MoveToBack(e.elem)
                return e.c, nil</span>
        }
        <span class="cov8" title="1">if c, err = sqliteOpenAccount(accountFile); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">l.add(c)
        return c, nil</span>
}

// Get returns a database given the incoming vars.
func (l *lruEngine) Get(vars map[string]string) (c Account, err error) <span class="cov8" title="1">{
        return l.getbypath(l.accountLocation(vars))
}</span>

// Create creates a new account.
func (l *lruEngine) Create(vars map[string]string, putTimestamp string, metadata map[string][]string) (bool, Account, error) <span class="cov8" title="1">{
        if c, err := l.Get(vars); err == nil </span><span class="cov0" title="0">{
                if created, err := sqliteCreateExistingAccount(c, putTimestamp, metadata); err != nil </span><span class="cov0" title="0">{
                        c.Close()
                        return false, nil, err
                }</span> else<span class="cov0" title="0"> {
                        return created, c, nil
                }</span>
        }
        <span class="cov8" title="1">if err := sqliteCreateAccount(l.accountLocation(vars), vars["account"], putTimestamp, metadata); err == errDatabaseExists </span><span class="cov0" title="0">{
                if c, err := l.Get(vars); err == nil </span><span class="cov0" title="0">{
                        if created, err := sqliteCreateExistingAccount(c, putTimestamp, metadata); err == nil </span><span class="cov0" title="0">{
                                return created, c, err
                        }</span>
                        <span class="cov0" title="0">c.Close()</span>
                }
                <span class="cov0" title="0">return false, nil, err</span>
        } else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                return false, nil, err
        }</span>
        <span class="cov8" title="1">c, err := l.Get(vars)
        return true, c, err</span>
}

// Return returns a database object to the engine.
func (l *lruEngine) Return(c Account) <span class="cov8" title="1">{
        l.m.Lock()
        if e := l.cache[c.ID()]; e != nil &amp;&amp; e.c == c </span><span class="cov8" title="1">{
                e.inUse--
        }</span> else<span class="cov8" title="1"> {
                l.add(c)
        }</span>
        <span class="cov8" title="1">l.m.Unlock()</span>
}

// GetByHash returns a database given its device and ring hash.
func (l *lruEngine) GetByHash(device, hash, partition string) (ReplicableAccount, error) <span class="cov8" title="1">{
        accountFile := filepath.Join(l.deviceRoot, device, "accounts", partition, hash[29:32], hash, hash+".db")
        c, err := l.getbypath(accountFile)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">rc, ok := c.(ReplicableAccount)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Account does not support replication.")
        }</span>
        <span class="cov8" title="1">return rc, nil</span>
}

// Invalidate removes any cached backend connections to the database.
func (l *lruEngine) Invalidate(id string) <span class="cov8" title="1">{
        l.m.Lock()
        if e := l.cache[id]; e != nil </span><span class="cov0" title="0">{
                e.c.Close()
                l.used.Remove(e.elem)
                delete(l.cache, id)
        }</span>
        <span class="cov8" title="1">l.m.Unlock()</span>
}

// Close shuts down any backend account database connections and clears the caches.
func (l *lruEngine) Close() <span class="cov8" title="1">{
        for k, v := range l.cache </span><span class="cov8" title="1">{
                v.c.Close()
                delete(l.cache, k)
        }</span>
        <span class="cov8" title="1">l.used = l.used.Init()</span>
}

func newLRUEngine(deviceRoot, hashPathPrefix, hashPathSuffix string, accountCount int) *lruEngine <span class="cov8" title="1">{
        return &amp;lruEngine{
                deviceRoot:     deviceRoot,
                hashPathPrefix: hashPathPrefix,
                hashPathSuffix: hashPathSuffix,
                maxSize:        accountCount,
                cache:          make(map[string]*lruEntry),
                used:           list.New(),
        }
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">//  Copyright (c) 2016-2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package accountserver

import (
        "encoding/json"
        "errors"
        "io"
        "net/http"
        "os"
        "path/filepath"

        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/srv"
        "go.uber.org/zap"
)

func isOkayFilename(s string) bool <span class="cov8" title="1">{
        if len(s) &lt; 5 || len(s) &gt; 100 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for _, c := range s </span><span class="cov8" title="1">{
                if !((c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= '0' &amp;&amp; c &lt;= '9') ||
                        (c == '-') || (c == '_') || (c == '.')) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// TmpUploadHandler handles uploading account files to the tmp directory for various replication strategies.
// This replaces the swift replicator's use of rsync.
func (server *AccountServer) TmpUploadHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        if !isOkayFilename(vars["filename"]) </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">filename := filepath.Join(server.driveRoot, vars["device"], "tmp", vars["filename"])
        if err := os.MkdirAll(filepath.Dir(filename), 0755); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">fp, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to create file.",
                        zap.String("filename", filename),
                        zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer fp.Close()
        if _, err := io.Copy(fp, request.Body); err != nil </span><span class="cov0" title="0">{
                os.RemoveAll(filename)
                srv.GetLogger(request).Error("Error saving file contents.",
                        zap.String("filename", filename),
                        zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
        }</span> else<span class="cov8" title="1"> {
                srv.StandardResponse(writer, http.StatusCreated)
        }</span>
}

// AccountReplicateHandler handles the REPLICATE call for accounts.
func (server *AccountServer) AccountReplicateHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        // make sure there's a tmp dir to rsync to
        if err := os.MkdirAll(filepath.Join(server.driveRoot, vars["device"], "tmp"), 0777); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">message := []json.RawMessage{}
        decoder := json.NewDecoder(request.Body)
        if err := decoder.Decode(&amp;message); err != nil </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">var op string
        if err := json.Unmarshal(message[0], &amp;op); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">extractArgs := func(args ...interface{}) error </span><span class="cov8" title="1">{
                if len(message)-1 &lt; len(args) </span><span class="cov8" title="1">{
                        return errors.New("Not enough arguments in payload.")
                }</span>
                <span class="cov8" title="1">for i, arg := range args </span><span class="cov8" title="1">{
                        if err := json.Unmarshal(message[i+1], arg); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov8" title="1">switch op </span>{
        case "complete_rsync":<span class="cov8" title="1">
                var tmpFileName string
                if err := extractArgs(&amp;tmpFileName); err != nil </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                }</span> else<span class="cov8" title="1"> {
                        status := server.replicateCompleteRsync(request, vars, tmpFileName)
                        srv.StandardResponse(writer, status)
                }</span>
        case "merge_items":<span class="cov8" title="1">
                var records []*ContainerRecord
                var remoteID string
                if err := extractArgs(&amp;records, &amp;remoteID); err != nil </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                }</span> else<span class="cov8" title="1"> {
                        status := server.replicateMergeItems(request, vars, records, remoteID)
                        srv.StandardResponse(writer, status)
                }</span>
        case "merge_syncs":<span class="cov8" title="1">
                var records []*SyncRecord
                if err := extractArgs(&amp;records); err != nil </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                }</span> else<span class="cov8" title="1"> {
                        status := server.replicateMergeSyncs(request, vars, records)
                        srv.StandardResponse(writer, status)
                }</span>
        case "sync":<span class="cov8" title="1">
                var maxRow int64
                var hash, id, createdAt, putTimestamp, deleteTimestamp, metadata string
                if err := extractArgs(&amp;maxRow, &amp;hash, &amp;id, &amp;createdAt, &amp;putTimestamp, &amp;deleteTimestamp, &amp;metadata); err != nil </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                }</span> else<span class="cov8" title="1"> if status, data := server.replicateSync(request, vars, maxRow, hash, id, createdAt, putTimestamp, deleteTimestamp, metadata); status == http.StatusOK </span><span class="cov8" title="1">{
                        writer.WriteHeader(http.StatusOK)
                        writer.Write(data)
                }</span> else<span class="cov8" title="1"> {
                        srv.StandardResponse(writer, status)
                }</span>
        default:<span class="cov8" title="1">
                srv.GetLogger(request).Error("Unknown replication op.", zap.String("op", op))
                srv.StandardResponse(writer, http.StatusBadRequest)</span>
        }
}

func (server *AccountServer) replicateCompleteRsync(request *http.Request, vars map[string]string, tmpFileName string) int <span class="cov8" title="1">{
        accountFile := filepath.Join(server.driveRoot, vars["device"], "accounts", vars["partition"], vars["hash"][29:32], vars["hash"], vars["hash"]+".db")
        tmpAccountFile := filepath.Join(server.driveRoot, vars["device"], "tmp", tmpFileName)
        if !fs.Exists(tmpAccountFile) || fs.Exists(accountFile) </span><span class="cov8" title="1">{
                return http.StatusNotFound
        }</span>
        <span class="cov8" title="1">if err := os.MkdirAll(filepath.Dir(accountFile), 0777); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error blessing new account db.",
                        zap.String("accountFile", accountFile), zap.Error(err))
                return http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">lock, err := fs.LockPath(filepath.Dir(accountFile), dirLockTimeout)
        if err != nil </span><span class="cov0" title="0">{
                return http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">defer lock.Close()
        tmpDb, err := sqliteOpenAccount(tmpAccountFile)
        if err != nil </span><span class="cov0" title="0">{
                return http.StatusNotFound
        }</span>
        <span class="cov8" title="1">defer tmpDb.Close()
        defer server.accountEngine.Invalidate(vars["hash"])
        if err := tmpDb.NewID(); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error blessing new account db.",
                        zap.String("accountFile", accountFile), zap.Error(err))
                return http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">if err := sqliteRename(tmpAccountFile, accountFile); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error blessing new account db.",
                        zap.String("accountFile", accountFile), zap.Error(err))
                return http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">return http.StatusNoContent</span>
}

func (server *AccountServer) replicateMergeItems(request *http.Request, vars map[string]string, records []*ContainerRecord, remoteID string) int <span class="cov8" title="1">{
        db, err := server.accountEngine.GetByHash(vars["device"], vars["hash"], vars["partition"])
        if err != nil </span><span class="cov8" title="1">{
                return http.StatusNotFound
        }</span>
        <span class="cov8" title="1">defer server.accountEngine.Return(db)
        if err := db.MergeItems(records, remoteID); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error merging records.",
                        zap.String("db.RingHash", db.RingHash()),
                        zap.Error(err))
                return http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">return http.StatusAccepted</span>
}

func (server *AccountServer) replicateMergeSyncs(request *http.Request, vars map[string]string, records []*SyncRecord) int <span class="cov8" title="1">{
        db, err := server.accountEngine.GetByHash(vars["device"], vars["hash"], vars["partition"])
        if err != nil </span><span class="cov8" title="1">{
                return http.StatusNotFound
        }</span>
        <span class="cov8" title="1">defer server.accountEngine.Return(db)
        if err := db.MergeSyncTable(records); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error merging sync table.",
                        zap.String("db.RingHash", db.RingHash()),
                        zap.Error(err))
                return http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">return http.StatusAccepted</span>
}

func (server *AccountServer) replicateSync(request *http.Request, vars map[string]string, maxRow int64, hash, id, createdAt, putTimestamp, deleteTimestamp, metadata string) (int, []byte) <span class="cov8" title="1">{
        db, err := server.accountEngine.GetByHash(vars["device"], vars["hash"], vars["partition"])
        if err != nil </span><span class="cov8" title="1">{
                return http.StatusNotFound, nil
        }</span>
        <span class="cov8" title="1">defer server.accountEngine.Return(db)
        info, err := db.SyncRemoteData(maxRow, hash, id, createdAt, putTimestamp, deleteTimestamp, metadata)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error syncing remote data.",
                        zap.String("vars['hash']", vars["hash"]),
                        zap.Error(err))
                return http.StatusInternalServerError, nil
        }</span>
        <span class="cov8" title="1">response, err := json.Marshal(info)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error marshaling info.",
                        zap.String("vars['hash']", vars["hash"]),
                        zap.Error(err))
                return http.StatusInternalServerError, nil
        }</span>
        <span class="cov8" title="1">return http.StatusOK, response</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package accountserver

import (
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/ring"
)

type PriorityRepJob struct {
        Partition  uint64       `json:"partition"`
        FromDevice *ring.Device `json:"from_device"`
        ToDevice   *ring.Device `json:"to_device"`
}

// TODO
func SendPriRepJob(job *PriorityRepJob, client common.HTTPClient) (string, bool) <span class="cov0" title="0">{
        return "pretending to do priority replication; normal replication should be fast enough for now", true
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">//  Copyright (c) 2016-2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

// NOTE: Replication requests use the standard ip and port as the
// account-replicator web service is just for metrics at this time.

package accountserver

import (
        "bytes"
        "encoding/json"
        "errors"
        "flag"
        "fmt"
        "io"
        "io/ioutil"
        "net"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/justinas/alice"
        opentracing "github.com/opentracing/opentracing-go"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/troubling/hummingbird/client"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/common/tracing"
        "github.com/troubling/hummingbird/middleware"
        "github.com/troubling/nectar"
        "github.com/uber-go/tally"
        promreporter "github.com/uber-go/tally/prometheus"
        "go.uber.org/zap"
        "golang.org/x/net/http2"
)

var (
        errDeviceNotMounted = errors.New("Remove drive was unmounted")
        deviceLockupTimeout = time.Hour
        // GetRing is a local pointer to the hummingbird function, for overriding in tests.
        GetRing = ring.GetRing
)

// Replicator is the account replicator daemon object
type Replicator struct {
        checkMounts       bool
        deviceRoot        string
        reconCachePath    string
        logger            srv.LowLevelLogger
        serverPort        int
        Ring              ring.Ring
        perUsync          int64
        maxUsyncs         int
        concurrencySem    chan struct{}
        sendStat          chan statUpdate
        checkin           chan string
        startRun          chan string
        client            common.HTTPClient
        certFile          string
        keyFile           string
        runningDevices    map[string]*replicationDevice
        reclaimAge        int64
        logLevel          zap.AtomicLevel
        metricsCloser     io.Closer
        traceCloser       io.Closer
        tracer            opentracing.Tracer
        clientTracer      opentracing.Tracer
        clientTraceCloser io.Closer
        reaperLock        sync.Mutex
        reaperLastCheckin time.Time
        reaperCanceler    chan struct{}
        reaperCheckin     chan struct{}
}

type statUpdate struct {
        device string
        stat   string
        value  int64
}

type replicationDevice struct {
        i interface {
                sendReplicationMessage(dev *ring.Device, part uint64, ringHash string, args ...interface{}) (int, []byte, error)
                sync(dev *ring.Device, part uint64, ringHash string, info *AccountInfo) (*AccountInfo, error)
                rsync(dev *ring.Device, c ReplicableAccount, part uint64, op string) error
                usync(dev *ring.Device, c ReplicableAccount, part uint64, localID string, point int64) error
                chooseReplicationStrategy(localInfo, remoteInfo *AccountInfo, usyncThreshold int64) string
                replicateDatabaseToDevice(dev *ring.Device, c ReplicableAccount, part uint64) error
                replicateDatabase(dbFile string) error
                checkForReaping(dbFile string) error
                findAccountDbs(devicePath string, results chan string)
                incrementStat(stat string)
        }
        r             *Replicator
        cancel        chan struct{}
        dev           *ring.Device
        stats         map[string]int64
        lifetimeStats map[string]int64
        lastCheckin   time.Time
        runStarted    time.Time
        deviceStarted time.Time
}

func (rd *replicationDevice) sendReplicationMessage(dev *ring.Device, part uint64, ringHash string, args ...interface{}) (int, []byte, error) <span class="cov8" title="1">{
        body, err := json.Marshal(args)
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>
        <span class="cov8" title="1">req, err := http.NewRequest("REPLICATE", fmt.Sprintf("%s://%s:%d/%s/%d/%s", dev.Scheme,
                dev.Ip, dev.Port, dev.Device, part, ringHash), bytes.NewBuffer(body))
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>
        <span class="cov8" title="1">req.Header.Set("X-Backend-Suppress-2xx-Logging", "t")
        req.Cancel = rd.cancel
        resp, err := rd.r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        respBody, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>
        <span class="cov8" title="1">return resp.StatusCode, respBody, nil</span>
}

func (rd *replicationDevice) sync(dev *ring.Device, part uint64, ringHash string, info *AccountInfo) (*AccountInfo, error) <span class="cov8" title="1">{
        var remoteInfo AccountInfo
        status, body, err := rd.i.sendReplicationMessage(dev, part, ringHash, "sync", info.MaxRow, info.Hash,
                info.ID, info.CreatedAt, info.PutTimestamp, info.DeleteTimestamp, info.RawMetadata)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("sending sync request to %s/%s: %v", dev.Ip, dev.Device, err)
        }</span> else<span class="cov8" title="1"> if status == http.StatusNotFound </span><span class="cov8" title="1">{
                return nil, nil
        }</span> else<span class="cov8" title="1"> if status == http.StatusInsufficientStorage </span><span class="cov8" title="1">{
                return nil, errDeviceNotMounted
        }</span> else<span class="cov8" title="1"> if status/100 != 2 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("bad status code %d", status)
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal(body, &amp;remoteInfo); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("unmarshalling sync response: %v", err)
        }</span>
        <span class="cov8" title="1">return &amp;remoteInfo, nil</span>
}

func (rd *replicationDevice) rsync(dev *ring.Device, c ReplicableAccount, part uint64, op string) error <span class="cov8" title="1">{
        tmpFilename := common.UUID()
        fp, release, err := c.OpenDatabaseFile()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Error opening databae: %v", err)
        }</span>
        <span class="cov8" title="1">defer release()
        req, err := http.NewRequest("PUT", fmt.Sprintf("%s://%s:%d/%s/tmp/%s", dev.Scheme, dev.Ip, dev.Port, dev.Device, tmpFilename), fp)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("creating request: %v", err)
        }</span>
        <span class="cov8" title="1">req.Cancel = rd.cancel
        resp, err := rd.r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("putting database to %s/%s: %v", dev.Ip, dev.Device, err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("bad status code %d rsyncing file with %s/%s", resp.StatusCode, dev.Ip, dev.Device)
        }</span>
        <span class="cov8" title="1">status, _, err := rd.i.sendReplicationMessage(dev, part, c.RingHash(), op, tmpFilename)
        if err != nil || status/100 != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("sending %s message to %s/%s: status %d: %v", op, dev.Ip, dev.Device, status, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (rd *replicationDevice) usync(dev *ring.Device, c ReplicableAccount, part uint64, localID string, point int64) error <span class="cov8" title="1">{
        objects, err := c.ItemsSince(point, int(rd.r.perUsync))
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("getting object records from %s: %v", c.RingHash(), err)
        }</span>
        <span class="cov8" title="1">usyncs := 0
        syncTable, err := c.SyncTable()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Error getting sync table: %v", err)
        }</span>
        <span class="cov8" title="1">for len(objects) != 0 &amp;&amp; usyncs &lt; rd.r.maxUsyncs </span><span class="cov8" title="1">{
                status, _, err := rd.i.sendReplicationMessage(dev, part, c.RingHash(), "merge_items", objects, localID)
                if err != nil || status/100 != 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("Bad response to merge_items with %s/%s: status %d: %v", dev.Ip, dev.Device, status, err)
                }</span>
                <span class="cov8" title="1">point = objects[len(objects)-1].Rowid
                usyncs++
                if objects, err = c.ItemsSince(point, int(rd.r.perUsync)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("getting object records from database: %s, %v", c.RingHash(), err)
                }</span>
        }
        <span class="cov8" title="1">if usyncs &gt;= rd.r.maxUsyncs </span><span class="cov0" title="0">{
                rd.i.incrementStat("diff_capped")
                return fmt.Errorf("capping usync at %d requests", usyncs)
        }</span>
        <span class="cov8" title="1">status, _, err := rd.i.sendReplicationMessage(dev, part, c.RingHash(), "merge_syncs", syncTable)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if status/100 != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid status code from merge_syncs: %d", status)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (rd *replicationDevice) chooseReplicationStrategy(localInfo, remoteInfo *AccountInfo, usyncThreshold int64) string <span class="cov8" title="1">{
        switch </span>{
        case remoteInfo == nil:<span class="cov8" title="1">
                return "complete_rsync"</span>
        case localInfo.MaxRow == -1:<span class="cov8" title="1">
                return "empty"</span>
        case localInfo.MaxRow == remoteInfo.Point:<span class="cov8" title="1">
                return "no_change"</span>
        case localInfo.Hash == remoteInfo.Hash:<span class="cov8" title="1">
                return "hashmatch"</span>
        default:<span class="cov8" title="1">
                return "diff"</span>
        }
}

func (rd *replicationDevice) replicateDatabaseToDevice(dev *ring.Device, c ReplicableAccount, part uint64) error <span class="cov8" title="1">{
        rd.i.incrementStat("attempted")
        info, err := c.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("getting local info from %s: %v", c.RingHash(), err)
        }</span>
        <span class="cov8" title="1">remoteInfo, err := rd.i.sync(dev, part, c.RingHash(), info)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">strategy := rd.i.chooseReplicationStrategy(info, remoteInfo, rd.r.perUsync*3)
        rd.i.incrementStat(strategy)
        switch strategy </span>{
        case "empty", "hashmatch", "no_change":<span class="cov8" title="1">
                rd.r.logger.Debug("Not replicating anything.",
                        zap.String("strategy", strategy),
                        zap.String("RingHash", c.RingHash()))</span>
        case "complete_rsync":<span class="cov8" title="1">
                rd.r.logger.Debug("Replicating ringhash",
                        zap.String("RingHash", c.RingHash()),
                        zap.String("Ip", dev.Ip),
                        zap.String("Device", dev.Device),
                        zap.String("strategy", strategy))
                return rd.i.rsync(dev, c, part, strategy)</span>
        case "diff":<span class="cov8" title="1">
                rd.r.logger.Debug("Replicating ringhash",
                        zap.String("RingHash", c.RingHash()),
                        zap.String("Ip", dev.Ip),
                        zap.String("Device", dev.Device),
                        zap.String("strategy", strategy))
                return rd.i.usync(dev, c, part, info.ID, remoteInfo.Point)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (rd *replicationDevice) checkForReaping(dbFile string) error <span class="cov8" title="1">{
        c, err := sqliteOpenAccount(dbFile)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer c.Close()
        if d, err := c.IsDeleted(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov8" title="1"> if !d </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">parts := filepath.Base(filepath.Dir(filepath.Dir(filepath.Dir(dbFile))))
        part, err := strconv.ParseUint(parts, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Bad partition: %s", parts)
        }</span>
        <span class="cov8" title="1">devs := rd.r.Ring.GetNodes(part)
        if len(devs) == 0 || devs[0].Id != rd.dev.Id </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">info, err := c.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">doDelete := false
        if info.DeleteTimestamp &gt; info.PutTimestamp </span><span class="cov8" title="1">{
                if dti, err := strconv.ParseFloat(info.DeleteTimestamp, 64); err == nil </span><span class="cov8" title="1">{
                        dt := time.Unix(int64(dti), 0)
                        cutOff := time.Now().Add(time.Second * time.Duration(-rd.r.reclaimAge))

                        if dt.Before(cutOff) </span><span class="cov8" title="1">{
                                doDelete = true
                        }</span>
                } else<span class="cov0" title="0"> {
                        return err
                }</span>
        }
        <span class="cov8" title="1">if doDelete </span><span class="cov8" title="1">{
                rd.r.TryToReapAccount(dbFile)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (rd *replicationDevice) replicateDatabase(dbFile string) error <span class="cov8" title="1">{
        rd.r.logger.Debug("Replicating database.", zap.String("dbFile", filepath.Base(dbFile)))
        parts := filepath.Base(filepath.Dir(filepath.Dir(filepath.Dir(dbFile))))
        part, err := strconv.ParseUint(parts, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Bad partition: %s", parts)
        }</span>
        <span class="cov8" title="1">devices, handoff := rd.r.Ring.GetJobNodes(part, rd.dev.Id)
        moreNodes := rd.r.Ring.GetMoreNodes(part)
        c, err := sqliteOpenAccount(dbFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer c.Close()
        if err := c.CleanupTombstones(rd.r.reclaimAge); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">successes := 0
        for i := 0; i &lt; len(devices); i++ </span><span class="cov8" title="1">{
                if err := rd.i.replicateDatabaseToDevice(devices[i], c, part); err == nil </span><span class="cov8" title="1">{
                        rd.i.incrementStat("success")
                        rd.r.logger.Debug("Succeeded replicating database.",
                                zap.String("dbFile", dbFile),
                                zap.String("Ip", devices[i].Ip),
                                zap.String("Device", devices[i].Device))
                        successes++
                }</span> else<span class="cov8" title="1"> {
                        rd.i.incrementStat("failure")
                        rd.r.logger.Error("Error replicating database.",
                                zap.String("dbFile", dbFile),
                                zap.String("Ip", devices[i].Ip),
                                zap.String("Device", devices[i].Device),
                                zap.Error(err))
                        if err == errDeviceNotMounted &amp;&amp; !handoff </span><span class="cov0" title="0">{
                                next := moreNodes.Next()
                                if next == nil </span><span class="cov0" title="0">{
                                        rd.r.logger.Error("Ran out of handoffs to talk to.",
                                                zap.String("dbFile", dbFile))
                                }</span> else<span class="cov0" title="0"> {
                                        devices = append(devices, moreNodes.Next())
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">if handoff &amp;&amp; successes == len(devices) </span><span class="cov8" title="1">{
                lock, err := fs.LockPath(filepath.Dir(dbFile), dirLockTimeout)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">defer lock.Close()
                rd.i.incrementStat("remove")
                return os.RemoveAll(filepath.Dir(dbFile))</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (rd *replicationDevice) findAccountDbs(devicePath string, results chan string) <span class="cov8" title="1">{
        defer close(results)
        accountsDir := filepath.Join(devicePath, "accounts")
        partitions, err := filepath.Glob(filepath.Join(accountsDir, "[0-9]*"))
        if err != nil </span><span class="cov0" title="0">{
                rd.r.logger.Error("Error getting partitions.",
                        zap.String("accountsDir", accountsDir),
                        zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">for _, part := range partitions </span><span class="cov8" title="1">{
                suffixes, err := filepath.Glob(filepath.Join(part, "[a-f0-9][a-f0-9][a-f0-9]"))
                if err != nil </span><span class="cov0" title="0">{
                        rd.r.logger.Error("Error getting suffixes.",
                                zap.String("part", part),
                                zap.Error(err))
                        return
                }</span>
                <span class="cov8" title="1">for _, suff := range suffixes </span><span class="cov8" title="1">{
                        hashes, err := filepath.Glob(filepath.Join(suff, "????????????????????????????????"))
                        if err != nil </span><span class="cov0" title="0">{
                                rd.r.logger.Error("Error getting hashes",
                                        zap.String("suff", suff),
                                        zap.Error(err))
                                return
                        }</span>
                        <span class="cov8" title="1">for _, hash := range hashes </span><span class="cov8" title="1">{
                                dbFile := filepath.Join(hash, filepath.Base(hash)+".db")
                                if fs.Exists(dbFile) </span><span class="cov8" title="1">{
                                        select </span>{
                                        case results &lt;- dbFile:</span><span class="cov8" title="1">
                                        case &lt;-rd.cancel:<span class="cov8" title="1">
                                                return</span>
                                        }
                                }
                        }
                }
        }
}

func (rd *replicationDevice) replicate() <span class="cov8" title="1">{
        rd.r.logger.Info("Beginning replication for device.",
                zap.String("device", rd.dev.Device))
        rd.r.startRun &lt;- rd.dev.Device
        devicePath := filepath.Join(rd.r.deviceRoot, rd.dev.Device)
        stat, err := os.Stat(devicePath)
        if err != nil || !stat.IsDir() </span><span class="cov0" title="0">{
                rd.r.logger.Error("Device doesn't exist.",
                        zap.String("devicePath", devicePath), zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">if mount, err := fs.IsMount(devicePath); rd.r.checkMounts &amp;&amp; (err != nil || !mount) </span><span class="cov0" title="0">{
                rd.r.logger.Error("Device not mounted.",
                        zap.String("devicePath", devicePath), zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">results := make(chan string, 100)
        go rd.i.findAccountDbs(devicePath, results)
        for dbFile := range results </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-rd.cancel:<span class="cov0" title="0">
                        return</span>
                case rd.r.concurrencySem &lt;- struct{}{}:<span class="cov8" title="1">
                        rd.r.checkin &lt;- rd.dev.Device
                        if err := rd.i.replicateDatabase(dbFile); err != nil </span><span class="cov0" title="0">{
                                rd.r.logger.Error("Error replicating database file.",
                                        zap.String("dbFile", dbFile),
                                        zap.Error(err))
                        }</span>
                        <span class="cov8" title="1">&lt;-rd.r.concurrencySem</span>
                }
                <span class="cov8" title="1">if err := rd.i.checkForReaping(dbFile); err != nil </span><span class="cov8" title="1">{
                        rd.r.logger.Error("Error checking for reaping database file.",
                                zap.String("dbFile", dbFile),
                                zap.Error(err))
                }</span>
        }
}

func (rd *replicationDevice) replicateLoop() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-rd.cancel:<span class="cov0" title="0">
                        return</span>
                default:<span class="cov8" title="1">
                        rd.replicate()</span>
                }
                <span class="cov0" title="0">time.Sleep(time.Second * 30)</span>
        }
}

func (rd *replicationDevice) incrementStat(stat string) <span class="cov8" title="1">{
        rd.r.sendStat &lt;- statUpdate{rd.dev.Device, stat, 1}
}</span>

func newReplicationDevice(dev *ring.Device, r *Replicator) *replicationDevice <span class="cov8" title="1">{
        rd := &amp;replicationDevice{
                r:             r,
                cancel:        make(chan struct{}),
                lastCheckin:   time.Now(),
                deviceStarted: time.Now(),
                dev:           dev,
                stats: map[string]int64{
                        "attempted":    0,
                        "success":      0,
                        "failure":      0,
                        "no_change":    0,
                        "hashmatch":    0,
                        "rsync":        0,
                        "diff":         0,
                        "remove":       0,
                        "empty":        0,
                        "remote_merge": 0,
                        "diff_capped":  0,
                },
                lifetimeStats: map[string]int64{
                        "attempted":    0,
                        "success":      0,
                        "failure":      0,
                        "no_change":    0,
                        "hashmatch":    0,
                        "rsync":        0,
                        "diff":         0,
                        "remove":       0,
                        "empty":        0,
                        "remote_merge": 0,
                        "diff_capped":  0,
                        "passes":       0,
                },
        }
        rd.i = rd
        return rd
}</span>

func (server *Replicator) Type() string <span class="cov0" title="0">{
        return "account-replicator"
}</span>

func (server *Replicator) Background(flags *flag.FlagSet) chan struct{} <span class="cov0" title="0">{
        once := false
        if f := flags.Lookup("once"); f != nil </span><span class="cov0" title="0">{
                once = f.Value.(flag.Getter).Get() == true
        }</span>
        <span class="cov0" title="0">if once </span><span class="cov0" title="0">{
                ch := make(chan struct{})
                go func() </span><span class="cov0" title="0">{
                        defer close(ch)
                        server.Run()
                }</span>()
                <span class="cov0" title="0">return ch</span>
        }
        <span class="cov0" title="0">go server.RunForever()
        return nil</span>
}

func (server *Replicator) GetHandler(config conf.Config, metricsPrefix string) http.Handler <span class="cov0" title="0">{
        var metricsScope tally.Scope
        metricsScope, server.metricsCloser = tally.NewRootScope(tally.ScopeOptions{
                Prefix:         metricsPrefix,
                Tags:           map[string]string{},
                CachedReporter: promreporter.NewReporter(promreporter.Options{}),
                Separator:      promreporter.DefaultSeparator,
        }, time.Second)
        commonHandlers := alice.New(
                middleware.NewDebugResponses(config.GetBool("debug", "debug_x_source_code", false)),
                server.LogRequest,
                middleware.RecoverHandler,
                middleware.ValidateRequest,
        )
        router := srv.NewRouter()
        router.Get("/metrics", prometheus.Handler())
        router.Get("/loglevel", server.logLevel)
        router.Put("/loglevel", server.logLevel)
        router.Get("/healthcheck", commonHandlers.ThenFunc(server.HealthcheckHandler))
        router.Get("/debug/pprof/:parm", http.DefaultServeMux)
        router.Post("/debug/pprof/:parm", http.DefaultServeMux)
        return alice.New(middleware.Metrics(metricsScope), middleware.ServerTracer(server.tracer)).Then(router)
}</span>

func (server *Replicator) Finalize() <span class="cov0" title="0">{
        if server.metricsCloser != nil </span><span class="cov0" title="0">{
                server.metricsCloser.Close()
        }</span>
        <span class="cov0" title="0">if server.traceCloser != nil </span><span class="cov0" title="0">{
                server.traceCloser.Close()
        }</span>
        <span class="cov0" title="0">if server.clientTraceCloser != nil </span><span class="cov0" title="0">{
                server.clientTraceCloser.Close()
        }</span>
}

func (server *Replicator) HealthcheckHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        writer.Header().Set("Content-Length", "2")
        writer.WriteHeader(http.StatusOK)
        writer.Write([]byte("OK"))
}</span>

func (server *Replicator) LogRequest(next http.Handler) http.Handler <span class="cov0" title="0">{
        return srv.LogRequest(server.logger, next)
}</span>

func (r *Replicator) verifyDevices() <span class="cov8" title="1">{
        // kill devices that haven't checked in for a while
        for key, rd := range r.runningDevices </span><span class="cov8" title="1">{
                if time.Since(rd.lastCheckin) &gt; deviceLockupTimeout </span><span class="cov8" title="1">{
                        close(rd.cancel)
                        delete(r.runningDevices, key)
                }</span>
        }
        <span class="cov8" title="1">if !r.reaperLastCheckin.IsZero() &amp;&amp; time.Since(r.reaperLastCheckin) &gt; deviceLockupTimeout </span><span class="cov0" title="0">{
                r.reaperLock.Lock()
                close(r.reaperCanceler)
                r.reaperCanceler = make(chan struct{})
                r.reaperLastCheckin = time.Time{}
                r.reaperLock.Unlock()
        }</span>
        <span class="cov8" title="1">ringDevices, err := r.Ring.LocalDevices(r.serverPort)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Error getting local devices from ring.",
                        zap.Error(err))
                return
        }</span>
        // look for devices that aren't running but should be
        <span class="cov8" title="1">for _, dev := range ringDevices </span><span class="cov8" title="1">{
                if _, ok := r.runningDevices[dev.Device]; !ok </span><span class="cov8" title="1">{
                        r.runningDevices[dev.Device] = newReplicationDevice(dev, r)
                        go r.runningDevices[dev.Device].replicateLoop()
                }</span>
        }
        // look for devices that are running but shouldn't be
        <span class="cov8" title="1">for key, rd := range r.runningDevices </span><span class="cov8" title="1">{
                found := false
                for _, dev := range ringDevices </span><span class="cov8" title="1">{
                        if dev.Device == key </span><span class="cov8" title="1">{
                                found = true
                        }</span>
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        close(rd.cancel)
                        delete(r.runningDevices, key)
                }</span>
        }
}

func (r *Replicator) reportStats() <span class="cov8" title="1">{
        var totalTime time.Duration
        aggStats := map[string]int64{"attempted": 0, "success": 0, "failure": 0, "remove": 0}
        for _, device := range r.runningDevices </span><span class="cov8" title="1">{
                totalTime += time.Since(device.runStarted)
                aggStats["attempted"] += device.stats["attempted"]
                aggStats["success"] += device.stats["success"]
                aggStats["failure"] += device.stats["failure"]
                aggStats["remove"] += device.stats["remove"]
        }</span>
        // there's no longer the concept of a single pass, so we report the average running time.
        <span class="cov8" title="1">if len(r.runningDevices) &gt; 0 </span><span class="cov8" title="1">{
                rate := 0.0
                runningTime := (totalTime / time.Duration(len(r.runningDevices))).Seconds()
                if runningTime &gt; 0 </span><span class="cov8" title="1">{
                        rate = float64(aggStats["attempted"]) / runningTime
                }</span>
                <span class="cov8" title="1">r.logger.Info("Attempted to replicate dbs",
                        zap.Int64("aggStats['attempted']", aggStats["attempted"]),
                        zap.Float64("runningTime", runningTime),
                        zap.Float64("rate", rate))

                r.logger.Info("Removed dbs",
                        zap.Int64("aggStats['remove']", aggStats["remove"]))
                r.logger.Info("Sucess &amp; Failure",
                        zap.Int64("success", aggStats["success"]),
                        zap.Int64("failure", aggStats["failure"]))</span>
        } else<span class="cov0" title="0"> {
                r.logger.Info("No devices replicating.")
        }</span>
}

func (r *Replicator) runLoopCheck(reportTimer &lt;-chan time.Time) <span class="cov8" title="1">{
        select </span>{
        case device := &lt;-r.checkin:<span class="cov8" title="1">
                if rd, ok := r.runningDevices[device]; ok </span><span class="cov8" title="1">{
                        rd.lastCheckin = time.Now() //TODO: add locking around this
                }</span>
        case &lt;-r.reaperCheckin:<span class="cov0" title="0">
                r.reaperLock.Lock()
                r.reaperLastCheckin = time.Now()
                r.reaperLock.Unlock()</span>
        case device := &lt;-r.startRun:<span class="cov8" title="1">
                if rd, ok := r.runningDevices[device]; ok </span><span class="cov8" title="1">{
                        rd.runStarted = time.Now()
                        rd.lastCheckin = time.Now()
                        for k, v := range rd.stats </span><span class="cov8" title="1">{
                                rd.stats[k] = 0
                                rd.lifetimeStats[k] += v
                        }</span>
                        <span class="cov8" title="1">rd.lifetimeStats["passes"]++</span>
                }
        case update := &lt;-r.sendStat:<span class="cov8" title="1">
                if rd, ok := r.runningDevices[update.device]; ok </span><span class="cov8" title="1">{
                        rd.stats[update.stat] += update.value
                }</span>
        case &lt;-reportTimer:<span class="cov8" title="1">
                r.reportStats()
                r.verifyDevices()</span>
        }
}

// RunForever runs the replicator in a forever-loop.
func (r *Replicator) RunForever() <span class="cov0" title="0">{
        reportTimer := time.NewTimer(time.Minute * 15)
        r.verifyDevices()
        for </span><span class="cov0" title="0">{
                r.runLoopCheck(reportTimer.C)
        }</span>
}

// Run runs a pass of the replicator once.
func (r *Replicator) Run() <span class="cov8" title="1">{
        done := make(chan struct{})
        devices, err := r.Ring.LocalDevices(r.serverPort)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Error getting local devices from ring.",
                        zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">for _, dev := range devices </span><span class="cov8" title="1">{
                r.runningDevices[dev.Device] = newReplicationDevice(dev, r)
                go func(rd *replicationDevice) </span><span class="cov8" title="1">{
                        rd.replicate()
                        done &lt;- struct{}{}
                }</span>(r.runningDevices[dev.Device])
        }
        <span class="cov8" title="1">waitingFor := len(devices)
        for waitingFor &gt; 0 </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-r.checkin:</span><span class="cov0" title="0">
                case &lt;-r.reaperCheckin:</span><span class="cov0" title="0">
                case &lt;-r.startRun:</span><span class="cov8" title="1">
                case update := &lt;-r.sendStat:<span class="cov0" title="0">
                        if ctx, ok := r.runningDevices[update.device]; ok </span><span class="cov0" title="0">{
                                ctx.stats[update.stat] += update.value
                        }</span>
                case &lt;-done:<span class="cov8" title="1">
                        waitingFor--</span>
                }
        }
        <span class="cov8" title="1">r.reportStats()</span>
}

// try to reap account for given database. will spin off a go routine to do
// actual deleting
func (r *Replicator) TryToReapAccount(dbFile string) <span class="cov8" title="1">{
        r.reaperLock.Lock()
        defer r.reaperLock.Unlock()

        if r.reaperLastCheckin.IsZero() </span><span class="cov0" title="0">{
                r.reaperLastCheckin = time.Now()
                go r.reapAccount(dbFile, r.reaperCanceler)
        }</span> else<span class="cov8" title="1"> if time.Since(r.reaperLastCheckin) &gt; deviceLockupTimeout </span><span class="cov0" title="0">{
                close(r.reaperCanceler)
                r.reaperCanceler = make(chan struct{})
                r.reaperLastCheckin = time.Now()
                go r.reapAccount(dbFile, r.reaperCanceler)
        }</span> else<span class="cov8" title="1"> {
                r.logger.Debug("Wanted to reap an account but one is already running", zap.String("dbFile", dbFile))
        }</span>
}
func (r *Replicator) reapContainer(cont string, dc nectar.Client, contObjChan chan *contObj, canceler chan struct{}) error <span class="cov0" title="0">{
        // TODO: add something here that will delete the container if it is empty
        // the reaper will just make 2 passes to get all the way done
        marker := ""
        objs, resp := dc.GetContainer(cont, marker, "", 10000, "", "", false, map[string]string{})
        var obj *nectar.ObjectRecord
        hdrs := map[string]string{}
        for len(objs) &gt; 0 </span><span class="cov0" title="0">{
                obj, objs = objs[0], objs[1:]
                contObjChan &lt;- &amp;contObj{cont, obj.Name}
                marker = obj.Name
                if len(objs) == 0 </span><span class="cov0" title="0">{
                        objs, resp = dc.GetContainer(cont, marker, "", 10000, "", "", false, map[string]string{})
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-canceler:<span class="cov0" title="0">
                        return nil</span>
                default:</span><span class="cov0" title="0">
                }
        }
        <span class="cov0" title="0">hdrs["X-Timestamp"] = common.GetTimestamp()
        if resp = dc.DeleteContainer(cont, hdrs); resp == nil || resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                r.logger.Debug("invalid reap cont resp", zap.String("container", cont))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type contObj struct {
        cont string
        obj  string
}

func (r *Replicator) reapAccount(dbFile string, canceler chan struct{}) <span class="cov0" title="0">{
        db, err := sqliteOpenAccount(dbFile)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("error on opening dbfile", zap.String("dbFile", dbFile), zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer db.Close()
        if d, err := db.IsDeleted(); err != nil </span><span class="cov0" title="0">{
                r.logger.Error("error on checking IsDeleted", zap.String("dbFile", dbFile), zap.Error(err))
                return
        }</span> else<span class="cov0" title="0"> if !d </span><span class="cov0" title="0">{
                r.logger.Error("reapAccount was call on active account", zap.String("dbFile", dbFile))
                return
        }</span>
        <span class="cov0" title="0">info, err := db.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("reapAccount getInfo errpr", zap.String("dbFile", dbFile), zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">dc, err := client.NewDirectClient(info.Account, srv.DefaultConfigLoader{}, r.certFile, r.keyFile, r.logger)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Could not create client to reap account.", zap.String("account", info.Account), zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">wg := sync.WaitGroup{}
        conc := 20 // TODO: make config
        wg.Add(conc)
        contObjChan := make(chan *contObj, conc)
        var objsDeleted int64

        for i := 0; i &lt; conc; i++ </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        for </span><span class="cov0" title="0">{
                                co := &lt;-contObjChan
                                if co == nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">if resp := dc.DeleteObject(co.cont, co.obj, map[string]string{"X-Timestamp": common.GetTimestamp()}); resp == nil || resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                                        r.logger.Debug("invalid reap object resp", zap.String("container", co.cont), zap.String("obj", co.obj))
                                }</span> else<span class="cov0" title="0"> {
                                        atomic.AddInt64(&amp;objsDeleted, 1)
                                }</span>
                                <span class="cov0" title="0">r.reaperCheckin &lt;- struct{}{}</span>
                        }
                }()
        }
        <span class="cov0" title="0">marker := ""
        conts, err := db.ListContainers(1000, marker, "", "", "", false)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("ListContainers error", zap.Error(err))
                conts = nil // should already be nil
        }</span>
        <span class="cov0" title="0">var contr interface{}
ContLoop:
        for len(conts) &gt; 0 </span><span class="cov0" title="0">{
                contr, conts = conts[0], conts[1:]
                cont, ok := contr.(*ContainerListingRecord)
                if ok </span><span class="cov0" title="0">{
                        if err = r.reapContainer(cont.Name, dc, contObjChan, canceler); err != nil </span><span class="cov0" title="0">{
                                r.logger.Error("error reaping container", zap.String("account", info.Account), zap.String("container", cont.Name), zap.Error(err))
                        }</span>
                        <span class="cov0" title="0">marker = cont.Name</span>
                } else<span class="cov0" title="0"> {
                        r.logger.Error("invalid listing", zap.String("record", fmt.Sprintf("%v", contr)))
                        break ContLoop</span>
                }
                <span class="cov0" title="0">if len(conts) == 0 </span><span class="cov0" title="0">{
                        conts, err = db.ListContainers(1000, marker, "", "", "", false)
                        if err != nil </span><span class="cov0" title="0">{
                                r.logger.Error("ListContainers error", zap.Error(err))
                                break ContLoop</span>
                        }
                }
                <span class="cov0" title="0">select </span>{
                case &lt;-canceler:<span class="cov0" title="0">
                        break ContLoop</span>
                default:</span><span class="cov0" title="0">
                }
        }
        <span class="cov0" title="0">close(contObjChan)
        wg.Wait()
        r.logger.Info("reaped account", zap.String("account", info.Account), zap.Int64("objectsDeleted", objsDeleted), zap.Bool("Errored Out", err != nil), zap.Error(err))</span>
}

// NewReplicator uses the config settings and command-line flags to configure and return a replicator daemon struct.
func NewReplicator(serverconf conf.Config, flags *flag.FlagSet, cnf srv.ConfigLoader) (*srv.IpPort, srv.Server, srv.LowLevelLogger, error) <span class="cov8" title="1">{
        var ipPort *srv.IpPort
        var err error
        var logger srv.LowLevelLogger
        if !serverconf.HasSection("account-replicator") </span><span class="cov8" title="1">{
                return ipPort, nil, nil, fmt.Errorf("Unable to find account-replicator config section")
        }</span>
        <span class="cov8" title="1">hashPathPrefix, hashPathSuffix, err := cnf.GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov8" title="1">{
                return ipPort, nil, nil, fmt.Errorf("Unable to get hash prefix and suffix: %s", err)
        }</span>
        <span class="cov8" title="1">ring, err := cnf.GetRing("account", hashPathPrefix, hashPathSuffix, 0)
        if err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, fmt.Errorf("Error loading account ring: %s", err)
        }</span>
        <span class="cov8" title="1">concurrency := int(serverconf.GetInt("account-replicator", "concurrency", 4))

        logLevelString := serverconf.GetDefault("account-replicator", "log_level", "INFO")
        logLevel := zap.NewAtomicLevel()
        logLevel.UnmarshalText([]byte(strings.ToLower(logLevelString)))

        if logger, err = srv.SetupLogger("account-replicator", &amp;logLevel, flags); err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, fmt.Errorf("Error setting up logger: %v", err)
        }</span>
        <span class="cov8" title="1">ip := serverconf.GetDefault("account-replicator", "bind_ip", "0.0.0.0")
        port := int(serverconf.GetInt("account-replicator", "bind_port", common.DefaultAccountReplicatorPort))
        certFile := serverconf.GetDefault("account-replicator", "cert_file", "")
        keyFile := serverconf.GetDefault("account-replicator", "key_file", "")

        transport := &amp;http.Transport{
                Dial:                (&amp;net.Dialer{Timeout: time.Second}).Dial,
                MaxIdleConnsPerHost: 100,
                MaxIdleConns:        0,
        }
        if certFile != "" &amp;&amp; keyFile != "" </span><span class="cov0" title="0">{
                tlsConf, err := common.NewClientTLSConfig(certFile, keyFile)
                if err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error getting TLS config: %v", err)
                }</span>
                <span class="cov0" title="0">transport.TLSClientConfig = tlsConf
                if err = http2.ConfigureTransport(transport); err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error setting up http2: %v", err)
                }</span>
        }
        <span class="cov8" title="1">c := &amp;http.Client{
                Timeout:   time.Minute * 15,
                Transport: transport,
        }
        server := &amp;Replicator{
                runningDevices: make(map[string]*replicationDevice),
                perUsync:       3000,
                maxUsyncs:      25,
                sendStat:       make(chan statUpdate),
                checkin:        make(chan string),
                reaperCheckin:  make(chan struct{}),
                reaperCanceler: make(chan struct{}),
                startRun:       make(chan string),
                reconCachePath: serverconf.GetDefault("account-replicator", "recon_cache_path", "/var/cache/swift"),
                checkMounts:    serverconf.GetBool("account-replicator", "mount_check", true),
                deviceRoot:     serverconf.GetDefault("account-replicator", "devices", "/srv/node"),
                serverPort:     port,
                reclaimAge:     serverconf.GetInt("account-replicator", "reclaim_age", 604800),
                logger:         logger,
                concurrencySem: make(chan struct{}, concurrency),
                Ring:           ring,
                client:         c,
                certFile:       certFile,
                keyFile:        keyFile,
                logLevel:       logLevel,
        }
        if serverconf.HasSection("tracing") </span><span class="cov0" title="0">{
                server.tracer, server.traceCloser, err = tracing.Init("account-replicator", server.logger, serverconf.GetSection("tracing"))
                if err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error setting up tracer: %v", err)
                }</span>
                <span class="cov0" title="0">server.clientTracer, server.clientTraceCloser, err = tracing.Init("account-replicator-client", server.logger, serverconf.GetSection("tracing"))
                if err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error setting up tracer: %v", err)
                }</span>
                <span class="cov0" title="0">enableHTTPTrace := serverconf.GetBool("tracing", "enable_httptrace", true)
                server.client, err = client.NewTracingClient(server.clientTracer, c, enableHTTPTrace)
                if err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error setting up tracing client: %v", err)
                }</span>
        }
        <span class="cov8" title="1">ipPort = &amp;srv.IpPort{Ip: ip, Port: port, CertFile: certFile, KeyFile: keyFile}
        return ipPort, server, logger, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">//  Copyright (c) 2016-2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package accountserver

import (
        "database/sql"
        "fmt"
        "strings"
)

const (
        accountDBScript = `
                CREATE TABLE outgoing_sync (
                        remote_id TEXT UNIQUE,
                        sync_point INTEGER,
                        updated_at TEXT DEFAULT 0
                );
                CREATE TRIGGER outgoing_sync_insert AFTER INSERT ON outgoing_sync
                        BEGIN
                                UPDATE outgoing_sync
                                SET updated_at = STRFTIME('%s', 'NOW')
                                WHERE ROWID = new.ROWID;
                        END;
                CREATE TRIGGER outgoing_sync_update AFTER UPDATE ON outgoing_sync
                        BEGIN
                                UPDATE outgoing_sync
                                SET updated_at = STRFTIME('%s', 'NOW')
                                WHERE ROWID = new.ROWID;
                        END;

                CREATE TABLE incoming_sync (
                        remote_id TEXT UNIQUE,
                        sync_point INTEGER,
                        updated_at TEXT DEFAULT 0
                );
                CREATE TRIGGER incoming_sync_insert AFTER INSERT ON incoming_sync
                        BEGIN
                                UPDATE incoming_sync
                                SET updated_at = STRFTIME('%s', 'NOW')
                                WHERE ROWID = new.ROWID;
                        END;
                CREATE TRIGGER incoming_sync_update AFTER UPDATE ON incoming_sync
                        BEGIN
                                UPDATE incoming_sync
                                SET updated_at = STRFTIME('%s', 'NOW')
                                WHERE ROWID = new.ROWID;
                        END;

                CREATE TABLE container (
                        ROWID INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT,
                        put_timestamp TEXT,
                        delete_timestamp TEXT,
                        object_count INTEGER,
                        bytes_used INTEGER,
                        deleted INTEGER DEFAULT 0,
                        storage_policy_index INTEGER DEFAULT 0
                );
                CREATE INDEX ix_container_deleted_name ON container (deleted, name);

                CREATE TABLE account_stat (
                        account TEXT,
                        created_at TEXT,
                        put_timestamp TEXT DEFAULT '0',
                        delete_timestamp TEXT DEFAULT '0',
                        container_count INTEGER,
                        object_count INTEGER DEFAULT 0,
                        bytes_used INTEGER DEFAULT 0,
                        hash TEXT default '00000000000000000000000000000000',
                        id TEXT,
                        status TEXT DEFAULT '',
                        status_changed_at TEXT DEFAULT '0',
                        metadata TEXT DEFAULT ''
                );

                CREATE TRIGGER container_update BEFORE UPDATE ON container
                        BEGIN
                                SELECT RAISE(FAIL, 'UPDATE not allowed; DELETE and INSERT');
                        END;
                CREATE TRIGGER container_insert AFTER INSERT ON container
                        BEGIN
                                UPDATE account_stat
                                SET container_count = container_count + (1 - new.deleted),
                                        object_count = object_count + new.object_count,
                                        bytes_used = bytes_used + new.bytes_used,
                                        hash = chexor(hash, new.name,
                                                                  new.put_timestamp || '-' ||
                                                                  new.delete_timestamp || '-' ||
                                                                  new.object_count || '-' || new.bytes_used);
                        END;
                CREATE TRIGGER container_delete AFTER DELETE ON container
                        BEGIN
                                UPDATE account_stat
                                SET container_count = container_count - (1 - old.deleted),
                                        object_count = object_count - old.object_count,
                                        bytes_used = bytes_used - old.bytes_used,
                                        hash = chexor(hash, old.name,
                                                                  old.put_timestamp || '-' ||
                                                                  old.delete_timestamp || '-' ||
                                                                  old.object_count || '-' || old.bytes_used);
                        END;
                `

        policyStatTableScript = `
                CREATE TABLE policy_stat (
                        storage_policy_index INTEGER PRIMARY KEY,
                        container_count INTEGER DEFAULT 0,
                        object_count INTEGER DEFAULT 0,
                        bytes_used INTEGER DEFAULT 0
                );
                INSERT OR IGNORE INTO policy_stat (storage_policy_index, container_count, object_count, bytes_used)
                        SELECT 0, container_count, object_count, bytes_used FROM account_stat WHERE container_count &gt; 0;
                `

        policyStatTriggerScript = `
                CREATE TRIGGER container_insert_ps AFTER INSERT ON container
                        BEGIN
                                INSERT OR IGNORE INTO policy_stat
                                        (storage_policy_index, container_count, object_count, bytes_used)
                                        VALUES (new.storage_policy_index, 0, 0, 0);
                                UPDATE policy_stat
                                SET container_count = container_count + (1 - new.deleted),
                                        object_count = object_count + new.object_count,
                                        bytes_used = bytes_used + new.bytes_used
                                WHERE storage_policy_index = new.storage_policy_index;
                        END;
                CREATE TRIGGER container_delete_ps AFTER DELETE ON container
                        BEGIN
                                UPDATE policy_stat
                                SET container_count = container_count - (1 - old.deleted),
                                        object_count = object_count - old.object_count,
                                        bytes_used = bytes_used - old.bytes_used
                                WHERE storage_policy_index = old.storage_policy_index;
                        END;
        `

        pragmaScript = `
                PRAGMA synchronous = NORMAL;
                PRAGMA cache_size = -4096;
                PRAGMA temp_store = MEMORY;
                PRAGMA journal_mode = WAL;
                PRAGMA busy_timeout = 25000;`
)

func schemaMigrate(db *sql.DB) (bool, error) <span class="cov8" title="1">{
        hasMetadata := false
        hasPolicyStat := false
        hasContainerCount := false
        hasDeletedNameIndex := false

        tx, err := db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        // We just pull the schema out of sqlite_master and look at it to get the current state of the database.
        rows, err := tx.Query("SELECT name, sql FROM sqlite_master WHERE name in ('policy_stat', 'account_stat', 'policy_stat', 'ix_container_deleted_name')")
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                var name, sql string
                if err := rows.Scan(&amp;name, &amp;sql); err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">if name == "policy_stat" </span><span class="cov8" title="1">{
                        hasPolicyStat = true
                        hasContainerCount = strings.Contains(sql, "container_count")
                }</span> else<span class="cov8" title="1"> if name == "account_stat" </span><span class="cov8" title="1">{
                        hasMetadata = strings.Contains(sql, "metadata")
                }</span> else<span class="cov8" title="1"> if name == "ix_container_deleted_name" </span><span class="cov8" title="1">{
                        hasDeletedNameIndex = true
                }</span>
        }

        <span class="cov8" title="1">if hasMetadata &amp;&amp; hasPolicyStat &amp;&amp; hasContainerCount </span><span class="cov8" title="1">{
                return hasDeletedNameIndex, nil
        }</span>

        <span class="cov0" title="0">if !hasMetadata </span><span class="cov0" title="0">{
                script := "ALTER TABLE account_stat ADD COLUMN metadata DEFAULT '{}';"
                if _, err := tx.Exec(script); err != nil </span><span class="cov0" title="0">{
                        return hasDeletedNameIndex, fmt.Errorf("Adding metadata column: %v", err)
                }</span>
        }
        <span class="cov0" title="0">if !hasPolicyStat </span><span class="cov0" title="0">{
                script := `
                        ALTER TABLE container ADD COLUMN storage_policy_index INTEGER DEFAULT 0;
                ` + policyStatTableScript + policyStatTriggerScript
                if _, err = tx.Exec(script); err != nil </span><span class="cov0" title="0">{
                        return hasDeletedNameIndex, fmt.Errorf("Performing policy migration: %v", err)
                }</span>
        } else<span class="cov0" title="0"> if !hasContainerCount </span><span class="cov0" title="0">{
                script := `
                        DROP TRIGGER container_delete_ps;
                        DROP TRIGGER container_insert_ps;
                        ALTER TABLE policy_stat ADD COLUMN container_count INTEGER DEFAULT 0;
                ` + policyStatTriggerScript + `
                        UPDATE policy_stat SET container_count = (SELECT container_count FROM account_stat)
                                WHERE (SELECT COUNT(storage_policy_index) FROM policy_stat) &lt;= 1;

                        INSERT OR REPLACE INTO policy_stat (storage_policy_index, container_count, object_count, bytes_used)
                                SELECT p.storage_policy_index, c.count, p.object_count, p.bytes_used
                                FROM (
                                        SELECT storage_policy_index, COUNT(*) as count FROM container
                                        WHERE deleted = 0 GROUP BY storage_policy_index
                                ) c
                                JOIN policy_stat p ON p.storage_policy_index = c.storage_policy_index
                                WHERE NOT EXISTS(SELECT changes() as change FROM policy_stat WHERE change &lt;&gt; 0);
                `
                if _, err = tx.Exec(script); err != nil </span><span class="cov0" title="0">{
                        return hasDeletedNameIndex, fmt.Errorf("Performing container-count migration: %v", err)
                }</span>
        }
        <span class="cov0" title="0">return hasDeletedNameIndex, tx.Commit()</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">//  Copyright (c) 2016-2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package accountserver

import (
        "encoding/json"
        "encoding/xml"
        "flag"
        "fmt"
        "io"
        "net/http"
        _ "net/http/pprof" // install pprof http handlers
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/justinas/alice"
        "github.com/opentracing/opentracing-go"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/common/tracing"
        "github.com/troubling/hummingbird/middleware"
        "github.com/uber-go/tally"
        promreporter "github.com/uber-go/tally/prometheus"
        "go.uber.org/zap"
)

// AccountServer contains all of the information for a running account server.
type AccountServer struct {
        driveRoot        string
        hashPathPrefix   string
        hashPathSuffix   string
        reconCachePath   string
        logger           srv.LowLevelLogger
        logLevel         zap.AtomicLevel
        diskInUse        *common.KeyedLimit
        checkMounts      bool
        accountEngine    AccountEngine
        autoCreatePrefix string
        policyList       conf.PolicyList
        metricsCloser    io.Closer
        traceCloser      io.Closer
        tracer           opentracing.Tracer
}

func formatTimestamp(ts string) (string, error) <span class="cov8" title="1">{
        if len(ts) == 16 &amp;&amp; ts[10] == '.' </span><span class="cov8" title="1">{
                return ts, nil
        }</span>
        <span class="cov8" title="1">t, err := strconv.ParseFloat(ts, 64)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">ret := strconv.FormatFloat(t, 'f', 5, 64)
        if len(ret) &lt; 16 </span><span class="cov8" title="1">{
                return strings.Repeat("0", 16-len(ret)) + ret, nil
        }</span>
        <span class="cov0" title="0">return ret, nil</span>
}

func (server *AccountServer) Type() string <span class="cov0" title="0">{
        return "account"
}</span>

func (server *AccountServer) Background(flags *flag.FlagSet) chan struct{} <span class="cov0" title="0">{
        return nil
}</span>

func (server *AccountServer) Finalize() <span class="cov0" title="0">{
        if server.metricsCloser != nil </span><span class="cov0" title="0">{
                server.metricsCloser.Close()
        }</span>
        <span class="cov0" title="0">if server.traceCloser != nil </span><span class="cov0" title="0">{
                server.traceCloser.Close()
        }</span>
}

// AccountGetHandler handles GET and HEAD requests for an account.
func (server *AccountServer) AccountGetHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        if err := request.ParseForm(); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">db, err := server.accountEngine.Get(vars)
        if err == ErrorNoSuchAccount </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get account.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer server.accountEngine.Return(db)
        info, err := db.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get account info. ", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">headers := writer.Header()
        if ts, err := formatTimestamp(info.CreatedAt); err == nil </span><span class="cov8" title="1">{
                headers.Set("X-Backend-Timestamp", ts)
        }</span>
        <span class="cov8" title="1">if ts, err := formatTimestamp(info.PutTimestamp); err == nil </span><span class="cov8" title="1">{
                headers.Set("X-Backend-Put-Timestamp", ts)
        }</span>
        <span class="cov8" title="1">if ts, err := formatTimestamp(info.DeleteTimestamp); err == nil </span><span class="cov8" title="1">{
                headers.Set("X-Backend-Delete-Timestamp", ts)
        }</span>
        <span class="cov8" title="1">if ts, err := formatTimestamp(info.StatusChangedAt); err == nil </span><span class="cov8" title="1">{
                headers.Set("X-Backend-Status-Changed-At", ts)
        }</span>
        <span class="cov8" title="1">metadata, err := db.GetMetadata()
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get metadata.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">for key, value := range metadata </span><span class="cov8" title="1">{
                headers.Set(key, value)
        }</span>
        <span class="cov8" title="1">if deleted, err := db.IsDeleted(); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error calling IsDeleted.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span> else<span class="cov8" title="1"> if deleted </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span> else<span class="cov8" title="1"> {
                headers.Set("X-Account-Container-Count", strconv.FormatInt(info.ContainerCount, 10))
                headers.Set("X-Account-Object-Count", strconv.FormatInt(info.ObjectCount, 10))
                headers.Set("X-Account-Bytes-Used", strconv.FormatInt(info.BytesUsed, 10))
                if ts, err := formatTimestamp(info.CreatedAt); err == nil </span><span class="cov8" title="1">{
                        headers.Set("X-Timestamp", ts)
                }</span>
                <span class="cov8" title="1">if ts, err := formatTimestamp(info.PutTimestamp); err == nil </span><span class="cov8" title="1">{
                        headers.Set("X-Put-Timestamp", ts)
                }</span>
        }
        <span class="cov8" title="1">if policyStats, err := db.PolicyStats(); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error calling PolicyStats.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span> else<span class="cov8" title="1"> {
                for _, policyStat := range policyStats </span><span class="cov8" title="1">{
                        var prefix string
                        if policy := server.policyList[policyStat.StoragePolicyIndex]; policy != nil </span><span class="cov0" title="0">{
                                prefix = fmt.Sprintf("X-Account-Storage-Policy-%s-", policy.Name)
                        }</span> else<span class="cov8" title="1"> {
                                prefix = fmt.Sprintf("X-Account-Storage-Policy-%d-", policyStat.StoragePolicyIndex)
                        }</span>
                        <span class="cov8" title="1">headers.Set(prefix+"Container-Count", fmt.Sprintf("%d", policyStat.ContainerCount))
                        headers.Set(prefix+"Object-Count", fmt.Sprintf("%d", policyStat.ObjectCount))
                        headers.Set(prefix+"Bytes-Used", fmt.Sprintf("%d", policyStat.BytesUsed))</span>
                }
        }
        <span class="cov8" title="1">if request.Method == "HEAD" </span><span class="cov8" title="1">{
                headers.Set("Content-Type", "text/plain; charset=utf-8")
                writer.WriteHeader(http.StatusNoContent)
                writer.Write([]byte(""))
                return
        }</span>
        <span class="cov8" title="1">limit := int64(10000)
        limitStr := request.FormValue("limit")
        if limitStr != "" </span><span class="cov0" title="0">{
                limit, _ = strconv.ParseInt(limitStr, 10, 64)
                if limit &gt; 10000 </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, http.StatusPreconditionFailed)
                        return
                }</span> else<span class="cov0" title="0"> if limit &lt; 0 </span><span class="cov0" title="0">{
                        limit = 10000
                }</span>
        }
        <span class="cov8" title="1">marker := request.Form.Get("marker")
        delimiter := request.Form.Get("delimiter")
        endMarker := request.Form.Get("end_marker")
        prefix := request.Form.Get("prefix")
        reverse := common.LooksTrue(request.Form.Get("reverse"))
        containers, err := db.ListContainers(int(limit), marker, endMarker, prefix, delimiter, reverse)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to list containers.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">format := request.Form.Get("format")
        if format == "" </span><span class="cov8" title="1">{ /* TODO: real accept parsing */
                accept := request.Header.Get("Accept")
                if strings.Contains(accept, "application/json") </span><span class="cov8" title="1">{
                        format = "json"
                }</span> else<span class="cov8" title="1"> if strings.Contains(accept, "application/xml") || strings.Contains(accept, "text/xml") </span><span class="cov0" title="0">{
                        format = "xml"
                }</span> else<span class="cov8" title="1"> {
                        format = "text"
                }</span>
        }
        <span class="cov8" title="1">if format == "json" </span><span class="cov8" title="1">{
                output, err := json.Marshal(containers)
                if err != nil </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">headers.Set("Content-Type", "application/json; charset=utf-8")
                headers.Set("Content-Length", strconv.Itoa(len(output)))
                writer.WriteHeader(200)
                writer.Write(output)</span>
        } else<span class="cov8" title="1"> if format == "xml" </span><span class="cov8" title="1">{
                type Account struct {
                        XMLName    xml.Name `xml:"account"`
                        Name       string   `xml:"name,attr"`
                        Containers []interface{}
                }
                container := &amp;Account{Name: vars["account"], Containers: containers}
                headers.Set("Content-Type", "application/xml; charset=utf-8")
                output, _ := xml.Marshal(container)
                headers.Set("Content-Length", strconv.Itoa(len(output)+39))
                writer.WriteHeader(200)
                writer.Write([]byte("&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n"))
                writer.Write(output)
        }</span> else<span class="cov8" title="1"> {
                response := ""
                for _, obj := range containers </span><span class="cov8" title="1">{
                        if or, ok := obj.(*ContainerListingRecord); ok </span><span class="cov8" title="1">{
                                response += or.Name + "\n"
                        }</span> else<span class="cov0" title="0"> if sr, ok := obj.(*SubdirListingRecord); ok </span><span class="cov0" title="0">{
                                response += sr.Name + "\n"
                        }</span>
                }
                <span class="cov8" title="1">headers.Set("Content-Type", "text/plain; charset=utf-8")
                if len(response) &gt; 0 </span><span class="cov8" title="1">{
                        headers.Set("Content-Length", strconv.Itoa(len(response)))
                        writer.WriteHeader(200)
                        writer.Write([]byte(response))
                }</span> else<span class="cov8" title="1"> {
                        headers.Set("Content-Length", "0")
                        writer.WriteHeader(204)
                        writer.Write([]byte(""))
                }</span>
        }
}

// AccountPutHandler handles PUT requests for an account.
func (server *AccountServer) AccountPutHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        timestamp, err := common.StandardizeTimestamp(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">metadata := make(map[string][]string)
        for key := range request.Header </span><span class="cov8" title="1">{
                if strings.HasPrefix(key, "X-Account-Meta-") || strings.HasPrefix(key, "X-Account-Sysmeta-") </span><span class="cov8" title="1">{
                        metadata[key] = []string{request.Header.Get(key), timestamp}
                }</span>
        }
        <span class="cov8" title="1">created, db, err := server.accountEngine.Create(vars, timestamp, metadata)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to create database.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer server.accountEngine.Return(db)
        if created </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusCreated)
        }</span> else<span class="cov0" title="0"> {
                srv.StandardResponse(writer, http.StatusAccepted)
        }</span>
}

// AccountDeleteHandler handles DELETE requests for an account.
func (server *AccountServer) AccountDeleteHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        db, err := server.accountEngine.Get(vars)
        if err == ErrorNoSuchAccount </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get account.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer server.accountEngine.Return(db)
        timestamp, err := common.StandardizeTimestamp(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">_, err = db.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get account info.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">status, err := db.Delete(timestamp)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to delete database", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if _, err = db.GetInfo(); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to update cache after delete database", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">writer.WriteHeader(status)
        writer.Write([]byte(""))</span>
}

// AccountPostHandler handles POST requests for an account.
func (server *AccountServer) AccountPostHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        timestamp, err := common.StandardizeTimestamp(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">updates := make(map[string][]string)
        for key := range request.Header </span><span class="cov8" title="1">{
                if strings.HasPrefix(key, "X-Account-Meta-") || strings.HasPrefix(key, "X-Account-Sysmeta-") </span><span class="cov8" title="1">{
                        updates[key] = []string{request.Header.Get(key), timestamp}
                }</span>
        }
        <span class="cov8" title="1">db, err := server.accountEngine.Get(vars)
        if err == ErrorNoSuchAccount </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get account.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer server.accountEngine.Return(db)
        if deleted, err := db.IsDeleted(); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error calling IsDeleted", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span> else<span class="cov8" title="1"> if deleted </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err := db.UpdateMetadata(updates); err == ErrorInvalidMetadata </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to update account metadata.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
        }</span> else<span class="cov8" title="1"> {
                writer.WriteHeader(http.StatusNoContent)
                writer.Write([]byte(""))
        }</span>
}

// ContainerPutHandler handles the PUT of container records to an account.
func (server *AccountServer) ContainerPutHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        putTimestamp, err := common.StandardizeTimestamp(request.Header.Get("X-Put-Timestamp"))
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">var objectCount, bytesUsed, storagePolicyIndex int64
        if objectCount, err = strconv.ParseInt(request.Header.Get("X-Object-Count"), 10, 64); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if bytesUsed, err = strconv.ParseInt(request.Header.Get("X-Bytes-Used"), 10, 64); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if storagePolicyIndex, err = strconv.ParseInt(request.Header.Get("X-Backend-Storage-Policy-Index"), 10, 64); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">deleteTimestamp := request.Header.Get("X-Delete-Timestamp")
        db, err := server.accountEngine.Get(vars)
        if err == ErrorNoSuchAccount </span><span class="cov8" title="1">{
                if strings.HasPrefix(vars["account"], server.autoCreatePrefix) </span><span class="cov8" title="1">{
                        if _, db, err = server.accountEngine.Create(vars, putTimestamp, map[string][]string{}); err != nil </span><span class="cov0" title="0">{
                                srv.GetLogger(request).Error("Unable to auto-create account.", zap.Error(err))
                                srv.StandardResponse(writer, http.StatusInternalServerError)
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        srv.StandardResponse(writer, http.StatusNotFound)
                        return
                }</span>
        } else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get account.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer server.accountEngine.Return(db)
        if err := db.PutContainer(vars["container"], putTimestamp, deleteTimestamp, objectCount, bytesUsed, int(storagePolicyIndex)); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error adding container to account.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">srv.StandardResponse(writer, http.StatusCreated)</span>
}

// HealthcheckHandler implements a basic health check, that just returns "OK".
func (server *AccountServer) HealthcheckHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        writer.Header().Set("Content-Length", "2")
        writer.WriteHeader(http.StatusOK)
        writer.Write([]byte("OK"))
}</span>

// ReconHandler delegates incoming /recon calls to the common recon handler.
func (server *AccountServer) ReconHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        middleware.ReconHandler(server.driveRoot, server.reconCachePath, server.checkMounts, writer, request)
}</span>

// DiskUsageHandler returns information on the current outstanding HTTP requests per-disk.
func (server *AccountServer) DiskUsageHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        if data, err := server.diskInUse.MarshalJSON(); err == nil </span><span class="cov0" title="0">{
                writer.WriteHeader(http.StatusOK)
                writer.Write(data)
        }</span> else<span class="cov0" title="0"> {
                writer.WriteHeader(http.StatusInternalServerError)
                writer.Write([]byte(err.Error()))
        }</span>
}

// LogRequest is a middleware that logs requests and also sets up a logger in the request context.
func (server *AccountServer) LogRequest(next http.Handler) http.Handler <span class="cov8" title="1">{
        return srv.LogRequest(server.logger, next)
}</span>

// AcquireDevice is a middleware that makes sure the device is available - mounted and not beyond its max concurrency.
func (server *AccountServer) AcquireDevice(next http.Handler) http.Handler <span class="cov8" title="1">{
        fn := func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                vars := srv.GetVars(request)
                if device, ok := vars["device"]; ok &amp;&amp; device != "" </span><span class="cov8" title="1">{
                        devicePath := filepath.Join(server.driveRoot, device)
                        if server.checkMounts </span><span class="cov0" title="0">{
                                if mounted, err := fs.IsMount(devicePath); err != nil || !mounted </span><span class="cov0" title="0">{
                                        vars["Method"] = request.Method
                                        srv.CustomErrorResponse(writer, 507, vars)
                                        return
                                }</span>
                        }

                        <span class="cov8" title="1">forceAcquire := request.Header.Get("X-Force-Acquire") == "true"
                        if concRequests := server.diskInUse.Acquire(device, forceAcquire); concRequests != 0 </span><span class="cov0" title="0">{
                                writer.Header().Set("X-Disk-Usage", strconv.FormatInt(concRequests, 10))
                                srv.StandardResponse(writer, 503)
                                return
                        }</span>
                        <span class="cov8" title="1">defer server.diskInUse.Release(device)</span>
                }
                <span class="cov8" title="1">next.ServeHTTP(writer, request)</span>
        }
        <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
}

func (server *AccountServer) updateDeviceLocks(seconds int64) <span class="cov0" title="0">{
        reloadTime := time.Duration(seconds) * time.Second
        for </span><span class="cov0" title="0">{
                time.Sleep(reloadTime)
                for _, key := range server.diskInUse.Keys() </span><span class="cov0" title="0">{
                        lockPath := filepath.Join(server.driveRoot, key, "lock_device")
                        if fs.Exists(lockPath) </span><span class="cov0" title="0">{
                                server.diskInUse.Lock(key)
                        }</span> else<span class="cov0" title="0"> {
                                server.diskInUse.Unlock(key)
                        }</span>
                }
        }
}

// GetHandler returns the server's http handler - it sets up routes and instantiates middleware.
func (server *AccountServer) GetHandler(config conf.Config, metricsPrefix string) http.Handler <span class="cov8" title="1">{
        var metricsScope tally.Scope
        metricsScope, server.metricsCloser = tally.NewRootScope(tally.ScopeOptions{
                Prefix:         metricsPrefix,
                Tags:           map[string]string{},
                CachedReporter: promreporter.NewReporter(promreporter.Options{}),
                Separator:      promreporter.DefaultSeparator,
        }, time.Second)
        commonHandlers := alice.New(
                middleware.NewDebugResponses(config.GetBool("debug", "debug_x_source_code", false)),
                server.LogRequest,
                middleware.RecoverHandler,
                middleware.ValidateRequest,
                server.AcquireDevice,
        )
        router := srv.NewRouter()
        router.Get("/metrics", prometheus.Handler())
        router.Get("/loglevel", server.logLevel)
        router.Put("/loglevel", server.logLevel)
        router.Get("/healthcheck", commonHandlers.ThenFunc(server.HealthcheckHandler))
        router.Get("/diskusage", commonHandlers.ThenFunc(server.DiskUsageHandler))
        router.Put("/ring/*ring_path", commonHandlers.ThenFunc(middleware.RingHandler))
        router.Get("/recon/:method/:recon_type", commonHandlers.ThenFunc(server.ReconHandler))
        router.Get("/recon/:method", commonHandlers.ThenFunc(server.ReconHandler))
        router.Delete("/recon/:device/:method/:recon_type/*item_path", commonHandlers.ThenFunc(server.ReconHandler))
        router.Get("/debug/pprof/:parm", http.DefaultServeMux)
        router.Post("/debug/pprof/:parm", http.DefaultServeMux)
        router.Put("/:device/tmp/:filename", commonHandlers.ThenFunc(server.TmpUploadHandler))
        router.Put("/:device/:partition/:account/:container", commonHandlers.ThenFunc(server.ContainerPutHandler))
        router.Put("/:device/:partition/:account", commonHandlers.ThenFunc(server.AccountPutHandler))
        router.Delete("/:device/:partition/:account", commonHandlers.ThenFunc(server.AccountDeleteHandler))
        router.Get("/:device/:partition/:account", commonHandlers.ThenFunc(server.AccountGetHandler))
        router.Head("/:device/:partition/:account", commonHandlers.ThenFunc(server.AccountGetHandler))
        router.Post("/:device/:partition/:account", commonHandlers.ThenFunc(server.AccountPostHandler))
        router.Replicate("/:device/:partition/:hash", commonHandlers.ThenFunc(server.AccountReplicateHandler))
        router.NotFoundHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Invalid path: %s", r.URL.Path), http.StatusBadRequest)
        }</span>)
        <span class="cov8" title="1">return alice.New(middleware.Metrics(metricsScope), middleware.GrepObject, middleware.ServerTracer(server.tracer)).Then(router)</span>
}

// NewServer parses configs and command-line flags, returning a configured server object and the ip and port it should bind on.
func NewServer(serverconf conf.Config, flags *flag.FlagSet, cnf srv.ConfigLoader) (*srv.IpPort, srv.Server, srv.LowLevelLogger, error) <span class="cov0" title="0">{
        var ipPort *srv.IpPort
        var err error
        server := &amp;AccountServer{driveRoot: "/srv/node", hashPathPrefix: "", hashPathSuffix: ""}
        server.hashPathPrefix, server.hashPathSuffix, err = cnf.GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, err
        }</span>
        <span class="cov0" title="0">server.policyList, err = cnf.GetPolicies()
        if err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, err
        }</span>
        <span class="cov0" title="0">server.autoCreatePrefix = serverconf.GetDefault("app:account-server", "auto_create_account_prefix", ".")
        server.driveRoot = serverconf.GetDefault("app:account-server", "devices", "/srv/node")
        server.reconCachePath = serverconf.GetDefault("app:account-server", "recon_cache_path", "/var/cache/swift")
        server.checkMounts = serverconf.GetBool("app:account-server", "mount_check", true)
        server.diskInUse = common.NewKeyedLimit(serverconf.GetLimit("app:account-server", "disk_limit", 0, 0))
        bindIP := serverconf.GetDefault("app:account-server", "bind_ip", "0.0.0.0")
        bindPort := int(serverconf.GetInt("app:account-server", "bind_port", common.DefaultAccountServerPort))
        certFile := serverconf.GetDefault("app:account-server", "cert_file", "")
        keyFile := serverconf.GetDefault("app:account-server", "key_file", "")

        logLevelString := serverconf.GetDefault("app:account-server", "log_level", "INFO")
        server.logLevel = zap.NewAtomicLevel()
        server.logLevel.UnmarshalText([]byte(strings.ToLower(logLevelString)))
        if server.logger, err = srv.SetupLogger("account-server", &amp;server.logLevel, flags); err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, fmt.Errorf("Error setting up logger: %v", err)
        }</span>
        <span class="cov0" title="0">server.accountEngine = newLRUEngine(server.driveRoot, server.hashPathPrefix, server.hashPathSuffix, 32)
        if serverconf.HasSection("tracing") </span><span class="cov0" title="0">{
                server.tracer, server.traceCloser, err = tracing.Init("accountserver", server.logger, serverconf.GetSection("tracing"))
                if err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error setting up tracer: %v", err)
                }</span>
        }
        <span class="cov0" title="0">ipPort = &amp;srv.IpPort{Ip: bindIP, Port: bindPort, CertFile: certFile, KeyFile: keyFile}
        return ipPort, server, server.logger, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">//  Copyright (c) 2016-2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package accountserver

import (
        "crypto/md5"
        "database/sql"
        "encoding/base64"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "math"
        "net/http"
        "os"
        "path"
        "path/filepath"
        "strconv"
        "strings"
        "sync/atomic"
        "time"

        "github.com/mattn/go-sqlite3"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/pickle"
)

const (
        maxQueryArgs       = 990
        maxOpenConns       = 2
        maxIdleConns       = 2
        pendingCap         = 131072
        maxMetaCount       = 90
        maxMetaOverallSize = 4096
        dirLockTimeout     = 30 * time.Second
)

var infoCacheTimeout = time.Second * 10
var policyStatsCacheTimeout = time.Second * 10
var errDatabaseExists = fmt.Errorf("Database file exists.")

func chexor(old, name, timestamp string) string <span class="cov8" title="1">{
        oldDigest, err := hex.DecodeString(old)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Error decoding hex: %v", err))</span>
        }
        <span class="cov8" title="1">h := md5.New()
        if _, err := io.WriteString(h, name+"-"+timestamp); err != nil </span><span class="cov0" title="0">{
                panic("THIS SHOULD NEVER HAPPEN")</span>
        }
        <span class="cov8" title="1">digest := h.Sum(nil)
        for i := range digest </span><span class="cov8" title="1">{
                digest[i] ^= oldDigest[i]
        }</span>
        <span class="cov8" title="1">return hex.EncodeToString(digest)</span>
}

func init() <span class="cov8" title="1">{
        // register our sql driver with user-defined chexor function
        sql.Register("sqlite3_account",
                &amp;sqlite3.SQLiteDriver{
                        ConnectHook: func(conn *sqlite3.SQLiteConn) error </span><span class="cov8" title="1">{
                                if err := conn.RegisterFunc("chexor", chexor, true); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">if _, err := conn.Exec(pragmaScript, nil); err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">if _, err := conn.Exec(`CREATE TEMPORARY VIEW IF NOT EXISTS maxrowid (max) AS
                                                                                  SELECT IFNULL(MAX(seq), -1) FROM sqlite_sequence WHERE name='container'`, nil); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">return nil</span>
                        },
                },
        )
}

type sqliteAccount struct {
        *sql.DB
        accountFile         string
        hasDeletedNameIndex bool
        infoCache           atomic.Value
        policyStatsCache    atomic.Value
        ringhash            string
        inode               uint64
}

var _ Account = &amp;sqliteAccount{}

func (db *sqliteAccount) connect() error <span class="cov8" title="1">{
        if db.DB != nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">lock, err := fs.LockPath(filepath.Dir(db.accountFile), dirLockTimeout)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer lock.Close()
        if db.DB != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">dbConn, err := sql.Open("sqlite3_account", "file:"+db.accountFile+"?psow=1&amp;_txlock=immediate&amp;mode=rw")
        if err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to open: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("Failed to open: %v", err)</span>
        }
        <span class="cov8" title="1">db.inode, err = fs.Inode(db.accountFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">dbConn.SetMaxOpenConns(maxOpenConns)
        dbConn.SetMaxIdleConns(maxIdleConns)
        if db.hasDeletedNameIndex, err = schemaMigrate(dbConn); err != nil </span><span class="cov8" title="1">{
                db.closeAlreadyLocked()
                if common.IsCorruptDBError(err) </span><span class="cov8" title="1">{
                        return fmt.Errorf("Error migrating database: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("Error migrating database: %v", err)</span>
        }
        <span class="cov8" title="1">db.DB = dbConn
        return nil</span>
}

// GetInfo returns the account's information as a AccountInfo struct.
func (db *sqliteAccount) GetInfo() (*AccountInfo, error) <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := db.flush(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if info, ok := db.infoCache.Load().(*AccountInfo); ok &amp;&amp; !info.invalid &amp;&amp; time.Since(info.updated) &lt; infoCacheTimeout </span><span class="cov8" title="1">{
                return info, nil
        }</span>
        <span class="cov8" title="1">info := &amp;AccountInfo{updated: time.Now()}
        row := db.QueryRow(`SELECT cs.account, cs.created_at, cs.put_timestamp,
                                                        cs.delete_timestamp, cs.status_changed_at,
                                                        cs.object_count, cs.bytes_used, cs.container_count,
                                                        cs.hash, cs.id, cs.metadata, maxrowid.max
                                                FROM account_stat cs, maxrowid`)
        if err := row.Scan(&amp;info.Account, &amp;info.CreatedAt, &amp;info.PutTimestamp,
                &amp;info.DeleteTimestamp, &amp;info.StatusChangedAt,
                &amp;info.ObjectCount, &amp;info.BytesUsed, &amp;info.ContainerCount,
                &amp;info.Hash, &amp;info.ID, &amp;info.RawMetadata, &amp;info.MaxRow); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to GetInfo: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">if info.RawMetadata == "" </span><span class="cov0" title="0">{
                info.Metadata = make(map[string][]string)
        }</span> else<span class="cov8" title="1"> if err := json.Unmarshal([]byte(info.RawMetadata), &amp;info.Metadata); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">db.infoCache.Store(info)
        return info, nil</span>
}

func (db *sqliteAccount) PolicyStats() ([]*PolicyStat, error) <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := db.flush(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if ps, ok := db.policyStatsCache.Load().(*policyStats); ok &amp;&amp; !ps.invalid &amp;&amp; time.Since(ps.updated) &lt; policyStatsCacheTimeout </span><span class="cov8" title="1">{
                return ps.list, nil
        }</span>
        <span class="cov8" title="1">ps := &amp;policyStats{updated: time.Now()}
        rows, err := db.Query(`SELECT storage_policy_index, container_count, object_count, bytes_used FROM policy_stat`)
        if err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to PolicyStats SELECT: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">defer rows.Close()
        for rows.Next() </span><span class="cov8" title="1">{
                e := &amp;PolicyStat{}
                if err := rows.Scan(&amp;e.StoragePolicyIndex, &amp;e.ContainerCount, &amp;e.ObjectCount, &amp;e.BytesUsed); err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Failed to PolicyStats Scan: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov8" title="1">ps.list = append(ps.list, e)</span>
        }
        <span class="cov8" title="1">db.policyStatsCache.Store(ps)
        return ps.list, nil</span>
}

func (db *sqliteAccount) invalidateCache() <span class="cov8" title="1">{
        db.infoCache.Store(&amp;AccountInfo{invalid: true})
        db.policyStatsCache.Store(&amp;policyStats{invalid: true})
}</span>

// IsDeleted returns true if the account is deleted - if its delete timestamp is later than its put timestamp.
func (db *sqliteAccount) IsDeleted() (bool, error) <span class="cov8" title="1">{
        info, err := db.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return info.DeleteTimestamp &gt; info.PutTimestamp, nil</span>
}

// Delete sets the account's deleted timestamp and tombstones any metadata older than that timestamp.
// This may or may not make the account "deleted".
func (db *sqliteAccount) Delete(timestamp string) (int, error) <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return http.StatusInternalServerError, err
        }</span>
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return http.StatusInternalServerError, err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        var deleteTimestamp, metastr string
        var metadata map[string][]string
        if err := tx.QueryRow("SELECT delete_timestamp, metadata FROM account_stat").Scan(&amp;deleteTimestamp, &amp;metastr); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return http.StatusInternalServerError, fmt.Errorf("Failed to Delete SELECT: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return http.StatusInternalServerError, err</span>
        }
        <span class="cov8" title="1">if deleteTimestamp &gt;= timestamp </span><span class="cov0" title="0">{
                return http.StatusConflict, nil
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal([]byte(metastr), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return http.StatusInternalServerError, err
        }</span>
        <span class="cov8" title="1">for key, value := range metadata </span><span class="cov8" title="1">{
                if value[1] &lt; timestamp </span><span class="cov8" title="1">{
                        metadata[key] = []string{"", timestamp}
                }</span>
        }
        <span class="cov8" title="1">serializedMetadata, err := json.Marshal(metadata)
        if err != nil </span><span class="cov0" title="0">{
                return http.StatusInternalServerError, err
        }</span>
        <span class="cov8" title="1">if _, err = tx.Exec("UPDATE account_stat SET delete_timestamp = ?, metadata = ?", timestamp, string(serializedMetadata)); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return http.StatusInternalServerError, fmt.Errorf("Failed to Delete UPDATE: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return http.StatusInternalServerError, err</span>
        }
        <span class="cov8" title="1">defer db.invalidateCache()
        if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return http.StatusInternalServerError, fmt.Errorf("Failed to Delete Commit: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return http.StatusInternalServerError, err</span>
        }
        <span class="cov8" title="1">return http.StatusNoContent, nil</span>
}

// MergeItems merges ContainerRecords into the account.  If a remote id is provided (incoming replication), the incoming_sync table is updated.
func (db *sqliteAccount) MergeItems(records []*ContainerRecord, remoteID string) error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return db.mergeItems(records, remoteID)</span>
}

func (db *sqliteAccount) mergeItems(records []*ContainerRecord, remoteID string) error <span class="cov8" title="1">{
        names := make([]interface{}, len(records))
        existing := make(map[string]*ContainerRecord)
        tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        for i, record := range records </span><span class="cov8" title="1">{
                names[i] = record.Name
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; len(records); i += maxQueryArgs </span><span class="cov8" title="1">{
                j := i + maxQueryArgs
                if j &gt; len(records) </span><span class="cov8" title="1">{
                        j = len(records)
                }</span>
                <span class="cov8" title="1">batch := names[i:j]
                query := ""
                if db.hasDeletedNameIndex </span><span class="cov8" title="1">{
                        query = fmt.Sprintf("SELECT name, put_timestamp, delete_timestamp, ROWID FROM container WHERE deleted IN (0, 1) AND name IN (%s)",
                                strings.TrimRight(strings.Repeat("?,", len(batch)), ","))
                }</span> else<span class="cov0" title="0"> {
                        query = fmt.Sprintf("SELECT name, put_timestamp, delete_timestamp, ROWID FROM container WHERE name IN (%s)",
                                strings.TrimRight(strings.Repeat("?,", len(batch)), ","))
                }</span>
                <span class="cov8" title="1">rows, err := tx.Query(query, batch...)
                if err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf("Failed to MergeItems SELECT: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov8" title="1">defer rows.Close()
                for rows.Next() </span><span class="cov8" title="1">{
                        var name, putTimestamp, deleteTimestamp string
                        var rowid int64
                        if err := rows.Scan(&amp;name, &amp;putTimestamp, &amp;deleteTimestamp, &amp;rowid); err != nil </span><span class="cov0" title="0">{
                                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                        return fmt.Errorf("Failed to MergeItems Scan: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                                }</span>
                                <span class="cov0" title="0">return err</span>
                        }
                        <span class="cov8" title="1">existing[name] = &amp;ContainerRecord{PutTimestamp: putTimestamp, DeleteTimestamp: deleteTimestamp, Rowid: rowid}</span>
                }
                <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf("Failed to MergeItems Err: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov8" title="1">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf("Failed to MergeItems Close: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        }

        <span class="cov8" title="1">dst, err := tx.Prepare("DELETE FROM container WHERE ROWID=?")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer dst.Close()

        ast, err := tx.Prepare(`INSERT INTO container (name, put_timestamp, delete_timestamp, object_count, bytes_used, deleted, storage_policy_index)
                                                        VALUES (?, ?, ?, ?, ?, ?, ?)`)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer ast.Close()

        var maxRowid int64 = -1
        for _, record := range records </span><span class="cov8" title="1">{
                if record.Rowid &gt; maxRowid </span><span class="cov8" title="1">{
                        maxRowid = record.Rowid
                }</span>
                <span class="cov8" title="1">if er, exists := existing[record.Name]; exists </span><span class="cov8" title="1">{
                        if _, err := dst.Exec(er.Rowid); err != nil </span><span class="cov0" title="0">{
                                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                        return fmt.Errorf("Failed to MergeItems DELETE: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                                }</span>
                                <span class="cov0" title="0">return err</span>
                        }
                        <span class="cov8" title="1">if er.PutTimestamp &gt; record.PutTimestamp </span><span class="cov0" title="0">{
                                record.PutTimestamp = er.PutTimestamp
                        }</span>
                        <span class="cov8" title="1">if er.DeleteTimestamp &gt; record.DeleteTimestamp </span><span class="cov0" title="0">{
                                record.DeleteTimestamp = er.DeleteTimestamp
                        }</span>
                        <span class="cov8" title="1">if record.DeleteTimestamp &gt; record.PutTimestamp </span><span class="cov8" title="1">{
                                record.Deleted = 1
                        }</span> else<span class="cov0" title="0"> {
                                record.Deleted = 0
                        }</span>
                }
                <span class="cov8" title="1">if res, err := ast.Exec(record.Name, record.PutTimestamp, record.DeleteTimestamp, record.ObjectCount,
                        record.BytesUsed, record.Deleted, record.StoragePolicyIndex); err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf("Failed to MergeItems INSERT: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                        }</span>
                        <span class="cov0" title="0">return err</span>
                } else<span class="cov8" title="1"> if record.Rowid, err = res.LastInsertId(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">existing[record.Name] = record</span>
        }

        <span class="cov8" title="1">if remoteID != "" &amp;&amp; maxRowid &gt; -1 </span><span class="cov8" title="1">{
                if _, err := tx.Exec(`UPDATE incoming_sync SET sync_point = ? WHERE remote_id = ?;
                                                          INSERT INTO incoming_sync (remote_id, sync_point) SELECT ?, ? WHERE changes() == 0;`,
                        maxRowid, remoteID, remoteID, maxRowid); err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf("Failed to MergeItems UPDATE: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        }

        <span class="cov8" title="1">defer db.invalidateCache()
        if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to MergeItems Commit: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func indexAfter(s, sep string, after int) int <span class="cov8" title="1">{
        index := strings.Index(s[after:], sep)
        if index == -1 </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">return index + after</span>
}

// ListContainers implements container listings.
func (db *sqliteAccount) ListContainers(limit int, marker string, endMarker string, prefix string, delimiter string,
        reverse bool) ([]interface{}, error) <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var point, pointDirection, queryTail, queryStart string

        queryStart = "SELECT name, object_count, bytes_used, put_timestamp FROM container WHERE "
        if reverse </span><span class="cov8" title="1">{
                marker, endMarker = endMarker, marker
                queryTail = "ORDER BY name DESC LIMIT ?"
                pointDirection = "name &lt; ?"
        }</span> else<span class="cov8" title="1"> {
                queryTail = "ORDER BY name LIMIT ?"
                pointDirection = "name &gt; ?"
        }</span>

        <span class="cov8" title="1">results := []interface{}{}
        queryArgs := make([]interface{}, 8)
        wheres := make([]string, 8)
        gotResults := true

        for len(results) &lt; limit &amp;&amp; gotResults </span><span class="cov8" title="1">{
                if db.hasDeletedNameIndex </span><span class="cov8" title="1">{
                        wheres = append(wheres[:0], "deleted = 0")
                }</span> else<span class="cov0" title="0"> {
                        wheres = append(wheres[:0], "+deleted = 0")
                }</span>
                <span class="cov8" title="1">queryArgs = queryArgs[:0]
                if prefix != "" </span><span class="cov8" title="1">{
                        wheres = append(wheres, "name BETWEEN ? AND ?")
                        queryArgs = append(queryArgs, prefix, prefix+"\xFF")
                }</span>
                <span class="cov8" title="1">if marker != "" </span><span class="cov8" title="1">{
                        wheres = append(wheres, "name &gt; ?")
                        queryArgs = append(queryArgs, marker)
                }</span>
                <span class="cov8" title="1">if endMarker != "" </span><span class="cov8" title="1">{
                        wheres = append(wheres, "name &lt; ?")
                        queryArgs = append(queryArgs, endMarker)
                }</span>
                <span class="cov8" title="1">if point != "" </span><span class="cov8" title="1">{
                        wheres = append(wheres, pointDirection)
                        queryArgs = append(queryArgs, point)
                }</span>
                <span class="cov8" title="1">rows, err := db.Query(queryStart+" "+strings.Join(wheres, " AND ")+" "+queryTail,
                        append(queryArgs, limit-len(results))...)
                if err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Failed to ListContainers SELECT: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov8" title="1">defer rows.Close()
                gotResults = false
                for rows.Next() &amp;&amp; len(results) &lt; limit </span><span class="cov8" title="1">{
                        gotResults = true
                        record := &amp;ContainerListingRecord{}
                        if err := rows.Scan(&amp;record.Name, &amp;record.Count, &amp;record.Bytes, &amp;record.LastModified); err != nil </span><span class="cov0" title="0">{
                                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("Failed to ListContainers Scan: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                                }</span>
                                <span class="cov0" title="0">return nil, err</span>
                        }
                        <span class="cov8" title="1">if f, err := strconv.ParseFloat(record.LastModified, 64); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span> else<span class="cov8" title="1"> {
                                whole, nans := math.Modf(f)
                                record.LastModified = time.Unix(int64(whole), int64(nans*1.0e9)).In(common.GMT).Format("2006-01-02T15:04:05.000000")
                        }</span>
                        <span class="cov8" title="1">point = record.Name
                        if delimiter != "" </span><span class="cov8" title="1">{
                                end := indexAfter(record.Name, delimiter, len(prefix))
                                if end &gt;= 0 &amp;&amp; len(record.Name) &gt; end+1 </span><span class="cov8" title="1">{
                                        dirName := record.Name[:end] + delimiter
                                        if reverse </span><span class="cov8" title="1">{
                                                point = record.Name[:end+len(delimiter)]
                                        }</span> else<span class="cov8" title="1"> {
                                                point = dirName + "\xFF"
                                        }</span>
                                        <span class="cov8" title="1">if dirName != marker </span><span class="cov8" title="1">{
                                                results = append(results, &amp;SubdirListingRecord{Name2: dirName, Name: dirName})
                                        }</span>
                                        <span class="cov8" title="1">break</span>
                                }
                        }
                        <span class="cov8" title="1">results = append(results, record)</span>
                }
                <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Failed to ListContainers Err: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov8" title="1">rows.Close()
                if delimiter == "" </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return results, nil</span>
}

// NewID sets the account's ID to a new, random string.
func (db *sqliteAccount) NewID() error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        _, err = tx.Exec(`INSERT OR REPLACE INTO incoming_sync (remote_id, sync_point)
                                          SELECT account_stat.id, maxrowid.max FROM account_stat, maxrowid`)
        if err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to NewID INSERT: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">if _, err = tx.Exec("UPDATE account_stat SET id = ?", common.UUID()); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to NewID UPDATE: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">defer db.invalidateCache()
        if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to NewID Commit: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ItemsSince returns (count) object records with a rowid greater than (start).
func (db *sqliteAccount) ItemsSince(start int64, count int) ([]*ContainerRecord, error) <span class="cov8" title="1">{
        db.flush()
        records := []*ContainerRecord{}
        rows, err := db.Query(`SELECT ROWID, name, put_timestamp, delete_timestamp, object_count,
                                                   bytes_used, deleted, storage_policy_index
                                                   FROM container WHERE ROWID &gt; ? ORDER BY ROWID ASC LIMIT ?`, start, count)
        if err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to ItemsSince SELECT: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">defer rows.Close()
        for rows.Next() </span><span class="cov8" title="1">{
                r := &amp;ContainerRecord{}
                if err := rows.Scan(&amp;r.Rowid, &amp;r.Name, &amp;r.PutTimestamp, &amp;r.DeleteTimestamp, &amp;r.ObjectCount, &amp;r.BytesUsed, &amp;r.Deleted, &amp;r.StoragePolicyIndex); err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Failed to ItemsSince Scan: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov8" title="1">records = append(records, r)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to ItemsSince Err: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return records, nil</span>
}

// GetMetadata returns the current account metadata as a simple map[string]string, i.e. it leaves out tombstones and timestamps.
func (db *sqliteAccount) GetMetadata() (map[string]string, error) <span class="cov8" title="1">{
        info, err := db.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">metadata := make(map[string]string)
        for key, value := range info.Metadata </span><span class="cov8" title="1">{
                if value[0] != "" </span><span class="cov8" title="1">{
                        metadata[key] = value[0]
                }</span>
        }
        <span class="cov8" title="1">return metadata, nil</span>
}

func (db *sqliteAccount) mergeMetas(a map[string][]string, b map[string][]string, deleteTimestamp string) (string, error) <span class="cov8" title="1">{
        newMeta := map[string][]string{}
        for k, v := range a </span><span class="cov8" title="1">{
                newMeta[k] = v
        }</span>
        <span class="cov8" title="1">for k, v := range b </span><span class="cov8" title="1">{
                if existing, ok := a[k]; ok </span><span class="cov8" title="1">{
                        if existing[1] &lt; v[1] </span><span class="cov8" title="1">{
                                newMeta[k] = v
                        }</span>
                } else<span class="cov8" title="1"> {
                        newMeta[k] = v
                }</span>
        }
        <span class="cov8" title="1">metaSize := 0
        metaCount := 0
        for k, v := range newMeta </span><span class="cov8" title="1">{
                if deleteTimestamp != "" &amp;&amp; v[1] &lt; deleteTimestamp </span><span class="cov8" title="1">{
                        newMeta[k] = []string{"", deleteTimestamp}
                }</span> else<span class="cov8" title="1"> if v[0] != "" &amp;&amp; strings.HasPrefix(strings.ToLower(k), "x-account-meta-") </span><span class="cov8" title="1">{
                        metaSize += len(k) - 15
                        metaSize += len(v[0])
                        metaCount++
                }</span>
        }
        <span class="cov8" title="1">if metaCount &gt; maxMetaCount || metaSize &gt; maxMetaOverallSize </span><span class="cov0" title="0">{
                return "", ErrorInvalidMetadata
        }</span>
        <span class="cov8" title="1">serMeta, err := json.Marshal(newMeta)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(serMeta), nil</span>
}

// UpdateMetadata merges the current account metadata with new incoming metadata.
func (db *sqliteAccount) UpdateMetadata(newMetadata map[string][]string) error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(newMetadata) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        var metadataValue, deleteTimestamp string
        if err := tx.QueryRow("SELECT metadata, delete_timestamp FROM account_stat").Scan(&amp;metadataValue, &amp;deleteTimestamp); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to UpdateMetadata SELECT: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">var existingMetadata map[string][]string
        if metadataValue == "" </span><span class="cov0" title="0">{
                existingMetadata = map[string][]string{}
        }</span> else<span class="cov8" title="1"> if err := json.Unmarshal([]byte(metadataValue), &amp;existingMetadata); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">metastr, err := db.mergeMetas(existingMetadata, newMetadata, deleteTimestamp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err = tx.Exec("UPDATE account_stat SET metadata=?", metastr); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to UpdateMetadata UPDATE: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">defer db.invalidateCache()
        if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to UpdateMetadata Commit: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// MergeSyncTable updates the account's current incoming_sync table records.
func (db *sqliteAccount) MergeSyncTable(records []*SyncRecord) error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        for _, record := range records </span><span class="cov8" title="1">{
                if _, err := tx.Exec(`UPDATE incoming_sync SET sync_point = ? WHERE remote_id = ?;
                                                          INSERT INTO incoming_sync (remote_id, sync_point) SELECT ?, ? WHERE changes() == 0;`,
                        record.SyncPoint, record.RemoteID, record.RemoteID, record.SyncPoint); err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf("Failed to MergeSyncTable UPDATE &amp; INSERT: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        }
        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to MergeSyncTable Commit: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// CleanupTombstones removes any expired tombstoned objects or metadata.
func (db *sqliteAccount) CleanupTombstones(reclaimAge int64) error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">now := float64(time.Now().UnixNano()) / 1000000000.0
        reclaimTimestamp := common.CanonicalTimestamp(now - float64(reclaimAge))

        tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        if _, err = tx.Exec("DELETE FROM container WHERE deleted=1 AND delete_timestamp &lt; ?", reclaimTimestamp); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to CleanupTombstones DELETE: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">var metastr string
        if err := tx.QueryRow("SELECT metadata FROM account_stat").Scan(&amp;metastr); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to CleanupTombstones SELECT: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">var metadata map[string][]string
        updated := false
        if metastr == "" </span><span class="cov0" title="0">{
                metadata = map[string][]string{}
                updated = true
        }</span> else<span class="cov8" title="1"> {
                if err := json.Unmarshal([]byte(metastr), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for k, v := range metadata </span><span class="cov0" title="0">{
                        if v[0] == "" </span><span class="cov0" title="0">{
                                if ts, err := common.GetEpochFromTimestamp(v[1]); err != nil || ts &lt; reclaimTimestamp </span><span class="cov0" title="0">{
                                        delete(metadata, k)
                                        updated = true
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">if updated </span><span class="cov0" title="0">{
                if mb, err := json.Marshal(metadata); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span> else<span class="cov0" title="0"> if _, err = tx.Exec("UPDATE account_stat SET metadata = ?", string(mb)); err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf("Failed to CleanupTombstones UPDATE: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        }
        <span class="cov8" title="1">defer db.invalidateCache()
        if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to CleanupTombstones Commit: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// SyncTable returns the account's current incoming_sync table, and also includes the current account's id and max row as an entry.
func (db *sqliteAccount) SyncTable() ([]*SyncRecord, error) <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">records := []*SyncRecord{}
        rows, err := db.Query(`SELECT sync_point, remote_id FROM incoming_sync
                                                   WHERE remote_id NOT IN (SELECT id FROM account_stat)
                                                   UNION
                                                   SELECT maxrowid.max AS sync_point, account_stat.id AS remote_id
                                                   FROM account_stat, maxrowid`)
        if err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to SyncTable SELECT: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">defer rows.Close()
        for rows.Next() </span><span class="cov8" title="1">{
                rec := &amp;SyncRecord{}
                if err := rows.Scan(&amp;rec.SyncPoint, &amp;rec.RemoteID); err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Failed to SyncTable Scan: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov8" title="1">records = append(records, rec)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to SyncTable Err: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return records, nil</span>
}

// SyncRemoteData compares a remote account's info to the local info and updates any necessary replication bookkeeping, returning the current account's info.
func (db *sqliteAccount) SyncRemoteData(maxRow int64, hash, id, createdAt, putTimestamp, deleteTimestamp, metadata string) (*AccountInfo, error) <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        var localMeta, localHash, localDeleteTimestamp string
        var localPoint int64
        if err := tx.QueryRow("SELECT hash, metadata, delete_timestamp FROM account_stat").Scan(&amp;localHash, &amp;localMeta, &amp;localDeleteTimestamp); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to SyncRemoteData SELECT: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">var lm, rm map[string][]string
        if err := json.Unmarshal([]byte(metadata), &amp;rm); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal([]byte(localMeta), &amp;lm); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if deleteTimestamp &gt; localDeleteTimestamp </span><span class="cov8" title="1">{
                localDeleteTimestamp = deleteTimestamp
        }</span>
        <span class="cov8" title="1">metastr, err := db.mergeMetas(lm, rm, localDeleteTimestamp)
        if _, err = tx.Exec(`UPDATE account_stat SET created_at=MIN(?, created_at), put_timestamp=MAX(?, put_timestamp),
                                                   delete_timestamp=MAX(?, delete_timestamp), metadata=?`,
                createdAt, putTimestamp, deleteTimestamp, metastr); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to SyncRemoteData UPDATE: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">if err := tx.QueryRow("SELECT IFNULL(MAX(sync_point), -1) FROM incoming_sync WHERE remote_id = ?", id).Scan(&amp;localPoint); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to SyncRemoteData SELECT2: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">if localHash == hash &amp;&amp; maxRow &gt; localPoint </span><span class="cov8" title="1">{
                localPoint = maxRow
                if _, err = tx.Exec("INSERT OR REPLACE INTO incoming_sync (remote_id, sync_point) VALUES (?, ?)", id, localPoint); err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Failed to SyncRemoteData INSERT: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
        }
        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to SyncRemoteData Commit: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">db.invalidateCache()
        info, err := db.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">info.Point = localPoint
        return info, nil</span>
}

// OpenDatabaseFile blocks updates and opens the underlying database file for reading, so it can be uploaded to a remote server.
func (db *sqliteAccount) OpenDatabaseFile() (*os.File, func(), error) <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">var fp *os.File
        if _, err := db.Exec(`
                PRAGMA locking_mode = EXCLUSIVE;      -- grab and hold a shared lock
                SELECT 1 FROM account_stat LIMIT 1;   -- it doesn't actually lock until you hit the database
                PRAGMA wal_checkpoint(TRUNCATE);      -- truncate the wal file, if it exists`,
        ); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("Failed to OpenDatabaseFile: %v; %v", err, common.QuarantineDir(path.Dir(db.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return nil, nil, fmt.Errorf("Error locking database%s: %v", db.accountFile, err)</span>
        }
        <span class="cov8" title="1">cleanup := func() </span><span class="cov8" title="1">{
                db.Exec(`
                        PRAGMA locking_mode = NORMAL;         -- release shared lock
                        SELECT 1 FROM account_stat LIMIT 1; -- actually release shared lock
                `)
                if fp != nil </span><span class="cov8" title="1">{
                        fp.Close()
                }</span>
        }
        // make sure there aren't any journals lying around
        <span class="cov8" title="1">if stat, err := os.Stat(db.accountFile + "-wal"); err == nil &amp;&amp; stat.Size() != 0 </span><span class="cov0" title="0">{
                cleanup()
                return nil, nil, fmt.Errorf("Stubborn wal file still exists: %s", db.accountFile)
        }</span>
        <span class="cov8" title="1">if stat, err := os.Stat(db.accountFile + "-journal"); err == nil &amp;&amp; stat.Size() != 0 </span><span class="cov0" title="0">{
                cleanup()
                return nil, nil, fmt.Errorf("Stubborn journal file still exists: %s", db.accountFile)
        }</span>
        <span class="cov8" title="1">fp, err := os.Open(db.accountFile)
        if err != nil </span><span class="cov0" title="0">{
                fp = nil
                cleanup()
                return nil, nil, fmt.Errorf("Error opening %s: %v", db.accountFile, err)
        }</span>
        <span class="cov8" title="1">return fp, cleanup, nil</span>
}

// Ping verifies the underlying sqlite file hasn't gone away.
func (db *sqliteAccount) Ping() error <span class="cov8" title="1">{
        lock, err := fs.LockPath(filepath.Dir(db.accountFile), dirLockTimeout)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer lock.Close()
        inode, err := fs.Inode(db.accountFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if inode != db.inode </span><span class="cov8" title="1">{
                return db.closeAlreadyLocked()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ID returns the account's ring hash as a unique identifier for it.
func (db *sqliteAccount) ID() string <span class="cov8" title="1">{
        return db.ringhash
}</span>

// RingHash returns the account's ring hash as a string.
func (db *sqliteAccount) RingHash() string <span class="cov8" title="1">{
        return db.ringhash
}</span>

func (db *sqliteAccount) flush() error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">lock, err := fs.LockPath(filepath.Dir(db.accountFile), dirLockTimeout)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer lock.Close()
        if stat, err := os.Stat(db.accountFile + ".pending"); err != nil || stat.Size() == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">contents, err := ioutil.ReadFile(db.accountFile + ".pending")
        if err != nil || len(contents) == 0 </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">var records []*ContainerRecord
        for _, base64ed := range strings.Split(string(contents), ":") </span><span class="cov8" title="1">{
                if len(base64ed) &lt; 1 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">pickled, err := base64.StdEncoding.DecodeString(base64ed)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">r, err := pickle.PickleLoads(pickled)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">record, ok := r.([]interface{})
                if !ok || len(record) &lt; 7 </span><span class="cov0" title="0">{
                        return fmt.Errorf("Invalid commit pending record")
                }</span>
                <span class="cov8" title="1">casts := make([]bool, 7)
                var deleted, spi int64
                rec := &amp;ContainerRecord{}
                rec.Name, casts[0] = record[0].(string)
                rec.PutTimestamp, casts[1] = record[1].(string)
                rec.DeleteTimestamp, casts[2] = record[2].(string)
                rec.ObjectCount, casts[3] = int64MaybeStringified(record[3])
                rec.BytesUsed, casts[4] = int64MaybeStringified(record[4])
                deleted, casts[5] = record[5].(int64)
                rec.Deleted = int(deleted)
                spi, casts[6] = int64MaybeStringified(record[6])
                rec.StoragePolicyIndex = int(spi)
                for i := 0; i &lt; 7; i++ </span><span class="cov8" title="1">{
                        if !casts[i] </span><span class="cov0" title="0">{
                                return fmt.Errorf("Invalid commit pending record")
                        }</span>
                }
                <span class="cov8" title="1">records = append(records, rec)</span>
        }
        <span class="cov8" title="1">err = db.mergeItems(records, "")
        if err == nil </span><span class="cov8" title="1">{
                err = os.Truncate(db.accountFile+".pending", 0)
        }</span>
        <span class="cov8" title="1">return err</span>
}

func int64MaybeStringified(i interface{}) (int64, bool) <span class="cov8" title="1">{
        if a, ok := i.(int64); ok </span><span class="cov8" title="1">{
                return a, true
        }</span> else<span class="cov8" title="1"> if b, ok := i.(string); !ok </span><span class="cov8" title="1">{
                return 0, false
        }</span> else<span class="cov8" title="1"> {
                c, err := strconv.ParseInt(b, 10, 64)
                return c, err == nil
        }</span>
}

// PutContainer adds a container to the account, by way of pending file.
func (db *sqliteAccount) PutContainer(name string, putTimestamp string, deleteTimestamp string, objectCount int64, bytesUsed int64, storagePolicyIndex int) error <span class="cov8" title="1">{
        lock, err := fs.LockPath(filepath.Dir(db.accountFile), dirLockTimeout)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer lock.Close()
        deleted := 0
        if deleteTimestamp &gt; putTimestamp </span><span class="cov0" title="0">{
                deleted = 1
        }</span>
        <span class="cov8" title="1">tuple := []interface{}{name, putTimestamp, deleteTimestamp, objectCount, bytesUsed, deleted, storagePolicyIndex}
        file, err := os.OpenFile(db.accountFile+".pending", os.O_RDWR|os.O_APPEND|os.O_CREATE, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        if _, err := file.WriteString(":" + base64.StdEncoding.EncodeToString(pickle.PickleDumps(tuple))); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if info, err := file.Stat(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov8" title="1"> if info.Size() &lt; pendingCap </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">if err = file.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">lock.Close()
        return db.flush()</span>
}

// Close closes the underlying sqlite database connection.
func (db *sqliteAccount) Close() error <span class="cov8" title="1">{
        lock, err := fs.LockPath(filepath.Dir(db.accountFile), dirLockTimeout)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer lock.Close()
        return db.closeAlreadyLocked()</span>
}

func (db *sqliteAccount) closeAlreadyLocked() error <span class="cov8" title="1">{
        if db.DB != nil </span><span class="cov8" title="1">{
                err := db.DB.Close()
                db.DB = nil
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func sqliteCreateExistingAccount(db Account, putTimestamp string, newMetadata map[string][]string) (bool, error) <span class="cov8" title="1">{
        cdb, ok := db.(*sqliteAccount)
        if !ok </span><span class="cov0" title="0">{
                return false, errors.New("Unable to work with non-sqliteAccount")
        }</span>
        <span class="cov8" title="1">if err := cdb.connect(); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">tx, err := cdb.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        var cDeleteTimestamp, cPutTimestamp, cMetadata string
        row := tx.QueryRow("SELECT put_timestamp, delete_timestamp, metadata FROM account_stat")
        if err := row.Scan(&amp;cPutTimestamp, &amp;cDeleteTimestamp, &amp;cMetadata); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("Failed to sqliteCreateExistingAccount SELECT: %v; %v", err, common.QuarantineDir(path.Dir(cdb.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        <span class="cov8" title="1">var existingMetadata map[string][]string
        if cMetadata == "" </span><span class="cov0" title="0">{
                existingMetadata = make(map[string][]string)
        }</span> else<span class="cov8" title="1"> if err := json.Unmarshal([]byte(cMetadata), &amp;existingMetadata); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">metastr, err := cdb.mergeMetas(existingMetadata, newMetadata, cDeleteTimestamp)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if _, err := tx.Exec("UPDATE account_stat SET put_timestamp = ?, metadata = ?",
                putTimestamp, metastr); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("Failed to sqliteCreateExistingAccount UPDATE: %v; %v", err, common.QuarantineDir(path.Dir(cdb.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        <span class="cov8" title="1">defer cdb.invalidateCache()
        if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("Failed to sqliteCreateExistingAccount Commit: %v; %v", err, common.QuarantineDir(path.Dir(cdb.accountFile), 4, "accounts"))
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        <span class="cov8" title="1">return (cDeleteTimestamp &gt; cPutTimestamp &amp;&amp; putTimestamp &gt; cDeleteTimestamp), nil</span>
}

func sqliteCreateAccount(accountFile string, account string, putTimestamp string, metadata map[string][]string) error <span class="cov8" title="1">{
        var serializedMetadata []byte
        var err error

        hashDir := filepath.Dir(accountFile)
        if err := os.MkdirAll(hashDir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">lock, err := fs.LockPath(hashDir, dirLockTimeout)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer lock.Close()

        if fs.Exists(accountFile) </span><span class="cov0" title="0">{
                return errDatabaseExists
        }</span>

        <span class="cov8" title="1">if metadata == nil </span><span class="cov8" title="1">{
                serializedMetadata = []byte("{}")
        }</span> else<span class="cov8" title="1"> if serializedMetadata, err = json.Marshal(metadata); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">tfp, err := ioutil.TempFile(hashDir, ".newdb")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := tfp.Chmod(0644); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tfp.Close()
        tempFile := tfp.Name()
        dbConn, err := sql.Open("sqlite3_account", "file:"+tempFile+"?psow=1&amp;_txlock=immediate&amp;mode=rwc")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer dbConn.Close()
        tx, err := dbConn.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        if _, err := tx.Exec(accountDBScript + policyStatTableScript + policyStatTriggerScript); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err := tx.Exec(`INSERT INTO account_stat (account, created_at, id, put_timestamp,
                                                  status_changed_at, metadata, container_count) VALUES (?, ?, ?, ?, ?, ?, 0)`,
                account, common.GetTimestamp(), common.UUID(), putTimestamp, putTimestamp, string(serializedMetadata)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := dbConn.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return sqliteRename(tempFile, accountFile)</span>
}

func sqliteOpenAccount(accountFile string) (ReplicableAccount, error) <span class="cov8" title="1">{
        if !fs.Exists(accountFile) </span><span class="cov8" title="1">{
                return nil, ErrorNoSuchAccount
        }</span>
        <span class="cov8" title="1">db := &amp;sqliteAccount{
                accountFile:         accountFile,
                hasDeletedNameIndex: false,
                ringhash:            filepath.Base(filepath.Dir(accountFile)),
        }
        return db, nil</span>
}

func sqliteRename(fromFile, toFile string) error <span class="cov8" title="1">{
        // make sure the destination path doesn't exist, including any journals
        ms, err := filepath.Glob(toFile + "*")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for _, m := range ms </span><span class="cov8" title="1">{
                if err := os.Remove(m); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        // make sure we copy over any journals for the new database file
        <span class="cov8" title="1">if ms, err = filepath.Glob(fromFile + "*"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for _, m := range ms </span><span class="cov8" title="1">{
                if err := os.Rename(m, toFile+m[len(fromFile):]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package client

import (
        "fmt"
        "io"
        "net/http"
        "os"
        "time"
)

type autoCloseResponses struct {
        http.RoundTripper
}

func (a *autoCloseResponses) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        resp, err := a.RoundTripper.RoundTrip(req)
        resp.Body = &amp;autoClosingBody{ReadCloser: resp.Body, timer: time.AfterFunc(time.Minute, func() </span><span class="cov0" title="0">{ autoCloseReport(req, resp) }</span>)}
        <span class="cov0" title="0">return resp, err</span>
}

type autoClosingBody struct {
        io.ReadCloser
        timer *time.Timer
}

func (a *autoClosingBody) Close() error <span class="cov0" title="0">{
        a.timer.Stop()
        return a.ReadCloser.Close()
}</span>

func autoCloseReport(req *http.Request, resp *http.Response) <span class="cov0" title="0">{
        fmt.Fprintf(os.Stderr, `
################################################################################
# Auto Closing Response
# Request: %s %#v %#v
# Response: %d %#v
################################################################################
`, req.Method, req.URL, req.Header, resp.StatusCode, resp.Header)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package client

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strconv"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/nectar"
        "github.com/troubling/nectar/nectarutil"
)

type directClient struct {
        pc      RequestClient
        account string
}

var _ nectar.Client = &amp;directClient{}

func NewDirectClient(account string, cnf srv.ConfigLoader, certFile, keyFile string, logger srv.LowLevelLogger) (nectar.Client, error) <span class="cov0" title="0">{
        policies, err := cnf.GetPolicies()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">pdc, err := NewProxyClient(policies, cnf, logger, certFile, keyFile, "", "", "", conf.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Could not make client: %v", err)
        }</span>
        <span class="cov0" title="0">return &amp;directClient{pc: pdc.NewRequestClient(nil, nil, logger), account: account}, nil</span>
}

func (c *directClient) GetURL() string <span class="cov0" title="0">{
        return "&lt;direct&gt;/" + c.account
}</span>

func (c *directClient) PutAccount(headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.pc.PutAccount(context.Background(), c.account, common.Map2Headers(headers))
}</span>

func (c *directClient) PostAccount(headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.pc.PostAccount(context.Background(), c.account, common.Map2Headers(headers))
}</span>

func (c *directClient) GetAccount(marker string, endMarker string, limit int, prefix string, delimiter string, reverse bool, headers map[string]string) ([]*nectar.ContainerRecord, *http.Response) <span class="cov0" title="0">{
        resp := c.GetAccountRaw(marker, endMarker, limit, prefix, delimiter, reverse, headers)
        if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                return nil, resp
        }</span>
        <span class="cov0" title="0">var accountListing []*nectar.ContainerRecord
        if err := json.NewDecoder(resp.Body).Decode(&amp;accountListing); err != nil </span><span class="cov0" title="0">{
                resp.Body.Close()
                // FIXME. Log something.
                return nil, nectarutil.ResponseStub(http.StatusInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">resp.Body.Close()
        return accountListing, resp</span>
}

func (c *directClient) GetAccountRaw(marker string, endMarker string, limit int, prefix string, delimiter string, reverse bool, headers map[string]string) *http.Response <span class="cov0" title="0">{
        options := map[string]string{
                "format":     "json",
                "marker":     marker,
                "end_marker": endMarker,
                "prefix":     prefix,
                "delimiter":  delimiter,
        }
        if limit != 0 </span><span class="cov0" title="0">{
                options["limit"] = strconv.Itoa(limit)
        }</span>
        <span class="cov0" title="0">if reverse </span><span class="cov0" title="0">{
                options["reverse"] = "true"
        }</span>
        <span class="cov0" title="0">return c.pc.GetAccountRaw(context.Background(), c.account, options, common.Map2Headers(headers))</span>
}

func (c *directClient) HeadAccount(headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.pc.HeadAccount(context.Background(), c.account, common.Map2Headers(headers))
}</span>

func (c *directClient) DeleteAccount(headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.pc.DeleteAccount(context.Background(), c.account, common.Map2Headers(headers))
}</span>

func (c *directClient) PutContainer(container string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.pc.PutContainer(context.Background(), c.account, container, common.Map2Headers(headers))
}</span>

func (c *directClient) PostContainer(container string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.pc.PostContainer(context.Background(), c.account, container, common.Map2Headers(headers))
}</span>

func (c *directClient) GetContainer(container string, marker string, endMarker string, limit int, prefix string, delimiter string, reverse bool, headers map[string]string) ([]*nectar.ObjectRecord, *http.Response) <span class="cov0" title="0">{
        resp := c.GetContainerRaw(container, marker, endMarker, limit, prefix, delimiter, reverse, headers)
        if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                return nil, resp
        }</span>
        <span class="cov0" title="0">var containerListing []*nectar.ObjectRecord
        if err := json.NewDecoder(resp.Body).Decode(&amp;containerListing); err != nil </span><span class="cov0" title="0">{
                resp.Body.Close()
                // FIXME. Log something.
                return nil, nectarutil.ResponseStub(http.StatusInternalServerError, err.Error())
        }</span>
        <span class="cov0" title="0">resp.Body.Close()
        return containerListing, resp</span>
}

func (c *directClient) GetContainerRaw(container string, marker string, endMarker string, limit int, prefix string, delimiter string, reverse bool, headers map[string]string) *http.Response <span class="cov0" title="0">{
        options := map[string]string{
                "format":     "json",
                "marker":     marker,
                "end_marker": endMarker,
                "prefix":     prefix,
                "delimiter":  delimiter,
        }
        if limit != 0 </span><span class="cov0" title="0">{
                options["limit"] = strconv.Itoa(limit)
        }</span>
        <span class="cov0" title="0">if reverse </span><span class="cov0" title="0">{
                options["reverse"] = "true"
        }</span>
        <span class="cov0" title="0">return c.pc.GetContainerRaw(context.Background(), c.account, container, options, common.Map2Headers(headers))</span>
}

func (c *directClient) HeadContainer(container string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.pc.HeadContainer(context.Background(), c.account, container, common.Map2Headers(headers))
}</span>

func (c *directClient) DeleteContainer(container string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.pc.DeleteContainer(context.Background(), c.account, container, common.Map2Headers(headers))
}</span>

func (c *directClient) PutObject(container string, obj string, headers map[string]string, src io.Reader) *http.Response <span class="cov0" title="0">{
        return c.pc.PutObject(context.Background(), c.account, container, obj, common.Map2Headers(headers), src)
}</span>

func (c *directClient) PostObject(container string, obj string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.pc.PostObject(context.Background(), c.account, container, obj, common.Map2Headers(headers))
}</span>

func (c *directClient) GetObject(container string, obj string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.pc.GetObject(context.Background(), c.account, container, obj, common.Map2Headers(headers))
}</span>

func (c *directClient) HeadObject(container string, obj string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.pc.HeadObject(context.Background(), c.account, container, obj, common.Map2Headers(headers))
}</span>

func (c *directClient) DeleteObject(container string, obj string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        return c.pc.DeleteObject(context.Background(), c.account, container, obj, common.Map2Headers(headers))
}</span>

func (c *directClient) Raw(method, urlAfterAccount string, headers map[string]string, body io.Reader) *http.Response <span class="cov0" title="0">{
        return nectarutil.ResponseStub(http.StatusNotImplemented, "Raw requests not implemented for direct clients")
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package client

import (
        "fmt"
        "math"
        "math/rand"
        "sort"
        "strconv"
        "strings"
        "sync"

        "github.com/troubling/hummingbird/common/ring"
)

type ringFilter interface {
        ReplicaCount() (cnt uint64)
        GetPartition(account string, container string, object string) uint64
        GetNodes(partition uint64) []*ring.Device
        getReadNodes(partition uint64) ([]*ring.Device, ring.MoreNodes)
        getWriteNodes(partition uint64) ([]*ring.Device, ring.MoreNodes)
        ring() ring.Ring
}

type writeNodeIter struct {
        mutex        sync.Mutex
        devs         []*ring.Device
        nonPreferred []*ring.Device
        more         ring.MoreNodes
        waffRegion   int
        waffCount    int
        limit        int
}

func (wni *writeNodeIter) next() *ring.Device <span class="cov8" title="1">{
        var dev *ring.Device
        for </span><span class="cov8" title="1">{
                if len(wni.devs) &gt; 0 </span><span class="cov8" title="1">{
                        dev, wni.devs = wni.devs[0], wni.devs[1:]
                }</span> else<span class="cov8" title="1"> if len(wni.nonPreferred) &gt; 0 &amp;&amp; wni.waffCount &lt;= 0 </span><span class="cov8" title="1">{
                        dev, wni.nonPreferred = wni.nonPreferred[0], wni.nonPreferred[1:]
                }</span> else<span class="cov8" title="1"> {
                        if dev = wni.more.Next(); dev == nil </span><span class="cov0" title="0">{
                                if len(wni.nonPreferred) &gt; 0 </span><span class="cov0" title="0">{
                                        dev, wni.nonPreferred = wni.nonPreferred[0], wni.nonPreferred[1:]
                                }</span>
                                <span class="cov0" title="0">return dev</span>
                        }
                }
                <span class="cov8" title="1">if wni.waffCount &lt;= 0 || wni.waffRegion == -1 || dev.Region == wni.waffRegion </span><span class="cov8" title="1">{
                        wni.waffCount--
                        return dev
                }</span>
                <span class="cov8" title="1">wni.nonPreferred = append(wni.nonPreferred, dev)</span>
        }
}

func (wni *writeNodeIter) Next() *ring.Device <span class="cov8" title="1">{
        wni.mutex.Lock()
        defer wni.mutex.Unlock()

        if wni.limit &lt;= 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">wni.limit--
        return wni.next()</span>
}

type readAffSection struct {
        zone   int
        region int
        weight float64
}

type clientRingFilter struct {
        ring.Ring
        raffs       []readAffSection
        waffRegion  int
        waffCount   int
        deviceLimit int
}

func (a *clientRingFilter) ring() ring.Ring <span class="cov8" title="1">{
        return a.Ring
}</span>

func (a *clientRingFilter) getReadNodes(partition uint64) ([]*ring.Device, ring.MoreNodes) <span class="cov8" title="1">{
        devs := a.GetNodes(partition)
        d2a := make(map[*ring.Device]int, len(devs))
        for i, af := range a.raffs </span><span class="cov8" title="1">{
                for _, dev := range devs </span><span class="cov8" title="1">{
                        if _, in := d2a[dev]; !in &amp;&amp; (af.region == dev.Region) &amp;&amp; (af.zone == dev.Zone || af.zone == -1) </span><span class="cov8" title="1">{
                                d2a[dev] = i
                        }</span>
                }
        }
        <span class="cov8" title="1">for _, dev := range devs </span><span class="cov8" title="1">{ // move any nodes that haven't matched a raff to the end.
                if _, in := d2a[dev]; !in </span><span class="cov8" title="1">{
                        d2a[dev] = len(a.raffs)
                }</span>
        }
        <span class="cov8" title="1">rand.Shuffle(len(devs), func(i, j int) </span><span class="cov8" title="1">{ devs[i], devs[j] = devs[j], devs[i] }</span>)
        <span class="cov8" title="1">sort.SliceStable(devs, func(i, j int) bool </span><span class="cov8" title="1">{ return d2a[devs[i]] &lt; d2a[devs[j]] }</span>)
        <span class="cov8" title="1">return devs, a.Ring.GetMoreNodes(partition)</span>
}

func (a *clientRingFilter) getWriteNodes(partition uint64) ([]*ring.Device, ring.MoreNodes) <span class="cov8" title="1">{
        var ndevs []*ring.Device
        devs := a.GetNodes(partition)
        if a.deviceLimit == 0 </span><span class="cov8" title="1">{
                a.deviceLimit = len(devs)
        }</span>
        <span class="cov8" title="1">more := &amp;writeNodeIter{
                devs:       devs,
                more:       a.GetMoreNodes(partition),
                waffRegion: a.waffRegion,
                waffCount:  a.waffCount,
                limit:      a.deviceLimit,
        }
        if a.deviceLimit &lt; len(devs) </span><span class="cov8" title="1">{
                ndevs = make([]*ring.Device, a.deviceLimit)
        }</span> else<span class="cov8" title="1"> {
                ndevs = make([]*ring.Device, len(devs))
        }</span>
        <span class="cov8" title="1">for i := range ndevs </span><span class="cov8" title="1">{
                ndevs[i] = more.next()
        }</span>
        <span class="cov8" title="1">return ndevs, more</span>
}

func newClientRingFilter(r ring.Ring, readAff, writeAff, waffCount string, deviceLimit int) *clientRingFilter <span class="cov8" title="1">{
        waffRegion := -1
        fmt.Sscanf(writeAff, "r%d", &amp;waffRegion)

        wc := 0
        var f float64
        if v, err := strconv.ParseInt(waffCount, 0, 64); err == nil </span><span class="cov8" title="1">{
                wc = int(v)
        }</span> else<span class="cov8" title="1"> if n, err := fmt.Sscanf(waffCount, "%f * replicas", &amp;f); err == nil &amp;&amp; n == 1 </span><span class="cov8" title="1">{
                wc = int(math.Ceil(f * float64(r.ReplicaCount())))
        }</span> else<span class="cov8" title="1"> {
                wc = int(2 * r.ReplicaCount())
        }</span>

        <span class="cov8" title="1">sections := strings.Split(readAff, ",")
        raffs := make([]readAffSection, 0, len(sections))
        for i := range sections </span><span class="cov8" title="1">{
                var weight float64
                var zone, region int
                if n, err := fmt.Sscanf(strings.TrimSpace(sections[i]), "r%dz%d=%f", &amp;region, &amp;zone, &amp;weight); err == nil &amp;&amp; n == 3 </span><span class="cov8" title="1">{
                        raffs = append(raffs, readAffSection{zone: zone, region: region, weight: weight})
                }</span> else<span class="cov8" title="1"> if n, err := fmt.Sscanf(strings.TrimSpace(sections[i]), "r%d=%f", &amp;region, &amp;weight); err == nil &amp;&amp; n == 2 </span><span class="cov8" title="1">{
                        raffs = append(raffs, readAffSection{zone: -1, region: region, weight: weight})
                }</span>
        }
        <span class="cov8" title="1">sort.Slice(raffs, func(i, j int) bool </span><span class="cov8" title="1">{ return raffs[i].weight &lt; raffs[j].weight }</span>)
        <span class="cov8" title="1">return &amp;clientRingFilter{
                Ring:        r,
                raffs:       raffs,
                waffRegion:  waffRegion,
                waffCount:   wc,
                deviceLimit: deviceLimit,
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package client

import (
        "context"
        "errors"
        "fmt"
        "io"
        "math"
        "net/http"
        "strconv"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/common/tracing"
        "github.com/troubling/nectar/nectarutil"
        "go.uber.org/zap"
)

type proxyObjectClient interface {
        putObject(ctx context.Context, account, container, obj string, headers http.Header, src io.Reader) *http.Response
        postObject(ctx context.Context, account, container, obj string, headers http.Header) *http.Response
        getObject(ctx context.Context, account, container, obj string, headers http.Header) *http.Response
        grepObject(ctx context.Context, account, container, obj string, search string) *http.Response
        headObject(ctx context.Context, account, container, obj string, headers http.Header) *http.Response
        deleteObject(ctx context.Context, account, container, obj string, headers http.Header) *http.Response
        ring() (ring.Ring, *http.Response)
}

type erroringObjectClient struct {
        status int
        body   string
}

func (oc *erroringObjectClient) putObject(ctx context.Context, account, container, obj string, headers http.Header, src io.Reader) *http.Response <span class="cov0" title="0">{
        return nectarutil.ResponseStub(oc.status, oc.body)
}</span>
func (oc *erroringObjectClient) postObject(ctx context.Context, account, container, obj string, headers http.Header) *http.Response <span class="cov0" title="0">{
        return nectarutil.ResponseStub(oc.status, oc.body)
}</span>
func (oc *erroringObjectClient) getObject(ctx context.Context, account, container, obj string, headers http.Header) *http.Response <span class="cov0" title="0">{
        return nectarutil.ResponseStub(oc.status, oc.body)
}</span>
func (oc *erroringObjectClient) grepObject(ctx context.Context, account, container, obj string, search string) *http.Response <span class="cov0" title="0">{
        return nectarutil.ResponseStub(oc.status, oc.body)
}</span>
func (oc *erroringObjectClient) headObject(ctx context.Context, account, container, obj string, headers http.Header) *http.Response <span class="cov0" title="0">{
        return nectarutil.ResponseStub(oc.status, oc.body)
}</span>
func (oc *erroringObjectClient) deleteObject(ctx context.Context, account, container, obj string, headers http.Header) *http.Response <span class="cov0" title="0">{
        return nectarutil.ResponseStub(oc.status, oc.body)
}</span>
func (oc *erroringObjectClient) ring() (ring.Ring, *http.Response) <span class="cov0" title="0">{
        return nil, nectarutil.ResponseStub(oc.status, oc.body)
}</span>

type standardObjectClient struct {
        pdc         *proxyClient
        policy      int
        objectRing  ringFilter
        deviceLimit int
        Logger      srv.LowLevelLogger
}

// putReader is a Reader proxy that sends its reader over the ready channel the first time Read is called.
// This is important because "Expect: 100-continue" requests don't call Read unless/until they get a 100 response.
type putReader struct {
        io.Reader
        cancel chan struct{}
        ready  chan io.WriteCloser
        w      io.WriteCloser
}

func (p *putReader) Read(b []byte) (int, error) <span class="cov0" title="0">{
        // if Read() is called, it means we've received a 100-continue.
        // So we notify the ready channel that we're good to go.
        if p.ready != nil </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-p.cancel:<span class="cov0" title="0">
                        return 0, errors.New("Request was cancelled")</span>
                case p.ready &lt;- p.w:<span class="cov0" title="0">
                        p.ready = nil</span>
                }
        }
        <span class="cov0" title="0">if i, err := p.Reader.Read(b); err == nil </span><span class="cov0" title="0">{
                return i, err
        }</span> else<span class="cov0" title="0"> {
                select </span>{
                case &lt;-p.cancel:<span class="cov0" title="0">
                        return 0, errors.New("Request was cancelled")</span>
                default:<span class="cov0" title="0">
                        return i, err</span>
                }
        }
}

func (oc *standardObjectClient) putObject(ctx context.Context, account, container, obj string, headers http.Header, src io.Reader) *http.Response <span class="cov0" title="0">{
        objectPartition := oc.objectRing.GetPartition(account, container, obj)
        containerPartition := oc.pdc.ContainerRing.GetPartition(account, container, "")
        containerDevices := oc.pdc.ContainerRing.GetNodes(containerPartition)
        ready := make(chan io.WriteCloser)
        cancel := make(chan struct{})
        defer close(cancel)
        responsec := make(chan *http.Response)
        devs, more := oc.objectRing.getWriteNodes(objectPartition)
        objectReplicaCount := len(devs)

        devToRequest := func(index int, dev *ring.Device) (*http.Request, error) </span><span class="cov0" title="0">{
                trp, wp := io.Pipe()
                rp := &amp;putReader{Reader: trp, cancel: cancel, w: wp, ready: ready}
                url := fmt.Sprintf("%s://%s:%d/%s/%d/%s/%s/%s", dev.Scheme, dev.Ip, dev.Port, dev.Device, objectPartition,
                        common.Urlencode(account), common.Urlencode(container), common.Urlencode(obj))
                req, err := http.NewRequest("PUT", url, rp)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req = req.WithContext(tracing.CopySpanFromContext(ctx))
                req.Header.Set("Content-Type", "application/octet-stream")
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(oc.policy))
                req.Header.Set("X-Container-Partition", strconv.FormatUint(containerPartition, 10))
                addUpdateHeaders("X-Container", req.Header, containerDevices, index, objectReplicaCount)
                req.Header.Set("Expect", "100-continue")
                return req, nil</span>
        }

        <span class="cov0" title="0">for i := 0; i &lt; objectReplicaCount; i++ </span><span class="cov0" title="0">{
                go func(index int) </span><span class="cov0" title="0">{
                        var resp *http.Response
                        for dev := devs[index]; dev != nil; dev = more.Next() </span><span class="cov0" title="0">{
                                if req, err := devToRequest(index, dev); err != nil </span><span class="cov0" title="0">{
                                        oc.Logger.Error("unable create PUT request", zap.Error(err))
                                        resp = nectarutil.ResponseStub(http.StatusInternalServerError, err.Error())
                                }</span> else<span class="cov0" title="0"> if r, err := oc.pdc.client.Do(req); err != nil </span><span class="cov0" title="0">{
                                        oc.Logger.Error("unable to PUT object", zap.Error(err))
                                        resp = nectarutil.ResponseStub(http.StatusInternalServerError, err.Error())
                                }</span> else<span class="cov0" title="0"> {
                                        resp = nectarutil.StubResponse(r)
                                        if r.StatusCode &gt;= 200 &amp;&amp; r.StatusCode &lt; 500 </span><span class="cov0" title="0">{
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">select </span>{
                                case &lt;-cancel:<span class="cov0" title="0">
                                        return</span>
                                default:</span><span class="cov0" title="0">
                                }
                        }
                        <span class="cov0" title="0">if resp == nil </span><span class="cov0" title="0">{
                                err := fmt.Errorf("no more nodes to try")
                                oc.Logger.Error("unable to PUT object", zap.Error(err))
                                resp = nectarutil.ResponseStub(http.StatusInternalServerError, err.Error())
                        }</span>
                        <span class="cov0" title="0">select </span>{
                        case responsec &lt;- resp:</span><span class="cov0" title="0">
                        case &lt;-cancel:<span class="cov0" title="0">
                                return</span>
                        }
                }(i)
        }
        <span class="cov0" title="0">responseClassCounts := make([]int, 6)
        quorum := int(math.Ceil(float64(objectReplicaCount) / 2.0))
        writers := make([]io.Writer, 0)
        cWriters := make([]io.WriteCloser, 0)
        responseCount := 0
        written := false
        for </span><span class="cov0" title="0">{
                select </span>{
                case resp := &lt;-responsec:<span class="cov0" title="0">
                        responseCount++
                        if resp != nil </span><span class="cov0" title="0">{
                                responseClassCounts[resp.StatusCode/100]++
                                if responseClassCounts[resp.StatusCode/100] &gt;= quorum </span><span class="cov0" title="0">{
                                        timeout := time.After(time.Duration(PostQuorumTimeoutMs) * time.Millisecond)
                                        for responseCount &lt; objectReplicaCount </span><span class="cov0" title="0">{
                                                select </span>{
                                                case &lt;-responsec:<span class="cov0" title="0">
                                                        responseCount++</span>
                                                case &lt;-timeout:<span class="cov0" title="0">
                                                        return resp</span>
                                                }
                                        }
                                        <span class="cov0" title="0">return resp</span>
                                } else<span class="cov0" title="0"> if responseCount == objectReplicaCount </span><span class="cov0" title="0">{
                                        return nectarutil.ResponseStub(http.StatusServiceUnavailable, "The service is currently unavailable.")
                                }</span>
                        }
                case w := &lt;-ready:<span class="cov0" title="0">
                        defer w.Close()
                        writers = append(writers, w)
                        cWriters = append(cWriters, w)</span>
                }
                <span class="cov0" title="0">if !written &amp;&amp; len(writers) &gt;= quorum &amp;&amp; len(writers)+responseCount == objectReplicaCount </span><span class="cov0" title="0">{
                        written = true
                        if _, err := common.CopyQuorum(src, quorum, writers...); err != nil </span><span class="cov0" title="0">{
                                return nectarutil.ResponseStub(http.StatusServiceUnavailable, "The service is currently unavailable.")
                        }</span>
                        <span class="cov0" title="0">for _, w := range cWriters </span><span class="cov0" title="0">{
                                w.Close()
                        }</span>
                }
        }
}

func (oc *standardObjectClient) postObject(ctx context.Context, account, container, obj string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := oc.objectRing.GetPartition(account, container, obj)
        containerPartition := oc.pdc.ContainerRing.GetPartition(account, container, "")
        containerDevices := oc.pdc.ContainerRing.GetNodes(containerPartition)
        devs, _ := oc.objectRing.getWriteNodes(partition)
        objectReplicaCount := len(devs)
        return oc.pdc.quorumResponse(oc.objectRing, partition, func(i int, dev *ring.Device) (*http.Request, error) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("%s://%s:%d/%s/%d/%s/%s/%s", dev.Scheme, dev.Ip, dev.Port, dev.Device, partition,
                        common.Urlencode(account), common.Urlencode(container), common.Urlencode(obj))
                req, err := http.NewRequest("POST", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req = req.WithContext(tracing.CopySpanFromContext(ctx))
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(oc.policy))
                req.Header.Set("X-Container-Partition", strconv.FormatUint(containerPartition, 10))
                addUpdateHeaders("X-Container", req.Header, containerDevices, i, objectReplicaCount)
                return req, nil</span>
        })
}

func (oc *standardObjectClient) getObject(ctx context.Context, account, container, obj string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := oc.objectRing.GetPartition(account, container, obj)
        return oc.pdc.firstResponse(oc.objectRing, partition, func(dev *ring.Device) (*http.Request, error) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("%s://%s:%d/%s/%d/%s/%s/%s", dev.Scheme, dev.Ip, dev.Port, dev.Device, partition,
                        common.Urlencode(account), common.Urlencode(container), common.Urlencode(obj))
                req, err := http.NewRequest("GET", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req = req.WithContext(tracing.CopySpanFromContext(ctx))
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(oc.policy))
                return req, nil</span>
        })
}

func (oc *standardObjectClient) grepObject(ctx context.Context, account, container, obj string, search string) *http.Response <span class="cov0" title="0">{
        partition := oc.objectRing.GetPartition(account, container, obj)
        return oc.pdc.firstResponse(oc.objectRing, partition, func(dev *ring.Device) (*http.Request, error) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("%s://%s:%d/%s/%d/%s/%s/%s?e=%s", dev.Scheme, dev.Ip, dev.Port, dev.Device, partition,
                        common.Urlencode(account), common.Urlencode(container), common.Urlencode(obj), common.Urlencode(search))
                req, err := http.NewRequest("GREP", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req = req.WithContext(tracing.CopySpanFromContext(ctx))
                req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(oc.policy))
                return req, nil</span>
        })
}

func (oc *standardObjectClient) headObject(ctx context.Context, account, container, obj string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := oc.objectRing.GetPartition(account, container, obj)
        return oc.pdc.firstResponse(oc.objectRing, partition, func(dev *ring.Device) (*http.Request, error) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("%s://%s:%d/%s/%d/%s/%s/%s", dev.Scheme, dev.Ip, dev.Port, dev.Device, partition,
                        common.Urlencode(account), common.Urlencode(container), common.Urlencode(obj))
                req, err := http.NewRequest("HEAD", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req = req.WithContext(tracing.CopySpanFromContext(ctx))
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(oc.policy))
                return req, nil</span>
        })
}

func (oc *standardObjectClient) deleteObject(ctx context.Context, account, container, obj string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := oc.objectRing.GetPartition(account, container, obj)
        containerPartition := oc.pdc.ContainerRing.GetPartition(account, container, "")
        containerDevices := oc.pdc.ContainerRing.GetNodes(containerPartition)
        devs, _ := oc.objectRing.getWriteNodes(partition)
        objectReplicaCount := len(devs)
        return oc.pdc.quorumResponse(oc.objectRing, partition, func(i int, dev *ring.Device) (*http.Request, error) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("%s://%s:%d/%s/%d/%s/%s/%s", dev.Scheme, dev.Ip, dev.Port, dev.Device, partition,
                        common.Urlencode(account), common.Urlencode(container), common.Urlencode(obj))
                req, err := http.NewRequest("DELETE", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req = req.WithContext(tracing.CopySpanFromContext(ctx))
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">if req.Header.Get("Content-Type") == "" </span><span class="cov0" title="0">{
                        req.Header.Set("Content-Type", "application/octet-stream")
                }</span>
                <span class="cov0" title="0">req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(oc.policy))
                req.Header.Set("X-Container-Partition", strconv.FormatUint(containerPartition, 10))
                addUpdateHeaders("X-Container", req.Header, containerDevices, i, objectReplicaCount)
                return req, nil</span>
        })
}

func (oc *standardObjectClient) ring() (ring.Ring, *http.Response) <span class="cov8" title="1">{
        return oc.objectRing.ring(), nil
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package client

import (
        "context"
        "errors"
        "fmt"
        "io"
        "math"
        "net"
        "net/http"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/common/tracing"
        "github.com/troubling/nectar/nectarutil"
        "go.uber.org/zap"
        "golang.org/x/net/http2"
)

const PostQuorumTimeoutMs = 100
const postPutTimeout = time.Second * 30
const firstResponseFinalTimeout = time.Second * 30

func addUpdateHeaders(prefix string, headers http.Header, devices []*ring.Device, i, replicas int) <span class="cov8" title="1">{
        if i &lt; len(devices) </span><span class="cov8" title="1">{
                host := ""
                device := ""
                scheme := ""
                for ; i &lt; len(devices); i += replicas </span><span class="cov8" title="1">{
                        host += fmt.Sprintf("%s:%d,", devices[i].Ip, devices[i].Port)
                        device += devices[i].Device + ","
                        scheme += devices[i].Scheme + ","
                }</span>
                <span class="cov8" title="1">headers.Set(prefix+"-Scheme", strings.TrimRight(scheme, ","))
                headers.Set(prefix+"-Host", strings.TrimRight(host, ","))
                headers.Set(prefix+"-Device", strings.TrimRight(device, ","))</span>
        }
}

type proxyClient struct {
        policyList        conf.PolicyList
        client            common.HTTPClient
        AccountRing       ringFilter
        ContainerRing     ringFilter
        objectClients     map[int]proxyObjectClient
        Logger            srv.LowLevelLogger
        ClientTraceCloser io.Closer
}

var _ ProxyClient = &amp;proxyClient{}

func NewProxyClient(policyList conf.PolicyList, cnf srv.ConfigLoader, logger srv.LowLevelLogger, certFile, keyFile, readAffinity, writeAffinity, writeAffinityCount string, serverconf conf.Config) (ProxyClient, error) <span class="cov8" title="1">{
        var xport http.RoundTripper = &amp;http.Transport{
                MaxIdleConnsPerHost: 100,
                MaxIdleConns:        0,
                IdleConnTimeout:     5 * time.Second,
                DisableCompression:  true,
                Dial: (&amp;net.Dialer{
                        Timeout:   10 * time.Second,
                        KeepAlive: 5 * time.Second,
                }).Dial,
                ExpectContinueTimeout: 10 * time.Minute, // TODO: this should probably be like infinity.
        }
        if certFile != "" &amp;&amp; keyFile != "" </span><span class="cov0" title="0">{
                tlsConf, err := common.NewClientTLSConfig(certFile, keyFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">xport.(*http.Transport).TLSClientConfig = tlsConf
                if err = http2.ConfigureTransport(xport.(*http.Transport)); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">httpClient := &amp;http.Client{
                Transport: xport,
                Timeout:   120 * time.Minute,
        }
        // Debug hook to auto-close responses and report on it. See debug.go
        // xport = &amp;autoCloseResponses{transport: xport}
        c := &amp;proxyClient{
                policyList: policyList,
                client:     httpClient,
                Logger:     logger,
        }
        if serverconf.HasSection("tracing") </span><span class="cov0" title="0">{
                clientTracer, clientTraceCloser, err := tracing.Init("proxydirect-client", logger, serverconf.GetSection("tracing"))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Error setting up tracer: %v", err)
                }</span>
                <span class="cov0" title="0">c.ClientTraceCloser = clientTraceCloser
                enableHTTPTrace := serverconf.GetBool("tracing", "enable_httptrace", true)
                c.client, err = NewTracingClient(clientTracer, httpClient, enableHTTPTrace)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Error setting up tracing client: %v", err)
                }</span>
        }

        <span class="cov8" title="1">if c.policyList == nil </span><span class="cov0" title="0">{
                policyList, err := cnf.GetPolicies()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">c.policyList = policyList</span>
        }
        <span class="cov8" title="1">hashPathPrefix, hashPathSuffix, err := cnf.GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">containerRing, err := cnf.GetRing("container", hashPathPrefix, hashPathSuffix, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">c.ContainerRing = newClientRingFilter(containerRing, readAffinity, "", "", 0)
        accountRing, err := cnf.GetRing("account", hashPathPrefix, hashPathSuffix, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">c.AccountRing = newClientRingFilter(accountRing, readAffinity, "", "", 0)
        c.objectClients = make(map[int]proxyObjectClient)
        for _, policy := range c.policyList </span><span class="cov8" title="1">{
                // TODO: the intention is to (if it becomes necessary) have a policy type to object client
                // constructor mapping here, similar to how object engines are loaded by policy type.
                ring, err := cnf.GetRing("object", hashPathPrefix, hashPathSuffix, policy.Index)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">policyReadAffinity := policy.Config["read_affinity"]
                if policyReadAffinity == "" </span><span class="cov8" title="1">{
                        policyReadAffinity = readAffinity
                }</span>
                <span class="cov8" title="1">policyWriteAffinity := policy.Config["write_affinity"]
                if policyWriteAffinity == "" </span><span class="cov8" title="1">{
                        policyWriteAffinity = writeAffinity
                }</span>
                <span class="cov8" title="1">policyWriteAffinityCount := policy.Config["write_affinity_node_count"]
                if policyWriteAffinityCount == "" </span><span class="cov8" title="1">{
                        policyWriteAffinityCount = writeAffinityCount
                }</span>
                <span class="cov8" title="1">var deviceLimit int
                if policy.Type == "hec" </span><span class="cov8" title="1">{
                        if replicas, err := strconv.Atoi(policy.Config["nursery_replicas"]); err == nil &amp;&amp; replicas &gt; 0 </span><span class="cov0" title="0">{
                                deviceLimit = replicas
                        }</span> else<span class="cov8" title="1"> {
                                deviceLimit = 3
                        }</span>
                }
                <span class="cov8" title="1">client := &amp;standardObjectClient{
                        pdc:        c,
                        policy:     policy.Index,
                        objectRing: newClientRingFilter(ring, policyReadAffinity, policyWriteAffinity, policyWriteAffinityCount, deviceLimit),
                        Logger:     logger,
                }
                c.objectClients[policy.Index] = client</span>
        }
        <span class="cov8" title="1">return c, nil</span>
}

// quorumResponse returns with a response representative of a quorum of nodes.
//
// This is analogous to swift's best_response function.
func (c *proxyClient) quorumResponse(r ringFilter, partition uint64, devToRequest func(int, *ring.Device) (*http.Request, error)) *http.Response <span class="cov0" title="0">{
        cancel := make(chan struct{})
        defer close(cancel)
        responsec := make(chan *http.Response)
        devs, more := r.getWriteNodes(partition)
        for i := 0; i &lt; int(len(devs)); i++ </span><span class="cov0" title="0">{
                go func(index int) </span><span class="cov0" title="0">{
                        var resp *http.Response
                        var firstResp *http.Response
                        for dev := devs[index]; dev != nil; dev = more.Next() </span><span class="cov0" title="0">{
                                if req, err := devToRequest(index, dev); err != nil </span><span class="cov0" title="0">{
                                        c.Logger.Error("unable to create request", zap.Error(err))
                                        resp = nectarutil.ResponseStub(http.StatusInternalServerError, err.Error())
                                }</span> else<span class="cov0" title="0"> if r, err := c.client.Do(req); err != nil </span><span class="cov0" title="0">{
                                        c.Logger.Error("unable to get response", zap.Error(err))
                                        resp = nectarutil.ResponseStub(http.StatusInternalServerError, err.Error())
                                }</span> else<span class="cov0" title="0"> {
                                        resp = nectarutil.StubResponse(r)
                                }</span>
                                <span class="cov0" title="0">if firstResp == nil </span><span class="cov0" title="0">{
                                        firstResp = resp
                                }</span>
                                <span class="cov0" title="0">if resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 500 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        // In the case where we're about to respond with Not Found, ensure
                        // it's a response from the primary node. This corrects for the
                        // case where the primary node 5xx errored and subsequent nodes
                        // don't know about the item requested.
                        <span class="cov0" title="0">if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                                resp = firstResp
                        }</span>
                        <span class="cov0" title="0">select </span>{
                        case responsec &lt;- resp:</span><span class="cov0" title="0">
                        case &lt;-cancel:<span class="cov0" title="0">
                                return</span>
                        }
                }(i)
        }
        <span class="cov0" title="0">responseClassCounts := make([]int, 6)
        quorum := int(math.Ceil(float64(len(devs)) / 2.0))
        for i := 0; i &lt; len(devs); i++ </span><span class="cov0" title="0">{
                if resp := &lt;-responsec; resp != nil </span><span class="cov0" title="0">{
                        responseClassCounts[resp.StatusCode/100]++
                        if responseClassCounts[resp.StatusCode/100] &gt;= quorum </span><span class="cov0" title="0">{
                                timeout := time.After(time.Duration(PostQuorumTimeoutMs) * time.Millisecond)
                                for i &lt; int(len(devs)-1) </span><span class="cov0" title="0">{
                                        select </span>{
                                        case &lt;-responsec:<span class="cov0" title="0">
                                                i++</span>
                                        case &lt;-timeout:<span class="cov0" title="0">
                                                return resp</span>
                                        }
                                }
                                <span class="cov0" title="0">return resp</span>
                        }
                }
        }
        <span class="cov0" title="0">return nectarutil.ResponseStub(http.StatusServiceUnavailable, "Unknown State")</span>
}

func (c *proxyClient) firstResponse(r ringFilter, partition uint64, devToRequest func(*ring.Device) (*http.Request, error)) (resp *http.Response) <span class="cov0" title="0">{
        receivedResponses := make(chan *http.Response)
        alreadyFoundGoodResponse := make(chan struct{})
        defer close(alreadyFoundGoodResponse)
        devs, more := r.getReadNodes(partition)
        internalErrors := 0
        notFounds := 0
        backendHeaders := map[string]string{}
        interpretResponse := func(resp *http.Response) *http.Response </span><span class="cov0" title="0">{
                if resp != nil &amp;&amp; (resp.StatusCode/100 == 2 || resp.StatusCode == http.StatusPreconditionFailed ||
                        resp.StatusCode == http.StatusNotModified || resp.StatusCode == http.StatusRequestedRangeNotSatisfiable) </span><span class="cov0" title="0">{
                        resp.Header.Set("Accept-Ranges", "bytes")
                        if etag := resp.Header.Get("Etag"); etag != "" </span><span class="cov0" title="0">{
                                resp.Header.Set("Etag", strings.Trim(etag, "\""))
                        }</span>
                        <span class="cov0" title="0">return resp</span>
                }
                <span class="cov0" title="0">if resp != nil </span><span class="cov0" title="0">{
                        resp.Body.Close()
                        for k := range resp.Header </span><span class="cov0" title="0">{
                                if strings.HasPrefix(k, "X-Backend") </span><span class="cov0" title="0">{
                                        backendHeaders[k] = resp.Header.Get(k)
                                }</span>
                        }
                        <span class="cov0" title="0">if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                                notFounds++
                        }</span> else<span class="cov0" title="0"> {
                                internalErrors++
                        }</span>
                } else<span class="cov0" title="0"> {
                        internalErrors++
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">maxRequests := int(r.ReplicaCount()) * 2
        requestsPending := 0
        for requestCount := 0; requestCount &lt; maxRequests; requestCount++ </span><span class="cov0" title="0">{
                var dev *ring.Device
                if requestCount &lt; len(devs) </span><span class="cov0" title="0">{
                        dev = devs[requestCount]
                }</span> else<span class="cov0" title="0"> {
                        dev = more.Next()
                        if dev == nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">req, err := devToRequest(dev)
                if err != nil </span><span class="cov0" title="0">{
                        c.Logger.Error("firstResponse devToRequest error", zap.Error(err))
                        internalErrors++
                        continue</span>
                }

                <span class="cov0" title="0">requestsPending++
                go func(r *http.Request) </span><span class="cov0" title="0">{
                        response, err := c.client.Do(r)
                        if err != nil </span><span class="cov0" title="0">{
                                c.Logger.Error("firstResponse response", zap.Error(err))
                                if response != nil </span><span class="cov0" title="0">{
                                        response.Body.Close()
                                }</span>
                                <span class="cov0" title="0">response = nil</span>
                        }
                        <span class="cov0" title="0">select </span>{
                        case receivedResponses &lt;- response:</span><span class="cov0" title="0">
                        case &lt;-alreadyFoundGoodResponse:<span class="cov0" title="0">
                                if response != nil </span><span class="cov0" title="0">{
                                        response.Body.Close()
                                }</span>
                        }
                }(req)

                <span class="cov0" title="0">select </span>{
                case resp = &lt;-receivedResponses:<span class="cov0" title="0">
                        requestsPending--
                        resp = interpretResponse(resp)
                        if resp != nil </span><span class="cov0" title="0">{
                                return resp
                        }</span>
                case &lt;-time.After(time.Second):</span><span class="cov0" title="0">
                }
        }
        <span class="cov0" title="0">giveUp := time.After(firstResponseFinalTimeout)
        for requestsPending &gt; 0 </span><span class="cov0" title="0">{
                select </span>{
                case resp = &lt;-receivedResponses:<span class="cov0" title="0">
                        requestsPending--
                        resp = interpretResponse(resp)
                        if resp != nil </span><span class="cov0" title="0">{
                                return resp
                        }</span>
                case &lt;-giveUp:<span class="cov0" title="0">
                        internalErrors += requestsPending
                        requestsPending = 0</span>
                }
        }
        <span class="cov0" title="0">if notFounds &gt; internalErrors </span><span class="cov0" title="0">{
                r := nectarutil.ResponseStub(http.StatusNotFound, "")
                for k, v := range backendHeaders </span><span class="cov0" title="0">{
                        r.Header.Set(k, v)
                }</span>
                <span class="cov0" title="0">return r</span>
        }
        <span class="cov0" title="0">return nectarutil.ResponseStub(http.StatusServiceUnavailable, "")</span>
}

func (c *proxyClient) Close() error <span class="cov0" title="0">{
        if c.ClientTraceCloser != nil </span><span class="cov0" title="0">{
                return c.ClientTraceCloser.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// NilContainerInfo is used for testing.
var NilContainerInfo = &amp;ContainerInfo{}

var ContainerNotFound = errors.New("Container Not Found")

func (c *proxyClient) NewRequestClient(mc ring.MemcacheRing, lc map[string]*ContainerInfo, logger srv.LowLevelLogger) RequestClient <span class="cov8" title="1">{
        return &amp;requestClient{pdc: c, mc: mc, lc: lc, Logger: logger}
}</span>

type requestClient struct {
        pdc    *proxyClient
        mc     ring.MemcacheRing
        lc     map[string]*ContainerInfo
        lcm    sync.RWMutex
        Logger srv.LowLevelLogger
}

var _ RequestClient = &amp;requestClient{}

func (c *requestClient) getObjectClient(ctx context.Context, account string, container string, mc ring.MemcacheRing, lc map[string]*ContainerInfo) proxyObjectClient <span class="cov8" title="1">{
        ci, err := c.GetContainerInfo(ctx, account, container)
        if err != nil </span><span class="cov0" title="0">{
                st := http.StatusInternalServerError
                if err == ContainerNotFound </span><span class="cov0" title="0">{
                        st = http.StatusNotFound
                }</span>
                <span class="cov0" title="0">return &amp;erroringObjectClient{st, err.Error()}</span>
        }
        <span class="cov8" title="1">return c.pdc.objectClients[ci.StoragePolicyIndex]</span>
}

func (c *requestClient) invalidateContainerInfo(ctx context.Context, account string, container string) <span class="cov0" title="0">{
        key := fmt.Sprintf("container/%s/%s", account, container)
        if c.lc != nil </span><span class="cov0" title="0">{
                delete(c.lc, key)
        }</span>
        <span class="cov0" title="0">if c.mc != nil </span><span class="cov0" title="0">{
                c.mc.Delete(ctx, key)
        }</span>
}

func (c *requestClient) PutAccount(ctx context.Context, account string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := c.pdc.AccountRing.GetPartition(account, "", "")
        return c.pdc.quorumResponse(c.pdc.AccountRing, partition, func(i int, dev *ring.Device) (*http.Request, error) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("%s://%s:%d/%s/%d/%s", dev.Scheme, dev.Ip, dev.Port, dev.Device, partition, common.Urlencode(account))
                req, err := http.NewRequest("PUT", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req = req.WithContext(tracing.CopySpanFromContext(ctx))
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">return req, nil</span>
        })
}

func (c *requestClient) PostAccount(ctx context.Context, account string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := c.pdc.AccountRing.GetPartition(account, "", "")
        return c.pdc.quorumResponse(c.pdc.AccountRing, partition, func(i int, dev *ring.Device) (*http.Request, error) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("%s://%s:%d/%s/%d/%s", dev.Scheme, dev.Ip, dev.Port, dev.Device, partition, common.Urlencode(account))
                req, err := http.NewRequest("POST", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req = req.WithContext(tracing.CopySpanFromContext(ctx))
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">return req, nil</span>
        })
}

func (c *requestClient) GetAccountRaw(ctx context.Context, account string, options map[string]string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := c.pdc.AccountRing.GetPartition(account, "", "")
        query := nectarutil.Mkquery(options)
        return c.pdc.firstResponse(c.pdc.AccountRing, partition, func(dev *ring.Device) (*http.Request, error) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("%s://%s:%d/%s/%d/%s%s", dev.Scheme, dev.Ip, dev.Port, dev.Device, partition,
                        common.Urlencode(account), query)
                req, err := http.NewRequest("GET", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req = req.WithContext(tracing.CopySpanFromContext(ctx))
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">return req, nil</span>
        })
}

func (c *requestClient) HeadAccount(ctx context.Context, account string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := c.pdc.AccountRing.GetPartition(account, "", "")
        return c.pdc.firstResponse(c.pdc.AccountRing, partition, func(dev *ring.Device) (*http.Request, error) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("%s://%s:%d/%s/%d/%s", dev.Scheme, dev.Ip, dev.Port, dev.Device, partition,
                        common.Urlencode(account))
                req, err := http.NewRequest("HEAD", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req = req.WithContext(tracing.CopySpanFromContext(ctx))
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">return req, nil</span>
        })
}

func (c *requestClient) DeleteAccount(ctx context.Context, account string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := c.pdc.AccountRing.GetPartition(account, "", "")
        return c.pdc.quorumResponse(c.pdc.AccountRing, partition, func(i int, dev *ring.Device) (*http.Request, error) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("%s://%s:%d/%s/%d/%s", dev.Scheme, dev.Ip, dev.Port, dev.Device, partition, common.Urlencode(account))
                req, err := http.NewRequest("DELETE", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req = req.WithContext(tracing.CopySpanFromContext(ctx))
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">return req, nil</span>
        })
}

func (c *requestClient) PutContainer(ctx context.Context, account string, container string, headers http.Header) *http.Response <span class="cov0" title="0">{
        defer c.invalidateContainerInfo(ctx, account, container)
        partition := c.pdc.ContainerRing.GetPartition(account, container, "")
        accountPartition := c.pdc.AccountRing.GetPartition(account, "", "")
        accountDevices := c.pdc.AccountRing.GetNodes(accountPartition)
        policyIndex := -1
        policyDefault := c.pdc.policyList.Default()
        if policyName := strings.TrimSpace(headers.Get("X-Storage-Policy")); policyName != "" </span><span class="cov0" title="0">{
                policy := c.pdc.policyList.NameLookup(policyName)
                if policy == nil </span><span class="cov0" title="0">{
                        return nectarutil.ResponseStub(http.StatusBadRequest, fmt.Sprintf("Invalid X-Storage-Policy %q", policyName))
                }</span> else<span class="cov0" title="0"> if policy.Deprecated </span><span class="cov0" title="0">{
                        return nectarutil.ResponseStub(http.StatusBadRequest, fmt.Sprintf("Storage Policy %q is deprecated", policyName))
                }</span>
                <span class="cov0" title="0">policyIndex = policy.Index</span>
        }
        <span class="cov0" title="0">containerReplicaCount := int(c.pdc.ContainerRing.ReplicaCount())
        return c.pdc.quorumResponse(c.pdc.ContainerRing, partition, func(i int, dev *ring.Device) (*http.Request, error) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("%s://%s:%d/%s/%d/%s/%s", dev.Scheme, dev.Ip, dev.Port, dev.Device, partition,
                        common.Urlencode(account), common.Urlencode(container))
                req, err := http.NewRequest("PUT", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req = req.WithContext(tracing.CopySpanFromContext(ctx))
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">if policyIndex != -1 </span><span class="cov0" title="0">{
                        req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(policyIndex))
                }</span>
                <span class="cov0" title="0">req.Header.Set("X-Backend-Storage-Policy-Default", strconv.Itoa(policyDefault))
                req.Header.Set("X-Account-Partition", strconv.FormatUint(accountPartition, 10))
                addUpdateHeaders("X-Account", req.Header, accountDevices, i, containerReplicaCount)
                return req, nil</span>
        })
}

func (c *requestClient) PostContainer(ctx context.Context, account string, container string, headers http.Header) *http.Response <span class="cov0" title="0">{
        defer c.invalidateContainerInfo(ctx, account, container)
        partition := c.pdc.ContainerRing.GetPartition(account, container, "")
        return c.pdc.quorumResponse(c.pdc.ContainerRing, partition, func(i int, dev *ring.Device) (*http.Request, error) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("%s://%s:%d/%s/%d/%s/%s", dev.Scheme, dev.Ip, dev.Port, dev.Device, partition,
                        common.Urlencode(account), common.Urlencode(container))
                req, err := http.NewRequest("POST", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req = req.WithContext(tracing.CopySpanFromContext(ctx))
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">return req, nil</span>
        })
}

func (c *requestClient) GetContainerRaw(ctx context.Context, account string, container string, options map[string]string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := c.pdc.ContainerRing.GetPartition(account, container, "")
        query := nectarutil.Mkquery(options)
        return c.pdc.firstResponse(c.pdc.ContainerRing, partition, func(dev *ring.Device) (*http.Request, error) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("%s://%s:%d/%s/%d/%s/%s%s", dev.Scheme, dev.Ip, dev.Port, dev.Device, partition,
                        common.Urlencode(account), common.Urlencode(container), query)
                req, err := http.NewRequest("GET", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req = req.WithContext(tracing.CopySpanFromContext(ctx))
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">return req, nil</span>
        })
}

func (c *requestClient) GetContainerInfo(ctx context.Context, account string, container string) (*ContainerInfo, error) <span class="cov8" title="1">{
        // if finds container info returns: *ci, nil
        // if gets 404 on HeadContainer returns: nil, ContainerNotFound
        // if errors on getting container retuns nil, err
        key := fmt.Sprintf("container/%s/%s", account, container)
        var ci *ContainerInfo
        contInCache := false
        if c.lc != nil </span><span class="cov8" title="1">{
                c.lcm.RLock()
                ci, contInCache = c.lc[key]
                c.lcm.RUnlock()
        }</span>
        <span class="cov8" title="1">if ci == nil &amp;&amp; contInCache </span><span class="cov0" title="0">{
                return nil, ContainerNotFound
        }</span>
        <span class="cov8" title="1">if !contInCache &amp;&amp; c.mc != nil </span><span class="cov0" title="0">{
                if err := c.mc.GetStructured(ctx, key, &amp;ci); err == nil </span><span class="cov0" title="0">{
                        if c.lc != nil </span><span class="cov0" title="0">{
                                c.lcm.RLock()
                                c.lc[key] = ci
                                c.lcm.RUnlock()
                        }</span>
                        <span class="cov0" title="0">contInCache = true</span>
                } else<span class="cov0" title="0"> {
                        ci = nil
                }</span>
        }
        <span class="cov8" title="1">if !contInCache </span><span class="cov0" title="0">{
                resp := c.HeadContainer(ctx, account, container, nil)
                resp.Body.Close()
                if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                        if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                                if c.lc != nil </span><span class="cov0" title="0">{
                                        c.lcm.RLock()
                                        c.lc[key] = nil
                                        c.lcm.RUnlock()
                                }</span>
                                <span class="cov0" title="0">return nil, ContainerNotFound</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("%d error retrieving info for container %s/%s", resp.StatusCode, account, container)</span>
                }
                <span class="cov0" title="0">var err error
                if ci, err = c.SetContainerInfo(ctx, account, container, resp); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">if ci == NilContainerInfo </span><span class="cov8" title="1">{
                return nil, errors.New("No container info for testing")
        }</span>
        <span class="cov8" title="1">return ci, nil</span>
}

func (c *requestClient) SetContainerInfo(ctx context.Context, account string, container string, resp *http.Response) (*ContainerInfo, error) <span class="cov0" title="0">{
        key := fmt.Sprintf("container/%s/%s", account, container)
        ci := &amp;ContainerInfo{
                Metadata:    make(map[string]string),
                SysMetadata: make(map[string]string),
        }
        var err error
        if ci.ObjectCount, err = strconv.ParseInt(resp.Header.Get("X-Container-Object-Count"), 10, 64); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Error retrieving X-Container-Object-Count for container %s/%s : %s", account, container, resp.Header.Get("X-Container-Object-Count"))
        }</span>
        <span class="cov0" title="0">if ci.ObjectBytes, err = strconv.ParseInt(resp.Header.Get("X-Container-Bytes-Used"), 10, 64); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Error retrieving X-Container-Bytes-Used for container %s/%s : %s", account, container, resp.Header.Get("X-Container-Bytes-Used"))
        }</span>
        <span class="cov0" title="0">if ci.StoragePolicyIndex, err = strconv.Atoi(resp.Header.Get("X-Backend-Storage-Policy-Index")); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Error retrieving X-Backend-Storage-Policy-Index for container %s/%s : %s", account, container, resp.Header.Get("X-Backend-Storage-Policy-Index"))
        }</span>
        <span class="cov0" title="0">for k := range resp.Header </span><span class="cov0" title="0">{
                if strings.HasPrefix(k, "X-Container-Meta-") </span><span class="cov0" title="0">{
                        ci.Metadata[k[17:]] = resp.Header.Get(k)
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(k, "X-Container-Sysmeta-") </span><span class="cov0" title="0">{
                        ci.SysMetadata[k[20:]] = resp.Header.Get(k)
                }</span> else<span class="cov0" title="0"> if k == "X-Container-Read" </span><span class="cov0" title="0">{
                        ci.ReadACL = resp.Header.Get(k)
                }</span> else<span class="cov0" title="0"> if k == "X-Container-Write" </span><span class="cov0" title="0">{
                        ci.WriteACL = resp.Header.Get(k)
                }</span> else<span class="cov0" title="0"> if k == "X-Container-Sync-Key" </span><span class="cov0" title="0">{
                        ci.SyncKey = resp.Header.Get(k)
                }</span>
        }
        <span class="cov0" title="0">if c.lc != nil &amp;&amp; ci != nil </span><span class="cov0" title="0">{
                c.lcm.Lock()
                c.lc[key] = ci
                c.lcm.Unlock()
        }</span>
        <span class="cov0" title="0">if c.mc != nil </span><span class="cov0" title="0">{
                c.mc.Set(ctx, key, ci, 10) // throwing away error here..
        }</span>
        <span class="cov0" title="0">return ci, nil</span>
}

func (c *requestClient) HeadContainer(ctx context.Context, account string, container string, headers http.Header) *http.Response <span class="cov0" title="0">{
        partition := c.pdc.ContainerRing.GetPartition(account, container, "")
        return c.pdc.firstResponse(c.pdc.ContainerRing, partition, func(dev *ring.Device) (*http.Request, error) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("%s://%s:%d/%s/%d/%s/%s", dev.Scheme, dev.Ip, dev.Port, dev.Device, partition,
                        common.Urlencode(account), common.Urlencode(container))
                req, err := http.NewRequest("HEAD", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req = req.WithContext(tracing.CopySpanFromContext(ctx))
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">return req, nil</span>
        })
}

func (c *requestClient) DeleteContainer(ctx context.Context, account string, container string, headers http.Header) *http.Response <span class="cov0" title="0">{
        defer c.invalidateContainerInfo(ctx, account, container)
        partition := c.pdc.ContainerRing.GetPartition(account, container, "")
        accountPartition := c.pdc.AccountRing.GetPartition(account, "", "")
        accountDevices := c.pdc.AccountRing.GetNodes(accountPartition)
        containerReplicaCount := int(c.pdc.ContainerRing.ReplicaCount())
        return c.pdc.quorumResponse(c.pdc.ContainerRing, partition, func(i int, dev *ring.Device) (*http.Request, error) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("%s://%s:%d/%s/%d/%s/%s", dev.Scheme, dev.Ip, dev.Port, dev.Device, partition,
                        common.Urlencode(account), common.Urlencode(container))
                req, err := http.NewRequest("DELETE", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req = req.WithContext(tracing.CopySpanFromContext(ctx))
                for key := range headers </span><span class="cov0" title="0">{
                        req.Header.Set(key, headers.Get(key))
                }</span>
                <span class="cov0" title="0">req.Header.Set("X-Account-Partition", strconv.FormatUint(accountPartition, 10))
                addUpdateHeaders("X-Account", req.Header, accountDevices, i, containerReplicaCount)
                return req, nil</span>
        })
}

func (c *requestClient) PutObject(ctx context.Context, account string, container string, obj string, headers http.Header, src io.Reader) *http.Response <span class="cov0" title="0">{
        return c.getObjectClient(ctx, account, container, c.mc, c.lc).putObject(ctx, account, container, obj, headers, src)
}</span>

func (c *requestClient) PostObject(ctx context.Context, account string, container string, obj string, headers http.Header) *http.Response <span class="cov0" title="0">{
        return c.getObjectClient(ctx, account, container, c.mc, c.lc).postObject(ctx, account, container, obj, headers)
}</span>

func (c *requestClient) GetObject(ctx context.Context, account string, container string, obj string, headers http.Header) *http.Response <span class="cov0" title="0">{
        return c.getObjectClient(ctx, account, container, c.mc, c.lc).getObject(ctx, account, container, obj, headers)
}</span>

func (c *requestClient) HeadObject(ctx context.Context, account string, container string, obj string, headers http.Header) *http.Response <span class="cov0" title="0">{
        return c.getObjectClient(ctx, account, container, c.mc, c.lc).headObject(ctx, account, container, obj, headers)
}</span>

func (c *requestClient) DeleteObject(ctx context.Context, account string, container string, obj string, headers http.Header) *http.Response <span class="cov0" title="0">{
        return c.getObjectClient(ctx, account, container, c.mc, c.lc).deleteObject(ctx, account, container, obj, headers)
}</span>

func (c *requestClient) ObjectRingFor(ctx context.Context, account string, container string) (ring.Ring, *http.Response) <span class="cov8" title="1">{
        return c.getObjectClient(ctx, account, container, c.mc, c.lc).ring()
}</span>

func (c *requestClient) ContainerRing() ring.Ring <span class="cov8" title="1">{
        return c.pdc.ContainerRing.ring()
}</span>

func (c *requestClient) AccountRing() ring.Ring <span class="cov8" title="1">{
        return c.pdc.AccountRing.ring()
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">//  Copyright (c) 2018 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package client

import (
        "errors"
        "io"
        "net"
        "net/http"
        "strconv"

        opentracing "github.com/opentracing/opentracing-go"
        "github.com/opentracing/opentracing-go/ext"
        "github.com/opentracing/opentracing-go/log"

        "crypto/tls"
        "fmt"
        "net/http/httptrace"
)

// ErrValidTracerRequired error
var ErrValidTracerRequired = errors.New("valid tracer required")

// TracingClient holds a opentracing instrumented HTTP Client.
type TracingClient struct {
        *http.Client
        tracer    opentracing.Tracer
        httpTrace bool
}

// NewTracingClient returns an HTTP Client adding Opentracing instrumentation around an
// embedded standard Go http.Client.
func NewTracingClient(tracer opentracing.Tracer, httpClient *http.Client, enableHTTPTrace bool) (*TracingClient, error) <span class="cov0" title="0">{
        if tracer == nil </span><span class="cov0" title="0">{
                return nil, ErrValidTracerRequired
        }</span>

        <span class="cov0" title="0">tc := &amp;TracingClient{tracer: tracer, Client: httpClient, httpTrace: enableHTTPTrace}

        transport, err := NewTransport(tracer, tc.Client.Transport, enableHTTPTrace)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tc.Client.Transport = transport

        return tc, nil</span>
}

// Do wraps http.Client's Do with tracing using an application span.
func (tc *TracingClient) Do(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        var parentContext opentracing.SpanContext

        if span := opentracing.SpanFromContext(req.Context()); span != nil </span><span class="cov0" title="0">{
                parentContext = span.Context()
        }</span>

        <span class="cov0" title="0">appSpan := tc.tracer.StartSpan("HTTP Client", opentracing.ChildOf(parentContext))

        ext.HTTPMethod.Set(appSpan, req.Method)
        ext.HTTPUrl.Set(appSpan, req.URL.String())

        res, err := tc.Client.Do(
                req.WithContext(opentracing.ContextWithSpan(req.Context(), appSpan)),
        )
        if err != nil </span><span class="cov0" title="0">{
                ext.Error.Set(appSpan, true)
                appSpan.SetTag("error", err.Error())
                appSpan.Finish()
                return res, err
        }</span>

        <span class="cov0" title="0">ext.HTTPStatusCode.Set(appSpan, uint16(res.StatusCode))
        if res.StatusCode &gt; 399 </span><span class="cov0" title="0">{
                ext.Error.Set(appSpan, true)
        }</span>
        <span class="cov0" title="0">if req.Method == "HEAD" </span><span class="cov0" title="0">{
                appSpan.Finish()
        }</span> else<span class="cov0" title="0"> {
                res.Body = &amp;spanCloser{
                        ReadCloser:   res.Body,
                        sp:           appSpan,
                        traceEnabled: tc.httpTrace,
                }
        }</span>
        <span class="cov0" title="0">return res, nil</span>
}

type transport struct {
        tracer    opentracing.Tracer
        rt        http.RoundTripper
        httpTrace bool
}

// NewTransport returns a new Opentracing instrumented http RoundTripper
func NewTransport(tracer opentracing.Tracer, rt http.RoundTripper, enableHTTPTrace bool) (http.RoundTripper, error) <span class="cov0" title="0">{
        if tracer == nil </span><span class="cov0" title="0">{
                return nil, ErrValidTracerRequired
        }</span>
        <span class="cov0" title="0">if rt == nil </span><span class="cov0" title="0">{
                rt = http.DefaultTransport
        }</span>
        <span class="cov0" title="0">t := &amp;transport{
                tracer:    tracer,
                rt:        rt,
                httpTrace: enableHTTPTrace,
        }

        return t, nil</span>
}

// RoundTrip satisfies the RoundTripper interface.
func (t *transport) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        parent := opentracing.SpanFromContext(req.Context())
        var spanctx opentracing.SpanContext
        if parent != nil </span><span class="cov0" title="0">{
                spanctx = parent.Context()
        }</span>
        <span class="cov0" title="0">sp := t.tracer.StartSpan("HTTP "+req.Method, opentracing.ChildOf(spanctx))
        ext.SpanKindRPCClient.Set(sp)

        if t.httpTrace </span><span class="cov0" title="0">{
                sptr := spanTrace{
                        Span: sp,
                }
                sptr.c = &amp;httptrace.ClientTrace{
                        GetConn:              sptr.getConn,
                        GotConn:              sptr.gotConn,
                        PutIdleConn:          sptr.putIdleConn,
                        GotFirstResponseByte: sptr.gotFirstResponseByte,
                        Got100Continue:       sptr.got100Continue,
                        DNSStart:             sptr.dnsStart,
                        DNSDone:              sptr.dnsDone,
                        ConnectStart:         sptr.connectStart,
                        ConnectDone:          sptr.connectDone,
                        TLSHandshakeStart:    sptr.tlsHandshakeStart,
                        TLSHandshakeDone:     sptr.tlsHandshakeDone,
                        WroteHeaders:         sptr.wroteHeaders,
                        Wait100Continue:      sptr.wait100Continue,
                        WroteRequest:         sptr.wroteRequest,
                }

                req = req.WithContext(
                        httptrace.WithClientTrace(req.Context(), sptr.c),
                )
        }</span>

        <span class="cov0" title="0">ext.HTTPMethod.Set(sp, req.Method)
        ext.HTTPUrl.Set(
                sp,
                fmt.Sprintf("%s://%s%s", req.URL.Scheme, req.URL.Host, req.URL.Path),
        )
        host, portString, err := net.SplitHostPort(req.URL.Host)
        if err == nil </span><span class="cov0" title="0">{
                ext.PeerHostname.Set(sp, host)
                if port, err := strconv.Atoi(portString); err != nil </span><span class="cov0" title="0">{
                        ext.PeerPort.Set(sp, uint16(port))
                }</span>
        } else<span class="cov0" title="0"> {
                ext.PeerHostname.Set(sp, req.URL.Host)
        }</span>

        <span class="cov0" title="0">carrier := opentracing.HTTPHeadersCarrier(req.Header)
        //TODO nadeem: check &amp; log error
        sp.Tracer().Inject(sp.Context(), opentracing.TextMap, carrier)

        res, err := t.rt.RoundTrip(req)

        if err != nil </span><span class="cov0" title="0">{
                sp.SetTag("error", err.Error())
                sp.Finish()
                return res, err
        }</span>

        <span class="cov0" title="0">ext.HTTPStatusCode.Set(sp, uint16(res.StatusCode))
        if res.StatusCode &gt; 399 </span><span class="cov0" title="0">{
                ext.Error.Set(sp, true)
        }</span>

        <span class="cov0" title="0">sp.Finish()
        return res, nil</span>
}

type spanTrace struct {
        opentracing.Span
        c *httptrace.ClientTrace
}

func (s *spanTrace) getConn(hostPort string) <span class="cov0" title="0">{
        s.LogFields(log.String("event", "GetConn"))
        ext.HTTPUrl.Set(s, hostPort)
}</span>

func (s *spanTrace) gotConn(info httptrace.GotConnInfo) <span class="cov0" title="0">{
        s.LogFields(log.String("event", "GotConn"))
        s.SetTag("httptrace.got_connection.reused", fmt.Sprintf("%t", info.Reused))
        s.SetTag("httptrace.got_connection.was_idle", fmt.Sprintf("%t", info.WasIdle))
        if info.WasIdle </span><span class="cov0" title="0">{
                s.SetTag("httptrace.got_connection.idle_time", info.IdleTime.String())
        }</span>
}

func (s *spanTrace) putIdleConn(err error) <span class="cov0" title="0">{
        s.LogFields(log.String("event", "PutIdleConn"))
        if err != nil </span><span class="cov0" title="0">{
                s.SetTag("httptrace.put_idle_connection.error", err.Error())
        }</span>
}

func (s *spanTrace) gotFirstResponseByte() <span class="cov0" title="0">{
        s.LogFields(log.String("event", "GotFirstResponseByte"))
}</span>

func (s *spanTrace) got100Continue() <span class="cov0" title="0">{
        s.LogFields(log.String("event", "Got100Continue"))
}</span>

func (s *spanTrace) dnsStart(info httptrace.DNSStartInfo) <span class="cov0" title="0">{
        s.LogFields(
                log.String("event", "DNSStart"),
                log.String("host", info.Host),
        )
}</span>

func (s *spanTrace) dnsDone(info httptrace.DNSDoneInfo) <span class="cov0" title="0">{
        fields := []log.Field{log.String("event", "DNSDone")}
        for _, addr := range info.Addrs </span><span class="cov0" title="0">{
                fields = append(fields, log.String("addr", addr.String()))
        }</span>
        <span class="cov0" title="0">if info.Err != nil </span><span class="cov0" title="0">{
                fields = append(fields, log.Error(info.Err))
        }</span>
        <span class="cov0" title="0">s.LogFields(fields...)</span>
}

func (s *spanTrace) connectStart(network, addr string) <span class="cov0" title="0">{
        s.LogFields(
                log.String("event", "ConnectStart"),
                log.String("network", network),
                log.String("addr", addr),
        )
}</span>

func (s *spanTrace) connectDone(network, addr string, err error) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                s.LogFields(
                        log.String("message", "ConnectDone"),
                        log.String("network", network),
                        log.String("addr", addr),
                        log.String("event", "error"),
                        log.Error(err),
                )
        }</span> else<span class="cov0" title="0"> {
                s.LogFields(
                        log.String("event", "ConnectDone"),
                        log.String("network", network),
                        log.String("addr", addr),
                )
        }</span>
}

func (s *spanTrace) tlsHandshakeStart() <span class="cov0" title="0">{
        s.LogFields(log.String("event", "TLS Handshake Start"))
}</span>

func (s *spanTrace) tlsHandshakeDone(_ tls.ConnectionState, err error) <span class="cov0" title="0">{
        s.LogFields(log.String("event", "TLS Handshake Done"))
        if err != nil </span><span class="cov0" title="0">{
                s.SetTag("httptrace.tls_handshake_done.error", err.Error())
        }</span>
}

func (s *spanTrace) wroteHeaders() <span class="cov0" title="0">{
        s.LogFields(log.String("event", "WroteHeaders"))
}</span>

func (s *spanTrace) wait100Continue() <span class="cov0" title="0">{
        s.LogFields(log.String("event", "Wait100Continue"))
}</span>

func (s *spanTrace) wroteRequest(info httptrace.WroteRequestInfo) <span class="cov0" title="0">{
        if info.Err != nil </span><span class="cov0" title="0">{
                s.LogFields(
                        log.String("message", "WroteRequest"),
                        log.String("event", "error"),
                        log.Error(info.Err),
                )
                ext.Error.Set(s, true)
        }</span> else<span class="cov0" title="0"> {
                s.LogFields(log.String("event", "WroteRequest"))
        }</span>
}

type spanCloser struct {
        io.ReadCloser
        sp           opentracing.Span
        traceEnabled bool
}

func (s *spanCloser) Close() (err error) <span class="cov0" title="0">{
        if s.traceEnabled </span><span class="cov0" title="0">{
                s.sp.LogFields(log.String("event", "ClosedBody"))
        }</span>
        <span class="cov0" title="0">err = s.ReadCloser.Close()
        s.sp.Finish()
        return</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package conf

import (
        "bytes"
        "errors"
        "fmt"
        "os"
        "os/user"
        "path/filepath"
        "sort"
        "strconv"
        "strings"

        "github.com/troubling/hummingbird/common"
        "github.com/vaughan0/go-ini"
)

// Config represents an ini file.
type Config struct{ ini.File }

type Section struct {
        ini.Section
        c       Config
        section string
}

// Get fetches a value from the Config, looking in the DEFAULT section if not found in the specific section.  Also ignores "set " key prefixes, like paste.
func (f Config) Get(section string, key string) (string, bool) <span class="cov8" title="1">{
        if value, ok := f.File.Get(section, key); ok </span><span class="cov8" title="1">{
                return value, true
        }</span> else<span class="cov8" title="1"> if value, ok := f.File.Get("DEFAULT", key); ok </span><span class="cov8" title="1">{
                return value, true
        }</span> else<span class="cov8" title="1"> if value, ok := f.File.Get(section, "set "+key); ok </span><span class="cov8" title="1">{
                return value, true
        }</span> else<span class="cov8" title="1"> if value, ok := f.File.Get("DEFAULT", "set "+key); ok </span><span class="cov0" title="0">{
                return value, true
        }</span>
        <span class="cov8" title="1">return "", false</span>
}

// GetDefault returns a value from the config, or returns the default setting if the entry doesn't exist.
func (f Config) GetDefault(section string, key string, dfl string) string <span class="cov8" title="1">{
        if value, ok := f.Get(section, key); ok </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return dfl</span>
}

// GetBool loads a true/false value from the config, with support for things like "yes", "true", "1", "t", etc.
func (f Config) GetBool(section string, key string, dfl bool) bool <span class="cov8" title="1">{
        if value, ok := f.Get(section, key); ok </span><span class="cov8" title="1">{
                return common.LooksTrue(value)
        }</span>
        <span class="cov8" title="1">return dfl</span>
}

// GetInt loads an entry from the config, parsed as an integer value.
func (f Config) GetInt(section string, key string, dfl int64) int64 <span class="cov8" title="1">{
        if value, ok := f.Get(section, key); ok </span><span class="cov8" title="1">{
                if val, err := strconv.ParseInt(value, 10, 64); err == nil </span><span class="cov8" title="1">{
                        return val
                }</span>
                <span class="cov0" title="0">panic(fmt.Sprintf("Error parsing integer %s/%s from config.", section, key))</span>
        }
        <span class="cov8" title="1">return dfl</span>
}

// GetFloat loads an entry from the config, parsed as a floating point value.
func (f Config) GetFloat(section string, key string, dfl float64) float64 <span class="cov8" title="1">{
        if value, ok := f.Get(section, key); ok </span><span class="cov8" title="1">{
                if val, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov8" title="1">{
                        return val
                }</span>
                <span class="cov0" title="0">panic(fmt.Sprintf("Error parsing float %s/%s from config.", section, key))</span>
        }
        <span class="cov8" title="1">return dfl</span>
}

// GetLimit loads an entry from the config in the format of %d/%d.
func (f Config) GetLimit(section string, key string, dfla int64, dflb int64) (int64, int64) <span class="cov8" title="1">{
        if value, ok := f.Get(section, key); ok </span><span class="cov8" title="1">{
                fmt.Sscanf(value, "%d/%d", &amp;dfla, &amp;dflb)
        }</span>
        <span class="cov8" title="1">return dfla, dflb</span>
}

// HasSection determines whether or not the section exists in the ini file.
func (f Config) HasSection(section string) bool <span class="cov8" title="1">{
        return f.File[section] != nil
}</span>

// GetSection returns a Section struct.
func (f Config) GetSection(section string) Section <span class="cov8" title="1">{
        return Section{f.File[section], f, section}
}</span>

func (s Section) Get(key string) (string, bool) <span class="cov8" title="1">{
        return s.c.Get(s.section, key)
}</span>

func (s Section) GetDefault(key string, dfl string) string <span class="cov8" title="1">{
        return s.c.GetDefault(s.section, key, dfl)
}</span>

func (s Section) GetBool(key string, dfl bool) bool <span class="cov0" title="0">{
        return s.c.GetBool(s.section, key, dfl)
}</span>

func (s Section) GetInt(key string, dfl int64) int64 <span class="cov0" title="0">{
        return s.c.GetInt(s.section, key, dfl)
}</span>

func (s Section) GetFloat(key string, dfl float64) float64 <span class="cov0" title="0">{
        return s.c.GetFloat(s.section, key, dfl)
}</span>

func (s Section) GetLimit(key string, dfla int64, dflb int64) (int64, int64) <span class="cov0" title="0">{
        return s.c.GetLimit(s.section, key, dfla, dflb)
}</span>

func (s Section) GetConfig() Config <span class="cov0" title="0">{
        return s.c
}</span>

// LoadConfig loads an ini from a path.  The path should be a *.conf file or a *.conf.d directory.
func LoadConfig(path string) (Config, error) <span class="cov8" title="1">{
        file := Config{make(ini.File)}
        if fi, err := os.Stat(path); err != nil </span><span class="cov8" title="1">{
                return file, err
        }</span> else<span class="cov8" title="1"> if fi.IsDir() </span><span class="cov8" title="1">{
                files, err := filepath.Glob(filepath.Join(path, "*.conf"))
                if err != nil </span><span class="cov0" title="0">{
                        return file, err
                }</span>
                <span class="cov8" title="1">sort.Strings(files)
                for _, subfile := range files </span><span class="cov8" title="1">{
                        sf, err := LoadConfig(subfile)
                        if err != nil </span><span class="cov0" title="0">{
                                return file, err
                        }</span>
                        <span class="cov8" title="1">for sec, val := range sf.File </span><span class="cov8" title="1">{
                                file.File[sec] = val
                        }</span>
                }
                <span class="cov8" title="1">return file, nil</span>
        }
        <span class="cov8" title="1">return file, file.LoadFile(path)</span>
}

// LoadConfigs finds and loads any configs that exist for the given path.  Multiple configs are supported for things like SAIO setups.
func LoadConfigs(path string) ([]Config, error) <span class="cov8" title="1">{
        configPaths := []string{}
        configs := []Config{}
        if fi, err := os.Stat(path); err == nil &amp;&amp; fi.IsDir() &amp;&amp; !strings.HasSuffix(path, ".conf.d") </span><span class="cov8" title="1">{
                if multiConfigs, err := filepath.Glob(filepath.Join(path, "*.conf")); err == nil </span><span class="cov8" title="1">{
                        configPaths = append(configPaths, multiConfigs...)
                }</span>
                <span class="cov8" title="1">if multiConfigs, err := filepath.Glob(filepath.Join(path, "*.conf.d")); err == nil </span><span class="cov8" title="1">{
                        configPaths = append(configPaths, multiConfigs...)
                }</span>
        } else<span class="cov8" title="1"> {
                configPaths = append(configPaths, path)
        }</span>
        <span class="cov8" title="1">for _, p := range configPaths </span><span class="cov8" title="1">{
                if config, err := LoadConfig(p); err == nil </span><span class="cov8" title="1">{
                        configs = append(configs, config)
                }</span>
        }
        <span class="cov8" title="1">if len(configs) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("Unable to find any configs")
        }</span>
        <span class="cov8" title="1">return configs, nil</span>
}

// StringConfig returns an Config from a string, for use in tests.
func StringConfig(data string) (Config, error) <span class="cov8" title="1">{
        file := Config{make(ini.File)}
        return file, file.Load(bytes.NewBufferString(data))
}</span>

// UidFromConf returns the uid and gid for the user set in the first config found.
func UidFromConf(path string) (uint32, uint32, error) <span class="cov8" title="1">{
        configs, err := LoadConfigs(path)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>
        <span class="cov8" title="1">for _, config := range configs </span><span class="cov8" title="1">{
                var usr *user.User
                var err error
                username := config.GetDefault("DEFAULT", "user", "")
                if username != "" </span><span class="cov8" title="1">{
                        usr, err = user.Lookup(username)
                }</span> else<span class="cov0" title="0"> {
                        usr, err = user.Current()
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        return 0, 0, err
                }</span>
                <span class="cov8" title="1">uid, err := strconv.ParseUint(usr.Uid, 10, 32)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, 0, err
                }</span>
                <span class="cov8" title="1">gid, err := strconv.ParseUint(usr.Gid, 10, 32)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, 0, err
                }</span>
                <span class="cov8" title="1">return uint32(uid), uint32(gid), nil</span>
        }
        <span class="cov0" title="0">return 0, 0, fmt.Errorf("Unable to find config")</span>
}

var configLocations = []string{"/etc/hummingbird/hummingbird.conf", "/etc/swift/swift.conf"}

// GetHashPrefixAndSuffix retrieves the hash path prefix and suffix from
// the correct configs based on the environments setup. The suffix cannot
// be nil
type getHashPrefixAndSuffixFunc func() (pfx string, sfx string, err error)

var GetHashPrefixAndSuffix getHashPrefixAndSuffixFunc = normalGetHashPrefixAndSuffix

func normalGetHashPrefixAndSuffix() (prefix string, suffix string, err error) <span class="cov8" title="1">{
        for _, loc := range configLocations </span><span class="cov8" title="1">{
                if conf, e := LoadConfig(loc); e == nil </span><span class="cov8" title="1">{
                        var ok bool
                        prefix, _ = conf.Get("swift-hash", "swift_hash_path_prefix")
                        if suffix, ok = conf.Get("swift-hash", "swift_hash_path_suffix"); !ok </span><span class="cov0" title="0">{
                                return prefix, suffix, errors.New("Hash path suffix not defined")
                        }</span>
                        <span class="cov8" title="1">return prefix, suffix, nil</span>
                }
        }
        <span class="cov0" title="0">return "", "", fmt.Errorf("No conf found; looked for %s", configLocations)</span>
}

func ReadResellerOptions(conf Section, defaults map[string][]string) ([]string, map[string]map[string][]string) <span class="cov8" title="1">{
        resellerPrefixOpt := conf.GetDefault("reseller_prefix", "AUTH")
        s := []string{}
        for _, val := range strings.Split(resellerPrefixOpt, ",") </span><span class="cov8" title="1">{
                v := strings.TrimSpace(val)
                if v != "" </span><span class="cov8" title="1">{
                        s = append(s, strings.TrimSpace(v))
                }</span>
        }
        <span class="cov8" title="1">resellerPrefix := []string{}
        for _, prefix := range s </span><span class="cov8" title="1">{
                if prefix == "''" </span><span class="cov8" title="1">{
                        prefix = ""
                }</span>
                <span class="cov8" title="1">if prefix != "" &amp;&amp; !strings.HasSuffix(prefix, "_") </span><span class="cov8" title="1">{
                        prefix = prefix + "_"
                }</span>
                <span class="cov8" title="1">if !common.StringInSlice(prefix, resellerPrefix) </span><span class="cov8" title="1">{
                        resellerPrefix = append(resellerPrefix, prefix)
                }</span>
        }
        <span class="cov8" title="1">if len(resellerPrefix) == 0 </span><span class="cov8" title="1">{
                resellerPrefix = append(resellerPrefix, "")
        }</span>
        <span class="cov8" title="1">associatedOptions := make(map[string]map[string][]string)
        for _, prefix := range resellerPrefix </span><span class="cov8" title="1">{
                associatedOptions[prefix] = make(map[string][]string)
                for k, v := range defaults </span><span class="cov8" title="1">{
                        associatedOptions[prefix][k] = v
                }</span>
                <span class="cov8" title="1">for k, v := range ReadPrefixedOptions(conf, "", defaults) </span><span class="cov8" title="1">{
                        associatedOptions[prefix][k] = v
                }</span>
                <span class="cov8" title="1">prefix_name := "''"
                if prefix != "" </span><span class="cov8" title="1">{
                        prefix_name = prefix
                }</span>
                <span class="cov8" title="1">for k, v := range ReadPrefixedOptions(conf, prefix_name, defaults) </span><span class="cov8" title="1">{
                        associatedOptions[prefix][k] = v
                }</span>
        }
        <span class="cov8" title="1">return resellerPrefix, associatedOptions</span>
}

func ReadPrefixedOptions(conf Section, prefixName string, defaults map[string][]string) map[string][]string <span class="cov8" title="1">{
        params := make(map[string][]string)
        for optionName := range defaults </span><span class="cov8" title="1">{
                if value, ok := conf.Get(fmt.Sprintf("%s%s", prefixName, optionName)); ok </span><span class="cov8" title="1">{
                        params[optionName] = []string{}
                        for _, role := range strings.Split(strings.ToLower(value), ",") </span><span class="cov8" title="1">{
                                params[optionName] = append(params[optionName], strings.TrimSpace(role))
                        }</span>
                }
        }
        <span class="cov8" title="1">return params</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package conf

import (
        "fmt"
        "strconv"
        "strings"
)

type Policy struct {
        Index      int
        Type       string
        Name       string
        Aliases    []string
        Default    bool
        Deprecated bool
        Config     map[string]string
}

func (p Policy) GetDbPartPower() (uint, error) <span class="cov8" title="1">{
        dbPartPower := 0
        if p.Config["db_part_power"] != "" </span><span class="cov0" title="0">{
                dbPartPowerInt64, err := strconv.ParseInt(p.Config["db_part_power"], 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("Could not parse db_part_power value %q: %s", p.Config["db_part_power"], err)
                }</span>
                <span class="cov0" title="0">dbPartPower = int(dbPartPowerInt64)</span>
        }
        <span class="cov8" title="1">if dbPartPower &lt; 1 </span><span class="cov8" title="1">{
                dbPartPower = 3
        }</span>
        <span class="cov8" title="1">return uint(dbPartPower), nil</span>
}
func (p Policy) GetDbSubDirs() (int, error) <span class="cov8" title="1">{
        subdirs := 0
        if p.Config["subdirs"] != "" </span><span class="cov0" title="0">{
                subdirsInt64, err := strconv.ParseInt(p.Config["subdirs"], 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("Could not parse subdirs value %q: %s", p.Config["subdirs"], err)
                }</span>
                <span class="cov0" title="0">subdirs = int(subdirsInt64)</span>
        }
        <span class="cov8" title="1">if subdirs &lt; 1 </span><span class="cov8" title="1">{
                subdirs = 32
        }</span>
        <span class="cov8" title="1">return subdirs, nil</span>
}

type PolicyList map[int]*Policy

func (p PolicyList) Default() int <span class="cov8" title="1">{
        for _, v := range p </span><span class="cov8" title="1">{
                if v.Default </span><span class="cov0" title="0">{
                        return v.Index
                }</span>
        }
        <span class="cov8" title="1">return 0</span>
}

func (p PolicyList) NameLookup(s string) *Policy <span class="cov8" title="1">{
        // a map would be faster, but this only happens on container PUT, so how fast does it need to be?
        s = strings.ToUpper(strings.TrimSpace(s))
        for _, v := range p </span><span class="cov8" title="1">{
                if s == strings.ToUpper(v.Name) </span><span class="cov0" title="0">{
                        return v
                }</span>
                <span class="cov8" title="1">for _, a := range v.Aliases </span><span class="cov8" title="1">{
                        if s == strings.ToUpper(a) </span><span class="cov0" title="0">{
                                return v
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (p PolicyList) GetPolicyInfo() []map[string]interface{} <span class="cov8" title="1">{
        policyInfo := []map[string]interface{}{}
        for _, v := range p </span><span class="cov8" title="1">{
                if v.Deprecated </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">pol := map[string]interface{}{}
                pol["name"] = v.Name
                if v.Default </span><span class="cov8" title="1">{
                        pol["default"] = v.Default
                }</span>
                <span class="cov8" title="1">pol["aliases"] = strings.Join(v.Aliases, ", ")
                policyInfo = append(policyInfo, pol)</span>
        }
        <span class="cov8" title="1">return policyInfo</span>
}

// LoadPolicies loads policies, probably from /etc/swift/swift.conf
func GetPolicies() (PolicyList, error) <span class="cov8" title="1">{
        policies := map[int]*Policy{0: {
                Index:      0,
                Type:       "replication",
                Name:       "Policy-0",
                Aliases:    nil,
                Default:    false,
                Deprecated: false,
        }}
        for _, loc := range configLocations </span><span class="cov8" title="1">{
                if conf, e := LoadConfig(loc); e == nil </span><span class="cov8" title="1">{
                        for key := range conf.File </span><span class="cov8" title="1">{
                                var policyIndex int
                                if c, err := fmt.Sscanf(key, "storage-policy:%d", &amp;policyIndex); err == nil &amp;&amp; c == 1 </span><span class="cov8" title="1">{
                                        name := conf.GetDefault(key, "name", fmt.Sprintf("Policy-%d", policyIndex))
                                        aliases := []string{name}
                                        aliasList := conf.GetDefault(key, "aliases", "")
                                        for _, alias := range strings.Split(aliasList, ",") </span><span class="cov8" title="1">{
                                                alias = strings.Trim(alias, " ")
                                                if alias != "" &amp;&amp; alias != name </span><span class="cov8" title="1">{
                                                        aliases = append(aliases, alias)
                                                }</span>
                                        }
                                        <span class="cov8" title="1">policies[policyIndex] = &amp;Policy{
                                                Index:      policyIndex,
                                                Type:       conf.GetDefault(key, "policy_type", "replication"),
                                                Name:       name,
                                                Aliases:    aliases,
                                                Deprecated: conf.GetBool(key, "deprecated", false),
                                                Default:    conf.GetBool(key, "default", false),
                                                Config:     map[string]string(conf.File[key]),
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">break</span>
                }
        }
        <span class="cov8" title="1">defaultFound := false
        for _, policy := range policies </span><span class="cov8" title="1">{
                if policy.Default </span><span class="cov8" title="1">{
                        defaultFound = true
                }</span>
        }
        <span class="cov8" title="1">if !defaultFound </span><span class="cov8" title="1">{
                policies[0].Default = true
        }</span>
        <span class="cov8" title="1">return PolicyList(policies), nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package conf

import "strings"

type SyncRealm struct {
        Name     string
        Key1     string
        Key2     string
        Clusters map[string]string
}

type SyncRealmList map[string]SyncRealm

func (l SyncRealmList) ValidateSyncTo(syncHeader string) bool <span class="cov8" title="1">{
        if !strings.HasPrefix(syncHeader, "//") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">parts := strings.Split(syncHeader[2:], "/")
        if len(parts) &lt; 4 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">realm := parts[0]
        cluster := parts[1]
        account := parts[2]
        container := parts[3]
        if account == "" || container == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if l[realm].Key1 == "" </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if l[realm].Clusters[cluster] == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

var syncRealmConfigLocations = []string{"/etc/hummingbird/container-sync-realms.conf", "/etc/swift/container-sync-realms.conf"}

func GetSyncRealms() (SyncRealmList, error) <span class="cov8" title="1">{
        resp := make(map[string]SyncRealm)
        for _, loc := range syncRealmConfigLocations </span><span class="cov8" title="1">{
                if conf, err := LoadConfig(loc); err == nil </span><span class="cov8" title="1">{
                        for realm, config := range conf.File </span><span class="cov8" title="1">{
                                realm := SyncRealm{Name: realm, Clusters: make(map[string]string)}
                                for k, v := range config </span><span class="cov8" title="1">{
                                        if k == "key" </span><span class="cov8" title="1">{
                                                realm.Key1 = v
                                        }</span> else<span class="cov8" title="1"> if k == "key2" </span><span class="cov8" title="1">{
                                                realm.Key2 = v
                                        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(k, "cluster_") </span><span class="cov8" title="1">{
                                                realm.Clusters[k[8:]] = v
                                        }</span>
                                }
                                <span class="cov8" title="1">resp[realm.Name] = realm</span>
                        }
                }
        }
        <span class="cov8" title="1">return SyncRealmList(resp), nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package common

import (
        "fmt"
        "net/http"
        "strconv"
        "strings"
        "time"
)

const (
        MAX_FILE_SIZE             = int64(5368709122)
        MAX_META_NAME_LENGTH      = 128
        MAX_META_VALUE_LENGTH     = 256
        MAX_META_COUNT            = 90
        MAX_META_OVERALL_SIZE     = 4096
        MAX_HEADER_SIZE           = 8192
        MAX_OBJECT_NAME_LENGTH    = 1024
        CONTAINER_LISTING_LIMIT   = 10000
        ACCOUNT_LISTING_LIMIT     = 10000
        MAX_ACCOUNT_NAME_LENGTH   = 256
        MAX_CONTAINER_NAME_LENGTH = 256
        EXTRA_HEADER_COUNT        = 0
)

var DEFAULT_CONSTRAINTS = map[string]interface{}{
        "max_file_size":             MAX_FILE_SIZE,
        "max_meta_name_length":      MAX_META_NAME_LENGTH,
        "max_meta_value_length":     MAX_META_VALUE_LENGTH,
        "max_meta_count":            MAX_META_COUNT,
        "max_meta_overall_size":     MAX_META_OVERALL_SIZE,
        "max_header_size":           MAX_HEADER_SIZE,
        "max_object_name_length":    MAX_OBJECT_NAME_LENGTH,
        "container_listing_limit":   CONTAINER_LISTING_LIMIT,
        "account_listing_limit":     ACCOUNT_LISTING_LIMIT,
        "max_account_name_length":   MAX_ACCOUNT_NAME_LENGTH,
        "max_container_name_length": MAX_CONTAINER_NAME_LENGTH,
        "extra_header_count":        EXTRA_HEADER_COUNT,
}

var OwnerHeaders = map[string]bool{
        "x-container-read":                true,
        "x-container-write":               true,
        "x-container-sync-key":            true,
        "x-container-sync-to":             true,
        "x-account-meta-temp-url-key":     true,
        "x-account-meta-temp-url-key-2":   true,
        "x-container-meta-temp-url-key":   true,
        "x-container-meta-temp-url-key-2": true,
        "x-account-access-control":        true,
}

func CheckMetadata(req *http.Request, targetType string) (int, string) <span class="cov8" title="1">{
        metaCount := 0
        metaSize := 0
        metaPrefix := fmt.Sprintf("X-%s-Meta-", targetType)
        fixKeys := make(map[string]string)
        for key := range req.Header </span><span class="cov8" title="1">{
                value := req.Header.Get(key)
                if len(value) &gt; MAX_HEADER_SIZE </span><span class="cov8" title="1">{
                        errStr := fmt.Sprintf("Header value too long: %s", key)
                        if len(key) &gt; MAX_META_NAME_LENGTH </span><span class="cov0" title="0">{
                                errStr = fmt.Sprintf("Header value too long: %s", key[:MAX_META_NAME_LENGTH])
                        }</span>
                        <span class="cov8" title="1">return http.StatusBadRequest, errStr</span>
                }
                <span class="cov8" title="1">if !strings.HasPrefix(key, metaPrefix) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">key = key[len(metaPrefix):]
                metaCount += 1
                metaSize += len(key) + len(value)
                if key == "" </span><span class="cov8" title="1">{
                        return http.StatusBadRequest, "Metadata name cannot be empty"
                }</span>
                <span class="cov8" title="1">if StringInSlice(targetType, []string{"Account", "Container"}) &amp;&amp; (strings.Contains(key, "\x00") || strings.Contains(value, "\x00")) </span><span class="cov0" title="0">{
                        return http.StatusBadRequest, "Metadata must be valid UTF-8"
                }</span>
                <span class="cov8" title="1">if len(key) &gt; MAX_META_NAME_LENGTH </span><span class="cov8" title="1">{
                        return http.StatusBadRequest, fmt.Sprintf("Metadata name too long: %s%s", metaPrefix, key)
                }</span>
                <span class="cov8" title="1">if len(value) &gt; MAX_META_VALUE_LENGTH </span><span class="cov8" title="1">{
                        return http.StatusBadRequest, fmt.Sprintf("Metadata value longer than %d: %s%s", MAX_META_VALUE_LENGTH, metaPrefix, key)
                }</span>
                <span class="cov8" title="1">if metaCount &gt; MAX_META_COUNT </span><span class="cov8" title="1">{
                        return http.StatusBadRequest, fmt.Sprintf("Too many metadata items; max %d", MAX_META_COUNT)
                }</span>
                <span class="cov8" title="1">if metaSize &gt; MAX_META_OVERALL_SIZE </span><span class="cov8" title="1">{
                        return http.StatusBadRequest, fmt.Sprintf("Total metadata too large; max %d", MAX_META_OVERALL_SIZE)
                }</span>
                <span class="cov8" title="1">fixedKey := strings.Replace(key, "_", "-", -1)
                if key != fixedKey </span><span class="cov8" title="1">{
                        fixKeys[key] = fixedKey
                }</span>
        }
        <span class="cov8" title="1">for oldKey, newKey := range fixKeys </span><span class="cov8" title="1">{
                oldKey = metaPrefix + oldKey
                newKey = metaPrefix + newKey
                req.Header.Set(newKey, req.Header.Get(oldKey))
                req.Header.Del(oldKey)
        }</span>
        <span class="cov8" title="1">return http.StatusOK, ""</span>
}

func handleObjDeleteHeaders(req *http.Request) (int, string) <span class="cov8" title="1">{
        if xda := req.Header.Get("X-Delete-At"); xda != "" </span><span class="cov8" title="1">{
                if deleteAfter, err := strconv.ParseInt(xda, 10, 64); err != nil </span><span class="cov8" title="1">{
                        return http.StatusBadRequest, "Non-integer X-Delete-At"
                }</span> else<span class="cov8" title="1"> if deleteAfter &lt; time.Now().Unix() </span><span class="cov8" title="1">{
                        return http.StatusBadRequest, "X-Delete-At in past"
                }</span>
        } else<span class="cov8" title="1"> if xda := req.Header.Get("X-Delete-After"); xda != "" </span><span class="cov8" title="1">{
                if deleteAfter, err := strconv.ParseInt(xda, 10, 64); err != nil </span><span class="cov8" title="1">{
                        return http.StatusBadRequest, "Non-integer X-Delete-After"
                }</span> else<span class="cov8" title="1"> if deleteAfter &lt; 0 </span><span class="cov8" title="1">{
                        return http.StatusBadRequest, "X-Delete-After in past"
                }</span> else<span class="cov8" title="1"> {
                        req.Header.Set("X-Delete-At", strconv.FormatInt(time.Now().Unix()+deleteAfter, 10))
                }</span>
        }
        <span class="cov8" title="1">return http.StatusOK, ""</span>
}

func CheckObjPost(req *http.Request, objectName string) (int, string) <span class="cov8" title="1">{
        if status, msg := handleObjDeleteHeaders(req); status != http.StatusOK </span><span class="cov8" title="1">{
                return status, msg
        }</span>
        <span class="cov8" title="1">return CheckMetadata(req, "Object")</span>
}

func CheckObjPut(req *http.Request, objectName string) (int, string) <span class="cov8" title="1">{
        if req.ContentLength &gt; MAX_FILE_SIZE </span><span class="cov8" title="1">{
                return http.StatusRequestEntityTooLarge, "Your request is too large."
        }</span>
        <span class="cov8" title="1">if req.Header.Get("X-Copy-From") != "" &amp;&amp; req.ContentLength != 0 </span><span class="cov8" title="1">{
                return http.StatusBadRequest, "Copy requests require a zero byte body"
        }</span>
        <span class="cov8" title="1">if req.Header.Get("Content-Length") == "" &amp;&amp; !StringInSlice("chunked", req.TransferEncoding) </span><span class="cov8" title="1">{
                return http.StatusLengthRequired, "Missing Content-Length header."
        }</span>
        <span class="cov8" title="1">if len(objectName) &gt; MAX_OBJECT_NAME_LENGTH </span><span class="cov8" title="1">{
                return http.StatusBadRequest, fmt.Sprintf("Object name length of %d longer than %d", len(objectName), MAX_OBJECT_NAME_LENGTH)
        }</span>
        <span class="cov8" title="1">if req.Header.Get("Content-Type") == "" </span><span class="cov8" title="1">{
                return http.StatusBadRequest, "No content type"
        }</span>
        <span class="cov8" title="1">if status, msg := handleObjDeleteHeaders(req); status != http.StatusOK </span><span class="cov8" title="1">{
                return status, msg
        }</span>
        <span class="cov8" title="1">if strings.Contains(req.Header.Get("Content-Type"), "\x00") </span><span class="cov0" title="0">{
                return http.StatusBadRequest, "Invalid Content-Type"
        }</span>
        <span class="cov8" title="1">return CheckMetadata(req, "Object")</span>
}

func CheckContainerPut(req *http.Request, containerName string) (int, string) <span class="cov8" title="1">{
        if len(containerName) &gt; MAX_CONTAINER_NAME_LENGTH </span><span class="cov8" title="1">{
                return http.StatusBadRequest, fmt.Sprintf("Container name length of %d longer than %d", len(containerName), MAX_CONTAINER_NAME_LENGTH)
        }</span>
        <span class="cov0" title="0">return CheckMetadata(req, "Container")</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">//  Copyright (c) 2018 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package common

import (
        "errors"
        "io"
        "io/ioutil"
        "net/http"
        "time"

        "github.com/troubling/nectar/nectarutil"
)

type expectReader struct {
        io.ReadCloser
        index  int
        cancel chan struct{}
        ready  chan int
}

// Read() proxies to the underlying ReadCloser, but notifies the ready channel on the first read.
// Also checks with the cancel channel for each read.
func (p *expectReader) Read(b []byte) (int, error) <span class="cov8" title="1">{
        if p.ready != nil </span><span class="cov8" title="1">{ // notify "ready" channel on first read
                select </span>{
                case &lt;-p.cancel:<span class="cov0" title="0">
                        return 0, errors.New("Request was cancelled")</span>
                case p.ready &lt;- p.index:<span class="cov8" title="1">
                        p.ready = nil</span>
                }
        }
        <span class="cov8" title="1">select </span>{ // check for cancellation, otherwise just proxy to underlying ReadCloser.
        case &lt;-p.cancel:<span class="cov0" title="0">
                return 0, errors.New("Request was cancelled")</span>
        default:<span class="cov8" title="1">
                return p.ReadCloser.Read(b)</span>
        }
}

type expectResponder struct {
        index int
        resp  *http.Response
}

// Expector helps organize a group of "Expect: 100-continue" requests.  It attempts to get all requests
// to a state where they've either given a non-100 response or they are ready to receive upload bodies.
type Expector struct {
        client        HTTPClient
        ready         chan int
        responded     chan expectResponder
        cancel        chan struct{}
        readyRequests []bool
        responses     []*http.Response
        closed        bool
}

// NewExpector returns an Expector object that uses the given http client.
func NewExpector(c HTTPClient) *Expector <span class="cov8" title="1">{
        e := &amp;Expector{
                client:    c,
                ready:     make(chan int),
                responded: make(chan expectResponder),
                cancel:    make(chan struct{}),
        }
        return e
}</span>

// AddRequest begins an http.Request and adds it to the set of requests being tracked by the Expector.
func (e *Expector) AddRequest(req *http.Request) <span class="cov8" title="1">{
        req.Header.Set("Expect", "100-Continue")
        e.readyRequests = append(e.readyRequests, false)
        e.responses = append(e.responses, nil)
        go func(i int, req *http.Request) </span><span class="cov8" title="1">{
                // replace the request's Body with one that we can notifies us on its first Read()
                req.Body = &amp;expectReader{index: i, cancel: e.cancel, ReadCloser: req.Body, ready: e.ready}
                resp, err := e.client.Do(req)
                if err != nil </span><span class="cov8" title="1">{
                        resp = nectarutil.ResponseStub(http.StatusServiceUnavailable, err.Error())
                }</span>
                <span class="cov8" title="1">select </span>{
                case &lt;-e.cancel:<span class="cov8" title="1">
                        resp.Body.Close()</span>
                case e.responded &lt;- expectResponder{i, resp}:</span><span class="cov8" title="1">
                }
        }(len(e.responses)-1, req)
}

// Wait waits up to timeout time for all of the Expector's requests to either be ready or have a response.
// It returns slices of responses (with nil responses for any requests that haven't received a response) and boolean "ready" states
// indicating if they are waiting to read from their Body.
func (e *Expector) Wait(timeout time.Duration) ([]*http.Response, []bool) <span class="cov8" title="1">{
        timer := time.After(timeout)
        for </span><span class="cov8" title="1">{
                // count requests that haven't reported ready or returned a response
                waitCount := 0
                for i := 0; i &lt; len(e.responses); i++ </span><span class="cov8" title="1">{
                        if e.readyRequests[i] == false &amp;&amp; e.responses[i] == nil </span><span class="cov8" title="1">{
                                waitCount++
                        }</span>
                }
                <span class="cov8" title="1">if waitCount &lt;= 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                // wait for any updates
                <span class="cov8" title="1">select </span>{
                case index := &lt;-e.ready:<span class="cov8" title="1">
                        e.readyRequests[index] = true</span>
                case resp := &lt;-e.responded:<span class="cov8" title="1">
                        e.responses[resp.index] = resp.resp</span>
                case &lt;-timer:<span class="cov0" title="0">
                        break</span>
                }
        }
        <span class="cov8" title="1">return e.responses, e.readyRequests</span>
}

// Successes waits up to timeout time for all of the Expector's requests to return a response,
// then returns the number of responses with status code matching okStatuses
// okStatuses of {2,404} means (r.StatusCode/100 == 2 || r.StatusCode == 404)
func (e *Expector) Successes(timeout time.Duration, okStatuses ...int) (count int) <span class="cov8" title="1">{
        timer := time.After(timeout)
        for </span><span class="cov8" title="1">{
                // count number of requests from which we're still waiting for responses
                waitCount := 0
                for i := 0; i &lt; len(e.responses); i++ </span><span class="cov8" title="1">{
                        if e.responses[i] == nil </span><span class="cov8" title="1">{
                                waitCount++
                        }</span>
                }
                <span class="cov8" title="1">if waitCount &lt;= 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                // wait for any updates
                <span class="cov8" title="1">select </span>{
                case index := &lt;-e.ready:<span class="cov8" title="1">
                        e.readyRequests[index] = true</span>
                case resp := &lt;-e.responded:<span class="cov8" title="1">
                        e.responses[resp.index] = resp.resp</span>
                case &lt;-timer:<span class="cov0" title="0">
                        break</span>
                }
        }
        // count the successes
        <span class="cov8" title="1">for _, r := range e.responses </span><span class="cov8" title="1">{
                if r != nil </span><span class="cov8" title="1">{
                        ok := false
                        for _, s := range okStatuses </span><span class="cov8" title="1">{
                                if s &lt; 100 </span><span class="cov8" title="1">{
                                        if r.StatusCode/100 == s </span><span class="cov8" title="1">{
                                                ok = true
                                        }</span>
                                } else<span class="cov8" title="1"> if r.StatusCode == s </span><span class="cov8" title="1">{
                                        ok = true
                                }</span>
                        }
                        <span class="cov8" title="1">if ok </span><span class="cov8" title="1">{
                                count++
                        }</span>
                }
        }
        <span class="cov8" title="1">return count</span>
}

// Closes responses bodies and attempts to cancel any outstanding requests by returning an error on read from their Body.
func (e *Expector) Close() <span class="cov8" title="1">{
        if !e.closed </span><span class="cov8" title="1">{
                for _, resp := range e.responses </span><span class="cov8" title="1">{
                        if resp != nil </span><span class="cov8" title="1">{
                                io.Copy(ioutil.Discard, resp.Body)
                                resp.Body.Close()
                        }</span>
                }
                <span class="cov8" title="1">close(e.cancel)
                e.closed = true</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package common

import (
        "sync/atomic"
        "unsafe"
)

type FreePool []*unsafe.Pointer

func (a FreePool) Get() interface{} <span class="cov8" title="1">{
        for _, p := range a </span><span class="cov8" title="1">{
                if v := atomic.SwapPointer(p, nil); v != nil </span><span class="cov8" title="1">{
                        return *(*interface{})(v)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (a FreePool) Put(v interface{}) <span class="cov8" title="1">{
        vp := unsafe.Pointer(&amp;v)
        for _, p := range a </span><span class="cov8" title="1">{
                if atomic.CompareAndSwapPointer(p, nil, vp) </span><span class="cov8" title="1">{
                        return
                }</span>
        }
}

func NewFreePool(size int) FreePool <span class="cov8" title="1">{
        a := make(FreePool, size)
        for i := range a </span><span class="cov8" title="1">{
                a[i] = new(unsafe.Pointer)
        }</span>
        <span class="cov8" title="1">return a</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

// +build linux

package fs

import (
        "errors"
        "fmt"
        "io/ioutil"
        "math/rand"
        "os"
        "path/filepath"
        "syscall"
        "unsafe"
)

/*
#include &lt;fcntl.h&gt;

#ifndef __O_TMPFILE
#define __O_TMPFILE        020000000
#endif
*/
import "C"

var (
        AT_FDCWD          = C.AT_FDCWD
        AT_SYMLINK_FOLLOW = C.AT_SYMLINK_FOLLOW
        O_TMPFILE         = C.__O_TMPFILE | syscall.O_DIRECTORY
        useOTempfile      = false
)

func init() <span class="cov8" title="1">{
        var buf syscall.Utsname
        var linuxMajorVersion = 0
        var linuxMinorVersion = 0
        if syscall.Uname(&amp;buf) == nil </span><span class="cov8" title="1">{
                var release string
                for _, c := range buf.Release </span><span class="cov8" title="1">{
                        if c == 0 </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">release += string(byte(c))</span>
                }
                <span class="cov8" title="1">if c, err := fmt.Sscanf(release, "%d.%d.", &amp;linuxMajorVersion, &amp;linuxMinorVersion); err != nil || c != 2 </span><span class="cov0" title="0">{
                        linuxMajorVersion = 0
                        linuxMinorVersion = 0
                }</span>
        }
        // Linux 3.15 is where XFS got O_TMPFILE support.
        <span class="cov8" title="1">useOTempfile = (linuxMajorVersion &gt; 3 || (linuxMajorVersion == 3 &amp;&amp; linuxMinorVersion &gt;= 15))</span>
}

func linkat(fd uintptr, dst string) error <span class="cov8" title="1">{
        prodFd := []byte(fmt.Sprintf("/proc/self/fd/%d\x00", fd))
        dstName := append([]byte(dst), 0)
        _, _, err := syscall.Syscall6(syscall.SYS_LINKAT,
                uintptr(AT_FDCWD), uintptr(unsafe.Pointer(&amp;prodFd[0])),
                uintptr(AT_FDCWD), uintptr(unsafe.Pointer(&amp;dstName[0])),
                uintptr(AT_SYMLINK_FOLLOW), 0)
        if err != 0 </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// TempFile implements an atomic file writer using linux's O_TMPFILE/linkat mechanism if available, otherwise by writing to a temp directory and renaming.
type TempFile struct {
        *os.File
        tempDir   string
        saved     bool
        otempfile bool
        synced    bool
}

// Abandon removes any resources associated with this file, if it hasn't already been saved.
func (o *TempFile) Abandon() error <span class="cov8" title="1">{
        if o.saved </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if !o.otempfile </span><span class="cov0" title="0">{
                os.Remove(o.Name())
        }</span>
        <span class="cov8" title="1">return o.File.Close()</span>
}

// Save atomically writes the file to its destination.
// You can also use Sync and Finalize instead of Save
func (o *TempFile) Save(dst string) error <span class="cov8" title="1">{
        if err := o.Sync(); err != nil </span><span class="cov0" title="0">{
                o.File.Close()
                return err
        }</span>
        <span class="cov8" title="1">return o.Finalize(dst)</span>
}

// sync file to disk
func (o *TempFile) Sync() error <span class="cov8" title="1">{
        if err := o.File.Sync(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">o.synced = true
        return nil</span>
}

// Finalize writes a synced file to its destination.
func (o *TempFile) Finalize(dst string) error <span class="cov8" title="1">{
        if !o.synced </span><span class="cov8" title="1">{
                return fmt.Errorf("must sync file first")
        }</span>
        <span class="cov8" title="1">defer o.File.Close()
        if o.otempfile </span><span class="cov8" title="1">{
                if err := linkat(o.File.Fd(), dst); err != nil </span><span class="cov8" title="1">{
                        if err := os.MkdirAll(o.tempDir, 0770); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">tmpLocation := filepath.Join(o.tempDir, fmt.Sprintf(".%016X", rand.Int63()))
                        if err := linkat(o.File.Fd(), tmpLocation); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if err := os.MkdirAll(filepath.Dir(dst), 0770); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">return os.Rename(tmpLocation, dst)</span>
                }
        } else<span class="cov0" title="0"> {
                if err := os.MkdirAll(filepath.Dir(dst), 0755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := os.Rename(o.File.Name(), dst); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">o.saved = true
        return nil</span>
}

// Preallocate pre-allocates space for the file.
func (o *TempFile) Preallocate(size int64, reserve int64) error <span class="cov8" title="1">{
        var st syscall.Statfs_t
        if reserve &gt; 0 </span><span class="cov0" title="0">{
                if err := syscall.Fstatfs(int(o.Fd()), &amp;st); err == nil </span><span class="cov0" title="0">{
                        freeSpace := int64(st.Frsize) * int64(st.Bavail)
                        if freeSpace-size &lt; reserve </span><span class="cov0" title="0">{
                                return errors.New("Not enough reserve space on disk.")
                        }</span>
                }
        }
        <span class="cov8" title="1">if size &gt; 0 </span><span class="cov8" title="1">{
                syscall.Fallocate(int(o.Fd()), 1, 0, size)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// NewAtomicFileWriter returns an AtomicFileWriter, which handles atomically writing files.
func NewAtomicFileWriter(tempDir string, dstDir string) (AtomicFileWriter, error) <span class="cov8" title="1">{
        if useOTempfile </span><span class="cov8" title="1">{
                if err := os.MkdirAll(dstDir, 0770); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">tempFile, err := os.OpenFile(dstDir, O_TMPFILE|os.O_RDWR, 0660)
                if err == nil </span><span class="cov8" title="1">{
                        return &amp;TempFile{File: tempFile, tempDir: tempDir, saved: false, otempfile: true}, nil
                }</span>
        }
        <span class="cov0" title="0">if err := os.MkdirAll(tempDir, 0770); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tempFile, err := ioutil.TempFile(tempDir, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;TempFile{File: tempFile, tempDir: tempDir, saved: false, otempfile: false}, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package fs

import (
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "syscall"
        "time"
)

// AtomicFileWriter saves a new file atomically.
type AtomicFileWriter interface {
        // Write writes the data to the underlying file.
        Write([]byte) (int, error)
        // Fd returns the file's underlying file descriptor.
        Fd() uintptr
        // Save atomically writes the file to its destination.
        Save(string) error
        // Abandon removes any resources associated with this file.
        Abandon() error
        // Preallocate pre-allocates space on disk, given the expected file size and disk reserve size.
        Preallocate(int64, int64) error
        // syncs file to disk (1st half of Save)
        Sync() error
        // links synced file to correct place in filesystem (2nd half of Save)
        Finalize(string) error
}

// LockPath locks a directory with a timeout.
func LockPath(directory string, timeout time.Duration) (*os.File, error) <span class="cov8" title="1">{
        file, err := os.Open(directory)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) &amp;&amp; os.MkdirAll(directory, 0755) == nil </span><span class="cov8" title="1">{
                        file, err = os.Open(directory)
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Unable to lock %s: %s", directory, err)
                }</span>
        }
        <span class="cov8" title="1">success := make(chan error)
        cancel := make(chan struct{})
        defer close(cancel)
        timer := time.NewTimer(timeout)
        defer timer.Stop()
        go func(fd int) </span><span class="cov8" title="1">{
                select </span>{
                case success &lt;- syscall.Flock(fd, syscall.LOCK_EX):</span><span class="cov8" title="1">
                case &lt;-cancel:</span><span class="cov8" title="1">
                }
        }(int(file.Fd()))
        <span class="cov8" title="1">select </span>{
        case err = &lt;-success:<span class="cov8" title="1">
                if err == nil </span><span class="cov8" title="1">{
                        return file, nil
                }</span>
        case &lt;-timer.C:<span class="cov8" title="1">
                err = fmt.Errorf("Flock timed out: %q: %s", directory, timeout)</span>
        }
        <span class="cov8" title="1">file.Close()
        return nil, err</span>
}

func IsMount(dir string) (bool, error) <span class="cov8" title="1">{
        dir = filepath.Clean(dir)
        if fileinfo, err := os.Stat(dir); err == nil </span><span class="cov8" title="1">{
                if parentinfo, err := os.Stat(filepath.Dir(dir)); err == nil </span><span class="cov8" title="1">{
                        return fileinfo.Sys().(*syscall.Stat_t).Dev != parentinfo.Sys().(*syscall.Stat_t).Dev, nil
                }</span> else<span class="cov0" title="0"> {
                        return false, fmt.Errorf("Unable to stat parent: %s", err)
                }</span>
        } else<span class="cov8" title="1"> {
                return false, fmt.Errorf("Unable to stat directory: %s", err)
        }</span>
}

func IsNotDir(err error) bool <span class="cov8" title="1">{
        if se, ok := err.(*os.SyscallError); ok </span><span class="cov8" title="1">{
                return se.Err == syscall.ENOTDIR || se.Err == syscall.EINVAL
        }</span>
        <span class="cov8" title="1">if se, ok := err.(*os.PathError); ok </span><span class="cov8" title="1">{
                return os.IsNotExist(se)
        }</span>
        <span class="cov0" title="0">return false</span>
}

func ReadDirNames(path string) ([]string, error) <span class="cov8" title="1">{
        f, err := os.Open(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">list, err := f.Readdirnames(-1)
        f.Close()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(list) &gt; 1 </span><span class="cov8" title="1">{
                sort.Strings(list)
        }</span>
        <span class="cov8" title="1">return list, nil</span>
}

func Exists(file string) bool <span class="cov8" title="1">{
        if _, err := os.Stat(file); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

func Inode(file string) (uint64, error) <span class="cov8" title="1">{
        fileinfo, err := os.Stat(file)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">stat, ok := fileinfo.Sys().(*syscall.Stat_t)
        if !ok </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Unable to cast stat object")
        }</span>
        <span class="cov8" title="1">return stat.Ino, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package fs

import "fmt"

// Setxattr sets xattrs for a file, given a file descriptor, attribute name, and value buffer.
func Setxattr(fileNameOrFd interface{}, attr string, value []byte) (int, error) <span class="cov8" title="1">{
        switch v := fileNameOrFd.(type) </span>{
        case string:<span class="cov8" title="1">
                return setxattr(v, attr, value)</span>
        case uintptr:<span class="cov8" title="1">
                return fsetxattr(v, attr, value)</span>
        case int:<span class="cov0" title="0">
                return fsetxattr(uintptr(v), attr, value)</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("Invalid fileNameOrFd: %T", fileNameOrFd)</span>
        }
}

// Getxattr gets xattrs from a file, given a filename(string) or file descriptor(uintptr), an attribute name, and value buffer to store it to.
func Getxattr(fileNameOrFd interface{}, attr string, value []byte) (int, error) <span class="cov8" title="1">{
        switch v := fileNameOrFd.(type) </span>{
        case string:<span class="cov8" title="1">
                return getxattr(v, attr, value)</span>
        case uintptr:<span class="cov8" title="1">
                return fgetxattr(v, attr, value)</span>
        case int:<span class="cov0" title="0">
                return fgetxattr(uintptr(v), attr, value)</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("Invalid fileNameOrFd: %T", fileNameOrFd)</span>
        }
}
</pre>
		
		<pre class="file" id="file22" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

// +build linux darwin

package fs

import (
        "syscall"
        "unsafe"
)

func fsetxattr(fd uintptr, attr string, value []byte) (int, error) <span class="cov8" title="1">{
        attrp, err := syscall.BytePtrFromString(attr)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">valuep := unsafe.Pointer(&amp;value[0])
        if r0, _, e1 := syscall.Syscall6(syscall.SYS_FSETXATTR, fd, uintptr(unsafe.Pointer(attrp)), uintptr(valuep), uintptr(len(value)), 0, 0); e1 == 0 </span><span class="cov8" title="1">{
                return int(r0), nil
        }</span> else<span class="cov0" title="0"> {
                return 0, e1
        }</span>
}

func setxattr(path string, attr string, value []byte) (int, error) <span class="cov8" title="1">{
        attrp, err := syscall.BytePtrFromString(attr)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">pathp, err := syscall.BytePtrFromString(path)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">valuep := unsafe.Pointer(&amp;value[0])
        if r0, _, e1 := syscall.Syscall6(syscall.SYS_SETXATTR, uintptr(unsafe.Pointer(pathp)), uintptr(unsafe.Pointer(attrp)), uintptr(valuep), uintptr(len(value)), 0, 0); e1 == 0 </span><span class="cov8" title="1">{
                return int(r0), nil
        }</span> else<span class="cov0" title="0"> {
                return 0, e1
        }</span>
}

func fgetxattr(fd uintptr, attr string, value []byte) (int, error) <span class="cov8" title="1">{
        attrp, err := syscall.BytePtrFromString(attr)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">var r0 uintptr
        var e1 syscall.Errno
        if len(value) == 0 </span><span class="cov8" title="1">{
                r0, _, e1 = syscall.Syscall6(syscall.SYS_FGETXATTR, fd, uintptr(unsafe.Pointer(attrp)), 0, 0, 0, 0)
        }</span> else<span class="cov8" title="1"> {
                valuep := unsafe.Pointer(&amp;value[0])
                r0, _, e1 = syscall.Syscall6(syscall.SYS_FGETXATTR, fd, uintptr(unsafe.Pointer(attrp)), uintptr(valuep), uintptr(len(value)), 0, 0)
        }</span>
        <span class="cov8" title="1">if e1 == 0 </span><span class="cov8" title="1">{
                return int(r0), nil
        }</span> else<span class="cov8" title="1"> {
                return 0, e1
        }</span>
}

func getxattr(path string, attr string, value []byte) (int, error) <span class="cov8" title="1">{
        attrp, err := syscall.BytePtrFromString(attr)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">pathp, err := syscall.BytePtrFromString(path)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">var r0 uintptr
        var e1 syscall.Errno
        if len(value) == 0 </span><span class="cov8" title="1">{
                r0, _, e1 = syscall.Syscall6(syscall.SYS_GETXATTR, uintptr(unsafe.Pointer(pathp)), uintptr(unsafe.Pointer(attrp)), 0, 0, 0, 0)
        }</span> else<span class="cov8" title="1"> {
                valuep := unsafe.Pointer(&amp;value[0])
                r0, _, e1 = syscall.Syscall6(syscall.SYS_GETXATTR, uintptr(unsafe.Pointer(pathp)), uintptr(unsafe.Pointer(attrp)), uintptr(valuep), uintptr(len(value)), 0, 0)
        }</span>
        <span class="cov8" title="1">if e1 == 0 </span><span class="cov8" title="1">{
                return int(r0), nil
        }</span> else<span class="cov8" title="1"> {
                return 0, e1
        }</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// TODO: Some of this code was pulled from the go stdlib and modified. figure out how to attribute this.
// https://wiki.openstack.org/wiki/LegalIssuesFAQ#Incorporating_BSD.2FMIT_Licensed_Code

package common

import (
        "bytes"
        "crypto/rand"
        "errors"
        "fmt"
        "io"
)

// MultiWriter is a streaming multipart writer, similar to the standard library's multipart.Writer, but
// compatible with Swift's output and with an API geared toward our common use, multi-range responses.
type MultiWriter struct {
        w              io.Writer
        boundary       string
        lastpart       *part
        contentType    string
        contentLength  int64
        lengthEstimate int64
}

// NewMultiWriter instantiates a new MultiWriter.
func NewMultiWriter(w io.Writer, contentType string, contentLength int64) *MultiWriter <span class="cov8" title="1">{
        var buf [32]byte
        _, err := io.ReadFull(rand.Reader, buf[:])
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return &amp;MultiWriter{
                w:              w,
                boundary:       fmt.Sprintf("%064x", buf[:]),
                contentType:    contentType,
                contentLength:  contentLength,
                lengthEstimate: int64(68), // length of --boundary--
        }</span>
}

// Expect adds an expected part to the Content-Length estimate for the multipart body.
func (w *MultiWriter) Expect(start, end int64) <span class="cov8" title="1">{
        w.lengthEstimate += int64(len(fmt.Sprintf("--%s\r\nContent-Type: %s\r\nContent-Range: bytes %d-%d/%d\r\n\r\n",
                w.boundary, w.contentType, start, end-1, w.contentLength)))
        w.lengthEstimate += (end - start) + 2 // part data and trailing \r\n
}</span>

// ContentLength returns the expected Content-Length of the multipart body.
func (w *MultiWriter) ContentLength() int64 <span class="cov8" title="1">{
        return w.lengthEstimate
}</span>

// Boundary returns the MultiWriter's boundary string.
func (w *MultiWriter) Boundary() string <span class="cov8" title="1">{
        return w.boundary
}</span>

// CreatePart begins a new part in the multi-part response, with the given content ranges.
func (w *MultiWriter) CreatePart(start, end int64) (io.Writer, error) <span class="cov8" title="1">{
        if w.lastpart != nil </span><span class="cov8" title="1">{
                if err := w.lastpart.close(); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">b := &amp;bytes.Buffer{}
        if w.lastpart != nil </span><span class="cov8" title="1">{
                fmt.Fprintf(b, "\r\n")
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(b, "--%s\r\nContent-Type: %s\r\nContent-Range: bytes %d-%d/%d\r\n\r\n",
                w.boundary, w.contentType, start, end-1, w.contentLength)
        _, err := io.Copy(w.w, b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">p := &amp;part{
                mw: w,
        }
        w.lastpart = p
        return p, nil</span>
}

// Close finalizes the output of the MultiWriter.
func (w *MultiWriter) Close() error <span class="cov8" title="1">{
        if w.lastpart != nil </span><span class="cov8" title="1">{
                if err := w.lastpart.close(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">w.lastpart = nil</span>
        }
        <span class="cov8" title="1">_, err := fmt.Fprintf(w.w, "\r\n--%s--", w.boundary)
        return err</span>
}

type part struct {
        mw     *MultiWriter
        closed bool
        we     error
}

func (p *part) close() error <span class="cov8" title="1">{
        p.closed = true
        return p.we
}</span>

func (p *part) Write(d []byte) (n int, err error) <span class="cov8" title="1">{
        if p.closed </span><span class="cov8" title="1">{
                return 0, errors.New("multipart: can't write to finished part")
        }</span>
        <span class="cov8" title="1">n, err = p.mw.w.Write(d)
        if err != nil </span><span class="cov8" title="1">{
                p.we = err
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package pickle

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "math"
        "reflect"
)

func picklestring(val string, buf *bytes.Buffer, scratch []byte) <span class="cov8" title="1">{
        length := len(val)
        if length &lt; 256 </span><span class="cov8" title="1">{
                buf.WriteByte('U') // SHORT_BINSTRING
                buf.WriteByte(byte(length))
                buf.WriteString(val)
        }</span> else<span class="cov8" title="1"> {
                scratch[0] = 'T' // BINSTRING
                binary.LittleEndian.PutUint32(scratch[1:5], uint32(length))
                buf.Write(scratch[0:5])
                buf.WriteString(val)
        }</span>
}

func pickleint(val int64, buf *bytes.Buffer, scratch []byte) <span class="cov8" title="1">{
        if int64(uint8(val)) == val </span><span class="cov8" title="1">{
                buf.WriteByte('K') // BININT1
                buf.WriteByte(byte(val))
        }</span> else<span class="cov8" title="1"> if int64(uint16(val)) == val </span><span class="cov8" title="1">{
                scratch[0] = 'M' // BININT2
                binary.LittleEndian.PutUint16(scratch[1:3], uint16(val))
                buf.Write(scratch[0:3])
        }</span> else<span class="cov8" title="1"> if int64(int32(val)) == val </span><span class="cov8" title="1">{
                scratch[0] = 'J' // BININT
                binary.LittleEndian.PutUint32(scratch[1:5], uint32(val))
                buf.Write(scratch[0:5])
        }</span> else<span class="cov8" title="1"> {
                scratch[0] = '\x8a' // LONG1
                scratch[1] = 8      // 8 bytes
                binary.LittleEndian.PutUint64(scratch[2:10], uint64(val))
                buf.Write(scratch[0:10])
        }</span>
}

func picklearray(typ interface{}, data interface{}, buf *bytes.Buffer, scratch []byte) error <span class="cov8" title="1">{
        buf.WriteString("carray\narray\n(") // GLOBAL array.array, MARK
        switch typ </span>{
        case "H":<span class="cov8" title="1">
                newdata := make([]uint16, 0)
                if err := unpack(reflect.ValueOf(&amp;data), reflect.ValueOf(&amp;newdata)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">buf.WriteString("U\x01HT") // SHORT_BINSTRING "H", begin BINSTRING
                binary.Write(buf, binary.LittleEndian, uint32(len(newdata)*2))
                binary.Write(buf, binary.LittleEndian, newdata)</span>
        case "B":<span class="cov8" title="1">
                newdata := make([]byte, 0)
                if err := unpack(reflect.ValueOf(&amp;data), reflect.ValueOf(&amp;newdata)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">buf.WriteString("U\x01BT") // SHORT_BINSTRING "B", begin BINSTRING
                binary.Write(buf, binary.LittleEndian, uint32(len(newdata)))
                binary.Write(buf, binary.LittleEndian, newdata)</span>
        default:<span class="cov0" title="0">
                if err := pickleobj(typ, buf, scratch); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := pickleobj(data, buf, scratch); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">buf.WriteString("tR") // TUPLE, REDUCE
        return nil</span>
}

func pickleobj(o interface{}, buf *bytes.Buffer, scratch []byte) error <span class="cov8" title="1">{
        v := reflect.ValueOf(o)
        switch v.Kind() </span>{
        case reflect.Ptr, reflect.Interface:<span class="cov8" title="1">
                if v.IsNil() </span><span class="cov8" title="1">{
                        buf.WriteByte('N') // NONE
                }</span> else<span class="cov8" title="1"> {
                        return pickleobj(v.Elem().Interface(), buf, scratch)
                }</span>
        case reflect.Invalid:<span class="cov8" title="1">
                buf.WriteByte('N')</span> // NONE
        case reflect.Bool:<span class="cov8" title="1">
                if v.Bool() </span><span class="cov8" title="1">{
                        buf.WriteByte('\x88') // NEWTRUE
                }</span> else<span class="cov8" title="1"> {
                        buf.WriteByte('\x89') // NEWFALSE
                }</span>
        case reflect.String:<span class="cov8" title="1">
                picklestring(v.String(), buf, scratch)</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                pickleint(v.Int(), buf, scratch)</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<span class="cov8" title="1">
                pickleint(int64(v.Uint()), buf, scratch)</span>
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                scratch[0] = 'G' // BINFLOAT
                bits := math.Float64bits(v.Float())
                binary.BigEndian.PutUint64(scratch[1:9], bits)
                buf.Write(scratch[0:9])</span>
        case reflect.Slice, reflect.Array:<span class="cov8" title="1">
                buf.WriteByte('(') // MARK
                for i := 0; i &lt; v.Len(); i++ </span><span class="cov8" title="1">{
                        if err := pickleobj(v.Index(i).Interface(), buf, scratch); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">buf.WriteByte('l')</span> // LIST
        case reflect.Map:<span class="cov8" title="1">
                buf.WriteByte('(') // MARK
                // Using "range" is way faster than iterating over maps with reflection,
                // but it's verbose and has to be a type we know ahead of time.
                switch o := o.(type) </span>{
                case map[string]string:<span class="cov8" title="1">
                        for k, v := range o </span><span class="cov8" title="1">{
                                picklestring(k, buf, scratch)
                                picklestring(v, buf, scratch)
                        }</span>
                case map[string]interface{}:<span class="cov8" title="1">
                        for k, v := range o </span><span class="cov8" title="1">{
                                picklestring(k, buf, scratch)
                                if err := pickleobj(v, buf, scratch); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                case map[interface{}]interface{}:<span class="cov8" title="1">
                        for k, v := range o </span><span class="cov8" title="1">{
                                if err := pickleobj(k, buf, scratch); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">if err := pickleobj(v, buf, scratch); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                default:<span class="cov8" title="1">
                        for _, k := range v.MapKeys() </span><span class="cov8" title="1">{
                                if err := pickleobj(k.Interface(), buf, scratch); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">if err := pickleobj(v.MapIndex(k).Interface(), buf, scratch); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
                <span class="cov8" title="1">buf.WriteByte('d')</span> // DICT
        case reflect.Struct:<span class="cov8" title="1">
                switch o := o.(type) </span>{
                case PickleTuple:<span class="cov8" title="1">
                        buf.WriteByte('(') // MARK
                        for _, to := range []interface{}{o.A, o.B, o.C, o.D}[:o.Len] </span><span class="cov8" title="1">{
                                if err := pickleobj(to, buf, scratch); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">buf.WriteByte('t')</span> // TUPLE
                case PickleArray:<span class="cov8" title="1">
                        return picklearray(o.Type, o.Data, buf, scratch)</span>
                default:<span class="cov8" title="1"> // why not serialize arbitrary structs as dicts while we're here
                        if v.NumField() == 2 &amp;&amp; v.Type().Field(0).Name == "ArrayType" </span><span class="cov8" title="1">{
                                return picklearray(v.Field(0).Interface(), v.Field(1).Interface(), buf, scratch)
                        }</span>
                        <span class="cov8" title="1">buf.WriteByte('(') // MARK
                        for i := 0; i &lt; v.Type().NumField(); i++ </span><span class="cov8" title="1">{
                                if !v.Field(i).CanInterface() </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">field := v.Type().Field(i)
                                if tag := field.Tag.Get("pickle"); tag != "" </span><span class="cov8" title="1">{
                                        picklestring(tag, buf, scratch)
                                }</span> else<span class="cov8" title="1"> {
                                        picklestring(v.Type().Field(i).Name, buf, scratch)
                                }</span>
                                <span class="cov8" title="1">if err := pickleobj(v.Field(i).Interface(), buf, scratch); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">buf.WriteByte('d')</span> // DICT
                }
        default:<span class="cov8" title="1">
                return fmt.Errorf("Unknown object type in pickle: %s", v.Kind())</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func PickleDumps(o interface{}) []byte <span class="cov8" title="1">{
        buf := &amp;bytes.Buffer{}
        buf.WriteByte('\x80') // PROTO
        buf.WriteByte(2)      // Protocol 2
        scratch := make([]byte, 10)
        if err := pickleobj(o, buf, scratch); err != nil </span><span class="cov8" title="1">{
                panic(err.Error())</span>
        }
        <span class="cov8" title="1">buf.WriteByte('.')
        return buf.Bytes()</span>
}

func Marshal(v interface{}) ([]byte, error) <span class="cov0" title="0">{
        buf := &amp;bytes.Buffer{}
        buf.WriteByte('\x80') // PROTO
        buf.WriteByte(2)      // Protocol 2
        scratch := make([]byte, 10)
        if err := pickleobj(v, buf, scratch); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">buf.WriteByte('.')
        return buf.Bytes(), nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package pickle

import (
        "fmt"
        "reflect"
)

func unpack(src reflect.Value, dst reflect.Value) error <span class="cov8" title="1">{
        for src.Kind() == reflect.Ptr || src.Kind() == reflect.Interface </span><span class="cov8" title="1">{
                if src.IsNil() </span><span class="cov8" title="1">{
                        dst.Set(dst)
                        return nil
                }</span>
                <span class="cov8" title="1">src = src.Elem()</span>
        }
        <span class="cov8" title="1">for dst.Kind() == reflect.Ptr || dst.Kind() == reflect.Interface </span><span class="cov8" title="1">{
                if dst.IsNil() </span><span class="cov8" title="1">{
                        dst.Set(reflect.New(dst.Type().Elem()))
                }</span>
                <span class="cov8" title="1">dst = dst.Elem()</span>
        }
        <span class="cov8" title="1">if src.Type().ConvertibleTo(dst.Type()) </span><span class="cov8" title="1">{
                dst.Set(src.Convert(dst.Type()))
                return nil
        }</span>
        <span class="cov8" title="1">switch dst.Kind() </span>{
        case reflect.Bool:<span class="cov8" title="1">
                dst.SetBool(src.Interface() != reflect.Zero(src.Type()).Interface())
                return nil</span>
        case reflect.Slice:<span class="cov8" title="1">
                if k := src.Kind(); k != reflect.Slice &amp;&amp; k != reflect.Array </span><span class="cov0" title="0">{
                        return fmt.Errorf("Unable to assign slice from non-slice: %s", src.Kind())
                }</span>
                <span class="cov8" title="1">dst.Set(reflect.MakeSlice(dst.Type(), src.Len(), src.Len()))
                for i := 0; i &lt; src.Len(); i++ </span><span class="cov8" title="1">{
                        if err := unpack(src.Index(i), dst.Index(i)); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        case reflect.Map:<span class="cov8" title="1">
                if src.Kind() != reflect.Map </span><span class="cov0" title="0">{
                        return fmt.Errorf("Unable to assign map from non-map: %s", src.Kind())
                }</span>
                <span class="cov8" title="1">dst.Set(reflect.MakeMap(dst.Type()))
                nk := reflect.New(dst.Type().Key())
                nv := reflect.New(dst.Type().Elem())
                for _, k := range src.MapKeys() </span><span class="cov8" title="1">{
                        if err := unpack(k, nk); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if err := unpack(src.MapIndex(k), nv); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">dst.SetMapIndex(nk.Elem(), nv.Elem())</span>
                }
        case reflect.Struct:<span class="cov8" title="1">
                if src.Type() == reflect.TypeOf(PickleArray{}) &amp;&amp; dst.NumField() == 2 &amp;&amp; dst.Type().Field(0).Name == "ArrayType" </span><span class="cov8" title="1">{
                        if err := unpack(src.Field(0), dst.Field(0)); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">return unpack(src.Field(1), dst.Field(1))</span>
                }
                <span class="cov8" title="1">for _, k := range src.MapKeys() </span><span class="cov8" title="1">{
                        for k.Kind() == reflect.Ptr || k.Kind() == reflect.Interface </span><span class="cov8" title="1">{
                                k = k.Elem()
                        }</span>
                        <span class="cov8" title="1">for i := 0; i &lt; dst.NumField(); i++ </span><span class="cov8" title="1">{
                                if f := dst.Type().Field(i); f.Name == k.String() || f.Tag.Get("pickle") == k.String() </span><span class="cov8" title="1">{
                                        if err := unpack(src.MapIndex(k), dst.Field(i)); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }
                        }
                }
        default:<span class="cov0" title="0">
                return fmt.Errorf("Assign to unknown type: %s", dst.Kind())</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Unmarshal parses the pickled data and stores the result in the value pointed to by v.
// Unmarshal is considerably less performant than PickleLoads, so think twice before using it in performance-sensitive code.
func Unmarshal(data []byte, v interface{}) error <span class="cov8" title="1">{
        src, err := PickleLoads(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return unpack(reflect.ValueOf(src), reflect.ValueOf(v))</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package pickle

import (
        "bytes"
        "encoding/binary"
        "errors"
        "fmt"
        "io"
        "math"
        "strconv"
)

var markster = "HI, I'M MARK!"
var mark = interface{}(&amp;markster)

type PickleTuple struct {
        Len int
        A   interface{}
        B   interface{}
        C   interface{}
        D   interface{}
}

type PickleArray struct {
        Type string
        Data []interface{}
}

type unpickleState struct {
        stack      []interface{}
        top        int
        data       []byte
        dataOffset int
        memoKey    []int
        memoVal    []interface{}
}

type pickleGlobal struct {
        name string
}

func (s *unpickleState) push(item interface{}) <span class="cov8" title="1">{
        if len(s.stack) &lt; s.top+1 </span><span class="cov8" title="1">{
                s.stack = append(s.stack, item)
        }</span> else<span class="cov8" title="1"> {
                s.stack[s.top] = item
        }</span>
        <span class="cov8" title="1">s.top++</span>
}

func (s *unpickleState) pop() (interface{}, error) <span class="cov8" title="1">{
        if s.top &lt;= 0 </span><span class="cov8" title="1">{
                return nil, errors.New("empty stack")
        }</span>
        <span class="cov8" title="1">s.top -= 1
        return s.stack[s.top], nil</span>
}

func (s *unpickleState) peek() (interface{}, error) <span class="cov8" title="1">{
        if s.top &lt;= 0 </span><span class="cov8" title="1">{
                return nil, errors.New("empty stack")
        }</span>
        <span class="cov8" title="1">return s.stack[s.top-1], nil</span>
}

func (s *unpickleState) setMark() <span class="cov8" title="1">{
        s.push(mark)
}</span>

func (s *unpickleState) mark() ([]interface{}, error) <span class="cov8" title="1">{
        start := s.top
        for s.top &gt; 0 &amp;&amp; s.stack[s.top-1] != mark </span><span class="cov8" title="1">{
                s.top--
        }</span>
        <span class="cov8" title="1">if s.top == 0 </span><span class="cov8" title="1">{
                return make([]interface{}, 0), errors.New("unable to find mark")
        }</span>
        <span class="cov8" title="1">s.top--
        return s.stack[s.top+1 : start], nil</span>
}

func (s *unpickleState) readByte() (byte, error) <span class="cov8" title="1">{
        if s.dataOffset &gt;= len(s.data) </span><span class="cov8" title="1">{
                return 0, io.EOF
        }</span>
        <span class="cov8" title="1">c := s.data[s.dataOffset]
        s.dataOffset++
        return c, nil</span>
}

func (s *unpickleState) readBytes(length int) ([]byte, error) <span class="cov8" title="1">{
        if len(s.data)-s.dataOffset &lt; length </span><span class="cov8" title="1">{
                return nil, io.EOF
        }</span>
        <span class="cov8" title="1">retval := s.data[s.dataOffset : s.dataOffset+length]
        s.dataOffset += length
        return retval, nil</span>
}

func (s *unpickleState) readString(delim byte) (string, error) <span class="cov8" title="1">{
        offset := bytes.IndexByte(s.data[s.dataOffset:], delim)
        if offset == -1 </span><span class="cov8" title="1">{
                return "", io.EOF
        }</span>
        <span class="cov8" title="1">retval := string(s.data[s.dataOffset : s.dataOffset+offset])
        s.dataOffset += offset + 1
        return retval, nil</span>
}

func (s *unpickleState) readFloat64() (float64, error) <span class="cov8" title="1">{
        if len(s.data)-s.dataOffset &lt; 8 </span><span class="cov8" title="1">{
                return 0, io.EOF
        }</span>
        <span class="cov8" title="1">v := binary.BigEndian.Uint64(s.data[s.dataOffset : s.dataOffset+8])
        s.dataOffset += 8
        return math.Float64frombits(v), nil</span>
}

func (s *unpickleState) readUint64() (uint64, error) <span class="cov0" title="0">{
        if len(s.data)-s.dataOffset &lt; 8 </span><span class="cov0" title="0">{
                return 0, io.EOF
        }</span>
        <span class="cov0" title="0">v := binary.LittleEndian.Uint64(s.data[s.dataOffset : s.dataOffset+8])
        s.dataOffset += 8
        return v, nil</span>
}

func (s *unpickleState) readUint32() (uint32, error) <span class="cov8" title="1">{
        if len(s.data)-s.dataOffset &lt; 4 </span><span class="cov8" title="1">{
                return 0, io.EOF
        }</span>
        <span class="cov8" title="1">v := binary.LittleEndian.Uint32(s.data[s.dataOffset : s.dataOffset+4])
        s.dataOffset += 4
        return v, nil</span>
}

func (s *unpickleState) readUint16() (uint16, error) <span class="cov8" title="1">{
        if len(s.data)-s.dataOffset &lt; 2 </span><span class="cov8" title="1">{
                return 0, io.EOF
        }</span>
        <span class="cov8" title="1">v := binary.LittleEndian.Uint16(s.data[s.dataOffset : s.dataOffset+2])
        s.dataOffset += 2
        return v, nil</span>
}

func (s *unpickleState) getMemo(m int) interface{} <span class="cov8" title="1">{
        for i, key := range s.memoKey </span><span class="cov8" title="1">{
                if key == m </span><span class="cov8" title="1">{
                        return s.memoVal[i]
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *unpickleState) setMemo(i int, v interface{}) <span class="cov8" title="1">{
        s.memoKey = append(s.memoKey, i)
        s.memoVal = append(s.memoVal, v)
}</span>

func newState(initialSize int, data []byte) *unpickleState <span class="cov8" title="1">{
        return &amp;unpickleState{stack: make([]interface{}, initialSize), top: 0, data: data, dataOffset: 0}
}</span>

func loadBinaryArray(typ string, data string) ([]interface{}, error) <span class="cov8" title="1">{
        dat := []byte(data)
        switch typ </span>{
        case "H":<span class="cov8" title="1">
                if len(dat)%2 != 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Pickle data not a multiple of type size: %d%%2 != 0", len(dat))
                }</span>
                <span class="cov8" title="1">newdata := make([]interface{}, len(dat)/2)
                for i := 0; i &lt; len(dat); i += 2 </span><span class="cov8" title="1">{
                        newdata[i/2] = int64(binary.LittleEndian.Uint16(dat[i : i+2]))
                }</span>
                <span class="cov8" title="1">return newdata, nil</span>
        case "B":<span class="cov8" title="1">
                newdata := make([]interface{}, len(dat))
                for i, b := range dat </span><span class="cov8" title="1">{
                        newdata[i] = int64(b)
                }</span>
                <span class="cov8" title="1">return newdata, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("Loading pickle of unknown type: %s", typ)</span>
        }
}

// attempt to convert python string representations to golang string
// basically this should return the same thing as eval(src) in python.
func pythonString(src string) (string, error) <span class="cov8" title="1">{
        origSrc := src
        if len(src) &lt; 2 || src[0] != src[len(src)-1] || (src[0] != '\'' &amp;&amp; src[0] != '"') </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid syntax: %q", src)
        }</span>
        <span class="cov8" title="1">quote := src[0]
        src = src[1 : len(src)-1]
        dst := []byte{'"'}
        backslashes := 0
        for _, c := range []byte(src) </span><span class="cov8" title="1">{
                switch c </span>{
                case '\\':<span class="cov8" title="1">
                        backslashes++
                        continue</span>
                case '"':<span class="cov8" title="1">
                        if quote == '\'' &amp;&amp; backslashes%2 == 0 </span><span class="cov8" title="1">{
                                backslashes++
                        }</span>
                case '\'':<span class="cov8" title="1">
                        if backslashes%2 == 1 </span><span class="cov8" title="1">{
                                backslashes--
                        }</span> else<span class="cov8" title="1"> if quote == '\'' </span><span class="cov8" title="1">{
                                return "", fmt.Errorf("invalid syntax: %q", origSrc)
                        }</span>
                }
                <span class="cov8" title="1">for ; backslashes &gt; 0; backslashes-- </span><span class="cov8" title="1">{
                        dst = append(dst, '\\')
                }</span>
                <span class="cov8" title="1">dst = append(dst, c)</span>
        }
        <span class="cov8" title="1">for ; backslashes &gt; 0; backslashes-- </span><span class="cov8" title="1">{
                dst = append(dst, '\\')
        }</span>
        <span class="cov8" title="1">dst = append(dst, '"')
        return strconv.Unquote(string(dst))</span>
}

func mapKey(i interface{}) (interface{}, error) <span class="cov8" title="1">{
        switch i := i.(type) </span>{
        case string, uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64:<span class="cov8" title="1">
                return i, nil</span>
        case []interface{}:<span class="cov8" title="1">
                pt := PickleTuple{Len: len(i)}
                at := []*interface{}{&amp;pt.A, &amp;pt.B, &amp;pt.C, &amp;pt.D}
                for j, v := range i </span><span class="cov8" title="1">{
                        switch v.(type) </span>{
                        case string, uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64:<span class="cov8" title="1">
                                *at[j] = v</span>
                        default:<span class="cov0" title="0">
                                return nil, fmt.Errorf("Unhashable tuple entry: %T", v)</span>
                        }
                }
                <span class="cov8" title="1">return pt, nil</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("Invalid map key type: %T", i)</span>
        }
}

func PickleLoads(data []byte) (interface{}, error) <span class="cov8" title="1">{
        state := newState(16, data)
        for op, err := state.readByte(); err == nil; op, err = state.readByte() </span><span class="cov8" title="1">{
                switch op </span>{
                case '\x80':<span class="cov8" title="1"> // PROTO
                        state.readByte()</span>
                case '(':<span class="cov8" title="1"> // MARK
                        state.setMark()</span>
                case '.':<span class="cov8" title="1"> // STOP
                        top, err := state.pop()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (STOP): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">return top, nil</span>
                case '0':<span class="cov8" title="1"> // POP
                        if _, err := state.pop(); err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (POP): " + err.Error())
                        }</span>
                case '1':<span class="cov8" title="1"> // POP_MARK
                        _, err := state.mark()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.New("Invalid pickle (SETITEMS): unable to find mark")
                        }</span>
                case '2':<span class="cov8" title="1"> // DUP
                        top, err := state.peek()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (POP): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(top)</span>
                case '\x88':<span class="cov8" title="1"> // NEWTRUE
                        state.push(true)</span>
                case '\x89':<span class="cov8" title="1"> // NEWFALSE
                        state.push(false)</span>
                case 'N':<span class="cov8" title="1"> // NONE
                        state.push(nil)</span>

                case 'S', 'V':<span class="cov8" title="1"> // STRING, UNICODE
                        val, err := state.readString('\n')
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (STRING): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">str, err := pythonString(val)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Unable to interpret Python string (STRING): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(str)</span>
                case 'U':<span class="cov8" title="1"> //SHORT_BINSTRING
                        length, err := state.readByte()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (SHORT_BINSTRING): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">str, err := state.readBytes(int(length))
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (SHORT_BINSTRING): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(string(str))</span>
                case 'T', 'X':<span class="cov8" title="1"> // BINUNICODE, BINSTRING
                        length, err := state.readUint32()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (BINSTRING): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">str, err := state.readBytes(int(length))
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (BINSTRING): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(string(str))</span>

                case 's':<span class="cov8" title="1"> // SETITEM
                        val, err1 := state.pop()
                        key, err2 := state.pop()
                        if err1 != nil || err2 != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (SETITEM): stack empty")
                        }</span>
                        <span class="cov8" title="1">if key, err = mapKey(key); err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (SETITEM): invalid key type")
                        }</span>
                        <span class="cov8" title="1">top, err := state.peek()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.New("Invalid pickle (SETITEM): stack empty")
                        }</span>
                        <span class="cov8" title="1">d, ok := top.(map[interface{}]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                return nil, errors.New("Incomplete pickle (SETITEM): stack top isn't a map")
                        }</span>
                        <span class="cov8" title="1">d[key] = val</span>
                case 'u':<span class="cov8" title="1"> // SETITEMS
                        vals, err := state.mark()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (SETITEMS): unable to find mark")
                        }</span>
                        <span class="cov8" title="1">if len(vals)%2 != 0 </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (SETITEMS): odd numbered mark")
                        }</span>
                        <span class="cov8" title="1">top, err := state.peek()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.New("Invalid pickle (SETITEMS): stack empty")
                        }</span>
                        <span class="cov8" title="1">dict, ok := top.(map[interface{}]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                return nil, errors.New("Incomplete pickle (SETITEMS): stack top isn't a map")
                        }</span>
                        <span class="cov8" title="1">for j := 0; j &lt; len(vals); j += 2 </span><span class="cov8" title="1">{
                                if key, err := mapKey(vals[j]); err != nil </span><span class="cov8" title="1">{
                                        return nil, errors.New("Invalid pickle (SETITEMS): invalid key type")
                                }</span> else<span class="cov8" title="1"> {
                                        dict[key] = vals[j+1]
                                }</span>
                        }

                case '}':<span class="cov8" title="1"> // EMPTY_DICT
                        state.push(make(map[interface{}]interface{}, 5))</span>
                case 'd':<span class="cov8" title="1"> // DICT
                        vals, err := state.mark()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.New("Invalid pickle (DICT): unable to find mark")
                        }</span>
                        <span class="cov8" title="1">if len(vals)%2 != 0 </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (DICT): odd numbered mark")
                        }</span>
                        <span class="cov8" title="1">dict := make(map[interface{}]interface{}, len(vals)/2)
                        for j := 0; j &lt; len(vals); j += 2 </span><span class="cov8" title="1">{
                                if key, err := mapKey(vals[j]); err != nil </span><span class="cov0" title="0">{
                                        return nil, errors.New("Invalid pickle (DICT): invalid key type")
                                }</span> else<span class="cov8" title="1"> {
                                        dict[key] = vals[j+1]
                                }</span>
                        }
                        <span class="cov8" title="1">state.push(dict)</span>
                case ']', ')':<span class="cov8" title="1"> // EMPTY_LIST, EMPTY_TUPLE
                        state.push(make([]interface{}, 0))</span>
                case 'l', 't':<span class="cov8" title="1"> // LIST, TUPLE
                        markState, err := state.mark()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (LIST, TUPLE): unable to find mark")
                        }</span>
                        <span class="cov8" title="1">newList := make([]interface{}, len(markState))
                        copy(newList, markState)
                        state.push(newList)</span>
                case 'a':<span class="cov8" title="1"> // APPEND
                        value, err1 := state.pop()
                        list, err2 := state.pop()
                        if err1 != nil || err2 != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (APPEND): stack empty")
                        }</span>
                        <span class="cov8" title="1">if list, ok := list.([]interface{}); !ok </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (APPEND): stack top not list")
                        }</span> else<span class="cov8" title="1"> {
                                state.push(append(list, value))
                        }</span>
                case 'e':<span class="cov8" title="1"> // APPENDS
                        items, err := state.mark()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (APPENDS): unable to find mark")
                        }</span>
                        <span class="cov8" title="1">top, err := state.pop()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.New("Invalid pickle (APPENDS): stack empty")
                        }</span>
                        <span class="cov8" title="1">l, ok := top.([]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                return nil, errors.New("Incomplete pickle (APPENDS): stack top isn't a list")
                        }</span>
                        <span class="cov8" title="1">state.push(append(l, items...))</span>
                case '\x85':<span class="cov8" title="1"> // TUPLE1
                        top, err := state.pop()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (TUPLE1): stack empty")
                        }</span>
                        <span class="cov8" title="1">state.push([]interface{}{top})</span>
                case '\x86':<span class="cov8" title="1"> // TUPLE2
                        a, err1 := state.pop()
                        b, err2 := state.pop()
                        if err1 != nil || err2 != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (TUPLE2): stack empty")
                        }</span>
                        <span class="cov8" title="1">state.push([]interface{}{b, a})</span>
                case '\x87':<span class="cov8" title="1"> // TUPLE3
                        a, err1 := state.pop()
                        b, err2 := state.pop()
                        c, err3 := state.pop()
                        if err1 != nil || err2 != nil || err3 != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (TUPLE3): stack empty")
                        }</span>
                        <span class="cov8" title="1">state.push([]interface{}{c, b, a})</span>

                case 'I', 'L':<span class="cov8" title="1"> // INT, LONG
                        line, err := state.readString('\n')
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (INT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">val, err := strconv.ParseInt(line, 10, 64)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (INT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(val)</span>
                case 'F':<span class="cov8" title="1"> // FLOAT
                        line, err := state.readString('\n')
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (FLOAT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">val, err := strconv.ParseFloat(line, 64)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (FLOAT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(val)</span>
                case 'K':<span class="cov8" title="1"> // BININT1
                        val, err := state.readByte()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (BININT1): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(int64(val))</span>
                case 'M':<span class="cov8" title="1"> // BININT2
                        val, err := state.readUint16()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (BININT2): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(int64(val))</span>
                case 'J':<span class="cov8" title="1"> // BININT
                        val, err := state.readUint32()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (BININT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(int64(int32(val)))</span>
                case '\x8a':<span class="cov8" title="1"> // LONG1
                        length, err := state.readByte()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (LONG1): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">val := int64(0)
                        if length &gt; 0 </span><span class="cov8" title="1">{
                                valb, err := state.readBytes(int(length))
                                if err != nil </span><span class="cov8" title="1">{
                                        return nil, errors.New("Incomplete pickle (LONG1): " + err.Error())
                                }</span>
                                <span class="cov8" title="1">for i, d := range valb </span><span class="cov8" title="1">{
                                        val |= (int64(d) &lt;&lt; uint64(i*8))
                                }</span>
                                <span class="cov8" title="1">if valb[len(valb)-1] &gt;= '\x80' </span><span class="cov8" title="1">{
                                        val -= int64(1) &lt;&lt; uint64(length*8)
                                }</span>
                        }
                        <span class="cov8" title="1">state.push(val)</span>
                case 'G':<span class="cov8" title="1"> // BINFLOAT
                        val, err := state.readFloat64()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (BINFLOAT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(val)</span>

                case 'p':<span class="cov8" title="1"> // PUT
                        line, err := state.readString('\n')
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (PUT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">id, err := strconv.ParseInt(line, 10, 64)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (PUT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">top, err := state.peek()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (PUT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.setMemo(int(id), top)</span>
                case 'g':<span class="cov8" title="1"> // GET
                        line, err := state.readString('\n')
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (GET): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">id, err := strconv.ParseInt(line, 10, 64)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (GET): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(state.getMemo(int(id)))</span>
                case 'q':<span class="cov8" title="1"> // BINPUT
                        id, err := state.readByte()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (BINPUT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">top, err := state.peek()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (PUT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.setMemo(int(id), top)</span>
                case 'h':<span class="cov8" title="1"> // BINGET
                        id, err := state.readByte()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (BINGET): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(state.getMemo(int(id)))</span>
                case 'j':<span class="cov8" title="1"> // LONG_BINGET
                        id, err := state.readUint32()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (LONG_BINGET): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(state.getMemo(int(id)))</span>
                case 'r':<span class="cov8" title="1"> // LONG_BINPUT
                        id, err := state.readUint32()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Incomplete pickle (LONG_BINPUT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">top, err := state.peek()
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, errors.New("Invalid pickle (PUT): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.setMemo(int(id), top)</span>
                case 'c':<span class="cov8" title="1"> // GLOBAL
                        module, err := state.readString('\n')
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.New("Incomplete pickle (GLOBAL): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">klass, err := state.readString('\n')
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.New("Incomplete pickle (GLOBAL): " + err.Error())
                        }</span>
                        <span class="cov8" title="1">state.push(pickleGlobal{module + "." + klass})</span>
                case 'R':<span class="cov8" title="1"> // REDUCE
                        arg, err1 := state.pop()
                        c, err2 := state.pop()
                        if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                                return nil, errors.New("Incomplete pickle (REDUCE): stack empty")
                        }</span>
                        <span class="cov8" title="1">callable, valid := c.(pickleGlobal)
                        if !valid </span><span class="cov0" title="0">{
                                return nil, errors.New("Invalid pickle (REDUCE): non-callable on stack")
                        }</span>
                        // we'll just have to re-implement/fake python callables as the need arises.
                        <span class="cov8" title="1">switch callable.name </span>{
                        case "array.array":<span class="cov8" title="1">
                                as, valid := arg.([]interface{})
                                if !valid || len(as) != 2 </span><span class="cov0" title="0">{
                                        return nil, errors.New("Invalid pickle (REDUCE): invalid array.array args")
                                }</span>
                                <span class="cov8" title="1">tc, ok1 := as[0].(string)
                                if !ok1 </span><span class="cov0" title="0">{
                                        return nil, errors.New("Invalid pickle (REDUCE): invalid array.array type")
                                }</span>
                                <span class="cov8" title="1">if val, ok2 := as[1].([]interface{}); ok2 </span><span class="cov8" title="1">{
                                        state.push(PickleArray{Type: tc, Data: val})
                                }</span> else<span class="cov8" title="1"> if valstr, ok2 := as[1].(string); ok2 </span><span class="cov8" title="1">{
                                        if val, err := loadBinaryArray(tc, valstr); err == nil </span><span class="cov8" title="1">{
                                                state.push(PickleArray{Type: tc, Data: val})
                                        }</span> else<span class="cov0" title="0"> {
                                                return nil, errors.New("Invalid pickle (REDUCE): invalid array.array value")
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        return nil, errors.New("Invalid pickle (REDUCE): invalid array.array value type")
                                }</span>
                        case "copy_reg._reconstructor":<span class="cov8" title="1">
                                // this is a pretty hackish way of loading a serialized swift.common.header_key_dict.HeaderKeyDict
                                // and probably any other python object that's just a wrapped dict.
                                a2, ok := arg.([]interface{})
                                if !ok || len(a2) != 3 </span><span class="cov0" title="0">{
                                        return nil, errors.New("Invalid pickle (REDUCE): copy_reg._reconstructor with unknown arg")
                                }</span>
                                <span class="cov8" title="1">if c, ok := a2[1].(pickleGlobal); !ok || c.name != "__builtin__.dict" </span><span class="cov0" title="0">{
                                        return nil, errors.New("Invalid pickle (REDUCE): unknown python object type in pickle")
                                }</span>
                                <span class="cov8" title="1">state.push(a2[2])</span>
                        default:<span class="cov0" title="0">
                                return nil, errors.New("Invalid pickle (REDUCE): unknown callable on stack")</span>
                        }
                default:<span class="cov8" title="1">
                        return nil, fmt.Errorf("Unknown pickle opcode: %c (%x)\n", op, op)</span>
                }
        }
        <span class="cov8" title="1">return nil, errors.New("Incomplete pickle: fell out of loop")</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package ring

import (
        "errors"
        "fmt"
        "math"
        "math/rand"
        "os"
        "path"
        "sort"
        "strings"
        "syscall"
        "time"

        "github.com/troubling/hummingbird/common/pickle"
)

func LockBuilderPath(pth string) (*os.File, error) <span class="cov0" title="0">{
        lockPath := path.Join(path.Dir(pth), ".lock."+path.Base(pth))
        f, err := os.Open(lockPath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        f, err = os.OpenFile(lockPath, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0755)
                        if err != nil </span><span class="cov0" title="0">{
                                f, err = os.Open(lockPath)
                        }</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">err = syscall.Flock(int(f.Fd()), syscall.LOCK_EX)
        if err != nil </span><span class="cov0" title="0">{
                f.Close()
                return nil, err
        }</span>
        <span class="cov0" title="0">return f, nil</span>
}

// GetRingBuilder will return the builder and builder-file-path or an error for
// the ring type and policy given. Note that no locking is done here, you
// should call LockBuilderPath and then call GetRingBuilder again.
func GetRingBuilder(ringType string, policy int) (*RingBuilder, string, error) <span class="cov0" title="0">{
        var ringBuilder *RingBuilder
        var ringBuilderFilePath string
        var err error
        var err2 error
        ringBuilderFile := fmt.Sprintf("%s.builder", ringType)
        if policy != 0 </span><span class="cov0" title="0">{
                ringBuilderFile = fmt.Sprintf("%s-%d.builder", ringType, policy)
        }</span>
        <span class="cov0" title="0">ringBuilderFilePath = fmt.Sprintf("/etc/hummingbird/%s", ringBuilderFile)
        if ringBuilder, err = NewRingBuilderFromFile(ringBuilderFilePath, false); err != nil </span><span class="cov0" title="0">{
                ringBuilderFilePath = fmt.Sprintf("/etc/swift/%s", ringBuilderFile)
                if ringBuilder, err2 = NewRingBuilderFromFile(ringBuilderFilePath, false); err2 != nil </span><span class="cov0" title="0">{
                        return nil, "", fmt.Errorf("Error loading %s:%d ring builder: %s: %s", ringType, policy, err, err2)
                }</span>
        }
        <span class="cov0" title="0">return ringBuilder, ringBuilderFilePath, nil</span>
}

const (
        NONE_DEV                 uint    = 65535
        MAX_BALANCE              float64 = 999.99
        MAX_BALANCE_GATHER_COUNT int     = 3
)

func maxInt(x, y int) int <span class="cov0" title="0">{
        if x &gt; y </span><span class="cov0" title="0">{
                return x
        }</span> else<span class="cov0" title="0"> {
                return y
        }</span>
}

// devIterator returns a function to iterate over each device, and the first device.  It will return nil when no other devices are available.
func devIterator(devs []*RingBuilderDevice) (func() *RingBuilderDevice, *RingBuilderDevice) <span class="cov0" title="0">{
        var index int = 0
        var numDevs = len(devs)
        iter := func() *RingBuilderDevice </span><span class="cov0" title="0">{
                for index &lt; numDevs &amp;&amp; devs[index] == nil </span><span class="cov0" title="0">{
                        index++
                }</span>
                <span class="cov0" title="0">if index &gt;= numDevs </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">devIndex := index
                index++
                return devs[devIndex]</span>
        }
        <span class="cov0" title="0">return iter, iter()</span>
}

type lastPartMovesArray struct {
        ArrayType string // should be "B"
        Data      []byte
}

type replica2Part2DevArray struct {
        ArrayType string // should be "H"
        Data      []uint
}

// RingBuilderPickle is used for pickling/unpickling ringbuilder data
type RingBuilderPickle struct {
        LastPartGatherStart int64                   `pickle:"_last_part_gather_start"`
        LastPartMovesEpoch  int64                   `pickle:"_last_part_moves_epoch"`
        PartPower           int64                   `pickle:"part_power"`
        DevsChanged         bool                    `pickle:"devs_changed"`
        Replicas            float64                 `pickle:"replicas"`
        MinPartHours        int64                   `pickle:"min_part_hours"`
        Parts               int64                   `pickle:"parts"`
        Overload            float64                 `pickle:"overload"`
        Dispersion          float64                 `pickle:"dispersion"`
        Version             int64                   `pickle:"version"`
        Devs                []*RingBuilderDevice    `pickle:"devs"`
        RemoveDevs          []*RingBuilderDevice    `pickle:"_remove_devs"`
        LastPartMoves       lastPartMovesArray      `pickle:"_last_part_moves"`
        Replica2Part2Dev    []replica2Part2DevArray `pickle:"_replica2part2dev"`
        //DispersionGraph     map[pickle.PickleTuple][]interface{} `pickle:"_dispersion_graph"`
}

type RingBuilderDevice struct {
        ReplicationPort int64   `pickle:"replication_port"`
        Meta            string  `pickle:"meta"`
        PartsWanted     int64   `pickle:"parts_wanted"`
        Device          string  `pickle:"device"`
        Zone            int64   `pickle:"zone"`
        Weight          float64 `pickle:"weight"`
        Scheme          string  `pickle:"scheme"`
        Ip              string  `pickle:"ip"`
        Region          int64   `pickle:"region"`
        Port            int64   `pickle:"port"`
        ReplicationIp   string  `pickle:"replication_ip"`
        Parts           int64   `pickle:"parts"`
        Id              int64   `pickle:"id"`
        tiers           [4]string
}

type RingBuilder struct {
        PartPower           int
        Replicas            float64
        MinPartHours        int
        Parts               int
        Overload            float64
        Devs                []*RingBuilderDevice
        DevsChanged         bool
        Version             int
        Dispersion          float64
        lastPartMoves       []byte
        lastPartMovesEpoch  int64
        lastPartGatherStart int
        partMovedBitmap     []byte
        replica2Part2Dev    [][]uint
        Debug               bool
        removedDevs         []*RingBuilderDevice
}

type minMax struct {
        min float64
        max float64
}

type replicaPlan struct {
        min    float64
        target float64
        max    float64
}

type devReplica struct {
        dev     *RingBuilderDevice
        replica int
}

type partReplicas struct {
        part     uint
        replicas []uint
}

func NewRingBuilder(partPower int, replicas float64, minPartHours int, debug bool) (*RingBuilder, error) <span class="cov0" title="0">{
        if partPower &gt; 32 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Part Power must be at most 32 (was %d)", partPower)
        }</span>
        <span class="cov0" title="0">if replicas &lt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Replicas must be at least 1 (was %f)", replicas)
        }</span>
        <span class="cov0" title="0">if minPartHours &lt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Min Part Hours must be non-negative (was %d)", minPartHours)
        }</span>
        <span class="cov0" title="0">builder := &amp;RingBuilder{
                PartPower:          partPower,
                Replicas:           replicas,
                MinPartHours:       minPartHours,
                Parts:              int(math.Exp2(float64(partPower))),
                DevsChanged:        false,
                Version:            0,
                lastPartMovesEpoch: 0,
                Dispersion:         0.0,
                Overload:           0.0,
                Debug:              debug,
        }

        // NOTE: In the python version, these were lazy created.
        builder.lastPartMoves = make([]byte, builder.Parts)
        builder.partMovedBitmap = make([]byte, maxInt(int(math.Exp2(float64(partPower-3))), 1))
        // TODO: Not sure if something needs to be done here to really support fractional replicas
        builder.replica2Part2Dev = make([][]uint, int(replicas))
        for i := 0; i &lt; int(replicas); i++ </span><span class="cov0" title="0">{
                builder.replica2Part2Dev[i] = make([]uint, 0, builder.Parts)
        }</span>

        <span class="cov0" title="0">return builder, nil</span>
}

// Note that no locking is done here, you should call LockBuilderPath first.
func NewRingBuilderFromFile(builderPath string, debug bool) (*RingBuilder, error) <span class="cov0" title="0">{

        f, err := os.Open(builderPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer f.Close()
        fi, err := f.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">buff := make([]byte, fi.Size())
        _, err = f.Read(buff)
        rbp := RingBuilderPickle{}
        err = pickle.Unmarshal(buff, &amp;rbp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">builder := &amp;RingBuilder{
                PartPower:           int(rbp.PartPower),
                Replicas:            rbp.Replicas,
                MinPartHours:        int(rbp.MinPartHours),
                Parts:               int(rbp.Parts),
                Overload:            rbp.Overload,
                DevsChanged:         rbp.DevsChanged,
                Version:             int(rbp.Version),
                Dispersion:          rbp.Dispersion,
                lastPartMovesEpoch:  rbp.LastPartMovesEpoch,
                lastPartGatherStart: int(rbp.LastPartGatherStart),
                Debug:               debug,
        }
        builder.lastPartGatherStart = 0
        builder.lastPartMoves = rbp.LastPartMoves.Data
        builder.replica2Part2Dev = make([][]uint, len(rbp.Replica2Part2Dev))
        for i := 0; i &lt; len(rbp.Replica2Part2Dev); i++ </span><span class="cov0" title="0">{
                builder.replica2Part2Dev[i] = rbp.Replica2Part2Dev[i].Data
        }</span>
        <span class="cov0" title="0">builder.partMovedBitmap = make([]byte, maxInt(int(math.Exp2(float64(builder.PartPower-3))), 1))
        builder.Devs = make([]*RingBuilderDevice, len(rbp.Devs))
        copy(builder.Devs, rbp.Devs)
        builder.removedDevs = make([]*RingBuilderDevice, len(rbp.RemoveDevs))
        copy(builder.removedDevs, rbp.RemoveDevs)

        return builder, nil</span>
}

// debug prints a debug message if debug is enabled
func (b *RingBuilder) debug(msg string) <span class="cov0" title="0">{
        if b.Debug </span><span class="cov0" title="0">{
                fmt.Println(msg)
        }</span>
}

// Save serializes this RingBuilder instance to disk
// Note that no locking is done here, you should call LockBuilderPath first.
func (b *RingBuilder) Save(builderPath string) error <span class="cov0" title="0">{
        f, err := os.OpenFile(builderPath, os.O_WRONLY|os.O_CREATE, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()
        rbp := RingBuilderPickle{
                PartPower:           int64(b.PartPower),
                Replicas:            b.Replicas,
                MinPartHours:        int64(b.MinPartHours),
                Parts:               int64(b.Parts),
                Overload:            b.Overload,
                DevsChanged:         b.DevsChanged,
                Version:             int64(b.Version),
                Dispersion:          b.Dispersion,
                LastPartMovesEpoch:  int64(b.lastPartMovesEpoch),
                LastPartGatherStart: int64(b.lastPartGatherStart),
        }

        rbp.LastPartMoves = lastPartMovesArray{
                ArrayType: "B",
                Data:      b.lastPartMoves,
        }
        rbp.Replica2Part2Dev = make([]replica2Part2DevArray, len(b.replica2Part2Dev))
        for i := 0; i &lt; len(b.replica2Part2Dev); i++ </span><span class="cov0" title="0">{
                rbp.Replica2Part2Dev[i] = replica2Part2DevArray{
                        ArrayType: "H",
                        Data:      b.replica2Part2Dev[i],
                }
        }</span>
        <span class="cov0" title="0">rbp.Devs = b.Devs
        rbp.RemoveDevs = b.removedDevs
        _, err = f.Write(pickle.PickleDumps(rbp))
        return err</span>
}

func (b *RingBuilder) setPartMoved(part uint) <span class="cov0" title="0">{
        b.lastPartMoves[part] = 0
        b.partMovedBitmap[part/8] |= (128 &gt;&gt; (part % 8))
}</span>

func (b *RingBuilder) hasPartMoved(part uint) bool <span class="cov0" title="0">{
        //return bool(b.partMovedBitmap[part/8] &amp; (128 &gt;&gt; (part % 8)))
        //NOTE: Not sure if this is the right thing yet
        return b.partMovedBitmap[part/8]&amp;(128&gt;&gt;(part%8)) &gt; 0
}</span>

func (b *RingBuilder) canPartMove(part uint) bool <span class="cov0" title="0">{
        return int(b.lastPartMoves[part]) &gt;= b.MinPartHours &amp;&amp; !b.hasPartMoved(part)
}</span>

func (b *RingBuilder) PretendMinPartHoursPassed() <span class="cov0" title="0">{
        b.lastPartMovesEpoch = 0
        if len(b.lastPartMoves) &gt; 0 </span><span class="cov0" title="0">{
                for i := 0; i &lt; len(b.lastPartMoves); i++ </span><span class="cov0" title="0">{
                        b.lastPartMoves[i] = 0xff
                }</span>
        }
}

// MinPartSecondsLeft returns the total seconds until a reblanace can be performed.
func (b *RingBuilder) MinPartSecondsLeft() int <span class="cov0" title="0">{
        elapsed := int(time.Now().Unix() - b.lastPartMovesEpoch)
        return maxInt(b.MinPartHours*3600-elapsed, 0)
}</span>

// WeightOfOnePart returns the weight of each partition as calculated from the total weight of all the devices.
func (b *RingBuilder) WeightOfOnePart() float64 <span class="cov0" title="0">{
        totalWeight := 0.0
        for next, dev := devIterator(b.Devs); dev != nil; dev = next() </span><span class="cov0" title="0">{
                if dev.Weight &gt; 0.0 </span><span class="cov0" title="0">{
                        totalWeight += dev.Weight
                }</span>
        }
        <span class="cov0" title="0">return float64(b.Parts) * b.Replicas / totalWeight</span>
}

// Set the weight of a device.  This should be called rather than just altering the weight directly, as the builder will need to rebuild some internal state to reflect the change.
func (b *RingBuilder) SetDevWeight(devId int64, weight float64) error <span class="cov0" title="0">{
        for _, dev := range b.removedDevs </span><span class="cov0" title="0">{
                if devId == dev.Id </span><span class="cov0" title="0">{
                        return fmt.Errorf("Can not set weight of devId %d because it is marked for removal", devId)
                }</span>
        }
        <span class="cov0" title="0">b.Devs[devId].Weight = weight
        b.DevsChanged = true
        b.Version += 1

        return nil</span>
}

// Remove a device from the ring.
func (b *RingBuilder) RemoveDev(devId int64, purge bool) <span class="cov0" title="0">{
        if purge </span><span class="cov0" title="0">{
                b.Devs[devId].Weight = -math.MaxFloat64
        }</span> else<span class="cov0" title="0"> {
                b.Devs[devId].Weight = -1.0
        }</span>
        <span class="cov0" title="0">b.removedDevs = append(b.removedDevs, b.Devs[devId])
        b.DevsChanged = true
        b.Version += 1</span>
}

// updateLatPartMoves updates how many hours ago each partition was moved based on the current time.  The builder won't move a partition that has been moved more recently than minPartHours.
func (b *RingBuilder) updateLastPartMoves() <span class="cov0" title="0">{
        elapsedHours := uint8((time.Now().Unix() - b.lastPartMovesEpoch) / 3600)
        if elapsedHours &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for part := 0; part &lt; b.Parts; part++ </span><span class="cov0" title="0">{
                lastPlusElapsed := b.lastPartMoves[part] + elapsedHours
                if lastPlusElapsed &lt; 0xff </span><span class="cov0" title="0">{
                        b.lastPartMoves[part] = lastPlusElapsed
                }</span> else<span class="cov0" title="0"> {
                        b.lastPartMoves[part] = 0xff
                }</span>
        }
        <span class="cov0" title="0">b.lastPartMovesEpoch = time.Now().Unix()</span>
}

// buildWeightedReplicasByTier returns a map &lt;tier&gt; =&gt; replicanths for all tiers in the ring based on their weights.
func (b *RingBuilder) buildWeightedReplicasByTier() (map[string]float64, error) <span class="cov0" title="0">{
        weightOfOnePart := b.WeightOfOnePart()

        devicesWithRoom := make([]int64, 0, len(b.Devs))
        weightedReplicasForDev := make(map[int64]float64)
        for next, dev := devIterator(b.Devs); dev != nil; dev = next() </span><span class="cov0" title="0">{
                if dev.Weight &lt;= 0.0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">weightedReplicas := dev.Weight * weightOfOnePart / float64(b.Parts)
                if weightedReplicas &lt; 1.0 </span><span class="cov0" title="0">{
                        devicesWithRoom = append(devicesWithRoom, dev.Id)
                }</span> else<span class="cov0" title="0"> {
                        weightedReplicas = 1.0
                }</span>
                <span class="cov0" title="0">weightedReplicasForDev[dev.Id] = weightedReplicas</span>
        }

        <span class="cov0" title="0">for true </span><span class="cov0" title="0">{
                remaining := b.Replicas
                for _, weight := range weightedReplicasForDev </span><span class="cov0" title="0">{
                        remaining -= weight
                }</span>
                <span class="cov0" title="0">if remaining &lt; 1e-10 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">d := devicesWithRoom[:0]
                relWeight := 0.0
                // TODO: we might be able to combine the following loops
                for _, id := range devicesWithRoom </span><span class="cov0" title="0">{
                        if weightedReplicasForDev[id] &lt; 1.0 </span><span class="cov0" title="0">{
                                d = append(d, id)
                                relWeight += weightedReplicasForDev[id]
                        }</span>
                }
                <span class="cov0" title="0">devicesWithRoom = d
                relWeight = remaining / relWeight
                for _, id := range devicesWithRoom </span><span class="cov0" title="0">{
                        weightedReplicasForDev[id] = math.Min(1.0, weightedReplicasForDev[id]*(relWeight+1.0))
                }</span>
        }

        <span class="cov0" title="0">weightedReplicasByTier := make(map[string]float64)
        for next, dev := devIterator(b.Devs); dev != nil; dev = next() </span><span class="cov0" title="0">{
                if dev.Weight &lt;= 0.0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">assignedReplicanths := weightedReplicasForDev[dev.Id]
                devTier := b.tiersForDev(dev)
                for _, tier := range devTier </span><span class="cov0" title="0">{
                        weightedReplicasByTier[tier] += assignedReplicanths
                }</span>

        }

        // Test that the for every level of the tier that the sum of weightedReplicas is very close to the total number of replicas for the ring
        <span class="cov0" title="0">replicasAtTier := [4]float64{0.0, 0.0, 0.0, 0.0}
        for t, w := range weightedReplicasByTier </span><span class="cov0" title="0">{
                if t != "" </span><span class="cov0" title="0">{
                        replicasAtTier[strings.Count(t, ";")] += w
                }</span>
        }
        <span class="cov0" title="0">for t, r := range replicasAtTier </span><span class="cov0" title="0">{
                if math.Abs(b.Replicas-r) &gt; 1e-10 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("1: %f != %f at tier %d", r, b.Replicas, t)
                }</span>
        }

        <span class="cov0" title="0">return weightedReplicasByTier, nil</span>
}

// buildTier2Children wraps buildTierTree to exclude zero-weight devices.
func (b *RingBuilder) buildTier2Children() map[string][]string <span class="cov0" title="0">{
        weightedDevs := make([]*RingBuilderDevice, 0, len(b.Devs))
        for i := range b.Devs </span><span class="cov0" title="0">{
                if b.Devs[i] != nil &amp;&amp; b.Devs[i].Weight &gt; 0.0 </span><span class="cov0" title="0">{
                        weightedDevs = append(weightedDevs, b.Devs[i])
                }</span>
        }
        <span class="cov0" title="0">return b.buildTierTree(weightedDevs)</span>
}

// buildMaxReplicasByTier returns a map of tier -&gt; replicaCount for all teirs in the ring excluding zero weight devices.
//
// There will always be a "" entry as the root of the structure, whose replicaCount will equal the ring's replicaCount.
//
// There will be "region" entries for each region, including the maximum number of replicas the region might have for any given partition.
//
// Next there will be "region;zone" entries for each zone, indicating the maximum number of replicas in a given region and zone.  Anything greater than 1 indicates a partition at slightly elevated risk, as if that zone were to fail mupltiple replicas of that partition would be unreachable.
//
// Next there will be "region;zone;ip:port" entries for each node, indicating the maximum number of replicas stored on a node in a give region and zone.  Anything greater than 1 indicates a partition at elevated risk, as if that ip:port were to fail, multiple replicas of that partition would be unreachable.
//
// Last there will be "region;zone;ip:port;device" entries for each device, indicating the maximum number of replicas the device shares with other devices on the same node for any given partition.  Anything greater than 1 indicates a partition at serious risk, as the data on that partition will not be store distictly at the ring's replicaCount.
//
// Example returned map:
//
func (b *RingBuilder) buildMaxReplicasByTier() map[string]float64 <span class="cov0" title="0">{
        tier2Children := b.buildTier2Children()

        var walkTree func(string, float64) map[string]float64
        walkTree = func(tier string, replicaCount float64) map[string]float64 </span><span class="cov0" title="0">{
                if strings.Count(tier, ";") == 3 </span><span class="cov0" title="0">{
                        replicaCount = math.Min(1.0, replicaCount)
                }</span>
                <span class="cov0" title="0">mr := make(map[string]float64)
                mr[tier] = replicaCount
                if subTiers, ok := tier2Children[tier]; ok </span><span class="cov0" title="0">{
                        for _, subtier := range subTiers </span><span class="cov0" title="0">{
                                subMax := math.Ceil(replicaCount / float64(len(subTiers)))
                                for k, v := range walkTree(subtier, subMax) </span><span class="cov0" title="0">{
                                        mr[k] = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">return mr</span>
        }
        <span class="cov0" title="0">return walkTree("", b.Replicas)</span>
}

// buildWantedReplicasByTier returns a map of tier -&gt; replicanths for all tiers in the ring based on unique as possible (full dispersion) with respect to their weights and device counts.
func (b *RingBuilder) buildWantedReplicasByTier() (map[string]float64, error) <span class="cov0" title="0">{
        weightedReplicas, err := b.buildWeightedReplicasByTier()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">dispersedReplicas := make(map[string]minMax)
        for t, r := range weightedReplicas </span><span class="cov0" title="0">{
                dispersedReplicas[t] = minMax{
                        min: math.Floor(r),
                        max: math.Ceil(r),
                }
        }</span>

        // Watch out for device limited tiers
        <span class="cov0" title="0">numDevices := make(map[string]int)
        numDevices[""] = 0
        for next, dev := devIterator(b.Devs); dev != nil; dev = next() </span><span class="cov0" title="0">{
                if dev.Weight &lt;= 0.0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">for _, t := range dev.tiers </span><span class="cov0" title="0">{
                        numDevices[t] += 1
                }</span>
                <span class="cov0" title="0">numDevices[""] += 1</span>
        }

        <span class="cov0" title="0">tier2Children := b.buildTier2Children()
        wantedReplicas := make(map[string]float64)

        var placeReplicas func(string, float64) error
        placeReplicas = func(tier string, replicanths float64) error </span><span class="cov0" title="0">{
                if replicanths &gt; float64(numDevices[tier]) </span><span class="cov0" title="0">{
                        return fmt.Errorf("More replicanths (%f) than devices (%d) in tier (%s)\n", replicanths, numDevices[tier], tier)
                }</span>
                <span class="cov0" title="0">wantedReplicas[tier] = replicanths
                if len(tier2Children[tier]) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">subTiers := make([]string, len(tier2Children[tier]))
                copy(subTiers, tier2Children[tier])
                sort.Strings(subTiers)
                toPlace := make(map[string]float64)
                remaining := replicanths
                tiersToSpread := make([]string, len(subTiers))
                copy(tiersToSpread, subTiers)
                deviceLimited := false

                for true </span><span class="cov0" title="0">{
                        sum := 0.0
                        for _, t := range tiersToSpread </span><span class="cov0" title="0">{
                                sum += weightedReplicas[t]
                        }</span>
                        <span class="cov0" title="0">relWeight := remaining / sum
                        for _, t := range tiersToSpread </span><span class="cov0" title="0">{
                                replicas := toPlace[t] + (weightedReplicas[t] * relWeight)
                                if replicas &lt; dispersedReplicas[t].min </span><span class="cov0" title="0">{
                                        replicas = dispersedReplicas[t].min
                                }</span> else<span class="cov0" title="0"> if replicas &gt; dispersedReplicas[t].max &amp;&amp; !deviceLimited </span><span class="cov0" title="0">{
                                        replicas = dispersedReplicas[t].max
                                }</span>
                                <span class="cov0" title="0">if replicas &gt; float64(numDevices[t]) </span><span class="cov0" title="0">{
                                        replicas = float64(numDevices[t])
                                }</span>
                                <span class="cov0" title="0">toPlace[t] = replicas</span>
                        }
                        <span class="cov0" title="0">remaining = replicanths
                        for _, v := range toPlace </span><span class="cov0" title="0">{
                                remaining -= v
                        }</span>
                        <span class="cov0" title="0">if remaining &lt; -1e-10 </span><span class="cov0" title="0">{
                                tiersToSpread = tiersToSpread[:0]
                                for _, t := range subTiers </span><span class="cov0" title="0">{
                                        if toPlace[t] &gt; dispersedReplicas[t].min </span><span class="cov0" title="0">{
                                                tiersToSpread = append(tiersToSpread, t)
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> if remaining &gt; 1e-10 </span><span class="cov0" title="0">{
                                tiersToSpread = tiersToSpread[:0]
                                for _, t := range subTiers </span><span class="cov0" title="0">{
                                        if float64(numDevices[t]) &gt; toPlace[t] &amp;&amp; toPlace[t] &lt; dispersedReplicas[t].max </span><span class="cov0" title="0">{
                                                tiersToSpread = append(tiersToSpread, t)
                                        }</span>
                                }
                                <span class="cov0" title="0">if len(tiersToSpread) == 0 </span><span class="cov0" title="0">{
                                        deviceLimited = true
                                        tiersToSpread = tiersToSpread[:0]
                                        for _, t := range subTiers </span><span class="cov0" title="0">{
                                                if toPlace[t] &lt; float64(numDevices[t]) </span><span class="cov0" title="0">{
                                                        tiersToSpread = append(tiersToSpread, t)
                                                }</span>
                                        }
                                }
                        } else<span class="cov0" title="0"> {
                                // Remaining is "empty"
                                break</span>
                        }

                }
                <span class="cov0" title="0">for _, t := range subTiers </span><span class="cov0" title="0">{
                        b.debug(fmt.Sprintf("Planning %f on %s", toPlace[t], t))
                        err := placeReplicas(t, toPlace[t])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }

        // Place all replicas in the cluster tier
        <span class="cov0" title="0">if err := placeReplicas("", b.Replicas); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Test that the for every level of the tier that the sum of weightedReplicas is very close to the total number of replicas for the ring
        <span class="cov0" title="0">replicasAtTier := [4]float64{0.0, 0.0, 0.0, 0.0}
        for t, w := range wantedReplicas </span><span class="cov0" title="0">{
                if t != "" </span><span class="cov0" title="0">{
                        replicasAtTier[strings.Count(t, ";")] += w
                }</span>
        }
        <span class="cov0" title="0">for t, r := range replicasAtTier </span><span class="cov0" title="0">{
                if math.Abs(b.Replicas-r) &gt; 1e-10 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("2: %f != %f at tier %d", r, b.Replicas, t)
                }</span>
        }

        <span class="cov0" title="0">return wantedReplicas, nil</span>
}

// GetRequiredOverload returns the minimum overload value required to make the ring maximally dispersed.
//
// The required overload is the largest percentage change of any single device from its weighted replicanth to its wanted replicanth (note: under weighted devices have a negative percentage of change) to achieve dispersion - that is to say a single device that must be overloaded by 5% is worse than 5 devices in a single tier overloaded by 1%.
func (b *RingBuilder) GetRequiredOverload(weighted map[string]float64, wanted map[string]float64) (float64, error) <span class="cov0" title="0">{
        maxOverload := 0.0

        for next, dev := devIterator(b.Devs); dev != nil; dev = next() </span><span class="cov0" title="0">{
                tier := b.tiersForDev(dev)[3]
                if dev.Weight &lt;= 0.0 </span><span class="cov0" title="0">{
                        if w, ok := wanted[tier]; !ok || w &lt;= 0.0 </span><span class="cov0" title="0">{
                                continue</span>
                        } else<span class="cov0" title="0"> {
                                return 0.0, fmt.Errorf("Device %s has zero weight and should not want any replicas\n", tier)
                        }</span>
                }
                <span class="cov0" title="0">required := (wanted[tier] - weighted[tier]) / weighted[tier]
                b.debug(fmt.Sprintf("%s wants %f and is weighted for %f so therefore requires %f overload", tier, wanted[tier], weighted[tier], required))
                if required &gt; maxOverload </span><span class="cov0" title="0">{
                        maxOverload = required
                }</span>
        }
        <span class="cov0" title="0">return maxOverload, nil</span>
}

// buildTartgetReplicasByTier builds a map of &lt;tier&gt; =&gt; &lt;targetReplicas&gt; account for device weights, unique as possible dispersion and overload.
//
//   &lt;tier&gt; - a tuple, describing each tier in the ring topology
//   &lt;targetReplicas&gt; - a float, the target replicas at the tier
func (b *RingBuilder) buildTargetReplicasByTier() (map[string]float64, error) <span class="cov0" title="0">{
        weightedReplicas, err := b.buildWeightedReplicasByTier()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">wantedReplicas, err := b.buildWantedReplicasByTier()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">maxOverload, err := b.GetRequiredOverload(weightedReplicas, wantedReplicas)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var overload float64
        if maxOverload &lt;= 0.0 </span><span class="cov0" title="0">{
                return wantedReplicas, nil
        }</span> else<span class="cov0" title="0"> {
                overload = math.Min(b.Overload, maxOverload)
        }</span>
        <span class="cov0" title="0">b.debug(fmt.Sprintf("Using effective overload of %f", overload))
        targetReplicas := make(map[string]float64)
        for tier, weighted := range weightedReplicas </span><span class="cov0" title="0">{
                m := (wantedReplicas[tier] - weighted) / maxOverload
                targetReplicas[tier] = m*overload + weighted
        }</span>

        // Test that the for every level of the tier that the sum of weightedReplicas is very close to the total number of replicas for the ring
        <span class="cov0" title="0">replicasAtTier := [4]float64{0.0, 0.0, 0.0, 0.0}
        for t, w := range targetReplicas </span><span class="cov0" title="0">{
                if t != "" </span><span class="cov0" title="0">{
                        replicasAtTier[strings.Count(t, ";")] += w
                }</span>
        }
        <span class="cov0" title="0">for t, r := range replicasAtTier </span><span class="cov0" title="0">{
                if math.Abs(b.Replicas-r) &gt; 1e-10 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("3: %f != %f at tier %d", r, b.Replicas, t)
                }</span>
        }

        <span class="cov0" title="0">return targetReplicas, nil</span>
}

// buildReplicaPlan wraps buildTargetReplicasByTier to include pre-calculated min and max values for each tier
func (b *RingBuilder) buildReplicaPlan() (map[string]replicaPlan, error) <span class="cov0" title="0">{
        targetReplicas, err := b.buildTargetReplicasByTier()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">plan := make(map[string]replicaPlan)
        for t, r := range targetReplicas </span><span class="cov0" title="0">{
                plan[t] = replicaPlan{
                        min:    math.Floor(r + 1e-10),
                        target: r,
                        max:    math.Ceil(r - 1e-10),
                }
        }</span>
        <span class="cov0" title="0">return plan, nil</span>
}

// tiersForDev returns an array of strings representing the tiers for a given device in assending order by length.
func (b *RingBuilder) tiersForDev(dev *RingBuilderDevice) [4]string <span class="cov0" title="0">{
        t1 := dev.Region
        t2 := dev.Zone
        t3 := dev.Ip
        t4 := dev.Id
        tiers := [4]string{fmt.Sprintf("%d", t1), fmt.Sprintf("%d;%d", t1, t2), fmt.Sprintf("%d;%d;%s", t1, t2, t3), fmt.Sprintf("%d;%d;%s;%d", t1, t2, t3, t4)}
        return tiers
}</span>

// buildTierTree constructs the tier tree from the zone layout.
//
// The tier tree is a map that maps tiers to their child tiers.
//
// An example tier tree could look like:
//
// { "":["1", "2"], "1":["1;1","1;2"], "2":["2:1"], "1;1":["1;1;192.168.101.1", "1;1;192.168.101.2"]...}
func (b *RingBuilder) buildTierTree(devs []*RingBuilderDevice) map[string][]string <span class="cov0" title="0">{
        tier2Children := make(map[string][]string)
        for next, dev := devIterator(devs); dev != nil; dev = next() </span><span class="cov0" title="0">{
                if dev.Weight &lt; 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">for _, tier := range b.tiersForDev(dev) </span><span class="cov0" title="0">{
                        parts := strings.Split(tier, ";")
                        if len(parts) == 1 </span><span class="cov0" title="0">{
                                found := false
                                for _, t := range tier2Children[""] </span><span class="cov0" title="0">{
                                        if t == tier </span><span class="cov0" title="0">{
                                                found = true
                                        }</span>
                                }
                                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                        tier2Children[""] = append(tier2Children[""], tier)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                t := strings.Join(parts[0:len(parts)-1], ";")
                                found := false
                                for _, t2 := range tier2Children[t] </span><span class="cov0" title="0">{
                                        if t2 == tier </span><span class="cov0" title="0">{
                                                found = true
                                        }</span>
                                }
                                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                        tier2Children[t] = append(tier2Children[t], tier)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return tier2Children</span>
}

// setPartsWanted sets the partsWanted key for each of the devices to the number of partitions the device wants based on its relative weight.  This key is used to sort the devices according to "most wanted" during rebalancing to best distribute partitions.  A negative partsWanted indicates the device is "overweight" and wishes to give partitions away if possible.
func (b *RingBuilder) setPartsWanted(repPlan map[string]replicaPlan) error <span class="cov0" title="0">{
        tier2Children := b.buildTier2Children()

        partsByTier := make(map[string]int)

        var placeParts func(string, int)
        placeParts = func(tier string, parts int) </span><span class="cov0" title="0">{
                partsByTier[tier] = parts
                subTiers := make([]string, len(tier2Children[tier]))
                copy(subTiers, tier2Children[tier])
                if len(subTiers) == 0 </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">sort.Strings(subTiers)
                toPlace := make(map[string]int)
                for _, t := range subTiers </span><span class="cov0" title="0">{
                        toPlace[t] = int(math.Min(float64(parts), math.Floor(repPlan[t].target*float64(b.Parts))))
                        parts -= toPlace[t]
                }</span>

                // If there are some parts left over, just throw them about
                <span class="cov0" title="0">sort.Slice(subTiers, func(i, j int) bool </span><span class="cov0" title="0">{ return repPlan[subTiers[i]].target &lt; repPlan[subTiers[j]].target }</span>)
                <span class="cov0" title="0">i := 0
                for parts &gt; 0 </span><span class="cov0" title="0">{
                        if i &gt; len(subTiers) </span><span class="cov0" title="0">{
                                i = 0
                        }</span>
                        <span class="cov0" title="0">toPlace[subTiers[i]] += 1
                        parts -= 1
                        i++</span>
                }

                <span class="cov0" title="0">for t, p := range toPlace </span><span class="cov0" title="0">{
                        placeParts(t, p)
                }</span>
        }

        <span class="cov0" title="0">totalParts := int(b.Replicas * float64(b.Parts))
        placeParts("", totalParts)

        // Test that the for every level the sum of partsByTier should be totalParts for the ring
        partsAtTier := [4]int{0, 0, 0, 0}
        for t, p := range partsByTier </span><span class="cov0" title="0">{
                if t != "" </span><span class="cov0" title="0">{
                        partsAtTier[strings.Count(t, ";")] += p
                }</span>
        }
        <span class="cov0" title="0">for t, p := range partsAtTier </span><span class="cov0" title="0">{
                if p != totalParts </span><span class="cov0" title="0">{
                        return fmt.Errorf("4: %d != %d at tier %d", p, totalParts, t)
                }</span>
        }

        <span class="cov0" title="0">for next, dev := devIterator(b.Devs); dev != nil; dev = next() </span><span class="cov0" title="0">{
                if dev.Weight &lt;= 0.0 </span><span class="cov0" title="0">{
                        // With no weight, that means we wish to "drain" the device.  So we set the partsWanted to a really large negative number to indicate its strong desire to give up everything it has
                        dev.PartsWanted = int64(-float64(b.Parts) * b.Replicas)
                }</span> else<span class="cov0" title="0"> {
                        tier := b.tiersForDev(dev)[3]
                        dev.PartsWanted = int64(partsByTier[tier]) - dev.Parts
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// adjustReplica2Part2DevSize makes sure the lengths of the arrays in replica2Part2Dev are correct for the currend value of Replicas and updates the mapping of partition -&gt; [replicas] that need assignment
//
// Example:
//   PartPower = 8
//   Replicas = 2.25
//
// replica2Part2Dev will contain 3 arrays: the first 2 of length 256 (2**8), and the last of length 64 (0.25 * 2**8).
func (b *RingBuilder) adjustReplica2Part2DevSize(toAssign map[uint][]uint) <span class="cov0" title="0">{
        wholeReplicas, fractionalReplicas := math.Modf(b.Replicas)
        removedParts := 0
        newParts := 0

        desiredLengths := make([]int, int(wholeReplicas))
        for i := range desiredLengths </span><span class="cov0" title="0">{
                desiredLengths[i] = b.Parts
        }</span>
        <span class="cov0" title="0">if fractionalReplicas &gt; 0.0 </span><span class="cov0" title="0">{
                desiredLengths = append(desiredLengths, b.Parts*int(fractionalReplicas))
        }</span>

        // If we crossed an integer threshold (say, 4.1 -&gt; 4), we'll have a partial extra replica clinging on here.  Clean up and such extra stuff.
        <span class="cov0" title="0">if len(b.replica2Part2Dev) &gt; len(desiredLengths) </span><span class="cov0" title="0">{
                for _, part2Dev := range b.replica2Part2Dev[len(desiredLengths):] </span><span class="cov0" title="0">{
                        for _, devId := range part2Dev </span><span class="cov0" title="0">{
                                b.Devs[devId].Parts -= 1
                                removedParts -= 1
                        }</span>
                }
                <span class="cov0" title="0">b.replica2Part2Dev = b.replica2Part2Dev[:len(desiredLengths)]</span>
        }

        <span class="cov0" title="0">for replica, desiredLength := range desiredLengths </span><span class="cov0" title="0">{
                if replica &lt; len(b.replica2Part2Dev) </span><span class="cov0" title="0">{
                        part2Dev := b.replica2Part2Dev[replica]
                        if len(part2Dev) &lt; desiredLength </span><span class="cov0" title="0">{
                                // Not leng enough: needs to be extended and the newly added pieces assigned to devices
                                for part := len(part2Dev); part &lt; desiredLength; part++ </span><span class="cov0" title="0">{
                                        toAssign[uint(part)] = append(toAssign[uint(part)], uint(replica))
                                        b.replica2Part2Dev[replica] = append(b.replica2Part2Dev[replica], NONE_DEV)
                                        newParts += 1
                                }</span>
                        } else<span class="cov0" title="0"> if len(part2Dev) &gt; desiredLength </span><span class="cov0" title="0">{
                                // Too long: truncate this mapping
                                for part := desiredLength; part &lt; len(part2Dev); part++ </span><span class="cov0" title="0">{
                                        b.Devs[part2Dev[part]].Parts -= 1
                                        removedParts -= 1
                                        b.replica2Part2Dev[replica] = part2Dev[:desiredLength]
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Maping not present at all: make one up and assign all of it
                        for part := 0; part &lt; desiredLength; part++ </span><span class="cov0" title="0">{
                                toAssign[uint(part)] = append(toAssign[uint(part)], uint(replica))
                                newParts += 1
                        }</span>
                        <span class="cov0" title="0">extra := make([]uint, desiredLength)
                        for i := 0; i &lt; len(extra); i++ </span><span class="cov0" title="0">{
                                extra[i] = NONE_DEV
                        }</span>
                        <span class="cov0" title="0">b.replica2Part2Dev = append(b.replica2Part2Dev, extra)</span>
                }
        }
        <span class="cov0" title="0">b.debug(fmt.Sprintf("%d new parts and %d removed parts from replica-count change.", newParts, removedParts))</span>
}

// gatherPartsFromFailedDevices updates the map of partition -&gt; replicas to be reassigned from removed devices.
func (b *RingBuilder) gatherPartsFromFailedDevices(assignParts map[uint][]uint) int <span class="cov0" title="0">{
        // First we gather partitions from removed devices.  Since removed devices usually indicate device failures, we have no choice but to reassing these partitions.  However, we mark them as moves so later choices will skip other replicas of the same partition if possible.
        if len(b.removedDevs) &gt; 0 </span><span class="cov0" title="0">{
                devsWithParts := make([]uint, 0, len(b.Devs))
                for _, dev := range b.removedDevs </span><span class="cov0" title="0">{
                        if dev.Parts &gt; 0 </span><span class="cov0" title="0">{
                                devsWithParts = append(devsWithParts, uint(dev.Id))
                                b.Devs[dev.Id].Parts = 0
                        }</span>
                }
                <span class="cov0" title="0">if len(devsWithParts) &gt; 0 </span><span class="cov0" title="0">{
                        for replica, part2Dev := range b.replica2Part2Dev </span><span class="cov0" title="0">{
                                for part, devId := range part2Dev </span><span class="cov0" title="0">{
                                        for _, d := range devsWithParts </span><span class="cov0" title="0">{
                                                if devId == d </span><span class="cov0" title="0">{
                                                        b.replica2Part2Dev[replica][part] = NONE_DEV
                                                        b.setPartMoved(uint(part))
                                                        assignParts[uint(part)] = append(assignParts[uint(part)], uint(replica))
                                                        b.debug(fmt.Sprintf("Gathers %d/%d from dev %d [dev removed]", part, replica, devId))
                                                        break</span>
                                                }
                                        }
                                }
                        }

                }
                <span class="cov0" title="0">for _, dev := range b.removedDevs </span><span class="cov0" title="0">{
                        if dev.Weight == -math.MaxFloat64 </span><span class="cov0" title="0">{
                                b.debug(fmt.Sprintf("Removing dev %d", dev.Id))
                                b.Devs[dev.Id] = nil
                        }</span>
                }
                <span class="cov0" title="0">removedDevs := len(b.removedDevs)
                b.removedDevs = b.removedDevs[:0]
                return removedDevs</span>
        }
        <span class="cov0" title="0">return 0</span>
}

// devsForPart returns a slice of devices for a specified partition.
//
// It deliberately includes duplicates.
func (b *RingBuilder) devsForPart(part int) []*RingBuilderDevice <span class="cov0" title="0">{
        devs := make([]*RingBuilderDevice, 0, len(b.Devs))
        for _, part2Dev := range b.replica2Part2Dev </span><span class="cov0" title="0">{
                if part &gt;= len(part2Dev) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">devId := part2Dev[part]
                if devId == NONE_DEV </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">devs = append(devs, b.Devs[devId])</span>
        }
        <span class="cov0" title="0">return devs</span>
}

// replicasForPart returns a list of replicas for a specified partition.
func (b *RingBuilder) replicasForPart(part int) []int <span class="cov0" title="0">{
        replicas := make([]int, 0, int(b.Replicas))
        for replica, part2Dev := range b.replica2Part2Dev </span><span class="cov0" title="0">{
                if part &lt; len(part2Dev) </span><span class="cov0" title="0">{
                        replicas = append(replicas, replica)
                }</span>
        }
        <span class="cov0" title="0">return replicas</span>
}

// gatherPartsForDispersion updates the map of partition -&gt; [replicas] to be reassigned from insufficiently-far-apart replicas.
func (b *RingBuilder) gatherPartsForDispersion(assignParts map[uint][]uint, repPlan map[string]replicaPlan) <span class="cov0" title="0">{
        // Gather partitions that are "at risk" because they aren't currently sufficiently spread out across the cluster.
        for part := 0; part &lt; b.Parts; part++ </span><span class="cov0" title="0">{
                if !b.canPartMove(uint(part)) </span><span class="cov0" title="0">{
                        continue</span>
                }
                // First, add up the count of replicas at each tier for each partition
                <span class="cov0" title="0">replicasAtTier := make(map[string]int)
                devs4Part := b.devsForPart(part)
                for _, dev := range devs4Part </span><span class="cov0" title="0">{
                        for _, tier := range dev.tiers </span><span class="cov0" title="0">{
                                replicasAtTier[tier] += 1
                        }</span>
                }

                // Look for partitions not yet spread out enough.
                <span class="cov0" title="0">rfp := b.replicasForPart(part)
                undispersedDevReplicas := make([]devReplica, 0, len(rfp))
                for _, replica := range rfp </span><span class="cov0" title="0">{
                        devId := b.replica2Part2Dev[replica][part]
                        if devId == NONE_DEV </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">dev := b.Devs[devId]
                        for _, tier := range dev.tiers </span><span class="cov0" title="0">{
                                if float64(replicasAtTier[tier]) &gt; repPlan[tier].max </span><span class="cov0" title="0">{
                                        undispersedDevReplicas = append(undispersedDevReplicas, devReplica{dev, replica})
                                        break</span>
                                }
                        }
                }
                <span class="cov0" title="0">if len(undispersedDevReplicas) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">sort.Slice(undispersedDevReplicas, func(i, j int) bool </span><span class="cov0" title="0">{
                        return undispersedDevReplicas[i].dev.PartsWanted &lt; undispersedDevReplicas[j].dev.PartsWanted
                }</span>)
                <span class="cov0" title="0">for _, dr := range undispersedDevReplicas </span><span class="cov0" title="0">{
                        // The min part hour check is ignored if and only if a device has more than one replica of a part assigned to it
                        dev := dr.dev
                        replica := dr.replica
                        if !b.canPartMove(uint(part)) &amp;&amp; !(replicasAtTier[dev.tiers[3]] &gt; 1) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">dev.PartsWanted += 1
                        dev.Parts -= 1
                        assignParts[uint(part)] = append(assignParts[uint(part)], uint(replica))
                        b.debug(fmt.Sprintf("Gathered %d/%d from dev %d [dispersion]", part, replica, dev.Id))
                        b.replica2Part2Dev[replica][part] = NONE_DEV
                        for _, tier := range dev.tiers </span><span class="cov0" title="0">{
                                replicasAtTier[tier] -= 1
                                b.setPartMoved(uint(part))
                        }</span>
                }
        }
}

// gatherPartsForBalanceCanDisperse updates the map of partition -&gt; [replicas] to be reassigned from overweight drives where the replicas can be better dispersed to another failure domain.
func (b *RingBuilder) gatherPartsForBalanceCanDisperse(assignParts map[uint][]uint, start int, repPlan map[string]replicaPlan) <span class="cov0" title="0">{
        for offset := 0; offset &lt; b.Parts; offset++ </span><span class="cov0" title="0">{
                part := (start + offset) % b.Parts
                if !b.canPartMove(uint(part)) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">rfp := b.replicasForPart(part)
                overweightDevReplica := make([]devReplica, 0, len(rfp))
                replicasAtTier := make(map[string]int)
                for _, replica := range rfp </span><span class="cov0" title="0">{
                        devId := b.replica2Part2Dev[replica][part]
                        if devId == NONE_DEV </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">dev := b.Devs[devId]
                        for _, tier := range dev.tiers </span><span class="cov0" title="0">{
                                replicasAtTier[tier] += 1
                        }</span>
                        <span class="cov0" title="0">if dev.PartsWanted &lt; 0 </span><span class="cov0" title="0">{
                                overweightDevReplica = append(overweightDevReplica, devReplica{dev, replica})
                        }</span>
                }
                <span class="cov0" title="0">if len(overweightDevReplica) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">sort.Slice(overweightDevReplica, func(i, j int) bool </span><span class="cov0" title="0">{
                        return overweightDevReplica[i].dev.PartsWanted &lt; overweightDevReplica[j].dev.PartsWanted
                }</span>)
        <span class="cov0" title="0">OUTER:
                for _, dt := range overweightDevReplica </span><span class="cov0" title="0">{
                        dev := dt.dev
                        replica := dt.replica
                        for _, tier := range dev.tiers </span><span class="cov0" title="0">{
                                if repPlan[tier].min &lt;= float64(replicasAtTier[tier]) &amp;&amp; float64(replicasAtTier[tier]) &lt; repPlan[tier].max </span><span class="cov0" title="0">{
                                        continue OUTER</span>
                                }
                        }

                        // This is the most overweightDevice holding a replica of this part that can shed it according to the plan
                        <span class="cov0" title="0">dev.PartsWanted += 1
                        dev.Parts -= 1
                        assignParts[uint(part)] = append(assignParts[uint(part)], uint(replica))
                        b.debug(fmt.Sprintf("Gathered %d/%d from dev %d [weight disperse]", part, replica, dev.Id))
                        b.replica2Part2Dev[replica][part] = NONE_DEV
                        for _, tier := range dev.tiers </span><span class="cov0" title="0">{
                                replicasAtTier[tier] -= 1
                        }</span>
                        <span class="cov0" title="0">b.setPartMoved(uint(part))
                        break</span>
                }
        }
}

// gatherPartsForBalanceForced updates the map of partition -&gt; [replicas] to be reassigned from overweight drives without restriction.  Parts gathered from this method may be placed back onto devices that are no better (or worse) than the device from which they are gathered.
//
// This method allows devices to flop around enough to unlock replicas that would have otherwise potentially been locked because of dispersion -- it should be used as a last resort.
func (b *RingBuilder) gatherPartsForBalanceForced(assignParts map[uint][]uint, start int) <span class="cov0" title="0">{
        for offset := 0; offset &lt; b.Parts; offset++ </span><span class="cov0" title="0">{
                part := (start + offset) % b.Parts
                if !b.canPartMove(uint(part)) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">rfp := b.replicasForPart(part)
                overweightDevReplica := make([]devReplica, 0, len(rfp))
                for _, replica := range rfp </span><span class="cov0" title="0">{
                        devId := b.replica2Part2Dev[replica][part]
                        if devId == NONE_DEV </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">dev := b.Devs[devId]
                        if dev.PartsWanted &lt; 0 </span><span class="cov0" title="0">{
                                overweightDevReplica = append(overweightDevReplica, devReplica{dev, replica})
                        }</span>
                }
                <span class="cov0" title="0">if len(overweightDevReplica) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">sort.Slice(overweightDevReplica, func(i, j int) bool </span><span class="cov0" title="0">{
                        return overweightDevReplica[i].dev.PartsWanted &lt; overweightDevReplica[j].dev.PartsWanted
                }</span>)

                <span class="cov0" title="0">dr := overweightDevReplica[0]
                dev := dr.dev
                replica := dr.replica
                // This is the most overweightDevice holding a replica of this part we don't know where it's going to end up -- but we'll pick it up and hope for the best
                dev.PartsWanted += 1
                dev.Parts -= 1
                assignParts[uint(part)] = append(assignParts[uint(part)], uint(replica))
                b.debug(fmt.Sprintf("Gathered %d/%d from dev %d [weight forced]", part, replica, dev.Id))
                b.replica2Part2Dev[replica][part] = NONE_DEV
                b.setPartMoved(uint(part))</span>

        }
}

// gatherPartsForBalance gathers parts that look like they should move for balance reasons.
func (b *RingBuilder) gatherPartsForBalance(assignParts map[uint][]uint, repPlan map[string]replicaPlan) <span class="cov0" title="0">{
        // Pick a random starting point on the other side of the ring
        quarterTurn := b.Parts / 4
        randomHalf := rand.Intn(b.Parts / 2)
        start := (b.lastPartGatherStart + quarterTurn + randomHalf) % b.Parts
        b.debug(fmt.Sprintf("Gather start is %d (Last start was %d)", start, b.lastPartGatherStart))
        b.lastPartGatherStart = start

        b.gatherPartsForBalanceCanDisperse(assignParts, start, repPlan)
        if len(assignParts) == 0 </span><span class="cov0" title="0">{
                b.gatherPartsForBalanceForced(assignParts, start)
        }</span>
}

// For an existing ring data set, partitions are reassigned similar to the initial assignment.
//
// The devices are ordered by how many partitions they still want and keps in that order throughout the process.
//
// The gathered partitions are iterated through, assigning them to devices according to the "most wanted" while keeping the replicas as "far apart" as possible.
//
// Two different regions are considred the fartheres-apart things, followed by zones, then different ip within a zone; the least-far-apart things are different devices with the same ip in the same zone.
func (b *RingBuilder) reassignParts(reassignParts []partReplicas, repPlan map[string]replicaPlan) error <span class="cov0" title="0">{
        partsAvailableInTier := make(map[string]int)
        availableDevs := make([]*RingBuilderDevice, 0, len(b.Devs))
        for next, dev := devIterator(b.Devs); dev != nil; dev = next() </span><span class="cov0" title="0">{
                wanted := int(math.Max(float64(dev.PartsWanted), 0))
                for _, tier := range dev.tiers </span><span class="cov0" title="0">{
                        partsAvailableInTier[tier] += wanted
                }</span>
                <span class="cov0" title="0">if dev.Weight &gt; 0.0 </span><span class="cov0" title="0">{
                        availableDevs = append(availableDevs, dev)
                }</span>
        }
        <span class="cov0" title="0">sort.Slice(availableDevs, func(i, j int) bool </span><span class="cov0" title="0">{
                if availableDevs[i].PartsWanted == availableDevs[j].PartsWanted </span><span class="cov0" title="0">{
                        return rand.Int() &lt; rand.Int()
                }</span> else<span class="cov0" title="0"> {
                        return availableDevs[i].PartsWanted &lt; availableDevs[j].PartsWanted
                }</span>
        })
        <span class="cov0" title="0">tier2Devs := make(map[string][]*RingBuilderDevice)
        maxTierDepth := 0
        for i := range availableDevs </span><span class="cov0" title="0">{
                for _, tier := range availableDevs[i].tiers </span><span class="cov0" title="0">{
                        tier2Devs[tier] = append(tier2Devs[tier], availableDevs[i])
                        tierDepth := strings.Count(tier, ";") + 1
                        if tierDepth &gt; maxTierDepth </span><span class="cov0" title="0">{
                                maxTierDepth = tierDepth
                        }</span>
                }
        }
        <span class="cov0" title="0">tier2ChildrenSets := b.buildTierTree(availableDevs)
        tier2Children := make(map[string][]string)
        tiersList := []string{""}
        depth := 1
        for depth &lt;= maxTierDepth </span><span class="cov0" title="0">{
                newTiersList := make([]string, 0)
                for _, tier := range tiersList </span><span class="cov0" title="0">{
                        childTiers := tier2ChildrenSets[tier]
                        // NOTE: Not sure if the following is in the same vein as the original
                        sort.Slice(childTiers, func(i, j int) bool </span><span class="cov0" title="0">{
                                iLen := len(tier2Devs[childTiers[i]])
                                jLen := len(tier2Devs[childTiers[j]])
                                if tier2Devs[childTiers[i]][iLen-1].PartsWanted == tier2Devs[childTiers[j]][jLen-1].PartsWanted </span><span class="cov0" title="0">{
                                        return rand.Int() &lt; rand.Int()
                                }</span> else<span class="cov0" title="0"> {
                                        return tier2Devs[childTiers[i]][iLen-1].PartsWanted &lt; tier2Devs[childTiers[j]][jLen-1].PartsWanted
                                }</span>
                        })
                        <span class="cov0" title="0">tier2Children[tier] = childTiers
                        for _, tier := range childTiers </span><span class="cov0" title="0">{
                                newTiersList = append(newTiersList, tier)
                        }</span>
                }
                <span class="cov0" title="0">tiersList = newTiersList
                depth += 1</span>
        }

        // Shuffle reassignParts
        <span class="cov0" title="0">for i := range reassignParts </span><span class="cov0" title="0">{
                j := rand.Intn(i + 1)
                reassignParts[i], reassignParts[j] = reassignParts[j], reassignParts[i]
        }</span>
        <span class="cov0" title="0">for _, rp := range reassignParts </span><span class="cov0" title="0">{
                part := rp.part
                replaceReplicas := rp.replicas
                // always update partMoves for minPartHours
                b.lastPartMoves[part] = 0
                // Count up where these replicas be
                replicasAtTier := make(map[string]int)
                for _, dev := range b.devsForPart(int(part)) </span><span class="cov0" title="0">{
                        for _, tier := range dev.tiers </span><span class="cov0" title="0">{
                                replicasAtTier[tier] += 1
                        }</span>
                }

                // Shuffle the replicas
                <span class="cov0" title="0">for i := range replaceReplicas </span><span class="cov0" title="0">{
                        j := rand.Intn(i + 1)
                        replaceReplicas[i], replaceReplicas[j] = replaceReplicas[j], replaceReplicas[i]
                }</span>
                <span class="cov0" title="0">for _, replica := range replaceReplicas </span><span class="cov0" title="0">{
                        // Find a new home for this replicas
                        tier := ""
                        depth := 1
                        for depth &lt;= maxTierDepth </span><span class="cov0" title="0">{
                                candidates := make([]string, 0)
                                for _, t := range tier2Children[tier] </span><span class="cov0" title="0">{
                                        if float64(replicasAtTier[t]) &lt; repPlan[t].max </span><span class="cov0" title="0">{
                                                candidates = append(candidates, t)
                                        }</span>
                                }
                                <span class="cov0" title="0">if len(candidates) == 0 </span><span class="cov0" title="0">{
                                        data := make(map[string]string)
                                        for _, t := range tier2Children[tier] </span><span class="cov0" title="0">{
                                                data[t] = fmt.Sprintf("%v - MAX: %v", replicasAtTier[t], repPlan[t].max)
                                        }</span>
                                        <span class="cov0" title="0">return fmt.Errorf("no home for %d/%d %+v", part, replica, data)</span>
                                }

                                // Shuffle the candidates
                                <span class="cov0" title="0">for i := range candidates </span><span class="cov0" title="0">{
                                        j := rand.Intn(i + 1)
                                        candidates[i], candidates[j] = candidates[j], candidates[i]
                                }</span>
                                <span class="cov0" title="0">curTier := candidates[0]
                                for _, t := range candidates </span><span class="cov0" title="0">{
                                        if partsAvailableInTier[t] &gt; partsAvailableInTier[curTier] </span><span class="cov0" title="0">{
                                                curTier = t
                                        }</span>
                                }
                                <span class="cov0" title="0">tier = curTier
                                depth += 1</span>
                        }

                        <span class="cov0" title="0">dev := tier2Devs[tier][len(tier2Devs[tier])-1]
                        dev.PartsWanted -= 1
                        dev.Parts += 1
                        for _, t := range dev.tiers </span><span class="cov0" title="0">{
                                partsAvailableInTier[t] -= 1
                                replicasAtTier[t] += 1
                        }</span>
                        <span class="cov0" title="0">b.replica2Part2Dev[replica][part] = uint(dev.Id)
                        b.debug(fmt.Sprintf("Placed %d/%d onto dev %d", part, replica, dev.Id))</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// buildBalancePerDev builds a map of deviceId -&gt; balance where balance represents the percentage difference from the desired amount of partitions a given device wants and the amount it has.
func (b *RingBuilder) buildBalancePerDev() map[int64]float64 <span class="cov0" title="0">{
        weightOfOnePart := b.WeightOfOnePart()
        balancePerDev := make(map[int64]float64)
        balance := 0.0
        for next, dev := devIterator(b.Devs); dev != nil; dev = next() </span><span class="cov0" title="0">{
                if dev.Weight &lt;= 0.0 </span><span class="cov0" title="0">{
                        if dev.Parts &gt; 0 </span><span class="cov0" title="0">{
                                // If a device has no weight but has partitions, then its overage is considered "infinity" and there always the wors possible.  We sho MAX_BALANCE for convenience.
                                balance = MAX_BALANCE
                        }</span> else<span class="cov0" title="0"> {
                                balance = 0.0
                        }</span>
                } else<span class="cov0" title="0"> {
                        balance = 100.0*float64(dev.Parts)/(dev.Weight*weightOfOnePart) - 100.0
                }</span>
                <span class="cov0" title="0">balancePerDev[dev.Id] = balance</span>
        }
        <span class="cov0" title="0">return balancePerDev</span>
}

// validate validates the ring.
//
// This is a safety method to try to catch any bugs in the building process.  It ensures partitions have been assigned to real devices, aren't doubly assigned, etc.
func (b *RingBuilder) Validate() error <span class="cov0" title="0">{

        partsOnDevs := int64(0)
        for next, dev := devIterator(b.Devs); dev != nil; dev = next() </span><span class="cov0" title="0">{
                partsOnDevs += dev.Parts
        }</span>

        <span class="cov0" title="0">if len(b.replica2Part2Dev) == 0 </span><span class="cov0" title="0">{
                return errors.New("replica2Part2Dev is emptyl did you forget to rebalance?")
        }</span>

        <span class="cov0" title="0">partsInMap := int64(0)
        for _, p2d := range b.replica2Part2Dev </span><span class="cov0" title="0">{
                partsInMap += int64(len(p2d))
        }</span>

        <span class="cov0" title="0">if partsOnDevs != partsInMap </span><span class="cov0" title="0">{
                return fmt.Errorf("All partitions are not double accounted for: %d != %d", partsOnDevs, partsInMap)
        }</span>

        <span class="cov0" title="0">for part := 0; part &lt; b.Parts; part++ </span><span class="cov0" title="0">{
                devsForPart := make([]uint, 0)
                for replica := range b.replica2Part2Dev </span><span class="cov0" title="0">{
                        if len(b.replica2Part2Dev[replica]) &lt;= part </span><span class="cov0" title="0">{
                                return fmt.Errorf("The partition assignments of replica %d were shorter than expected (%d &lt; %d)", replica, len(b.replica2Part2Dev[replica]), b.Parts)
                        }</span>
                        <span class="cov0" title="0">devId := b.replica2Part2Dev[replica][part]
                        if devId &gt;= uint(len(b.Devs)) || b.Devs[devId] == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("Partition %d, replica %d was not allocated to a device.", part, replica)
                        }</span>
                        <span class="cov0" title="0">devsForPart = append(devsForPart, devId)</span>
                }
                <span class="cov0" title="0">devsForPartSet := make(map[uint]bool)
                for _, devId := range devsForPart </span><span class="cov0" title="0">{
                        if _, ok := devsForPartSet[devId]; ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("The partitions %d has been assigned to duplicate devices %v", part, devsForPart)
                        }</span>
                        <span class="cov0" title="0">devsForPartSet[devId] = true</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// GetBalance gets the balance of the ring.
//
// The balance value is the highest percentage of the desired amount of partitions a given device wants.  For instance, if the "worst" device wants (based on tis weight relative to the sum of all devices' weights) 123 partitions and it has 124 partitions, the balance value would be 0.83 (1 extra / 123 wanted * 100)
func (b *RingBuilder) GetBalance() float64 <span class="cov0" title="0">{
        balancePerDev := b.buildBalancePerDev()
        balance := 0.0
        for _, b := range balancePerDev </span><span class="cov0" title="0">{
                balance = math.Max(math.Abs(b), balance)
        }</span>
        <span class="cov0" title="0">return balance</span>
}

// Rebalance rebalances the ring.
//
// This is the main work function of the builder, as it will assign and reassing partitions to devices in the ring based on weights, distinct zones, recent reassignments, etc.
//
// The proces doesn't always perfectly assign partitions (that'd take a lot more analysis and therefore a lot more time.  Because of this, it keeps rebalancing until the device skew (number of partitions a device wants compared to what it has) gets below 1% or doesn't change by more than 1% (only happens with a ring that can't be balanced no matter what).
func (b *RingBuilder) Rebalance() (int, float64, int, error) <span class="cov0" title="0">{
        numDevices := 0
        for next, dev := devIterator(b.Devs); dev != nil; dev = next() </span><span class="cov0" title="0">{
                // NOTE: original ringbuilder added a tiers thing, not sure if needed yet
                dev.tiers = b.tiersForDev(dev)
                if dev.Weight &gt; 0 </span><span class="cov0" title="0">{
                        numDevices += 1
                }</span>
        }
        <span class="cov0" title="0">if float64(numDevices) &lt; b.Replicas </span><span class="cov0" title="0">{
                return 0, 0.0, 0, fmt.Errorf("Replica count of %f requires more than %d devices.", b.Replicas, numDevices)
        }</span>

        <span class="cov0" title="0">oldReplica2Part2Dev := make([][]uint, len(b.replica2Part2Dev))
        for i := range b.replica2Part2Dev </span><span class="cov0" title="0">{
                oldReplica2Part2Dev[i] = make([]uint, len(b.replica2Part2Dev[i]))
                copy(oldReplica2Part2Dev[i], b.replica2Part2Dev[i])
        }</span>

        <span class="cov0" title="0">b.updateLastPartMoves()

        repPlan, err := b.buildReplicaPlan()
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0.0, 0, err
        }</span>
        <span class="cov0" title="0">if err := b.setPartsWanted(repPlan); err != nil </span><span class="cov0" title="0">{
                return 0, 0.0, 0, err
        }</span>

        <span class="cov0" title="0">assignParts := make(map[uint][]uint)
        // gather parts from replica count adjustments
        b.adjustReplica2Part2DevSize(assignParts)
        // Gather parts for failed devices
        removedDevs := b.gatherPartsFromFailedDevices(assignParts)
        // Gather parts for dispersion
        b.gatherPartsForDispersion(assignParts, repPlan)

        finishStatus := "Unable to finish"
        // Gather a few times or until we achive the plan
        gatherCount := 0
GATHER:
        for gatherCount = 0; gatherCount &lt; MAX_BALANCE_GATHER_COUNT; gatherCount++ </span><span class="cov0" title="0">{
                b.gatherPartsForBalance(assignParts, repPlan)
                if len(assignParts) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">assignPartsList := make([]partReplicas, 0, len(assignParts))
                for p, r := range assignParts </span><span class="cov0" title="0">{
                        assignPartsList = append(assignPartsList, partReplicas{p, r})
                }</span>
                // range on a map is already random, so we don't have to shuffle assignPartsList
                // reset assignParts map for next iteration
                // NOTE: It isn't clear to me why this is done...
                <span class="cov0" title="0">assignParts = make(map[uint][]uint)

                numPartReplicas := 0
                for _, pr := range assignPartsList </span><span class="cov0" title="0">{
                        numPartReplicas += len(pr.replicas)
                }</span>
                <span class="cov0" title="0">b.debug(fmt.Sprintf("Gathered %d parts.", numPartReplicas))
                b.reassignParts(assignPartsList, repPlan)
                b.debug(fmt.Sprintf("Assigned %d parts.", numPartReplicas))

                for next, dev := devIterator(b.Devs); dev != nil; dev = next() </span><span class="cov0" title="0">{
                        if dev.PartsWanted &gt;= 0 </span><span class="cov0" title="0">{
                                continue GATHER</span>
                        }
                }
                <span class="cov0" title="0">finishStatus = "Finished"
                break</span>
        }
        <span class="cov0" title="0">b.debug(fmt.Sprintf("%s rebalance plan after %d attempts.", finishStatus, gatherCount+1))
        b.DevsChanged = false
        b.Version += 1
        // NOTE/TODO?: Dispersion graph isn't currently implemented

        // Figure out how many parts moved
        changedParts := 0
        for repId := range b.replica2Part2Dev </span><span class="cov0" title="0">{
                for partId, devId := range b.replica2Part2Dev[repId] </span><span class="cov0" title="0">{
                        if partId &gt;= len(oldReplica2Part2Dev[repId]) || devId != oldReplica2Part2Dev[repId][partId] </span><span class="cov0" title="0">{
                                changedParts += 1
                        }</span>
                }
        }

        <span class="cov0" title="0">return changedParts, b.GetBalance(), removedDevs, nil</span>
}

func (b *RingBuilder) SearchDevs(region, zone int64, ip string, port int64, repIp string, repPort int64, device string, weight float64, meta string, scheme string) []*RingBuilderDevice <span class="cov0" title="0">{
        foundDevs := make([]*RingBuilderDevice, 0, len(b.Devs))
        for next, dev := devIterator(b.Devs); dev != nil; dev = next() </span><span class="cov0" title="0">{
                if region &gt;= 0 &amp;&amp; region != dev.Region </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if zone &gt;= 0 &amp;&amp; zone != dev.Zone </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if ip != "" &amp;&amp; ip != dev.Ip </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if port &gt;= 0 &amp;&amp; port != dev.Port </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if repIp != "" &amp;&amp; repIp != dev.ReplicationIp </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if repPort &gt;= 0 &amp;&amp; repPort != dev.ReplicationPort </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if device != "" &amp;&amp; device != dev.Device </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if weight &gt;= 0.0 &amp;&amp; weight != dev.Weight </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if meta != "" &amp;&amp; strings.Contains(dev.Meta, meta) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if scheme != "" &amp;&amp; scheme != dev.Scheme </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">foundDevs = append(foundDevs, dev)</span>
        }
        <span class="cov0" title="0">return foundDevs</span>
}

func (b *RingBuilder) UpdateDevInfo(devId int64, newIp string, newPort int64, newRepIp string, newRepPort int64, newDevice, newMeta, newScheme string) error <span class="cov0" title="0">{
        // first check to make sure another device doesn't have the ip/port/device
        if newIp == "" </span><span class="cov0" title="0">{
                newIp = b.Devs[devId].Ip
        }</span>
        <span class="cov0" title="0">if newPort &lt; 0 </span><span class="cov0" title="0">{
                newPort = b.Devs[devId].Port
        }</span>
        <span class="cov0" title="0">if newDevice == "" </span><span class="cov0" title="0">{
                newDevice = b.Devs[devId].Device
        }</span>
        <span class="cov0" title="0">for next, dev := devIterator(b.Devs); dev != nil; dev = next() </span><span class="cov0" title="0">{
                if dev.Id != devId &amp;&amp; dev.Ip == newIp &amp;&amp; dev.Port == newPort &amp;&amp; dev.Device == newDevice </span><span class="cov0" title="0">{
                        return fmt.Errorf("Device id %d already uses %s:%d:/%s.", dev.Id, newIp, newPort, newDevice)
                }</span>
        }
        <span class="cov0" title="0">b.Devs[devId].Ip = newIp
        b.Devs[devId].Port = newPort
        b.Devs[devId].Device = newDevice
        if newRepIp != "" </span><span class="cov0" title="0">{
                b.Devs[devId].ReplicationIp = newRepIp
        }</span>
        <span class="cov0" title="0">if newRepPort &gt;= 0 </span><span class="cov0" title="0">{
                b.Devs[devId].ReplicationPort = newRepPort
        }</span>
        <span class="cov0" title="0">if newMeta != "" </span><span class="cov0" title="0">{
                b.Devs[devId].Meta = newMeta
        }</span>
        <span class="cov0" title="0">if newScheme != "" </span><span class="cov0" title="0">{
                if newScheme != "http" &amp;&amp; newScheme != "https" </span><span class="cov0" title="0">{
                        return errors.New("scheme can only http or https")
                }</span>
                <span class="cov0" title="0">b.Devs[devId].Scheme = newScheme</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ChangeMinPartHours changes the value used to decide if a given partition can be moved again.  This restriction is to give the overall system enough time to settl a partition to its new location before moving it to yet another location.  While no data would be lost if a partition is moved several times quickly, it could make the data unreachable for a short period of time.
//
// This should be set to at least the average full partition replication time.  Starting it at 24 hours and then lowering it to what the replicator reprots as the longest partition cycle is best.
func (b *RingBuilder) ChangeMinPartHours(minPartHours int) <span class="cov0" title="0">{
        b.MinPartHours = minPartHours
}</span>

// SetReplicas sets the number of replicas in this ring.
//
// If the new replica count is sufficiently different that replica2Part2Dev will change size, sets devsChanged.  This is so tools can know to write out the new ring rather than bailing out due to lack of balance change.
func (b *RingBuilder) SetReplicas(newReplicaCount float64) <span class="cov0" title="0">{
        oldSlotsUsed := int(float64(b.Parts) * b.Replicas)
        newSlotsUsed := int(float64(b.Parts) * newReplicaCount)
        if oldSlotsUsed != newSlotsUsed </span><span class="cov0" title="0">{
                b.DevsChanged = true
        }</span>
        <span class="cov0" title="0">b.Replicas = newReplicaCount</span>
}

func (b *RingBuilder) GetRing() *hashRing <span class="cov0" title="0">{
        data := ringData{
                ReplicaCount: int(b.Replicas),
                PartShift:    uint64(32 - b.PartPower),
        }
        for i, dev := range b.Devs </span><span class="cov0" title="0">{
                if dev != nil </span><span class="cov0" title="0">{
                        data.Devs = append(data.Devs, &amp;Device{
                                Id:              int(b.Devs[i].Id),
                                Device:          b.Devs[i].Device,
                                Ip:              b.Devs[i].Ip,
                                Scheme:          b.Devs[i].Scheme,
                                Meta:            b.Devs[i].Meta,
                                Port:            int(b.Devs[i].Port),
                                Region:          int(b.Devs[i].Region),
                                ReplicationIp:   b.Devs[i].ReplicationIp,
                                ReplicationPort: int(b.Devs[i].ReplicationPort),
                                Weight:          b.Devs[i].Weight,
                                Zone:            int(b.Devs[i].Zone),
                        })
                }</span> else<span class="cov0" title="0"> {
                        data.Devs = append(data.Devs, nil)
                }</span>
        }
        <span class="cov0" title="0">data.replica2part2devId = make([][]uint16, len(b.replica2Part2Dev))
        for i := range b.replica2Part2Dev </span><span class="cov0" title="0">{
                data.replica2part2devId[i] = make([]uint16, len(b.replica2Part2Dev[i]))
                for j := range b.replica2Part2Dev[i] </span><span class="cov0" title="0">{
                        data.replica2part2devId[i][j] = uint16(b.replica2Part2Dev[i][j])
                }</span>
        }
        <span class="cov0" title="0">r := &amp;hashRing{}
        r.data.Store(&amp;data)

        return r</span>
}

// AddDev adds a device to the ring
//
// Note: This will not reblance the ring immediately as you may want to make multiple changes for a single rebalance
//
// Returns the id of the device
func (b *RingBuilder) AddDev(dev *RingBuilderDevice) (int64, error) <span class="cov0" title="0">{
        // Check for duplicat ip:port/devs
        for i := 0; i &lt; len(b.Devs); i++ </span><span class="cov0" title="0">{
                if b.Devs[i] != nil </span><span class="cov0" title="0">{
                        if b.Devs[i].Ip == dev.Ip &amp;&amp; b.Devs[i].Port == dev.Port &amp;&amp; b.Devs[i].Device == dev.Device </span><span class="cov0" title="0">{
                                return 0, fmt.Errorf("Device %d already uses %s:%d/%s.", i, dev.Ip, dev.Port, dev.Device)
                        }</span>
                }
        }
        <span class="cov0" title="0">if dev.Id &lt; 0 </span><span class="cov0" title="0">{
                // find the next id
                id := int64(0)
                for i := 0; i &lt; len(b.Devs); i++ </span><span class="cov0" title="0">{
                        if b.Devs[i] == nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">id += 1</span>
                }
                <span class="cov0" title="0">dev.Id = id</span>
        }
        <span class="cov0" title="0">if dev.Id &lt; int64(len(b.Devs)) &amp;&amp; b.Devs[dev.Id] != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("Duplicate device id: %d", dev.Id)
        }</span>
        <span class="cov0" title="0">for dev.Id &gt;= int64(len(b.Devs)) </span><span class="cov0" title="0">{
                // We need to fill in the gaps
                b.Devs = append(b.Devs, nil)
        }</span>
        <span class="cov0" title="0">dev.Parts = 0
        b.Devs[dev.Id] = dev
        b.DevsChanged = true
        b.Version += 1
        return dev.Id, nil</span>
}

// Command line functions

// CreateRing creates a ring builder file.
//   builderpath must include the filename of the the builder to create.
//   A backup folder will also be created in the back with a backup of the original builder.
// Note that no locking is done here, you should call LockBuilderPath first.
func CreateRing(builderPath string, partPower int, replicas float64, minPartHours int, debug bool) error <span class="cov0" title="0">{
        builder, err := NewRingBuilder(partPower, replicas, minPartHours, debug)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">backupPath := path.Join(path.Dir(builderPath), "backups")
        err = os.Mkdir(backupPath, 0777)
        if err != nil </span><span class="cov0" title="0">{
                e := err.(*os.PathError)
                if e.Err != syscall.EEXIST </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">err = builder.Save(path.Join(backupPath, fmt.Sprintf("%d.%s", time.Now().UnixNano(), path.Base(builderPath))))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return builder.Save(builderPath)</span>
}

// Rebalance attempts to rebalance the ring by reassigning partitions that haven't been recently reassigned.
// Note that no locking is done here, you should call LockBuilderPath first.
func Rebalance(builderPath string, debug bool, dryrun bool, quiet bool) (int, float64, int, error) <span class="cov0" title="0">{
        builder, err := NewRingBuilderFromFile(builderPath, debug)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, 0, err
        }</span>
        <span class="cov0" title="0">changed, balance, removed, err := builder.Rebalance()
        if err != nil </span><span class="cov0" title="0">{
                return changed, balance, removed, err
        }</span>
        // make sure the ring is valid
        <span class="cov0" title="0">err = builder.Validate()
        if err != nil </span><span class="cov0" title="0">{
                return changed, balance, removed, err
        }</span>
        <span class="cov0" title="0">if !quiet </span><span class="cov0" title="0">{
                fmt.Printf("Changed: %d Balance: %f Removed: %d\n", changed, balance, removed)
        }</span>
        <span class="cov0" title="0">if dryrun </span><span class="cov0" title="0">{
                fmt.Println("Dry run complete; rebalance was not saved.")
                return changed, balance, removed, nil
        }</span>
        <span class="cov0" title="0">backupPath := path.Join(path.Dir(builderPath), "backups")
        err = os.Mkdir(backupPath, 0777)
        if err != nil </span><span class="cov0" title="0">{
                e := err.(*os.PathError)
                if e.Err != syscall.EEXIST </span><span class="cov0" title="0">{
                        return changed, balance, removed, err
                }</span>
        }
        <span class="cov0" title="0">ts := time.Now().UnixNano()
        err = builder.Save(path.Join(backupPath, fmt.Sprintf("%d.%s", ts, path.Base(builderPath))))
        if err != nil </span><span class="cov0" title="0">{
                return changed, balance, removed, err
        }</span>
        <span class="cov0" title="0">err = builder.Save(builderPath)
        if err != nil </span><span class="cov0" title="0">{
                return changed, balance, removed, err
        }</span>
        <span class="cov0" title="0">ringFile := strings.TrimSuffix(builderPath, ".builder") + ".ring.gz"
        r := builder.GetRing()
        err = r.Save(path.Join(backupPath, fmt.Sprintf("%d.%s", ts, path.Base(ringFile))))
        if err != nil </span><span class="cov0" title="0">{
                return changed, balance, removed, err
        }</span>
        <span class="cov0" title="0">return changed, balance, removed, r.Save(ringFile)</span>
}

// AddDevice adds a device to the builder filer
//   builderpath must include the filename of the builder file.
//   Returns the id of the device in the ring.
// Note that no locking is done here, you should call LockBuilderPath first.
func AddDevice(builderPath string, id, region, zone int64, scheme, ip string, port int64, replicationIp string, replicationPort int64, device string, weight float64, debug bool) (int64, error) <span class="cov0" title="0">{
        builder, err := NewRingBuilderFromFile(builderPath, debug)
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>
        <span class="cov0" title="0">dev := &amp;RingBuilderDevice{
                Id:              id,
                Region:          region,
                Zone:            zone,
                Scheme:          scheme,
                Ip:              ip,
                Port:            port,
                ReplicationIp:   replicationIp,
                ReplicationPort: replicationPort,
                Device:          device,
                Weight:          weight,
        }
        id, err = builder.AddDev(dev)
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>
        <span class="cov0" title="0">err = builder.Save(builderPath)
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>
        <span class="cov0" title="0">return id, nil</span>
}

// Note that no locking is done here, you should call LockBuilderPath first.
func Search(builderPath string, region, zone int64, ip string, port int64, repIp string, repPort int64, device string, weight float64, meta string, scheme string) ([]*RingBuilderDevice, error) <span class="cov0" title="0">{
        builder, err := NewRingBuilderFromFile(builderPath, false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">devs := builder.SearchDevs(region, zone, ip, port, repIp, repPort, device, weight, meta, scheme)
        return devs, nil</span>
}

// Note that no locking is done here, you should call LockBuilderPath first.
func SetWeight(builderPath string, devs []*RingBuilderDevice, weight float64) error <span class="cov0" title="0">{
        builder, err := NewRingBuilderFromFile(builderPath, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, dev := range devs </span><span class="cov0" title="0">{
                err := builder.SetDevWeight(dev.Id, weight)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return builder.Save(builderPath)</span>
}

// Note that no locking is done here, you should call LockBuilderPath first.
func RemoveDevs(builderPath string, devs []*RingBuilderDevice, purge bool) error <span class="cov0" title="0">{
        builder, err := NewRingBuilderFromFile(builderPath, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, dev := range devs </span><span class="cov0" title="0">{
                builder.RemoveDev(dev.Id, purge)
        }</span>
        <span class="cov0" title="0">return builder.Save(builderPath)</span>
}

// Note that no locking is done here, you should call LockBuilderPath first.
func SetInfo(builderPath string, devs []*RingBuilderDevice, newIp string, newPort int64, newRepIp string, newRepPort int64, newDevice, newMeta string, newScheme string) error <span class="cov0" title="0">{
        builder, err := NewRingBuilderFromFile(builderPath, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, dev := range devs </span><span class="cov0" title="0">{
                err := builder.UpdateDevInfo(dev.Id, newIp, newPort, newRepIp, newRepPort, newDevice, newMeta, newScheme)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return builder.Save(builderPath)</span>
}

// Note that no locking is done here, you should call LockBuilderPath first.
func WriteRing(builderPath string) error <span class="cov0" title="0">{
        builder, err := NewRingBuilderFromFile(builderPath, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">r := builder.GetRing()
        if len(builder.replica2Part2Dev) == 0 </span><span class="cov0" title="0">{
                if len(builder.Devs) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Println("Warning: Writing a ring with no partiton assignments but with devices;  did you forget to run \"rebalance\"?")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("Warning: Writing an empty ring.")
                }</span>
        }
        <span class="cov0" title="0">backupPath := path.Join(path.Dir(builderPath), "backups")
        err = os.Mkdir(backupPath, 0777)
        if err != nil </span><span class="cov0" title="0">{
                e := err.(*os.PathError)
                if e.Err != syscall.EEXIST </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">ts := time.Now().UnixNano()
        ringFile := strings.TrimSuffix(builderPath, ".builder") + ".ring.gz"
        err = r.Save(path.Join(backupPath, fmt.Sprintf("%d.%s", ts, path.Base(ringFile))))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return r.Save(ringFile)</span>
}

// Note that no locking is done here, you should call LockBuilderPath first.
func PretendMinPartHoursPassed(builderPath string) error <span class="cov0" title="0">{
        builder, err := NewRingBuilderFromFile(builderPath, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">builder.PretendMinPartHoursPassed()
        return builder.Save(builderPath)</span>
}

// Note that no locking is done here, you should call LockBuilderPath first.
func Validate(builderPath string) error <span class="cov0" title="0">{
        builder, err := NewRingBuilderFromFile(builderPath, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = builder.Validate()
        return err</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package ring

import (
        "bufio"
        "context"
        "crypto/md5"
        "encoding/binary"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"

        opentracing "github.com/opentracing/opentracing-go"
)

const (
        jsonFlag    = 2
        opGet       = byte(0x00)
        opSet       = byte(0x01)
        opDelete    = byte(0x04)
        opIncrement = byte(0x05)
        opDecrement = byte(0x06)
        confSection = "filter:cache"
)

type MemcacheRing interface {
        Decr(ctx context.Context, key string, delta int64, timeout int) (int64, error)
        Delete(ctx context.Context, key string) error
        Get(ctx context.Context, key string) (interface{}, error)
        GetStructured(ctx context.Context, key string, val interface{}) error
        GetMulti(ctx context.Context, serverKey string, keys []string) (map[string]interface{}, error)
        Incr(ctx context.Context, key string, delta int64, timeout int) (int64, error)
        Set(ctx context.Context, key string, value interface{}, timeout int) error
        SetMulti(ctx context.Context, serverKey string, values map[string]interface{}, timeout int) error
}

type tracingMemcacheRing struct {
        MemcacheRing
        tracer opentracing.Tracer
}

func NewTracingMemcacheRing(mc MemcacheRing, tracer opentracing.Tracer) *tracingMemcacheRing <span class="cov0" title="0">{
        return &amp;tracingMemcacheRing{MemcacheRing: mc, tracer: tracer}
}</span>

func (r *tracingMemcacheRing) getSpanContext(ctx context.Context) opentracing.SpanContext <span class="cov0" title="0">{
        var parentContext opentracing.SpanContext
        if span := opentracing.SpanFromContext(ctx); span != nil </span><span class="cov0" title="0">{
                parentContext = span.Context()
        }</span>
        <span class="cov0" title="0">return parentContext</span>
}

func (r *tracingMemcacheRing) addKey(span opentracing.Span, key string) <span class="cov0" title="0">{
        if strings.HasPrefix(key, "account/") || strings.HasPrefix(key, "container/") </span><span class="cov0" title="0">{
                span.SetTag("key", key)
        }</span>
}

func (r *tracingMemcacheRing) addError(span opentracing.Span, err error) <span class="cov0" title="0">{
        if err == CacheMiss </span><span class="cov0" title="0">{
                span.SetTag("CacheMiss", true)
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                span.SetTag("error", true)
        }</span>
}

func (r *tracingMemcacheRing) Decr(ctx context.Context, key string, delta int64, timeout int) (int64, error) <span class="cov0" title="0">{
        mcSpan := r.tracer.StartSpan("Memcache Decr", opentracing.ChildOf(r.getSpanContext(ctx)))
        r.addKey(mcSpan, key)
        defer mcSpan.Finish()
        ret, err := r.MemcacheRing.Decr(ctx, key, delta, timeout)
        r.addError(mcSpan, err)
        return ret, err
}</span>

func (r *tracingMemcacheRing) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        mcSpan := r.tracer.StartSpan("Memcache Delete", opentracing.ChildOf(r.getSpanContext(ctx)))
        r.addKey(mcSpan, key)
        defer mcSpan.Finish()
        err := r.MemcacheRing.Delete(ctx, key)
        r.addError(mcSpan, err)
        return err
}</span>

func (r *tracingMemcacheRing) Get(ctx context.Context, key string) (interface{}, error) <span class="cov0" title="0">{
        mcSpan := r.tracer.StartSpan("Memcache Get", opentracing.ChildOf(r.getSpanContext(ctx)))
        r.addKey(mcSpan, key)
        defer mcSpan.Finish()
        ret, err := r.MemcacheRing.Get(ctx, key)
        r.addError(mcSpan, err)
        return ret, err
}</span>

func (r *tracingMemcacheRing) GetStructured(ctx context.Context, key string, val interface{}) error <span class="cov0" title="0">{
        mcSpan := r.tracer.StartSpan("Memcache GetStructured", opentracing.ChildOf(r.getSpanContext(ctx)))
        r.addKey(mcSpan, key)
        defer mcSpan.Finish()
        err := r.MemcacheRing.GetStructured(ctx, key, val)
        r.addError(mcSpan, err)
        return err
}</span>

func (r *tracingMemcacheRing) GetMulti(ctx context.Context, serverKey string, keys []string) (map[string]interface{}, error) <span class="cov0" title="0">{
        mcSpan := r.tracer.StartSpan("Memcache GetMulti", opentracing.ChildOf(r.getSpanContext(ctx)))
        r.addKey(mcSpan, serverKey)
        defer mcSpan.Finish()
        ret, err := r.MemcacheRing.GetMulti(ctx, serverKey, keys)
        r.addError(mcSpan, err)
        return ret, err
}</span>

func (r *tracingMemcacheRing) Incr(ctx context.Context, key string, delta int64, timeout int) (int64, error) <span class="cov0" title="0">{
        mcSpan := r.tracer.StartSpan("Memcache Incr", opentracing.ChildOf(r.getSpanContext(ctx)))
        r.addKey(mcSpan, key)
        defer mcSpan.Finish()
        ret, err := r.MemcacheRing.Incr(ctx, key, delta, timeout)
        r.addError(mcSpan, err)
        return ret, err
}</span>

func (r *tracingMemcacheRing) Set(ctx context.Context, key string, value interface{}, timeout int) error <span class="cov0" title="0">{
        mcSpan := r.tracer.StartSpan("Memcache Set", opentracing.ChildOf(r.getSpanContext(ctx)))
        r.addKey(mcSpan, key)
        defer mcSpan.Finish()
        err := r.MemcacheRing.Set(ctx, key, value, timeout)
        r.addError(mcSpan, err)
        return err
}</span>

func (r *tracingMemcacheRing) SetMulti(ctx context.Context, serverKey string, values map[string]interface{}, timeout int) error <span class="cov0" title="0">{
        mcSpan := r.tracer.StartSpan("Memcache SetMulti", opentracing.ChildOf(r.getSpanContext(ctx)))
        r.addKey(mcSpan, serverKey)
        defer mcSpan.Finish()
        err := r.MemcacheRing.SetMulti(ctx, serverKey, values, timeout)
        r.addError(mcSpan, err)
        return err
}</span>

type memcacheRing struct {
        ring                        map[string]string
        serverKeys                  []string
        servers                     map[string]*server
        connTimeout                 int64
        responseTimeout             int64
        maxFreeConnectionsPerServer int64
        tries                       int64
        nodeWeight                  int64
        tracing                     bool
}

func NewMemcacheRing(confPath string) (*memcacheRing, error) <span class="cov0" title="0">{
        config, err := conf.LoadConfig(confPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Unable to load conf file: %s: %s", confPath, err)
        }</span>
        <span class="cov0" title="0">return NewMemcacheRingFromConfig(config)</span>
}

func NewMemcacheRingFromConfig(config conf.Config) (*memcacheRing, error) <span class="cov0" title="0">{
        ring := &amp;memcacheRing{}
        ring.ring = make(map[string]string)
        ring.serverKeys = make([]string, 0)
        ring.servers = make(map[string]*server)

        ring.maxFreeConnectionsPerServer = config.GetInt(confSection, "max_free_connections_per_server", 100)
        ring.connTimeout = config.GetInt(confSection, "conn_timeout", 100)
        ring.responseTimeout = config.GetInt(confSection, "response_timeout", 100)
        ring.nodeWeight = config.GetInt(confSection, "node_weight", 50)
        ring.tries = config.GetInt(confSection, "tries", 5)
        for _, s := range strings.Split(config.GetDefault(confSection, "memcache_servers", ""), ",") </span><span class="cov0" title="0">{
                err := ring.addServer(s)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">if len(ring.servers) == 0 </span><span class="cov0" title="0">{
                ring.addServer("127.0.0.1:11211")
        }</span>
        <span class="cov0" title="0">ring.sortServerKeys()
        if int64(len(ring.servers)) &lt; ring.tries </span><span class="cov0" title="0">{
                ring.tries = int64(len(ring.servers))
        }</span>
        <span class="cov0" title="0">return ring, nil</span>
}

func hashKey(s string) string <span class="cov0" title="0">{
        h := md5.New()
        io.WriteString(h, s)
        return hex.EncodeToString(h.Sum(nil))
}</span>

func (ring *memcacheRing) addServer(serverString string) error <span class="cov0" title="0">{
        server, err := newServer(serverString, ring.connTimeout, ring.responseTimeout, ring.maxFreeConnectionsPerServer)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ring.servers[serverString] = server
        for i := 0; int64(i) &lt; ring.nodeWeight; i++ </span><span class="cov0" title="0">{
                ring.ring[hashKey(fmt.Sprintf("%s-%d", serverString, i))] = serverString
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (ring *memcacheRing) sortServerKeys() <span class="cov0" title="0">{
        ring.serverKeys = make([]string, 0)
        for k := range ring.ring </span><span class="cov0" title="0">{
                ring.serverKeys = append(ring.serverKeys, k)
        }</span>
        <span class="cov0" title="0">sort.Strings(ring.serverKeys)</span>
}

func (ring *memcacheRing) Decr(ctx context.Context, key string, delta int64, timeout int) (int64, error) <span class="cov0" title="0">{
        return ring.Incr(ctx, key, -delta, timeout)
}</span>

func (ring *memcacheRing) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        fn := func(conn *connection) error </span><span class="cov0" title="0">{
                _, _, err := conn.roundTripPacket(opDelete, hashKey(key), nil, nil)
                if err != nil &amp;&amp; err != CacheMiss </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">return ring.loop(key, fn)</span>
}

func (ring *memcacheRing) GetStructured(ctx context.Context, key string, val interface{}) error <span class="cov0" title="0">{
        fn := func(conn *connection) error </span><span class="cov0" title="0">{
                value, extras, err := conn.roundTripPacket(opGet, hashKey(key), nil, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">flags := binary.BigEndian.Uint32(extras[0:4])
                if flags&amp;jsonFlag == 0 </span><span class="cov0" title="0">{
                        return errors.New("Not json data")
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(value, val); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">return ring.loop(key, fn)</span>
}

func (ring *memcacheRing) Get(ctx context.Context, key string) (interface{}, error) <span class="cov0" title="0">{
        type Return struct {
                value interface{}
        }
        ret := &amp;Return{}
        fn := func(conn *connection) error </span><span class="cov0" title="0">{
                value, extras, err := conn.roundTripPacket(opGet, hashKey(key), nil, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">flags := binary.BigEndian.Uint32(extras[0:4])
                if flags&amp;jsonFlag != 0 </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(value, &amp;ret.value); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        ret.value = value
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">return ret.value, ring.loop(key, fn)</span>
}

func (ring *memcacheRing) GetMulti(ctx context.Context, serverKey string, keys []string) (map[string]interface{}, error) <span class="cov0" title="0">{
        type Return struct {
                value map[string]interface{}
        }
        ret := &amp;Return{}
        fn := func(conn *connection) error </span><span class="cov0" title="0">{
                ret.value = make(map[string]interface{})
                for _, key := range keys </span><span class="cov0" title="0">{
                        if err := conn.sendPacket(opGet, hashKey(key), nil, nil); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">for _, key := range keys </span><span class="cov0" title="0">{
                        value, extras, err := conn.receivePacket()
                        if err != nil </span><span class="cov0" title="0">{
                                if err == CacheMiss </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">return err</span>
                        }
                        <span class="cov0" title="0">flags := binary.BigEndian.Uint32(extras[0:4])
                        if flags&amp;jsonFlag != 0 </span><span class="cov0" title="0">{
                                var v interface{}
                                if err := json.Unmarshal(value, &amp;v); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">ret.value[key] = v</span>
                        } else<span class="cov0" title="0"> {
                                ret.value[key] = value
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">return ret.value, ring.loop(serverKey, fn)</span>
}

func (ring *memcacheRing) Incr(ctx context.Context, key string, delta int64, timeout int) (int64, error) <span class="cov0" title="0">{
        type Return struct {
                value int64
        }
        ret := &amp;Return{}
        op := opIncrement
        dfl := delta
        if delta &lt; 0 </span><span class="cov0" title="0">{
                op = opDecrement
                delta = 0 - delta
                dfl = 0
        }</span>
        <span class="cov0" title="0">extras := make([]byte, 20)
        binary.BigEndian.PutUint64(extras[0:8], uint64(delta))
        binary.BigEndian.PutUint64(extras[8:16], uint64(dfl))
        binary.BigEndian.PutUint32(extras[16:20], uint32(timeout))
        fn := func(conn *connection) error </span><span class="cov0" title="0">{
                value, _, err := conn.roundTripPacket(op, hashKey(key), nil, extras)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">ret.value = int64(binary.BigEndian.Uint64(value[0:8]))
                return nil</span>
        }
        <span class="cov0" title="0">return ret.value, ring.loop(key, fn)</span>
}

func (ring *memcacheRing) Set(ctx context.Context, key string, value interface{}, timeout int) error <span class="cov0" title="0">{
        serl, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">extras := make([]byte, 8)
        binary.BigEndian.PutUint32(extras[0:4], uint32(jsonFlag))
        binary.BigEndian.PutUint32(extras[4:8], uint32(timeout))
        fn := func(conn *connection) error </span><span class="cov0" title="0">{
                _, _, err = conn.roundTripPacket(opSet, hashKey(key), serl, extras)
                return err
        }</span>
        <span class="cov0" title="0">return ring.loop(key, fn)</span>
}

func (ring *memcacheRing) SetMulti(ctx context.Context, serverKey string, values map[string]interface{}, timeout int) error <span class="cov0" title="0">{
        fn := func(conn *connection) error </span><span class="cov0" title="0">{
                for key, value := range values </span><span class="cov0" title="0">{
                        serl, err := json.Marshal(value)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">extras := make([]byte, 8)
                        binary.BigEndian.PutUint32(extras[0:4], uint32(jsonFlag))
                        binary.BigEndian.PutUint32(extras[4:8], uint32(timeout))
                        if err = conn.sendPacket(opSet, hashKey(key), serl, extras); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">for range values </span><span class="cov0" title="0">{
                        if _, _, err := conn.receivePacket(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">return ring.loop(serverKey, fn)</span>
}

type serverIterator struct {
        ring    *memcacheRing
        key     string
        current int
        servers []string
}

func (ring *memcacheRing) newServerIterator(key string) *serverIterator <span class="cov0" title="0">{
        return &amp;serverIterator{ring, hashKey(key), -1, make([]string, 0)}
}</span>

func (it *serverIterator) next() bool <span class="cov0" title="0">{
        return int64(len(it.servers)) &lt; it.ring.tries
}</span>

func (it *serverIterator) value() *server <span class="cov0" title="0">{
        if int64(len(it.servers)) &gt; it.ring.tries </span><span class="cov0" title="0">{
                panic("serverIterator.Value() called when there are no more tries left")</span>
        }
        <span class="cov0" title="0">if it.current == -1 </span><span class="cov0" title="0">{
                it.current = sort.SearchStrings(it.ring.serverKeys, it.key) % len(it.ring.serverKeys)
        }</span> else<span class="cov0" title="0"> {
                for common.StringInSlice(it.ring.ring[it.ring.serverKeys[it.current]], it.servers) </span><span class="cov0" title="0">{
                        it.current = (it.current + 1) % len(it.ring.serverKeys)
                }</span>
        }
        <span class="cov0" title="0">serverString := it.ring.ring[it.ring.serverKeys[it.current]]
        it.servers = append(it.servers, serverString)
        return it.ring.servers[serverString]</span>
}

var noServersError = errors.New("no memcache servers in ring")

func (ring *memcacheRing) loop(key string, fn func(*connection) error) error <span class="cov0" title="0">{
        err := noServersError
        it := ring.newServerIterator(key)
        for it.next() </span><span class="cov0" title="0">{
                server := it.value()
                var conn *connection
                conn, err = server.getConnection()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">err = fn(conn)
                server.releaseConnection(conn, err)
                if err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span> else<span class="cov0" title="0"> if err == CacheMiss </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return err</span>
}

type server struct {
        serverString       string
        addr               net.Addr
        lock               sync.Mutex
        connTimeout        time.Duration
        requestTimeout     time.Duration
        maxFreeConnections int64
        connections        []*connection
}

func newServer(serverString string, connTimeout int64, requestTimeout int64, maxFreeConnections int64) (*server, error) <span class="cov0" title="0">{
        var addr net.Addr
        var err error
        s := server{serverString: serverString}
        if strings.Contains(serverString, "/") </span><span class="cov0" title="0">{
                addr, err = net.ResolveUnixAddr("unix", serverString)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                if !strings.Contains(serverString, ":") </span><span class="cov0" title="0">{
                        serverString = fmt.Sprintf("%s:11211", serverString)
                }</span>
                <span class="cov0" title="0">addr, err = net.ResolveTCPAddr("tcp", serverString)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">s.addr = addr
        s.connTimeout = time.Duration(connTimeout) * time.Millisecond
        s.requestTimeout = time.Duration(requestTimeout) * time.Millisecond
        s.maxFreeConnections = maxFreeConnections
        s.connections = make([]*connection, 0)
        return &amp;s, nil</span>
}

func (s *server) connectionCount() uint64 <span class="cov0" title="0">{
        return uint64(len(s.connections))
}</span>

func (s *server) getExistingConnection() *connection <span class="cov0" title="0">{
        s.lock.Lock()
        defer s.lock.Unlock()
        if len(s.connections) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">conn := s.connections[len(s.connections)-1]
        s.connections = s.connections[:len(s.connections)-1]
        return conn</span>
}

func (s *server) getConnection() (*connection, error) <span class="cov0" title="0">{
        conn := s.getExistingConnection()
        if conn != nil </span><span class="cov0" title="0">{
                return conn, nil
        }</span>
        <span class="cov0" title="0">return newConnection(s.serverString, s.connTimeout, s.requestTimeout)</span>
}

func (s *server) releaseConnection(conn *connection, err error) <span class="cov0" title="0">{
        if err == nil || err == CacheMiss </span><span class="cov0" title="0">{
                s.lock.Lock()
                defer s.lock.Unlock()
                if int64(len(s.connections)) &lt; s.maxFreeConnections </span><span class="cov0" title="0">{
                        s.connections = append(s.connections, conn)
                        return
                }</span>
        }
        <span class="cov0" title="0">conn.close()</span>
}

var CacheMiss = fmt.Errorf("Server cache miss")

type connection struct {
        conn       net.Conn
        rw         *bufio.ReadWriter
        reqTimeout time.Duration
        packetBuf  []byte
}

func newConnection(address string, connTimeout time.Duration, requestTimeout time.Duration) (*connection, error) <span class="cov0" title="0">{
        domain := "tcp"
        if strings.Contains(address, "/") </span><span class="cov0" title="0">{
                domain = "unix"
        }</span> else<span class="cov0" title="0"> if !strings.Contains(address, ":") </span><span class="cov0" title="0">{
                address = fmt.Sprintf("%s:%d", address, 11211)
        }</span>
        <span class="cov0" title="0">conn, err := net.DialTimeout(domain, address, connTimeout)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if c, ok := conn.(*net.TCPConn); ok </span><span class="cov0" title="0">{
                c.SetNoDelay(true)
        }</span>
        <span class="cov0" title="0">return &amp;connection{
                conn:       conn,
                rw:         bufio.NewReadWriter(bufio.NewReader(conn), bufio.NewWriter(conn)),
                reqTimeout: requestTimeout,
                packetBuf:  make([]byte, 256),
        }, nil</span>
}

func (c *connection) close() error <span class="cov0" title="0">{
        return c.conn.Close()
}</span>

func (c *connection) receivePacket() ([]byte, []byte, error) <span class="cov0" title="0">{
        packet := c.packetBuf[0:24]
        if _, err := io.ReadFull(c.rw, packet); err != nil </span><span class="cov0" title="0">{
                c.close()
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">keyLen := binary.BigEndian.Uint16(packet[2:4])
        extrasLen := packet[4]
        status := binary.BigEndian.Uint16(packet[6:8])
        bodyLen := int(binary.BigEndian.Uint32(packet[8:12]))
        for cap(c.packetBuf) &lt; bodyLen </span><span class="cov0" title="0">{
                c.packetBuf = append(c.packetBuf, ' ')
        }</span>
        <span class="cov0" title="0">body := c.packetBuf[0:bodyLen]
        if _, err := io.ReadFull(c.rw, body); err != nil </span><span class="cov0" title="0">{
                c.close()
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">switch status </span>{
        case 0:<span class="cov0" title="0">
                return body[int(keyLen)+int(extrasLen) : int(bodyLen)], body[int(keyLen):int(extrasLen)], nil</span>
        case 1:<span class="cov0" title="0">
                return nil, nil, CacheMiss</span>
        default:<span class="cov0" title="0">
                return nil, nil, fmt.Errorf("Error response from memcache: %d", status)</span>
        }
}

func (c *connection) roundTripPacket(opcode byte, hashKey string, value []byte, extras []byte) ([]byte, []byte, error) <span class="cov0" title="0">{
        if err := c.sendPacket(opcode, hashKey, value, extras); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return c.receivePacket()</span>
}

func (c *connection) sendPacket(opcode byte, hashKey string, value []byte, extras []byte) error <span class="cov0" title="0">{
        key := []byte(hashKey)
        c.conn.SetDeadline(time.Now().Add(c.reqTimeout))
        packet := c.packetBuf[0:24]
        packet[0], packet[1], packet[4], packet[5] = 0x80, opcode, byte(len(extras)), 0
        binary.BigEndian.PutUint16(packet[2:4], uint16(len(key)))
        packet[6], packet[7] = 0, 0
        binary.BigEndian.PutUint32(packet[8:12], uint32(len(key)+len(value)+len(extras)))
        packet[12], packet[13], packet[14], packet[15] = 0, 0, 0, 0
        packet[16], packet[17], packet[18], packet[19], packet[20], packet[21], packet[22], packet[23] = 0, 0, 0, 0, 0, 0, 0, 0
        packet = append(append(append(packet, extras...), key...), value...)
        if _, err := c.rw.Write(packet); err != nil || c.rw.Flush() != nil </span><span class="cov0" title="0">{
                c.close()
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package ring

import (
        "compress/gzip"
        "crypto/md5"
        "encoding/binary"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"
)

const reloadTime = 15 * time.Second

type Ring interface {
        GetNodes(partition uint64) (response []*Device)
        GetJobNodes(partition uint64, localDevice int) (response []*Device, handoff bool)
        GetPartition(account string, container string, object string) uint64
        LocalDevices(localPort int) (devs []*Device, err error)
        AllDevices() (devs []*Device)
        GetMoreNodes(partition uint64) MoreNodes
        ReplicaCount() (cnt uint64)
        PartitionCount() (cnt uint64)
        PartitionForHash(string) (uint64, error)
}

type MoreNodes interface {
        Next() *Device
}

type Device struct {
        Id              int     `json:"id"`
        Device          string  `json:"device"`
        Scheme          string  `json:"scheme"`
        Ip              string  `json:"ip"`
        Meta            string  `json:"meta"`
        Port            int     `json:"port"`
        Region          int     `json:"region"`
        ReplicationIp   string  `json:"replication_ip"`
        ReplicationPort int     `json:"replication_port"`
        Weight          float64 `json:"weight"`
        Zone            int     `json:"zone"`
}

type RingMD5 interface {
        Ring
        MD5() string
        DiskPath() string
        RingMatching(md5 string) RingMD5
        Reload() error
        AssignmentCount(devId int) int
}

type ringData struct {
        Devs                                []*Device `json:"devs"`
        ReplicaCount                        int       `json:"replica_count"`
        PartShift                           uint64    `json:"part_shift"`
        replica2part2devId                  [][]uint16
        regionCount, zoneCount, ipPortCount int
        md5                                 string
}

type hashRing struct {
        data    atomic.Value
        path    string
        prefix  string
        suffix  string
        mtime   time.Time
        calcMD5 bool
}

type regionZone struct {
        region, zone int
}

type ipPort struct {
        region, zone, port int
        ip                 string
}

type hashMoreNodes struct {
        r                 *hashRing
        used, sameRegions map[int]bool
        sameZones         map[regionZone]bool
        sameIpPorts       map[ipPort]bool
        parts, start, inc int
        partition         uint64
        m                 sync.Mutex
}

func (d *Device) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("Device{Id: %d, Device: %s, Ip: %s, Port: %d}", d.Id, d.Device, d.Ip, d.Port)
}</span>

func (d *Device) Active() bool <span class="cov8" title="1">{
        return d != nil &amp;&amp; d.Weight &gt;= 0
}</span>

func (r *hashRing) getData() *ringData <span class="cov8" title="1">{
        return r.data.Load().(*ringData)
}</span>

func (r *hashRing) GetNodes(partition uint64) (response []*Device) <span class="cov8" title="1">{
        d := r.getData()
        if partition &gt;= uint64(len(d.replica2part2devId[0])) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; d.ReplicaCount; i++ </span><span class="cov8" title="1">{
                response = append(response, d.Devs[d.replica2part2devId[i][partition]])
        }</span>
        <span class="cov8" title="1">return response</span>
}

func (r *hashRing) GetJobNodes(partition uint64, localDevice int) (response []*Device, handoff bool) <span class="cov8" title="1">{
        d := r.getData()
        handoff = true
        if partition &gt;= uint64(len(d.replica2part2devId[0])) </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; d.ReplicaCount; i++ </span><span class="cov8" title="1">{
                dev := d.Devs[d.replica2part2devId[i][partition]]
                if dev.Id == localDevice </span><span class="cov8" title="1">{
                        handoff = false
                }</span> else<span class="cov8" title="1"> {
                        response = append(response, dev)
                }</span>
        }
        <span class="cov8" title="1">return response, handoff</span>
}

func (r *hashRing) GetPartition(account string, container string, object string) uint64 <span class="cov0" title="0">{
        d := r.getData()
        hash := md5.New()
        hash.Write([]byte(r.prefix + "/" + account))
        if container != "" </span><span class="cov0" title="0">{
                hash.Write([]byte("/" + container))
                if object != "" </span><span class="cov0" title="0">{
                        hash.Write([]byte("/" + object))
                }</span>
        }
        <span class="cov0" title="0">hash.Write([]byte(r.suffix))
        digest := hash.Sum(nil)
        // treat as big endian unsigned int
        val := uint64(digest[0])&lt;&lt;24 | uint64(digest[1])&lt;&lt;16 | uint64(digest[2])&lt;&lt;8 | uint64(digest[3])
        return val &gt;&gt; d.PartShift</span>
}

// uses first 8 bytes of hsh to figure out partition
func (r *hashRing) PartitionForHash(hsh string) (uint64, error) <span class="cov0" title="0">{
        hshi, err := strconv.ParseUint(hsh[:8], 16, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return hshi &gt;&gt; r.getData().PartShift, nil</span>
}

func (r *hashRing) LocalDevices(localPort int) (devs []*Device, err error) <span class="cov8" title="1">{
        d := r.getData()
        var localIPs = make(map[string]bool)

        localAddrs, err := net.InterfaceAddrs()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for _, addr := range localAddrs </span><span class="cov8" title="1">{
                localIPs[strings.Split(addr.String(), "/")[0]] = true
        }</span>

        <span class="cov8" title="1">for i, dev := range d.Devs </span><span class="cov8" title="1">{
                if !dev.Active() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if localIPs[dev.ReplicationIp] &amp;&amp; dev.ReplicationPort == localPort </span><span class="cov8" title="1">{
                        devs = append(devs, d.Devs[i])
                }</span>
        }
        <span class="cov8" title="1">return devs, nil</span>
}

func (r *hashRing) AllDevices() (devs []*Device) <span class="cov0" title="0">{
        d := r.getData()
        return d.Devs
}</span>

func (r *hashRing) GetMoreNodes(partition uint64) MoreNodes <span class="cov0" title="0">{
        return &amp;hashMoreNodes{r: r, partition: partition, used: nil}
}</span>

func (r *hashRing) ReplicaCount() (cnt uint64) <span class="cov8" title="1">{
        d := r.getData()
        return uint64(len(d.replica2part2devId))
}</span>

func (r *hashRing) PartitionCount() (cnt uint64) <span class="cov8" title="1">{
        d := r.getData()
        return uint64(len(d.replica2part2devId[0]))
}</span>

func (r *hashRing) MD5() string <span class="cov0" title="0">{
        d := r.getData()
        return d.md5
}</span>

func (r *hashRing) DiskPath() string <span class="cov0" title="0">{
        return r.path
}</span>

func (r *hashRing) RingMatching(md5 string) RingMD5 <span class="cov0" title="0">{
        d := r.getData()
        if d.md5 == md5 </span><span class="cov0" title="0">{
                if r2, err := LoadRingMD5(r.path, r.prefix, r.suffix); err == nil </span><span class="cov0" title="0">{
                        return r2
                }</span>
        }
        <span class="cov0" title="0">backupsDir := filepath.Join(filepath.Dir(r.path), "backups")
        f, err := os.Open(backupsDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">fis, err := f.Readdir(-1)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        // object.ring.gz =&gt; ["object"]
        // object-1.ring.gz =&gt; ["object", "1"]
        <span class="cov0" title="0">parts := strings.SplitN(strings.SplitN(filepath.Base(r.path), ".", 2)[0], "-", 2)
        typ := parts[0]
        policyString := ""
        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                policyString = parts[1]
        }</span>
        <span class="cov0" title="0">for _, fi := range fis </span><span class="cov0" title="0">{
                if fi.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if !strings.HasSuffix(fi.Name(), ".ring.gz") </span><span class="cov0" title="0">{
                        continue</span>
                }
                // 1520549739234856985.object.ring.gz =&gt; ["1520549739234856985", "object.ring.gz"]
                // 1520549739289612841.object-1.ring.gz =&gt; ["1520549739289612841", "object-1.ring.gz"]
                <span class="cov0" title="0">parts = strings.SplitN(fi.Name(), ".", 2)
                if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                        continue</span>
                }
                // object.ring.gz =&gt; ["object"]
                // object-1.ring.gz =&gt; ["object", "1"]
                <span class="cov0" title="0">parts = strings.SplitN(strings.SplitN(parts[1], ".", 2)[0], "-", 2)
                if parts[0] != typ </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if len(parts) &lt; 2 &amp;&amp; policyString != "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if len(parts) &gt; 1 &amp;&amp; parts[1] != policyString </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">r2, err := LoadRingMD5(filepath.Join(backupsDir, fi.Name()), r.prefix, r.suffix)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if r2.MD5() == md5 </span><span class="cov0" title="0">{
                        return r2
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (r *hashRing) Reload() error <span class="cov8" title="1">{
        fi, err := os.Stat(r.path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if fi.ModTime() == r.mtime </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">data := &amp;ringData{}
        fp, err := os.Open(r.path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer fp.Close()
        if r.calcMD5 </span><span class="cov0" title="0">{
                h := md5.New()
                if _, err := io.Copy(h, fp); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">data.md5 = fmt.Sprintf("%x", h.Sum(nil))
                fp.Seek(0, 0)</span>
        }
        <span class="cov8" title="1">gz, err := gzip.NewReader(fp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">magicBuf := make([]byte, 4)
        io.ReadFull(gz, magicBuf)
        if string(magicBuf) != "R1NG" </span><span class="cov0" title="0">{
                return errors.New("Bad magic string")
        }</span>
        <span class="cov8" title="1">var ringVersion uint16
        binary.Read(gz, binary.BigEndian, &amp;ringVersion)
        if ringVersion != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("Unknown ring version %d", ringVersion)
        }</span>
        <span class="cov8" title="1">var json_len uint32
        binary.Read(gz, binary.BigEndian, &amp;json_len)
        jsonBuf := make([]byte, json_len)
        io.ReadFull(gz, jsonBuf)
        if err := json.Unmarshal(jsonBuf, data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">partitionCount := 1 &lt;&lt; (32 - data.PartShift)
        for i := 0; i &lt; data.ReplicaCount; i++ </span><span class="cov8" title="1">{
                part2dev := make([]uint16, partitionCount)
                binary.Read(gz, binary.LittleEndian, &amp;part2dev)
                data.replica2part2devId = append(data.replica2part2devId, part2dev)
        }</span>
        <span class="cov8" title="1">regionCount := make(map[int]bool)
        zoneCount := make(map[regionZone]bool)
        ipPortCount := make(map[ipPort]bool)
        for _, d := range data.Devs </span><span class="cov8" title="1">{
                if !d.Active() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if d.ReplicationIp == "" </span><span class="cov8" title="1">{
                        d.ReplicationIp = d.Ip
                }</span>
                <span class="cov8" title="1">if d.ReplicationPort == 0 </span><span class="cov8" title="1">{
                        d.ReplicationPort = d.Port + 500
                }</span>
                <span class="cov8" title="1">if d.Scheme == "" </span><span class="cov0" title="0">{
                        d.Scheme = "http"
                }</span>
                <span class="cov8" title="1">regionCount[d.Region] = true
                zoneCount[regionZone{d.Region, d.Zone}] = true
                ipPortCount[ipPort{d.Region, d.Zone, d.Port, d.Ip}] = true</span>
        }
        <span class="cov8" title="1">data.regionCount = len(regionCount)
        data.zoneCount = len(zoneCount)
        data.ipPortCount = len(ipPortCount)
        r.mtime = fi.ModTime()
        r.data.Store(data)
        return nil</span>
}

func (r *hashRing) reloader() error <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                time.Sleep(reloadTime)
                r.Reload()
        }</span>
}

func (r *hashRing) AssignmentCount(devId int) int <span class="cov0" title="0">{
        count := 0
        for _, part2devId := range r.getData().replica2part2devId </span><span class="cov0" title="0">{
                for _, rDevId := range part2devId </span><span class="cov0" title="0">{
                        if int(rDevId) == devId </span><span class="cov0" title="0">{
                                count++
                        }</span>
                }
        }
        <span class="cov0" title="0">return count</span>
}

func (m *hashMoreNodes) addDevice(d *Device) <span class="cov0" title="0">{
        m.used[d.Id] = true
        m.sameRegions[d.Region] = true
        m.sameZones[regionZone{d.Region, d.Zone}] = true
        m.sameIpPorts[ipPort{d.Region, d.Zone, d.Port, d.Ip}] = true
}</span>

func (m *hashMoreNodes) initialize() <span class="cov0" title="0">{
        d := m.r.getData()
        m.parts = len(d.replica2part2devId[0])
        m.used = make(map[int]bool)
        m.sameRegions = make(map[int]bool)
        m.sameZones = make(map[regionZone]bool)
        m.sameIpPorts = make(map[ipPort]bool)
        for _, mp := range d.replica2part2devId </span><span class="cov0" title="0">{
                m.addDevice(d.Devs[mp[m.partition]])
        }</span>
        <span class="cov0" title="0">hash := md5.New()
        hash.Write([]byte(strconv.FormatUint(m.partition, 10)))
        digest := hash.Sum(nil)
        m.start = int((uint64(digest[0])&lt;&lt;24 | uint64(digest[1])&lt;&lt;16 | uint64(digest[2])&lt;&lt;8 | uint64(digest[3])) &gt;&gt; d.PartShift)
        m.inc = m.parts / 65536
        if m.inc == 0 </span><span class="cov0" title="0">{
                m.inc = 1
        }</span>
}

func (m *hashMoreNodes) Next() *Device <span class="cov0" title="0">{
        m.m.Lock()
        defer m.m.Unlock()
        d := m.r.getData()
        if m.used == nil </span><span class="cov0" title="0">{
                m.initialize()
        }</span>
        <span class="cov0" title="0">var check func(d *Device) bool
        if len(m.sameRegions) &lt; d.regionCount </span><span class="cov0" title="0">{
                check = func(d *Device) bool </span><span class="cov0" title="0">{ return !m.sameRegions[d.Region] }</span>
        } else<span class="cov0" title="0"> if len(m.sameZones) &lt; d.zoneCount </span><span class="cov0" title="0">{
                check = func(d *Device) bool </span><span class="cov0" title="0">{ return !m.sameZones[regionZone{d.Region, d.Zone}] }</span>
        } else<span class="cov0" title="0"> if len(m.sameIpPorts) &lt; d.ipPortCount </span><span class="cov0" title="0">{
                check = func(d *Device) bool </span><span class="cov0" title="0">{ return !m.sameIpPorts[ipPort{d.Region, d.Zone, d.Port, d.Ip}] }</span>
        } else<span class="cov0" title="0"> {
                check = func(d *Device) bool </span><span class="cov0" title="0">{ return !m.used[d.Id] }</span>
        }
        <span class="cov0" title="0">for i := 0; i &lt; m.parts; i += m.inc </span><span class="cov0" title="0">{
                handoffPart := (i + m.start) % m.parts
                for _, part2devId := range d.replica2part2devId </span><span class="cov0" title="0">{
                        if handoffPart &lt; len(part2devId) </span><span class="cov0" title="0">{
                                if check(d.Devs[part2devId[handoffPart]]) </span><span class="cov0" title="0">{
                                        m.addDevice(d.Devs[part2devId[handoffPart]])
                                        return d.Devs[part2devId[handoffPart]]
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

var loadedRingsLock sync.Mutex
var loadedRings map[string]*hashRing = make(map[string]*hashRing)

func LoadRing(path string, prefix string, suffix string) (Ring, error) <span class="cov8" title="1">{
        loadedRingsLock.Lock()
        defer loadedRingsLock.Unlock()
        ring := loadedRings[path]
        if ring == nil </span><span class="cov8" title="1">{
                ring = &amp;hashRing{prefix: prefix, suffix: suffix, path: path, mtime: time.Unix(0, 0)}
                if err := ring.Reload(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">go ring.reloader()
                loadedRings[path] = ring</span>
        }
        <span class="cov8" title="1">return ring, nil</span>
}

func LoadRingMD5(path string, prefix string, suffix string) (RingMD5, error) <span class="cov0" title="0">{
        ring := &amp;hashRing{prefix: prefix, suffix: suffix, path: path, mtime: time.Unix(0, 0), calcMD5: true}
        if err := ring.Reload(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ring, nil</span>
}

// save serializes the hashRing to disk
func (r *hashRing) Save(filename string) error <span class="cov0" title="0">{
        // NOTE: the swift ringbuilder puts a time in, do we really need this?
        fp, err := os.Create(filename)
        defer fp.Close()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">gz := gzip.NewWriter(fp)
        defer gz.Close()
        // Write out the magic string
        _, err = gz.Write([]byte("R1NG"))
        // Write out the version (1)
        ringVersion := uint16(1)
        binary.Write(gz, binary.BigEndian, &amp;ringVersion)
        // Generate the json data
        data := r.getData()
        dataBuf, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">json_len := uint32(len(dataBuf))
        // Write out the json length
        binary.Write(gz, binary.BigEndian, &amp;json_len)
        // Write the json
        gz.Write(dataBuf)
        // Write replica2part2devId
        d := r.getData()
        for i := range d.replica2part2devId </span><span class="cov0" title="0">{
                if err := binary.Write(gz, binary.LittleEndian, d.replica2part2devId[i]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetRing returns the current ring given the ring_type ("account", "container", "object"),
// hash path prefix, and hash path suffix. An error is returned if the requested ring does
// not exist.
func GetRing(ringType, prefix, suffix string, policy int) (Ring, error) <span class="cov8" title="1">{
        ring, err := getRingLogic(ringType, prefix, suffix, policy, LoadRing)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return ring, nil</span>
}

// GetRingMD5 returns the current ring given the ring_type ("account",
// "container", "object"), hash path prefix, and hash path suffix. An error is
// returned if the requested ring does not exist. This differs from GetRing in
// that it returns a ring satisfying the RingMD5 interface and that it will
// compute the MD5 hash of the ring's persisted contents. Also, it will not
// automatically reload itself -- an explicit Reload is required.
func GetRingMD5(ringType, prefix, suffix string, policy int) (RingMD5, error) <span class="cov0" title="0">{
        ring, err := getRingLogic(
                ringType, prefix, suffix, policy,
                func(path string, prefix string, suffix string) (Ring, error) </span><span class="cov0" title="0">{
                        ring, err := LoadRingMD5(path, prefix, suffix)
                        return ring, err
                }</span>,
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ring.(RingMD5), nil</span>
}

func getRingLogic(ringType, prefix, suffix string, policy int, loadRing func(path string, prefix string, suffix string) (Ring, error)) (Ring, error) <span class="cov8" title="1">{
        var ring Ring
        var err error
        var err2 error
        ringFile := fmt.Sprintf("%s.ring.gz", ringType)
        if policy != 0 </span><span class="cov8" title="1">{
                ringFile = fmt.Sprintf("%s-%d.ring.gz", ringType, policy)
        }</span>
        <span class="cov8" title="1">if ring, err = loadRing(fmt.Sprintf("/etc/hummingbird/%s", ringFile), prefix, suffix); err != nil </span><span class="cov0" title="0">{
                if ring, err2 = loadRing(fmt.Sprintf("/etc/swift/%s", ringFile), prefix, suffix); err2 != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Error loading %s:%d ring: %s: %s", ringType, policy, err, err2)
                }</span>
        }
        <span class="cov8" title="1">return ring, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package srv

import (
        "context"
        "net/http"
)

type KeyType int

const logkey KeyType = iota

func GetLogger(r *http.Request) LowLevelLogger <span class="cov8" title="1">{
        if rv := r.Context().Value(logkey); rv != nil </span><span class="cov8" title="1">{
                return rv.(LowLevelLogger)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func SetLogger(r *http.Request, l LowLevelLogger) *http.Request <span class="cov8" title="1">{
        return r.WithContext(context.WithValue(r.Context(), logkey, l))
}</span>

func GetVars(r *http.Request) map[string]string <span class="cov8" title="1">{
        if rv := r.Context().Value("vars"); rv != nil </span><span class="cov8" title="1">{
                return rv.(map[string]string)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func SetVars(r *http.Request, v map[string]string) *http.Request <span class="cov8" title="1">{
        return r.WithContext(context.WithValue(r.Context(), "vars", v))
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package srv

import (
        "net/http"
        "strconv"
        "strings"

        "github.com/troubling/hummingbird/common"
)

type variable struct {
        name string
        pos  int
}

type matcher struct {
        method       string
        length       int
        hasCatchall  bool
        endSlash     bool
        catchallName string
        vars         []variable
        static       []variable
        policy       int
        handler      http.Handler
}

type router struct {
        matchers                []*matcher
        staticMatchers          []*matcher
        NotFoundHandler         http.Handler
        MethodNotAllowedHandler http.Handler
}

const anyPolicy = -1

// Split a string in twain on sep.  Doing it this way over strings.Split*() saves allocating a slice.
func Split2(path string, sep string) (string, string) <span class="cov8" title="1">{
        if nextSlash := strings.Index(path, sep); nextSlash == -1 </span><span class="cov8" title="1">{
                return path, ""
        }</span> else<span class="cov8" title="1"> {
                return path[:nextSlash], path[nextSlash+1:]
        }</span>
}

// Given a method and path, return the handler and vars that should be used to serve them.
func (r *router) route(method, path string, policy int) (http.Handler, map[string]string) <span class="cov8" title="1">{
        methodFound := false
        path = path[1:]
        slashCount := strings.Count(path, "/")
        // This code is slightly gnarly because it avoids allocating anything until it's sure of a match.
        for i := 0; i &lt; 2; i++ </span><span class="cov8" title="1">{
                matchers := r.staticMatchers
                if i == 1 </span><span class="cov8" title="1">{
                        matchers = r.matchers
                }</span>
        <span class="cov8" title="1">NEXTMATCH:
                for _, m := range matchers </span><span class="cov8" title="1">{
                        if m.policy != anyPolicy &amp;&amp; m.policy != policy </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if m.method != method </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">methodFound = true
                        if !m.hasCatchall &amp;&amp; len(path) != 0 &amp;&amp; m.endSlash != (path[len(path)-1] == '/') </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if slashCount+1 == m.length || (m.hasCatchall &amp;&amp; slashCount+1 &gt; m.length) </span><span class="cov8" title="1">{
                                var vars map[string]string

                                // make sure all static parts of the route match the pattern
                                j := 0
                                part, tmppath := Split2(path, "/")
                                for _, s := range m.static </span><span class="cov8" title="1">{
                                        for ; j &lt; s.pos; j++ </span><span class="cov8" title="1">{
                                                part, tmppath = Split2(tmppath, "/")
                                        }</span>
                                        <span class="cov8" title="1">if s.name != part </span><span class="cov8" title="1">{
                                                continue NEXTMATCH</span>
                                        }
                                }

                                // if there's a catchall, grab it from the end of the path.
                                <span class="cov8" title="1">if m.hasCatchall </span><span class="cov8" title="1">{
                                        tmppath = path
                                        for i := 0; i &lt; m.length-1; i++ </span><span class="cov8" title="1">{
                                                _, tmppath = Split2(tmppath, "/")
                                        }</span>
                                        <span class="cov8" title="1">if tmppath == "" </span><span class="cov8" title="1">{
                                                continue NEXTMATCH</span>
                                        }
                                        <span class="cov8" title="1">vars = map[string]string{m.catchallName: tmppath}</span>
                                } else<span class="cov8" title="1"> {
                                        vars = make(map[string]string, len(m.vars))
                                }</span>

                                // extract any vars
                                <span class="cov8" title="1">j = 0
                                part, tmppath = Split2(path, "/")
                                for _, s := range m.vars </span><span class="cov8" title="1">{
                                        for ; j &lt; s.pos; j++ </span><span class="cov8" title="1">{
                                                part, tmppath = Split2(tmppath, "/")
                                        }</span>
                                        <span class="cov8" title="1">vars[s.name] = part</span>
                                }
                                <span class="cov8" title="1">return m.handler, vars</span>
                        }
                }
        }
        <span class="cov8" title="1">if !methodFound </span><span class="cov8" title="1">{
                return r.MethodNotAllowedHandler, nil
        }</span>
        <span class="cov8" title="1">return r.NotFoundHandler, nil</span>
}

// HandlePolicy registers a handler for the given method, pattern, and policy header.
// The pattern is pretty much what you're used to, i.e. /static/:variable/*catchall
func (r *router) HandlePolicy(method, pattern string, policy int, handler http.Handler) <span class="cov8" title="1">{
        m := &amp;matcher{method: method, policy: policy}
        parts := strings.Split(pattern[1:], "/")
        m.length = len(parts)
        if pattern[len(pattern)-1] == '/' </span><span class="cov8" title="1">{
                m.endSlash = true
        }</span>
        <span class="cov8" title="1">for i, v := range parts </span><span class="cov8" title="1">{
                if len(v) &gt; 0 &amp;&amp; v[0] == ':' </span><span class="cov8" title="1">{
                        m.vars = append(m.vars, variable{v[1:], i})
                }</span> else<span class="cov8" title="1"> if len(v) &gt; 0 &amp;&amp; v[0] == '*' </span><span class="cov8" title="1">{
                        m.catchallName = v[1:]
                        m.hasCatchall = true
                }</span> else<span class="cov8" title="1"> {
                        m.static = append(m.static, variable{v, i})
                }</span>
        }
        <span class="cov8" title="1">m.handler = handler
        if len(m.static) &gt; 0 </span><span class="cov8" title="1">{
                r.staticMatchers = append(r.staticMatchers, m)
        }</span> else<span class="cov8" title="1"> {
                r.matchers = append(r.matchers, m)
        }</span>
}

// Handle registers a handler for the given method and pattern.
// The pattern is pretty much what you're used to, i.e. /static/:variable/*catchall
func (r *router) Handle(method, pattern string, handler http.Handler) <span class="cov8" title="1">{
        r.HandlePolicy(method, pattern, anyPolicy, handler)
}</span>

func (r *router) Get(path string, handler http.Handler) <span class="cov8" title="1">{
        r.Handle("GET", path, handler)
}</span>

func (r *router) Put(path string, handler http.Handler) <span class="cov8" title="1">{
        r.Handle("PUT", path, handler)
}</span>

func (r *router) Head(path string, handler http.Handler) <span class="cov8" title="1">{
        r.Handle("HEAD", path, handler)
}</span>

func (r *router) Delete(path string, handler http.Handler) <span class="cov8" title="1">{
        r.Handle("DELETE", path, handler)
}</span>

func (r *router) Replicate(path string, handler http.Handler) <span class="cov8" title="1">{
        r.Handle("REPLICATE", path, handler)
}</span>

func (r *router) Sync(path string, handler http.Handler) <span class="cov0" title="0">{
        r.Handle("SYNC", path, handler)
}</span>

func (r *router) Post(path string, handler http.Handler) <span class="cov8" title="1">{
        r.Handle("POST", path, handler)
}</span>

func (r *router) Options(path string, handler http.Handler) <span class="cov8" title="1">{
        r.Handle("OPTIONS", path, handler)
}</span>

func (r *router) ServeHTTP(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        policy, err := strconv.Atoi(request.Header.Get("X-Backend-Storage-Policy-Index"))
        if err != nil </span><span class="cov8" title="1">{
                policy = 0
        }</span>
        <span class="cov8" title="1">handler, vars := r.route(request.Method, request.URL.Path, policy)
        txnId := request.Header.Get("X-Trans-Id")
        if vars != nil &amp;&amp; txnId != "" </span><span class="cov8" title="1">{
                vars["txnId"] = txnId
        }</span>
        <span class="cov8" title="1">request = SetVars(request, vars)
        handler.ServeHTTP(writer, request)</span>
}

func routerNotFound(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if pm, err := common.ParseProxyPath(r.URL.Path); err == nil &amp;&amp; pm["account"] == "" </span><span class="cov0" title="0">{
                SimpleErrorResponse(w, http.StatusPreconditionFailed, "Bad URL")
        }</span> else<span class="cov0" title="0"> {
                SimpleErrorResponse(w, http.StatusNotFound, "")
        }</span>
}

func NewRouter() *router <span class="cov8" title="1">{
        return &amp;router{
                NotFoundHandler:         http.HandlerFunc(routerNotFound),
                MethodNotAllowedHandler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{ http.Error(w, "Method Not Allowed", 405) }</span>),
        }
}
</pre>
		
		<pre class="file" id="file32" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package srv

import (
        "bufio"
        "context"
        "crypto/tls"
        "flag"
        "fmt"
        "io"
        "io/ioutil"
        "net"
        "net/http"
        "os"
        "os/signal"
        "path/filepath"
        "runtime"
        "strconv"
        "strings"
        "sync"
        "syscall"
        "time"
        "unicode/utf8"

        opentracing "github.com/opentracing/opentracing-go"
        "github.com/opentracing/opentracing-go/ext"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/ring"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "golang.org/x/net/http2"
)

var responseTemplate = "&lt;html&gt;&lt;h1&gt;%s&lt;/h1&gt;&lt;p&gt;%s&lt;/p&gt;&lt;/html&gt;"

var responseBodies = map[int]string{
        100: "",
        200: "",
        201: "",
        202: fmt.Sprintf(responseTemplate, "Accepted", "The request is accepted for processing."),
        204: "",
        206: "",
        301: fmt.Sprintf(responseTemplate, "Moved Permanently", "The resource has moved permanently."),
        302: fmt.Sprintf(responseTemplate, "Found", "The resource has moved temporarily."),
        303: fmt.Sprintf(responseTemplate, "See Other", "The response to the request can be found under a different URI."),
        304: "",
        307: fmt.Sprintf(responseTemplate, "Temporary Redirect", "The resource has moved temporarily."),
        400: fmt.Sprintf(responseTemplate, "Bad Request", "The server could not comply with the request since it is either malformed or otherwise incorrect."),
        401: fmt.Sprintf(responseTemplate, "Unauthorized", "This server could not verify that you are authorized to access the document you requested."),
        402: fmt.Sprintf(responseTemplate, "Payment Required", "Access was denied for financial reasons."),
        403: fmt.Sprintf(responseTemplate, "Forbidden", "Access was denied to this resource."),
        404: fmt.Sprintf(responseTemplate, "Not Found", "The resource could not be found."),
        405: fmt.Sprintf(responseTemplate, "Method Not Allowed", "The method is not allowed for this resource."),
        406: fmt.Sprintf(responseTemplate, "Not Acceptable", "The resource is not available in a format acceptable to your browser."),
        408: fmt.Sprintf(responseTemplate, "Request Timeout", "The server has waited too long for the request to be sent by the client."),
        409: fmt.Sprintf(responseTemplate, "Conflict", "There was a conflict when trying to complete your request."),
        410: fmt.Sprintf(responseTemplate, "Gone", "This resource is no longer available."),
        411: fmt.Sprintf(responseTemplate, "Length Required", "Content-Length header required."),
        412: "",
        413: fmt.Sprintf(responseTemplate, "Request Entity Too Large", "The body of your request was too large for this server."),
        414: fmt.Sprintf(responseTemplate, "Request URI Too Long", "The request URI was too long for this server."),
        415: fmt.Sprintf(responseTemplate, "Unsupported Media Type", "The request media type is not supported by this server."),
        416: fmt.Sprintf(responseTemplate, "Requested Range Not Satisfiable", "The Range requested is not available."),
        417: fmt.Sprintf(responseTemplate, "Expectation Failed", "Expectation failed."),
        422: fmt.Sprintf(responseTemplate, "Unprocessable Entity", "Unable to process the contained instructions"),
        498: fmt.Sprintf(responseTemplate, "Ratelimited", "The client is sending too many requests and should slow down."),
        499: fmt.Sprintf(responseTemplate, "Client Disconnect", "The client was disconnected during request."),
        500: fmt.Sprintf(responseTemplate, "Internal Error", "The server has either erred or is incapable of performing the requested operation."),
        501: fmt.Sprintf(responseTemplate, "Not Implemented", "The requested method is not implemented by this server."),
        502: fmt.Sprintf(responseTemplate, "Bad Gateway", "Bad gateway."),
        503: fmt.Sprintf(responseTemplate, "Service Unavailable", "The server is currently unavailable. Please try again at a later time."),
        504: fmt.Sprintf(responseTemplate, "Gateway Timeout", "A timeout has occurred speaking to a backend server."),
}

type customWriter struct {
        http.ResponseWriter
        f func(w http.ResponseWriter, status int) int
}

type IpPort struct {
        Ip                string
        Port              int
        CertFile, KeyFile string
}

func (w *customWriter) WriteHeader(status int) <span class="cov8" title="1">{
        w.ResponseWriter.WriteHeader(w.f(w.ResponseWriter, status))
}</span>

func (w *customWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) <span class="cov0" title="0">{
        return w.ResponseWriter.(http.Hijacker).Hijack()
}</span>

// NewCustomWriter creates an http.ResponseWriter wrapper that calls your function on WriteHeader.
func NewCustomWriter(w http.ResponseWriter, f func(w http.ResponseWriter, status int) int) http.ResponseWriter <span class="cov8" title="1">{
        return &amp;customWriter{ResponseWriter: w, f: f}
}</span>

// ResponseWriter that saves its status - used for logging.

type WebWriter struct {
        http.ResponseWriter
        Status          int
        ResponseStarted time.Time
        ByteCount       int
}

func (w *WebWriter) WriteHeader(status int) <span class="cov8" title="1">{
        w.Status = status
        w.ResponseStarted = time.Now()
        w.ResponseWriter.WriteHeader(status)
}</span>

func (w WebWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) <span class="cov8" title="1">{
        return w.ResponseWriter.(http.Hijacker).Hijack()
}</span>

func (w *WebWriter) Response() (time.Time, int) <span class="cov0" title="0">{
        return w.ResponseStarted, w.Status
}</span>

func (w *WebWriter) Write(b []byte) (n int, err error) <span class="cov8" title="1">{
        n, err = w.ResponseWriter.Write(b)
        w.ByteCount += n
        return n, err
}</span>

type CountingReadCloser struct {
        io.ReadCloser
        ByteCount int
}

func (crc *CountingReadCloser) Read(b []byte) (n int, err error) <span class="cov8" title="1">{
        n, err = crc.ReadCloser.Read(b)
        crc.ByteCount += n
        return n, err
}</span>

func CopyResponseHeaders(w http.ResponseWriter, src *http.Response) <span class="cov0" title="0">{
        for key := range src.Header </span><span class="cov0" title="0">{
                w.Header().Set(key, src.Header.Get(key))
        }</span>
}

func StandardResponse(w http.ResponseWriter, statusCode int) <span class="cov8" title="1">{
        body := responseBodies[statusCode]
        w.Header().Set("Content-Type", "text/html; charset=UTF-8")
        w.Header().Set("Content-Length", strconv.FormatInt(int64(len(body)), 10))
        w.WriteHeader(statusCode)
        w.Write([]byte(body))
}</span>

func SimpleErrorResponse(w http.ResponseWriter, statusCode int, body string) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "text/html; charset=UTF-8")
        w.Header().Set("Content-Length", strconv.FormatInt(int64(len(body)), 10))
        w.WriteHeader(statusCode)
        w.Write([]byte(body))
}</span>

func CustomErrorResponse(w http.ResponseWriter, statusCode int, vars map[string]string) <span class="cov0" title="0">{
        body := ""
        switch statusCode </span>{
        case 507:<span class="cov0" title="0">
                w.Header().Set("Content-Type", "text/html; charset=UTF-8")
                if vars["Method"] != "HEAD" </span><span class="cov0" title="0">{
                        body = fmt.Sprintf("&lt;html&gt;&lt;h1&gt;Insufficient Storage&lt;/h1&gt;&lt;p&gt;There was not enough space to save the resource. Drive: %s&lt;/p&gt;&lt;/html&gt;", vars["device"])
                }</span>
        }
        <span class="cov0" title="0">w.Header().Set("Content-Length", strconv.FormatInt(int64(len(body)), 10))
        w.WriteHeader(statusCode)
        w.Write([]byte(body))</span>
}

func CopyRequestHeaders(r *http.Request, dst *http.Request) <span class="cov0" title="0">{
        for key := range r.Header </span><span class="cov0" title="0">{
                dst.Header.Set(key, r.Header.Get(key))
        }</span>
}

type WebWriterInterface interface {
        http.ResponseWriter
        Response() (time.Time, int)
}

func ValidateRequest(w http.ResponseWriter, r *http.Request) bool <span class="cov8" title="1">{
        // if invalid request will right own response and return false, otherwise true
        if !utf8.ValidString(r.URL.Path) || strings.Contains(r.URL.Path, "\x00") </span><span class="cov0" title="0">{
                SimpleErrorResponse(w, 412, "Invalid UTF8 or contains NULL")
                return false
        }</span>
        <span class="cov8" title="1">if !utf8.ValidString(r.Header.Get("Content-Type")) || strings.Contains(r.Header.Get("Content-Type"), "\x00") </span><span class="cov0" title="0">{
                SimpleErrorResponse(w, 400, "Invalid UTF8 or contains NULL")
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

type LowLevelLogger interface {
        Error(msg string, fields ...zapcore.Field)
        Info(msg string, fields ...zapcore.Field)
        Debug(msg string, fields ...zapcore.Field)
        With(fields ...zapcore.Field) *zap.Logger
        Sugar() *zap.SugaredLogger
}

func LogPanics(logger LowLevelLogger, msg string) <span class="cov8" title="1">{
        if e := recover(); e != nil </span><span class="cov0" title="0">{
                recoveredMsg := fmt.Sprintf("PANIC (%s)", msg)
                logger.Error(recoveredMsg, zap.Any("err", e))
        }</span>
}

// SetupLogger configures structured logging using uber's zap library.
func SetupLogger(prefix string, atomicLevel *zap.AtomicLevel, flags *flag.FlagSet) (LowLevelLogger, error) <span class="cov8" title="1">{

        highPriority := zap.LevelEnablerFunc(func(lvl zapcore.Level) bool </span><span class="cov8" title="1">{
                return lvl &gt;= atomicLevel.Level() &amp;&amp; lvl &gt;= zapcore.ErrorLevel
        }</span>)
        <span class="cov8" title="1">lowPriority := zap.LevelEnablerFunc(func(lvl zapcore.Level) bool </span><span class="cov8" title="1">{
                return lvl &gt;= atomicLevel.Level() &amp;&amp; lvl &lt; zapcore.ErrorLevel
        }</span>)

        <span class="cov8" title="1">var lowPrioFile, highPrioFile zapcore.WriteSyncer
        var err error
        name := "stdout"
        if lFlag := flags.Lookup("l"); lFlag != nil </span><span class="cov0" title="0">{
                name = lFlag.Value.(flag.Getter).Get().(string)
        }</span>
        <span class="cov8" title="1">if name == "" </span><span class="cov0" title="0">{
                name = "stdout"
        }</span>
        <span class="cov8" title="1">switch name </span>{
        case "stdout", "stderr":<span class="cov8" title="1">
                lowPrioFile, _, err = zap.Open(name)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Unable to open low priority logger: %s %v", name, err)
                }</span>
        default:<span class="cov0" title="0">
                lowPrioFile, err = os.OpenFile(name, os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0644)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Unable to open file for low priority logger: %s %v", name, err)
                }</span>
                <span class="cov0" title="0">err := syscall.Dup2(int(lowPrioFile.(*os.File).Fd()), int(os.Stdout.Fd()))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Unable to redirect STDOUT: %s", err)
                }</span>
        }
        <span class="cov8" title="1">name = "stderr"
        if eFlag := flags.Lookup("e"); eFlag != nil </span><span class="cov0" title="0">{
                name = eFlag.Value.(flag.Getter).Get().(string)
        }</span>
        <span class="cov8" title="1">if name == "" </span><span class="cov0" title="0">{
                name = "stderr"
        }</span>
        <span class="cov8" title="1">switch name </span>{
        case "stdout", "stderr":<span class="cov8" title="1">
                highPrioFile, _, err = zap.Open(name)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Unable to open high priority logger: %s %v", name, err)
                }</span>
        default:<span class="cov0" title="0">
                highPrioFile, err = os.OpenFile(name, os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0644)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Unable to open file for high priority logger: %s %v", name, err)
                }</span>
                <span class="cov0" title="0">err := syscall.Dup2(int(highPrioFile.(*os.File).Fd()), int(os.Stderr.Fd()))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Unable to redirect STDERR: %s", err)
                }</span>
        }

        <span class="cov8" title="1">infos := zapcore.AddSync(lowPrioFile)
        errors := zapcore.AddSync(highPrioFile)

        encoder := zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig())

        core := zapcore.NewTee(
                zapcore.NewCore(encoder, infos, lowPriority),
                zapcore.NewCore(encoder, errors, highPriority),
        )

        baseLogger := zap.New(core)
        logger := baseLogger.With(zap.String("name", prefix))
        return logger, nil</span>
}

// LogRequest is a middleware that logs requests and also sets up a logger in
// the request context.
func LogRequest(logger LowLevelLogger, next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                start := time.Now()
                newWriter := &amp;WebWriter{ResponseWriter: writer, Status: 500}
                newReader := &amp;CountingReadCloser{ReadCloser: request.Body}
                request.Body = newReader
                logr := logger.With(zap.String("txn", request.Header.Get("X-Trans-Id")))
                request = SetLogger(request, logr)
                next.ServeHTTP(newWriter, request)
                LogRequestLine(logr, request, start, newWriter, newReader)
        }</span>)
}

func LogRequestLine(logger *zap.Logger, request *http.Request, start time.Time, newWriter *WebWriter, newReader *CountingReadCloser) <span class="cov8" title="1">{
        if newWriter.Status/100 != 2 || request.Header.Get("X-Backend-Suppress-2xx-Logging") != "t" || logger.Core().Enabled(zap.DebugLevel) </span><span class="cov8" title="1">{
                extraInfo := "-"
                if request.Header.Get("X-Force-Acquire") == "true" </span><span class="cov0" title="0">{
                        extraInfo = "FA"
                }</span>
                <span class="cov8" title="1">logger.Info(
                        "Request log",
                        zap.String("remoteAddr", common.GetDefault(request.Header, "X-Forwarded-For", request.RemoteAddr)),
                        zap.String("eventTime", time.Now().Format("02/Jan/2006:15:04:05 -0700")),
                        zap.String("method", request.Method),
                        zap.String("urlPath", common.Urlencode(request.URL.Path)),
                        zap.Int("status", newWriter.Status),
                        zap.Int("contentBytesIn", newReader.ByteCount),
                        zap.Int("contentBytesOut", newWriter.ByteCount),
                        zap.String("contentLengthIn", common.GetDefault(request.Header, "Content-Length", "-")),
                        zap.String("contentLengthOut", common.GetDefault(newWriter.Header(), "Content-Length", "-")),
                        zap.String("referer", common.GetDefault(request.Header, "Referer", "-")),
                        zap.String("userAgent", common.GetDefault(request.Header, "User-Agent", "-")),
                        zap.Float64("requestTimeSeconds", time.Since(start).Seconds()),
                        zap.Float64("requestTimeToHeaderSeconds", newWriter.ResponseStarted.Sub(start).Seconds()),
                        zap.String("extraInfo", extraInfo),
                )
                if span := opentracing.SpanFromContext(request.Context()); span != nil </span><span class="cov0" title="0">{
                        span.LogKV("remoteAddr", common.GetDefault(request.Header, "X-Forwarded-For", request.RemoteAddr),
                                "eventTime", time.Now().Format("02/Jan/2006:15:04:05 -0700"),
                                "method", request.Method,
                                "urlPath", common.Urlencode(request.URL.Path),
                                "status", newWriter.Status,
                                "contentBytesIn", newReader.ByteCount,
                                "contentBytesOut", newWriter.ByteCount,
                                "contentLengthIn", common.GetDefault(request.Header, "Content-Length", "-"),
                                "contentLengthOut", common.GetDefault(newWriter.Header(), "Content-Length", "-"),
                                "referer", common.GetDefault(request.Header, "Referer", "-"),
                                "userAgent", common.GetDefault(request.Header, "User-Agent", "-"),
                                "requestTimeSeconds", time.Since(start).Seconds(),
                                "requestTimeToHeaderSeconds", newWriter.ResponseStarted.Sub(start).Seconds(),
                                "txn", request.Header.Get("X-Trans-Id"),
                                "extraInfo", extraInfo)
                        ext.HTTPStatusCode.Set(span, uint16(newWriter.Status))
                }</span>
        }
}

type ConfigLoader interface {
        GetHashPrefixAndSuffix() (string, string, error)
        GetPolicies() (conf.PolicyList, error)
        GetSyncRealms() (conf.SyncRealmList, error)
        GetRing(ringType, prefix, suffix string, policy int) (ring.Ring, error)
}

type DefaultConfigLoader struct{}

func (d DefaultConfigLoader) GetHashPrefixAndSuffix() (string, string, error) <span class="cov0" title="0">{
        return conf.GetHashPrefixAndSuffix()
}</span>

func (d DefaultConfigLoader) GetPolicies() (conf.PolicyList, error) <span class="cov0" title="0">{
        return conf.GetPolicies()
}</span>

func (d DefaultConfigLoader) GetSyncRealms() (conf.SyncRealmList, error) <span class="cov8" title="1">{
        return conf.GetSyncRealms()
}</span>

func (d DefaultConfigLoader) GetRing(ringType, prefix, suffix string, policy int) (ring.Ring, error) <span class="cov0" title="0">{
        return ring.GetRing(ringType, prefix, suffix, policy)
}</span>

type TestConfigLoader struct {
        DefaultConfigLoader
        GetHashPrefixAndSuffixFunc func() (string, string, error)
        GetPoliciesFunc            func() (conf.PolicyList, error)
        GetSyncRealmsFunc          func() (conf.SyncRealmList, error)
        GetRingFunc                func(ringType, prefix, suffix string, policy int) (ring.Ring, error)
}

func (t *TestConfigLoader) GetHashPrefixAndSuffix() (string, string, error) <span class="cov8" title="1">{
        if t.GetHashPrefixAndSuffixFunc != nil </span><span class="cov8" title="1">{
                return t.GetHashPrefixAndSuffixFunc()
        }</span> else<span class="cov0" title="0"> {
                return t.DefaultConfigLoader.GetHashPrefixAndSuffix()
        }</span>
}

func (t *TestConfigLoader) GetPolicies() (conf.PolicyList, error) <span class="cov8" title="1">{
        if t.GetPoliciesFunc != nil </span><span class="cov8" title="1">{
                return t.GetPoliciesFunc()
        }</span> else<span class="cov0" title="0"> {
                return t.DefaultConfigLoader.GetPolicies()
        }</span>
}

func (t *TestConfigLoader) GetSyncRealms() (conf.SyncRealmList, error) <span class="cov8" title="1">{
        if t.GetSyncRealmsFunc != nil </span><span class="cov0" title="0">{
                return t.GetSyncRealmsFunc()
        }</span> else<span class="cov8" title="1"> {
                return t.DefaultConfigLoader.GetSyncRealms()
        }</span>
}

func (t *TestConfigLoader) GetRing(ringType, prefix, suffix string, policy int) (ring.Ring, error) <span class="cov8" title="1">{
        if t.GetRingFunc != nil </span><span class="cov8" title="1">{
                return t.GetRingFunc(ringType, prefix, suffix, policy)
        }</span> else<span class="cov0" title="0"> {
                return t.DefaultConfigLoader.GetRing(ringType, prefix, suffix, policy)
        }</span>
}

func NewTestConfigLoader(testRing ring.Ring) *TestConfigLoader <span class="cov8" title="1">{
        confLoader := &amp;TestConfigLoader{
                GetRingFunc: func(ringType, prefix, suffix string, policy int) (ring.Ring, error) </span><span class="cov8" title="1">{
                        return testRing, nil
                }</span>,
                GetPoliciesFunc: func() (conf.PolicyList, error) <span class="cov8" title="1">{
                        return conf.PolicyList(map[int]*conf.Policy{
                                0: {
                                        Index:      0,
                                        Type:       "replication",
                                        Name:       "Policy-0",
                                        Aliases:    nil,
                                        Default:    false,
                                        Deprecated: false,
                                },
                                1: {
                                        Index:      1,
                                        Type:       "replication",
                                        Name:       "Policy-1",
                                        Aliases:    nil,
                                        Default:    false,
                                        Deprecated: false,
                                },
                                2: {
                                        Index:      2,
                                        Type:       "hec",
                                        Name:       "HecPolicy-2",
                                        Aliases:    nil,
                                        Default:    false,
                                        Deprecated: false,
                                        Config:     map[string]string{"data_shards": "2", "parity_shards": "1", "nursery_replicas": "1"},
                                },
                        }), nil
                }</span>,
                GetHashPrefixAndSuffixFunc: func() (string, string, error) <span class="cov8" title="1">{
                        return "changeme", "changeme", nil
                }</span>,
        }
        <span class="cov8" title="1">return confLoader</span>
}

/* http.Server that knows how to shut down gracefully */

type HummingbirdServer struct {
        *http.Server
        logger   LowLevelLogger
        finalize func()
}

func RetryListen(ip string, port int) (net.Listener, error) <span class="cov0" title="0">{
        address := fmt.Sprintf("%s:%d", ip, port)
        started := time.Now()
        for </span><span class="cov0" title="0">{
                if sock, err := net.Listen("tcp", address); err == nil </span><span class="cov0" title="0">{
                        return sock, nil
                }</span> else<span class="cov0" title="0"> if time.Now().Sub(started) &gt; 10*time.Second </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to bind for 10 seconds (%v)", err)
                }</span>
                <span class="cov0" title="0">time.Sleep(time.Second / 5)</span>
        }
}

func DumpGoroutinesStackTrace(pid int) <span class="cov0" title="0">{
        filename := filepath.Join("/tmp", strconv.Itoa(pid)+".dump")
        buf := make([]byte, 1&lt;&lt;20)
        for </span><span class="cov0" title="0">{
                n := runtime.Stack(buf, true)
                if n &lt; len(buf) </span><span class="cov0" title="0">{
                        buf = buf[:n]
                        break</span>
                }
                <span class="cov0" title="0">buf = make([]byte, 2*len(buf))</span>
        }
        <span class="cov0" title="0">ioutil.WriteFile(filename, buf, 0644)</span>
}

type Server interface {
        Type() string
        Background(flags *flag.FlagSet) chan struct{}
        GetHandler(config conf.Config, metricsPrefix string) http.Handler
        Finalize() // This is called before stoping gracefully so that a server can clean up before closing
}

func RunServers(getServer func(conf.Config, *flag.FlagSet, ConfigLoader) (*IpPort, Server, LowLevelLogger, error), flags *flag.FlagSet) <span class="cov0" title="0">{
        var servers []*HummingbirdServer

        if flags.NArg() != 0 </span><span class="cov0" title="0">{
                flags.Usage()
                return
        }</span>
        <span class="cov0" title="0">configFile := flags.Lookup("c").Value.(flag.Getter).Get().(string)
        configs, err := conf.LoadConfigs(configFile)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error finding configs: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">var wg *sync.WaitGroup

        for _, config := range configs </span><span class="cov0" title="0">{
                ipPort, server, logger, err := getServer(config, flags, DefaultConfigLoader{})
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "%v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">var metricsPrefix string
                if len(configs) == 1 </span><span class="cov0" title="0">{
                        metricsPrefix = fmt.Sprintf("hb_%s", server.Type())
                }</span> else<span class="cov0" title="0"> {
                        metricsPrefix = fmt.Sprintf("hb_%s_%s_%d", server.Type(), ipPort.Ip, ipPort.Port)
                }</span>
                <span class="cov0" title="0">metricsPrefix = strings.Replace(metricsPrefix, "-", "_", -1)
                metricsPrefix = strings.Replace(metricsPrefix, ".", "_", -1)
                sock, err := RetryListen(ipPort.Ip, ipPort.Port)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error listening: %v\n", err)
                        logger.Error("Error listening", zap.Error(err))
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">var srv HummingbirdServer
                if ipPort.CertFile != "" &amp;&amp; ipPort.KeyFile != "" </span><span class="cov0" title="0">{
                        tlsConf := &amp;tls.Config{
                                PreferServerCipherSuites: true,
                                MinVersion:               tls.VersionTLS12,
                        }
                        if server.Type() != "proxy" </span><span class="cov0" title="0">{
                                tlsConf.ClientAuth = tls.RequireAndVerifyClientCert
                        }</span>
                        <span class="cov0" title="0">httpServer := http.Server{
                                Handler:      server.GetHandler(config, metricsPrefix),
                                ReadTimeout:  24 * time.Hour,
                                WriteTimeout: 24 * time.Hour,
                                TLSConfig:    tlsConf,
                        }
                        err := http2.ConfigureServer(&amp;httpServer, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Error enabling http2 on server: %v\n", err)
                                logger.Error("Error enabling http2 on server", zap.Error(err))
                                os.Exit(1)
                        }</span>
                        <span class="cov0" title="0">srv = HummingbirdServer{
                                Server:   &amp;httpServer,
                                logger:   logger,
                                finalize: server.Finalize,
                        }
                        go srv.ServeTLS(sock, ipPort.CertFile, ipPort.KeyFile)</span>
                } else<span class="cov0" title="0"> {
                        srv = HummingbirdServer{
                                Server: &amp;http.Server{
                                        Handler:      server.GetHandler(config, metricsPrefix),
                                        ReadTimeout:  24 * time.Hour,
                                        WriteTimeout: 24 * time.Hour,
                                },
                                logger:   logger,
                                finalize: server.Finalize,
                        }
                        go srv.Serve(sock)
                }</span>
                <span class="cov0" title="0">ch := server.Background(flags)
                if ch != nil </span><span class="cov0" title="0">{
                        if wg == nil </span><span class="cov0" title="0">{
                                wg = &amp;sync.WaitGroup{}
                        }</span>
                        <span class="cov0" title="0">wg.Add(1)
                        go func(ch2 chan struct{}) </span><span class="cov0" title="0">{
                                defer wg.Done()
                                &lt;-ch2
                        }</span>(ch)
                }
                <span class="cov0" title="0">servers = append(servers, &amp;srv)
                logger.Info("Server started", zap.Int("port", ipPort.Port))</span>
        }

        <span class="cov0" title="0">if wg != nil </span><span class="cov0" title="0">{
                wg.Wait()
                return
        }</span>

        <span class="cov0" title="0">if len(servers) &gt; 0 </span><span class="cov0" title="0">{
                c := make(chan os.Signal, 1)
                signal.Notify(c, syscall.SIGHUP, syscall.SIGTERM, syscall.SIGINT, syscall.SIGQUIT, syscall.SIGABRT)
                s := &lt;-c
                switch s </span>{
                case syscall.SIGTERM, syscall.SIGHUP:<span class="cov0" title="0"> // graceful shutdown
                        var wg sync.WaitGroup
                        ctx, cancel := context.WithTimeout(context.Background(), time.Minute*5)
                        defer cancel()
                        for _, srv := range servers </span><span class="cov0" title="0">{
                                // Shutdown the HTTP server
                                wg.Add(1)
                                go func(hserv *HummingbirdServer) </span><span class="cov0" title="0">{
                                        defer wg.Done()
                                        if err := hserv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                                                // failure/timeout shutting down the server gracefully
                                                hserv.logger.Error("Error with graceful shutdown", zap.Error(err))
                                        }</span>
                                        // Wait for any async processes to quit
                                        <span class="cov0" title="0">hserv.finalize()</span>
                                }(srv)
                        }
                        // Wait for everything to complete
                        <span class="cov0" title="0">wgc := make(chan struct{})
                        go func() </span><span class="cov0" title="0">{
                                defer close(wgc)
                                wg.Wait()
                        }</span>()
                        <span class="cov0" title="0">select </span>{
                        case &lt;-wgc:<span class="cov0" title="0">
                                // Everything has completed
                                fmt.Println("Graceful shutdown complete.")
                                return</span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                // Timeout before everything completing
                                fmt.Println("Forcing shutdown after timeout.")
                                return</span>
                        }
                case syscall.SIGABRT, syscall.SIGQUIT:<span class="cov0" title="0"> // drop a traceback
                        pid := os.Getpid()
                        DumpGoroutinesStackTrace(pid)</span>
                default:<span class="cov0" title="0">
                        for _, srv := range servers </span><span class="cov0" title="0">{
                                if err := srv.Close(); err != nil </span><span class="cov0" title="0">{
                                        srv.logger.Error("Error shutdown", zap.Error(err))
                                }</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package common

import (
        "fmt"
        "strconv"

        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/pickle"
)

const SWIFT_OBJECT_METADATA_CHUNK_SIZE = 65536

func SwiftObjectRawReadMetadata(fileNameOrFd interface{}) ([]byte, error) <span class="cov8" title="1">{
        var pickledMetadata []byte
        offset := 0
        for index := 0; ; index += 1 </span><span class="cov8" title="1">{
                var metadataName string
                // get name of next xattr
                if index == 0 </span><span class="cov8" title="1">{
                        metadataName = "user.swift.metadata"
                }</span> else<span class="cov8" title="1"> {
                        metadataName = "user.swift.metadata" + strconv.Itoa(index)
                }</span>
                // get size of xattr
                <span class="cov8" title="1">length, err := fs.Getxattr(fileNameOrFd, metadataName, nil)
                if err != nil || length &lt;= 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                // grow buffer to hold xattr
                <span class="cov8" title="1">for cap(pickledMetadata) &lt; offset+length </span><span class="cov8" title="1">{
                        pickledMetadata = append(pickledMetadata, 0)
                }</span>
                <span class="cov8" title="1">pickledMetadata = pickledMetadata[0 : offset+length]
                if _, err := fs.Getxattr(fileNameOrFd, metadataName, pickledMetadata[offset:]); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">offset += length</span>
        }
        <span class="cov8" title="1">return pickledMetadata, nil</span>
}

func SwiftObjectReadMetadata(fileNameOrFd interface{}) (map[string]string, error) <span class="cov8" title="1">{
        pickledMetadata, err := SwiftObjectRawReadMetadata(fileNameOrFd)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">v, err := pickle.PickleLoads(pickledMetadata)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if v, ok := v.(map[interface{}]interface{}); ok </span><span class="cov8" title="1">{
                metadata := make(map[string]string, len(v))
                for mk, mv := range v </span><span class="cov8" title="1">{
                        var mks, mvs string
                        if mks, ok = mk.(string); !ok </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("Metadata key not string: %T %v", mk, mk)
                        }</span> else<span class="cov8" title="1"> if mvs, ok = mv.(string); !ok </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("Metadata value not string: %T %v", mv, mv)
                        }</span>
                        <span class="cov8" title="1">metadata[mks] = mvs</span>
                }
                <span class="cov8" title="1">return metadata, nil</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("Unpickled metadata not correct type: %T", v)</span>
}

func SwiftObjectRawWriteMetadata(fd uintptr, buf []byte) error <span class="cov8" title="1">{
        for index := 0; len(buf) &gt; 0; index++ </span><span class="cov8" title="1">{
                var metadataName string
                if index == 0 </span><span class="cov8" title="1">{
                        metadataName = "user.swift.metadata"
                }</span> else<span class="cov0" title="0"> {
                        metadataName = "user.swift.metadata" + strconv.Itoa(index)
                }</span>
                <span class="cov8" title="1">writelen := SWIFT_OBJECT_METADATA_CHUNK_SIZE
                if len(buf) &lt; writelen </span><span class="cov8" title="1">{
                        writelen = len(buf)
                }</span>
                <span class="cov8" title="1">if _, err := fs.Setxattr(fd, metadataName, buf[0:writelen]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">buf = buf[writelen:]</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func SwiftObjectWriteMetadata(fd uintptr, v map[string]string) error <span class="cov8" title="1">{
        return SwiftObjectRawWriteMetadata(fd, pickle.PickleDumps(v))
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">//  Copyright (c) 2016 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package test

import (
        "bytes"
        "context"
        "encoding/json"
        "io"
        "net/http"

        "github.com/troubling/hummingbird/common/ring"
)

// a place for utility functions and interface satisifiers that are used across tests

type CaptureResponse struct {
        Status int
        header http.Header
        Body   *bytes.Buffer
}

func (w *CaptureResponse) WriteHeader(status int) <span class="cov0" title="0">{
        w.Status = status
}</span>

func (w *CaptureResponse) Header() http.Header <span class="cov0" title="0">{
        return w.header
}</span>

func (w *CaptureResponse) Write(b []byte) (int, error) <span class="cov0" title="0">{
        return w.Body.Write(b)
}</span>

func MakeCaptureResponse() *CaptureResponse <span class="cov0" title="0">{
        return &amp;CaptureResponse{
                Status: 0,
                header: make(http.Header),
                Body:   new(bytes.Buffer),
        }
}</span>

// FakeRing
type FakeRing struct {
        // Overrides for function returns
        MockLocalDevices       []*ring.Device
        MockGetJobNodes        []*ring.Device
        MockGetJobNodesHandoff bool
        MockGetMoreNodes       ring.MoreNodes

        // Used for probe
        MockMoreNodes *ring.Device
        MockDevices   []*ring.Device
}

func (r *FakeRing) GetNodes(partition uint64) (response []*ring.Device) <span class="cov0" title="0">{
        if len(r.MockDevices) &gt; 0 </span><span class="cov0" title="0">{
                return r.MockDevices[0:3]
        }</span> else<span class="cov0" title="0"> {
                return nil
        }</span>
}

func (r *FakeRing) GetJobNodes(partition uint64, localDevice int) (response []*ring.Device, handoff bool) <span class="cov8" title="1">{
        if len(r.MockDevices) &gt; 0 </span><span class="cov8" title="1">{
                switch localDevice </span>{
                case 0:<span class="cov8" title="1">
                        return []*ring.Device{r.MockDevices[1], r.MockDevices[2]}, false</span>
                case 1:<span class="cov8" title="1">
                        return []*ring.Device{r.MockDevices[0], r.MockDevices[2]}, false</span>
                case 2:<span class="cov0" title="0">
                        return []*ring.Device{r.MockDevices[0], r.MockDevices[1]}, false</span>
                default:<span class="cov8" title="1">
                        return r.MockDevices[0:3], true</span>
                }
        } else<span class="cov0" title="0"> if len(r.MockGetJobNodes) &gt; 0 </span><span class="cov0" title="0">{
                return r.MockGetJobNodes, r.MockGetJobNodesHandoff
        }</span> else<span class="cov0" title="0"> {
                return []*ring.Device{
                        {Device: "sda", ReplicationIp: "127.0.0.1", ReplicationPort: 20000},
                        {Device: "sdb", ReplicationIp: "127.0.0.2", ReplicationPort: 2000},
                }, r.MockGetJobNodesHandoff
        }</span>
}

func (r *FakeRing) GetPartition(account string, container string, object string) uint64 <span class="cov8" title="1">{
        return 0
}</span>

func (r *FakeRing) PartitionForHash(hsh string) (uint64, error) <span class="cov0" title="0">{
        return 0, nil
}</span>

func (r *FakeRing) LocalDevices(localPort int) (devs []*ring.Device, err error) <span class="cov8" title="1">{
        if len(r.MockDevices) &gt; 0 </span><span class="cov8" title="1">{
                for _, d := range r.MockDevices </span><span class="cov8" title="1">{
                        if d.ReplicationPort == localPort </span><span class="cov8" title="1">{
                                return []*ring.Device{d}, nil
                        }</span>
                }
                <span class="cov0" title="0">return nil, nil</span>
        } else<span class="cov0" title="0"> if len(r.MockLocalDevices) &gt; 0 </span><span class="cov0" title="0">{
                return r.MockLocalDevices, nil
        }</span> else<span class="cov0" title="0"> {
                return nil, nil
        }</span>
}

func (r *FakeRing) AllDevices() (devs []*ring.Device) <span class="cov0" title="0">{
        return nil
}</span>

func (r *FakeRing) GetMoreNodes(partition uint64) ring.MoreNodes <span class="cov8" title="1">{
        if r.MockMoreNodes != nil </span><span class="cov8" title="1">{
                return &amp;fakeMoreNodes{r.MockMoreNodes}
        }</span> else<span class="cov0" title="0"> if r.MockGetMoreNodes != nil </span><span class="cov0" title="0">{
                return r.MockGetMoreNodes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *FakeRing) PartitionCount() uint64 <span class="cov0" title="0">{
        return 64
}</span>

func (r *FakeRing) ReplicaCount() uint64 <span class="cov0" title="0">{
        return 3
}</span>

type fakeMoreNodes struct {
        dev *ring.Device
}

func (m *fakeMoreNodes) Next() *ring.Device <span class="cov8" title="1">{
        return m.dev
}</span>

// Fake MemcacheRing
type FakeMemcacheRing struct {
        MockIncrResults   []int64
        MockIncrKeys      []string
        MockSetValues     []interface{}
        MockGetStructured map[string][]byte
}

func (mr *FakeMemcacheRing) Decr(ctx context.Context, key string, delta int64, timeout int) (int64, error) <span class="cov0" title="0">{
        return int64(0), nil
}</span>

func (mr *FakeMemcacheRing) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        return nil
}</span>

func (mr *FakeMemcacheRing) Get(ctx context.Context, key string) (interface{}, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (mr *FakeMemcacheRing) GetStructured(ctx context.Context, key string, val interface{}) error <span class="cov0" title="0">{
        if v, ok := mr.MockGetStructured[key]; ok </span><span class="cov0" title="0">{
                json.Unmarshal(v, val)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (mr *FakeMemcacheRing) GetMulti(ctx context.Context, serverKey string, keys []string) (map[string]interface{}, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (mr *FakeMemcacheRing) Incr(ctx context.Context, key string, delta int64, timeout int) (int64, error) <span class="cov0" title="0">{
        mr.MockIncrKeys = append(mr.MockIncrKeys, key)
        if len(mr.MockIncrResults) &gt; 0 </span><span class="cov0" title="0">{
                res := mr.MockIncrResults[0] + delta
                mr.MockIncrResults = mr.MockIncrResults[1:]
                return res, nil
        }</span>
        <span class="cov0" title="0">return int64(0), nil</span>
}

func (mr *FakeMemcacheRing) Set(ctx context.Context, key string, value interface{}, timeout int) error <span class="cov0" title="0">{
        mr.MockSetValues = append(mr.MockSetValues, value)
        return nil
}</span>

func (mr *FakeMemcacheRing) SetMulti(ctx context.Context, serverKey string, values map[string]interface{}, timeout int) error <span class="cov0" title="0">{
        return nil
}</span>

type MockResponseWriter struct {
        SaveHeader *http.Header
        StatusMap  map[string]int
        Body       io.Writer
}

func (m MockResponseWriter) Header() (h http.Header) <span class="cov0" title="0">{
        if m.SaveHeader == nil </span><span class="cov0" title="0">{
                return http.Header{}
        }</span>
        <span class="cov0" title="0">return *m.SaveHeader</span>
}

func (m MockResponseWriter) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        if m.Body != nil </span><span class="cov0" title="0">{
                return m.Body.Write(p)
        }</span>
        <span class="cov0" title="0">return len(p), nil</span>
}

func (m MockResponseWriter) WriteString(s string) (n int, err error) <span class="cov0" title="0">{
        return m.Write([]byte(s))
}</span>

func (m MockResponseWriter) WriteHeader(s int) <span class="cov0" title="0">{
        if m.StatusMap != nil </span><span class="cov0" title="0">{
                m.StatusMap["S"] = s
        }</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package common

import (
        "sync"
        "sync/atomic"

        "github.com/uber-go/tally"
)

type testScope struct {
        lock     sync.RWMutex
        counters map[string]tally.Counter
}

func NewTestScope() *testScope <span class="cov8" title="1">{
        return &amp;testScope{counters: map[string]tally.Counter{}}
}</span>

func (t *testScope) Counter(name string) tally.Counter <span class="cov8" title="1">{
        t.lock.RLock()
        c := t.counters[name]
        t.lock.RUnlock()
        if c == nil </span><span class="cov8" title="1">{
                t.lock.Lock()
                c = t.counters[name]
                if c == nil </span><span class="cov8" title="1">{
                        c = &amp;TestCounter{}
                        t.counters[name] = c
                }</span>
                <span class="cov8" title="1">t.lock.Unlock()</span>
        }
        <span class="cov8" title="1">return c</span>
}

func (t *testScope) Gauge(name string) tally.Gauge <span class="cov0" title="0">{
        panic("Not implemented yet.")</span>
}

func (t *testScope) Timer(name string) tally.Timer <span class="cov0" title="0">{
        panic("Not implemented yet.")</span>
}

func (t *testScope) Histogram(name string, buckets tally.Buckets) tally.Histogram <span class="cov0" title="0">{
        panic("Not implemented yet.")</span>
}

func (t *testScope) Tagged(tags map[string]string) tally.Scope <span class="cov0" title="0">{
        panic("Not implemented yet.")</span>
}

func (t *testScope) SubScope(name string) tally.Scope <span class="cov0" title="0">{
        panic("Not implemented yet.")</span>
}

func (t *testScope) Capabilities() tally.Capabilities <span class="cov0" title="0">{
        panic("Not implemented yet.")</span>
}

type TestCounter struct {
        count int64
}

func (c *TestCounter) Inc(delta int64) <span class="cov8" title="1">{
        atomic.AddInt64(&amp;c.count, delta)
}</span>

func (c *TestCounter) Value() int64 <span class="cov8" title="1">{
        return atomic.LoadInt64(&amp;c.count)
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">//  Copyright (c) 2018 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package tracing

import (
        "io"
        "time"

        opentracing "github.com/opentracing/opentracing-go"
        "github.com/uber/jaeger-client-go/config"

        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"
)

// Init creates a new instance of Jaeger tracer.
func Init(serviceName string, logger srv.LowLevelLogger, section conf.Section) (opentracing.Tracer, io.Closer, error) <span class="cov0" title="0">{
        cfg := config.Configuration{
                Disabled: section.GetBool("disabled", false),
                Sampler: &amp;config.SamplerConfig{
                        Type:  section.GetDefault("sampler_type", "const"),
                        Param: section.GetFloat("sampler_param", 1),
                },
                Reporter: &amp;config.ReporterConfig{
                        LogSpans:            section.GetBool("reporter_log_spans", false),
                        BufferFlushInterval: 1 * time.Second,
                        LocalAgentHostPort:  section.GetDefault("agent_host_port", ""),
                },
        }
        tracer, closer, err := cfg.New(
                serviceName,
                config.Logger(NewTraceLogger(logger)),
        )
        return tracer, closer, err
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">//  Copyright (c) 2018 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package tracing

import (
        "github.com/troubling/hummingbird/common/srv"
        "go.uber.org/zap"
)

// TraceLogger is an adapter from LowLevelLogger to jaeger-lib Logger interface.
type TraceLogger struct {
        logger *zap.SugaredLogger
}

// NewLogger creates a new Sugared Logger.
func NewTraceLogger(logger srv.LowLevelLogger) *TraceLogger <span class="cov0" title="0">{
        return &amp;TraceLogger{logger: logger.Sugar()}
}</span>

// Error logs a message at error priority
func (l *TraceLogger) Error(msg string) <span class="cov0" title="0">{
        l.logger.Error(msg)
}</span>

// Infof logs a message at info priority
func (l *TraceLogger) Infof(msg string, args ...interface{}) <span class="cov0" title="0">{
        l.logger.Infof(msg, args...)
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">//  Copyright (c) 2018 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package tracing

import (
        "context"

        opentracing "github.com/opentracing/opentracing-go"
)

func CopySpanFromContext(ctx context.Context) context.Context <span class="cov8" title="1">{
        newCtx := context.Background()
        span := opentracing.SpanFromContext(ctx)
        if span != nil </span><span class="cov0" title="0">{
                newCtx = opentracing.ContextWithSpan(newCtx, span)
        }</span>
        <span class="cov8" title="1">return newCtx</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package common

import (
        "crypto/md5"
        "crypto/tls"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "math/rand"
        "mime"
        "net/http"
        "os"
        "path"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "time"
)

const ONE_WEEK = 604800
const ONE_DAY = 86400

type HttpRange struct {
        Start, End int64
}

var GMT = time.FixedZone("GMT", 0)

var urlSafeMap = [256]bool{'A': true, 'B': true, 'C': true, 'D': true, 'E': true, 'F': true,
        'G': true, 'H': true, 'I': true, 'J': true, 'K': true, 'L': true, 'M': true, 'N': true,
        'O': true, 'P': true, 'Q': true, 'R': true, 'S': true, 'T': true, 'U': true, 'V': true,
        'W': true, 'X': true, 'Y': true, 'Z': true, 'a': true, 'b': true, 'c': true, 'd': true,
        'e': true, 'f': true, 'g': true, 'h': true, 'i': true, 'j': true, 'k': true, 'l': true,
        'm': true, 'n': true, 'o': true, 'p': true, 'q': true, 'r': true, 's': true, 't': true,
        'u': true, 'v': true, 'w': true, 'x': true, 'y': true, 'z': true, '0': true, '1': true,
        '2': true, '3': true, '4': true, '5': true, '6': true, '7': true, '8': true, '9': true,
        '_': true, '.': true, '-': true, '/': true,
}

func Urlencode(str string) string <span class="cov8" title="1">{
        // output matches python's urllib.quote()

        finalSize := len(str)
        for i := 0; i &lt; len(str); i++ </span><span class="cov8" title="1">{
                if !urlSafeMap[str[i]] </span><span class="cov8" title="1">{
                        finalSize += 2
                }</span>
        }
        <span class="cov8" title="1">if finalSize == len(str) </span><span class="cov8" title="1">{
                return str
        }</span>
        <span class="cov8" title="1">buf := make([]byte, finalSize)
        j := 0
        for i := 0; i &lt; len(str); i++ </span><span class="cov8" title="1">{
                if urlSafeMap[str[i]] </span><span class="cov8" title="1">{
                        buf[j] = str[i]
                        j++
                }</span> else<span class="cov8" title="1"> {
                        buf[j] = '%'
                        buf[j+1] = "0123456789ABCDEF"[str[i]&gt;&gt;4]
                        buf[j+2] = "0123456789ABCDEF"[str[i]&amp;15]
                        j += 3
                }</span>
        }
        <span class="cov8" title="1">return string(buf)</span>
}

func ParseDate(date string) (time.Time, error) <span class="cov8" title="1">{
        if date == "" </span><span class="cov8" title="1">{
                return time.Now(), fmt.Errorf("invalid time: %q", date)
        }</span>
        <span class="cov8" title="1">if timestamp, err := strconv.ParseFloat(date, 64); err == nil </span><span class="cov8" title="1">{
                nans := int64((timestamp - float64(int64(timestamp))) * 1.0e9)
                return time.Unix(int64(timestamp), nans).In(GMT), nil
        }</span>
        <span class="cov8" title="1">if ius, err := time.ParseInLocation(time.RFC1123, date, GMT); err == nil </span><span class="cov8" title="1">{
                return ius, nil
        }</span>
        <span class="cov8" title="1">if ius, err := time.ParseInLocation(time.RFC1123Z, date, GMT); err == nil </span><span class="cov8" title="1">{
                return ius, nil
        }</span>
        <span class="cov8" title="1">if ius, err := time.ParseInLocation(time.ANSIC, date, GMT); err == nil </span><span class="cov8" title="1">{
                return ius, nil
        }</span>
        <span class="cov8" title="1">if ius, err := time.ParseInLocation(time.RFC850, date, GMT); err == nil </span><span class="cov8" title="1">{
                return ius, nil
        }</span>
        <span class="cov8" title="1">if ius, err := time.ParseInLocation(time.RFC3339, date, GMT); err == nil </span><span class="cov8" title="1">{
                return ius, nil
        }</span>
        <span class="cov8" title="1">if strings.Contains(date, "_") </span><span class="cov0" title="0">{
                allDateParts := strings.Split(date, "_")
                return ParseDate(allDateParts[0])
        }</span>
        <span class="cov8" title="1">return time.Now(), fmt.Errorf("invalid time: %q", date)</span>
}

func CanonicalTimestamp(t float64) string <span class="cov8" title="1">{
        ret := strconv.FormatFloat(t, 'f', 5, 64)
        for len(ret) &lt; 16 </span><span class="cov8" title="1">{
                ret = "0" + ret
        }</span>
        <span class="cov8" title="1">return ret</span>
}

func LooksTrue(check string) bool <span class="cov8" title="1">{
        check = strings.TrimSpace(strings.ToLower(check))
        return check == "true" || check == "yes" || check == "1" || check == "on" || check == "t" || check == "y"
}</span>

func UUID() string <span class="cov8" title="1">{
        return fmt.Sprintf("%08x-%04x-%04x-%04x-%012x", rand.Int63n(0xffffffff), rand.Int63n(0xffff), rand.Int63n(0xffff), rand.Int63n(0xffff), rand.Int63n(0xffffffffffff))
}</span>

func CanonicalTimestampFromTime(t time.Time) string <span class="cov8" title="1">{
        return CanonicalTimestamp(float64(t.UnixNano()) / 1000000000.0)
}</span>

func GetTimestamp() string <span class="cov8" title="1">{
        return CanonicalTimestampFromTime(time.Now())
}</span>

func FormatLastModified(lastModified time.Time) string <span class="cov8" title="1">{
        if lastModified.Nanosecond() &gt; 0 </span><span class="cov8" title="1">{ // for some reason, Last-Modified is ceil(X-Timestamp)
                lastModified = lastModified.Truncate(time.Second).Add(time.Second)
        }</span>
        <span class="cov8" title="1">return lastModified.In(GMT).Format(time.RFC1123)</span>
}

func GetTransactionId() string <span class="cov8" title="1">{
        return fmt.Sprintf("tx%012x%09x-%x", rand.Int63n(0xffffffffffff), rand.Int63n(0xfffffffff), time.Now().UnixNano())
}</span>

func HeaderGetDefault(h http.Header, key string, dfl string) string <span class="cov0" title="0">{
        val := h.Get(key)
        if val == "" </span><span class="cov0" title="0">{
                return dfl
        }</span>
        <span class="cov0" title="0">return val</span>
}

func ParseRange(rangeHeader string, fileSize int64) (reqRanges []HttpRange, err error) <span class="cov8" title="1">{
        origRangeHeader := rangeHeader
        rangeHeader = strings.Replace(strings.ToLower(rangeHeader), " ", "", -1)
        if !strings.HasPrefix(rangeHeader, "bytes=") </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">rangeHeader = rangeHeader[6:]
        rangeStrings := strings.Split(rangeHeader, ",")
        if len(rangeStrings) &gt; 100 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Too many ranges: %q", origRangeHeader)
        }</span>
        <span class="cov8" title="1">if len(rangeStrings) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">for _, rng := range rangeStrings </span><span class="cov8" title="1">{
                var start, end int64
                var err error
                startend := strings.Split(rng, "-")
                if len(startend) != 2 || (startend[0] == "" &amp;&amp; startend[1] == "") </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">if start, err = strconv.ParseInt(startend[0], 0, 64); err != nil &amp;&amp; startend[0] != "" </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">if end, err = strconv.ParseInt(startend[1], 0, 64); err != nil &amp;&amp; startend[1] != "" </span><span class="cov8" title="1">{
                        return nil, nil
                }</span> else<span class="cov8" title="1"> if startend[1] != "" &amp;&amp; end &lt; start </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>

                <span class="cov8" title="1">if startend[0] == "" </span><span class="cov8" title="1">{
                        if end == 0 </span><span class="cov8" title="1">{
                                continue</span>
                        } else<span class="cov8" title="1"> if end &gt; fileSize </span><span class="cov8" title="1">{
                                reqRanges = append(reqRanges, HttpRange{0, fileSize})
                        }</span> else<span class="cov8" title="1"> {
                                reqRanges = append(reqRanges, HttpRange{fileSize - end, fileSize})
                        }</span>
                } else<span class="cov8" title="1"> if startend[1] == "" </span><span class="cov8" title="1">{
                        if start &lt; fileSize </span><span class="cov8" title="1">{
                                reqRanges = append(reqRanges, HttpRange{start, fileSize})
                        }</span> else<span class="cov8" title="1"> {
                                continue</span>
                        }
                } else<span class="cov8" title="1"> if start &lt; fileSize </span><span class="cov8" title="1">{
                        if end+1 &lt; fileSize </span><span class="cov8" title="1">{
                                reqRanges = append(reqRanges, HttpRange{start, end + 1})
                        }</span> else<span class="cov8" title="1"> {
                                reqRanges = append(reqRanges, HttpRange{start, fileSize})
                        }</span>
                }
        }
        <span class="cov8" title="1">if len(reqRanges) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Unsatisfiable range: %q", origRangeHeader)
        }</span>
        <span class="cov8" title="1">return reqRanges, nil</span>
}

func GetEpochFromTimestamp(timestamp string) (string, error) <span class="cov8" title="1">{
        split_timestamp := strings.Split(timestamp, "_")
        floatTimestamp, err := strconv.ParseFloat(split_timestamp[0], 64)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("Could not parse float from %q", split_timestamp[0])
        }</span>
        <span class="cov8" title="1">return CanonicalTimestamp(floatTimestamp), nil</span>
}

func StandardizeTimestamp(timestamp string) (string, error) <span class="cov8" title="1">{
        offset := strings.Contains(timestamp, "_")
        if offset </span><span class="cov8" title="1">{
                split_timestamp := strings.Split(timestamp, "_")
                floatTimestamp, err := strconv.ParseFloat(split_timestamp[0], 64)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("Could not parse float from %q", split_timestamp[0])
                }</span>
                <span class="cov8" title="1">intOffset, err := strconv.ParseInt(split_timestamp[1], 16, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("Could not parse int from %q", split_timestamp[1])
                }</span>

                <span class="cov8" title="1">split_timestamp[0] = CanonicalTimestamp(floatTimestamp)
                split_timestamp[1] = fmt.Sprintf("%016x", intOffset)
                timestamp = strings.Join(split_timestamp, "_")</span>
        } else<span class="cov8" title="1"> {
                floatTimestamp, err := strconv.ParseFloat(timestamp, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("Could not parse float from %q", timestamp)
                }</span>
                <span class="cov8" title="1">timestamp = CanonicalTimestamp(floatTimestamp)</span>
        }
        <span class="cov8" title="1">return timestamp, nil</span>
}

// will split out url path the proxy would receive and return map
// with keys: "vrs", "account", "container", "object"
func ParseProxyPath(pth string) (pathMap map[string]string, err error) <span class="cov8" title="1">{
        pathParts := []string{"", "vrs", "account", "container", "object"}
        pathSplit := strings.SplitN(pth, "/", 5)
        if pathSplit[0] != "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Invalid path: %s", pth)
        }</span>
        <span class="cov8" title="1">pathMap = map[string]string{}
        for i := 1; i &lt; len(pathParts); i++ </span><span class="cov8" title="1">{
                if len(pathSplit) &lt;= i </span><span class="cov8" title="1">{
                        pathMap[pathParts[i]] = ""
                }</span> else<span class="cov8" title="1"> {
                        if pathSplit[i] == "" &amp;&amp; len(pathSplit)-1 != i </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("Invalid path: %s", pth)
                        }</span>
                        <span class="cov8" title="1">pathMap[pathParts[i]] = pathSplit[i]</span>
                }
        }
        <span class="cov8" title="1">return pathMap, err</span>
}

var buf64kpool = NewFreePool(128)

// CopyQuorum copies data from src to dsts.
// It behaves mostly like a Copy to a MultiWriter, but it doesn't return an error when a single dst has a write error,
// only after the number of working dsts drops below quorum.
func CopyQuorum(src io.Reader, quorum int, dsts ...io.Writer) (int64, error) <span class="cov0" title="0">{
        buf, ok := buf64kpool.Get().([]byte)
        if !ok </span><span class="cov0" title="0">{
                buf = make([]byte, 64*1024)
        }</span>
        <span class="cov0" title="0">defer buf64kpool.Put(buf)

        var written int64
        for </span><span class="cov0" title="0">{
                nr, rerr := src.Read(buf)
                if nr &gt; 0 </span><span class="cov0" title="0">{
                        working := 0
                        for i, w := range dsts </span><span class="cov0" title="0">{
                                if w == nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">if n, err := w.Write(buf[0:nr]); err != nil || n != nr </span><span class="cov0" title="0">{
                                        dsts[i] = nil
                                        continue</span>
                                }
                                <span class="cov0" title="0">working++</span>
                        }
                        <span class="cov0" title="0">if working &lt; quorum </span><span class="cov0" title="0">{
                                return written, errors.New("Too many writers failed.")
                        }</span>
                }
                <span class="cov0" title="0">if rerr == io.EOF </span><span class="cov0" title="0">{
                        return written, nil
                }</span> else<span class="cov0" title="0"> if rerr != nil </span><span class="cov0" title="0">{
                        return written, rerr
                }</span>
                <span class="cov0" title="0">written += int64(nr)</span>
        }
}

func Copy(src io.Reader, dsts ...io.Writer) (written int64, err error) <span class="cov8" title="1">{
        var buf []byte
        var ok bool
        if buf, ok = buf64kpool.Get().([]byte); !ok </span><span class="cov8" title="1">{
                buf = make([]byte, 64*1024)
        }</span>
        <span class="cov8" title="1">written, err = io.CopyBuffer(io.MultiWriter(dsts...), src, buf)
        buf64kpool.Put(buf)
        return</span>
}

func CopyN(src io.Reader, n int64, dsts ...io.Writer) (written int64, err error) <span class="cov8" title="1">{
        written, err = Copy(io.LimitReader(src, n), dsts...)
        if written == n </span><span class="cov8" title="1">{
                return n, nil
        }</span>
        <span class="cov0" title="0">if written &lt; n &amp;&amp; err == nil </span><span class="cov0" title="0">{
                err = io.EOF
        }</span>
        <span class="cov0" title="0">return</span>
}

func GetDefault(h http.Header, key string, dfl string) string <span class="cov8" title="1">{
        val := h.Get(key)
        if val == "" </span><span class="cov8" title="1">{
                return dfl
        }</span>
        <span class="cov8" title="1">return val</span>
}

// More like a map of semaphores.  I don't know what to call it.
type KeyedLimit struct {
        limitPerKey int64
        totalLimit  int64
        lock        sync.Mutex
        locked      map[string]bool
        inUse       map[string]int64
        totalUse    int64
}

func (k *KeyedLimit) Acquire(key string, force bool) int64 <span class="cov8" title="1">{
        // returns 0 if Acquire is successful, otherwise the number of requests inUse by disk or -1 if disk is locked
        k.lock.Lock()
        if k.locked[key] </span><span class="cov0" title="0">{
                k.lock.Unlock()
                return -1
        }</span> else<span class="cov8" title="1"> if v := k.inUse[key]; !force &amp;&amp; ((k.limitPerKey &gt; 0 &amp;&amp; v &gt;= k.limitPerKey) || (k.totalLimit &gt; 0 &amp;&amp; k.totalUse &gt; k.totalLimit)) </span><span class="cov8" title="1">{
                k.lock.Unlock()
                return v
        }</span> else<span class="cov8" title="1"> {
                k.inUse[key] += 1
                k.totalUse += 1
                k.lock.Unlock()
                return 0
        }</span>
}

func (k *KeyedLimit) Release(key string) <span class="cov8" title="1">{
        k.lock.Lock()
        k.inUse[key] -= 1
        k.totalUse -= 1
        k.lock.Unlock()
}</span>

func (k *KeyedLimit) Lock(key string) <span class="cov0" title="0">{
        k.lock.Lock()
        k.locked[key] = true
        k.lock.Unlock()
}</span>

func (k *KeyedLimit) Unlock(key string) <span class="cov0" title="0">{
        k.lock.Lock()
        k.locked[key] = false
        k.lock.Unlock()
}</span>

func (k *KeyedLimit) Keys() []string <span class="cov0" title="0">{
        k.lock.Lock()
        keys := make([]string, len(k.inUse))
        i := 0
        for key := range k.inUse </span><span class="cov0" title="0">{
                keys[i] = key
                i += 1
        }</span>
        <span class="cov0" title="0">k.lock.Unlock()
        return keys</span>
}

func (k *KeyedLimit) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        k.lock.Lock()
        data, err := json.Marshal(k.inUse)
        k.lock.Unlock()
        return data, err
}</span>

func NewKeyedLimit(limitPerKey int64, totalLimit int64) *KeyedLimit <span class="cov8" title="1">{
        return &amp;KeyedLimit{limitPerKey: limitPerKey, totalLimit: totalLimit, locked: make(map[string]bool), inUse: make(map[string]int64)}
}</span>

func Map2Headers(m map[string]string) http.Header <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">headers := make(http.Header, len(m))
        for k, v := range m </span><span class="cov8" title="1">{
                headers.Set(k, v)
        }</span>
        <span class="cov8" title="1">return headers</span>
}

func Headers2Map(headers http.Header) map[string]string <span class="cov8" title="1">{
        if headers == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">m := make(map[string]string, len(headers))
        for k := range headers </span><span class="cov8" title="1">{
                m[k] = headers.Get(k)
        }</span>
        <span class="cov8" title="1">return m</span>
}

func CheckNameFormat(req *http.Request, name string, target string) (string, error) <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("%s name cannot be empty", target)
        }</span>
        <span class="cov8" title="1">if strings.Contains(name, "/") </span><span class="cov8" title="1">{
                return "", fmt.Errorf("%s name cannot contain slashes", target)
        }</span>
        <span class="cov8" title="1">return name, nil</span>
}

func ParseContentTypeForSlo(contentType string, listedSize int64) (string, int64, error) <span class="cov8" title="1">{
        // somewhat dirty check to see if we need to parse the content-type
        if strings.Contains(contentType, ";") &amp;&amp; strings.Contains(contentType, "swift_bytes") </span><span class="cov8" title="1">{
                contentTypeCleaned, params, err := mime.ParseMediaType(contentType)
                if err != nil </span><span class="cov0" title="0">{
                        return "", 0, err
                }</span>
                <span class="cov8" title="1">if v, ok := params["swift_bytes"]; ok </span><span class="cov8" title="1">{
                        sloSize, err := strconv.ParseInt(v, 0, 64)
                        if err != nil </span><span class="cov8" title="1">{
                                return "", 0, err
                        }</span>
                        <span class="cov8" title="1">delete(params, "swift_bytes")
                        return mime.FormatMediaType(contentTypeCleaned, params), sloSize, nil</span>
                }
        }
        <span class="cov8" title="1">return contentType, listedSize, nil</span>
}

func SliceFromCSV(csv string) []string <span class="cov8" title="1">{
        s := []string{}
        for _, val := range strings.Split(csv, ",") </span><span class="cov8" title="1">{
                if strings.TrimSpace(val) != "" </span><span class="cov8" title="1">{
                        s = append(s, strings.TrimSpace(val))
                }</span>
        }
        <span class="cov8" title="1">return s</span>
}

func StringInSlice(s string, slice []string) bool <span class="cov8" title="1">{
        for _, x := range slice </span><span class="cov8" title="1">{
                if x == s </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func StringInSliceIndex(s string, slice []string) int <span class="cov8" title="1">{
        for i, x := range slice </span><span class="cov8" title="1">{
                if x == s </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func IsOriginAllowed(allowedOriginHeader, requestOrigin string) bool <span class="cov8" title="1">{
        allowOrigins := strings.Split(allowedOriginHeader, " ")
        for _, o := range allowOrigins </span><span class="cov8" title="1">{
                if o == "*" || o == requestOrigin </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func ParseIfMatch(s string) map[string]bool <span class="cov8" title="1">{
        r := make(map[string]bool)
        if len(strings.Trim(s, " ")) &gt; 0 </span><span class="cov0" title="0">{
                for _, ss := range strings.Split(s, ",") </span><span class="cov0" title="0">{
                        if sst := strings.Trim(ss, " "); sst != "" </span><span class="cov0" title="0">{
                                if sst[0] == '"' &amp;&amp; sst[len(sst)-1] == '"' </span><span class="cov0" title="0">{
                                        r[sst[1:len(sst)-1]] = true
                                }</span> else<span class="cov0" title="0"> {
                                        r[sst] = true
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return r</span>
}

func FileMD5(files ...string) (map[string]string, error) <span class="cov0" title="0">{
        response := make(map[string]string)
        for _, file := range files </span><span class="cov0" title="0">{
                fp, err := os.Open(file)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">defer fp.Close()
                hash := md5.New()
                io.Copy(hash, fp)
                response[file] = fmt.Sprintf("%x", hash.Sum(nil))</span>
        }
        <span class="cov0" title="0">return response, nil</span>
}

func GetAllRingFileMd5s() (map[string]string, error) <span class="cov0" title="0">{
        // if there is a /etc/hummingbird- use it for all rings
        ringMap := map[string]string{}
        etcDir := "/etc/hummingbird"
        if _, err := os.Stat(etcDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                etcDir = "/etc/swift"
        }</span>
        <span class="cov0" title="0">ringFiles := []string{filepath.Join(etcDir, "account.ring.gz"),
                filepath.Join(etcDir, "container.ring.gz")}
        if files, err := ioutil.ReadDir(etcDir); err == nil </span><span class="cov0" title="0">{
                for _, file := range files </span><span class="cov0" title="0">{
                        fname := file.Name()
                        if strings.HasPrefix(fname, "object") &amp;&amp; strings.HasSuffix(fname, "ring.gz") </span><span class="cov0" title="0">{
                                ringFiles = append(ringFiles, filepath.Join(etcDir, fname))
                        }</span>
                }
                <span class="cov0" title="0">return FileMD5(ringFiles...)</span>
        } else<span class="cov0" title="0"> {
                return ringMap, err
        }</span>
}

func NewClientTLSConfig(certFile, keyFile string) (*tls.Config, error) <span class="cov0" title="0">{
        cert, err := tls.LoadX509KeyPair(certFile, keyFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Unable to load cert %s %s: %s", certFile, keyFile, err.Error())
        }</span>
        <span class="cov0" title="0">tlsConf := &amp;tls.Config{
                Certificates: []tls.Certificate{cert},
                MinVersion:   tls.VersionTLS12,
        }
        return tlsConf, nil</span>
}

func IsCorruptDBError(err error) bool <span class="cov8" title="1">{
        a := err.Error()
        for _, b := range []string{
                "database disk image is malformed",
                "file is encrypted or is not a database",
                "file is not a database",
        } </span><span class="cov8" title="1">{
                if strings.Contains(a, b) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func QuarantineDir(dirPath string, dirDepth int, dirType string) error <span class="cov8" title="1">{
        dstDirPath := dirPath
        for dirDepth &gt; 0 </span><span class="cov8" title="1">{
                dstDirPath = path.Dir(dstDirPath)
                dirDepth--
        }</span>
        <span class="cov8" title="1">dstDirPath = path.Join(dstDirPath, "quarantined", dirType)
        err := os.MkdirAll(dstDirPath, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not quarantine; error: %s", err)
        }</span>
        <span class="cov8" title="1">dstDirPath, err = ioutil.TempDir(dstDirPath, path.Base(dirPath)+"-")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not quarantine; error: %s", err)
        }</span>
        <span class="cov8" title="1">err = os.Remove(dstDirPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not quarantine; error: %s", err)
        }</span>
        <span class="cov8" title="1">err = os.Rename(dirPath, dstDirPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not quarantine; error: %s", err)
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("quarantined %s to %s", dirPath, dstDirPath)</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">//  Copyright (c) 2016 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package containerserver

import (
        "container/list"
        "crypto/md5"
        "encoding/xml"
        "fmt"
        "os"
        "path/filepath"
        "sync"
        "time"

        "github.com/troubling/hummingbird/common/fs"
)

var (
        // ErrorNoSuchContainer is returned when a requested container doesn't exist.
        ErrorNoSuchContainer = fmt.Errorf("No such container.")
        // ErrorInvalidMetadata is returned for errors that violate the API metadata constraints.
        ErrorInvalidMetadata = fmt.Errorf("Invalid metadata value")
        // ErrorPolicyConflict is returned when an operation conflicts with the container's existing policy.
        ErrorPolicyConflict = fmt.Errorf("Policy conflicts with existing value")
)

// ContainerInfo represents the container_info database record - basic information about the container.
type ContainerInfo struct {
        Account                 string              `json:"account"`
        Container               string              `json:"container"`
        CreatedAt               string              `json:"created_at"`
        PutTimestamp            string              `json:"put_timestamp"`
        DeleteTimestamp         string              `json:"delete_timestamp"`
        StatusChangedAt         string              `json:"status_changed_at"`
        ObjectCount             int64               `json:"count"`
        BytesUsed               int64               `json:"bytes_used"`
        ReportedPutTimestamp    string              `json:"-"`
        ReportedDeleteTimestamp string              `json:"-"`
        ReportedObjectCount     int64               `json:"-"`
        ReportedBytesUsed       int64               `json:"-"`
        Hash                    string              `json:"hash"`
        ID                      string              `json:"id"`
        XContainerSyncPoint1    string              `json:"-"`
        XContainerSyncPoint2    string              `json:"-"`
        StoragePolicyIndex      int                 `json:"storage_policy_index"`
        RawMetadata             string              `json:"metadata"`
        Metadata                map[string][]string `json:"-"`
        MaxRow                  int64               `json:"max_row"`
        invalid                 bool
        updated                 time.Time
        // This row isn't populated by GetInfo, it only exists for the times this is
        // serialized during replication.
        Point int64 `json:"point"`
}

// ObjectListingRecord is the struct used for serializing objects in json and xml container listings.
type ObjectListingRecord struct {
        XMLName      xml.Name `xml:"object" json:"-"`
        Name         string   `xml:"name" json:"name"`
        LastModified string   `xml:"last_modified" json:"last_modified"`
        Size         int64    `xml:"bytes" json:"bytes"`
        ContentType  string   `xml:"content_type" json:"content_type"`
        ETag         string   `xml:"hash" json:"hash"`
}

// SubdirListingRecord is the struct used for serializing subdirs in json and xml container listings.
type SubdirListingRecord struct {
        XMLName xml.Name `xml:"subdir" json:"-"`
        Name2   string   `xml:"name,attr" json:"-"`
        Name    string   `xml:"name" json:"subdir"`
}

// ObjectRecord represents the object's data in-databaee, it is used by replication.
type ObjectRecord struct {
        Rowid              int64   `json:"ROWID"`
        Name               string  `json:"name"`
        CreatedAt          string  `json:"created_at"`
        Size               int64   `json:"size"`
        ContentType        string  `json:"content_type"`
        ETag               string  `json:"etag"`
        Deleted            int     `json:"deleted"`
        StoragePolicyIndex int     `json:"storage_policy_index"`
        Expires            *string `json:"expires"`
}

// SyncRecord represents a row in the incoming_sync table.  It is used by replication.
type SyncRecord struct {
        SyncPoint int64  `json:"sync_point"`
        RemoteID  string `json:"remote_id"`
}

// Container is the interface implemented by a container.
type Container interface {
        // GetInfo returns the ContainerInfo struct for the container.
        GetInfo() (*ContainerInfo, error)
        // IsDeleted returns true if the container has been deleted.
        IsDeleted() (bool, error)
        // Delete deletes the container.
        Delete(timestamp string) error
        // ListObjects lists the container's object entries.
        ListObjects(limit int, marker string, endMarker string, prefix string, delimiter string, path *string, reverse bool, storagePolicyIndex int) ([]interface{}, error)
        // GetMetadata returns the container's current metadata.
        GetMetadata() (map[string]string, error)
        // UpdateMetadata applies updates to the container's metadata.
        UpdateMetadata(updates map[string][]string, timestamp string) error
        // PutObject adds a new object to the container.
        PutObject(name string, timestamp string, size int64, contentType string, etag string, storagePolicyIndex int, expires string) error
        // DeleteObject deletes an object from the container.
        DeleteObject(name string, timestamp string, storagePolicyIndex int) error
        // ID returns a unique identifier for the container.
        ID() string
        // Close frees any resources associated with the container.
        Close() error
}

// ReplicableContainer is a container that also implements the replication API.
type ReplicableContainer interface {
        Container
        // MergeItems merges object records into the container, with an optional remoteId.
        MergeItems(records []*ObjectRecord, remoteID string) error
        // ItemsSince returns count object records with a ROWID greater than start.
        ItemsSince(start int64, count int) ([]*ObjectRecord, error)
        // MergeSyncTable updates the container's incoming sync tables with new data.
        MergeSyncTable(records []*SyncRecord) error
        // SyncTable returns the container's current sync table.
        SyncTable() ([]*SyncRecord, error)
        // SyncRemoteData accepts a remote container's current status information and updates local records accordingly.
        SyncRemoteData(maxRow int64, hash, id, createdAt, putTimestamp, deleteTimestamp, metadata string) (*ContainerInfo, error)
        // NewID gives the database a new unique identifier, which is used for incoming_sync entries.
        NewID() error
        // OpenDatabaseFile returns a consistent reader for the underlying database file.
        OpenDatabaseFile() (*os.File, func(), error)
        // CleanupTombstones removes any metadata and object tombstones older than reclaimAge seconds.
        CleanupTombstones(reclaimAge int64) error
        // CheckSyncLinks makes sure container sync symlinks are correct for the database.
        CheckSyncLink() error
        // RingHash returns the container's ring hash.
        RingHash() string
        // Reported records the information as having been reported to an account database.
        Reported(putTimestamp, deleteTimestamp string, objectCount, bytesUsed int64) error
}

// ContainerEngine is the interface of an object that creates and returns containers.
type ContainerEngine interface {
        // GET returns a container, given a vars mapping.
        Get(vars map[string]string) (c Container, err error)
        // Return returns a Container to the engine, where it can close or retain them as it sees fit.
        Return(c Container)
        // Create creates a new container.  Returns true if the container was created and a pointer to the container.
        Create(vars map[string]string, putTimestamp string, metadata map[string][]string, policyIndex, defaultPolicyIndex int) (bool, Container, error)
        // Close releases all cached containers and any other retained resources.
        Close()

        // GetByHash returns a replicable database given its hash.  This will probably move from this interface once we
        // have replicator-&gt;replicator communication.
        GetByHash(device, hash, partition string) (c ReplicableContainer, err error)
        // Invalidate removes a container from the cache entirely.  This will probably also move, since it's only used by replication.
        Invalidate(c Container)

        // Number of containers that have been Get()ted but not Return()ed
        OpenCount() (count int)
}

// My attempts at making this lruEngine reusable have not been successful, so for now it's sqlite-specific and not exported.
type lruEngine struct {
        deviceRoot     string
        hashPathPrefix string
        hashPathSuffix string
        maxSize        int
        cache          map[string]*lruEntry
        used           *list.List
        m              sync.Mutex
}

type lruEntry struct {
        c     Container
        inUse int
        elem  *list.Element
}

func (l *lruEngine) add(c Container) <span class="cov8" title="1">{
        if len(l.cache) &gt;= l.maxSize </span><span class="cov8" title="1">{
                for elem := l.used.Front(); elem != nil; elem = elem.Next() </span><span class="cov8" title="1">{
                        if entry, ok := elem.Value.(*lruEntry); ok &amp;&amp; entry.inUse == 0 </span><span class="cov8" title="1">{
                                l.used.Remove(elem)
                                delete(l.cache, entry.c.ID())
                                entry.c.Close()
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">holder := &amp;lruEntry{c: c, inUse: 1}
        holder.elem = l.used.PushBack(holder)
        l.cache[c.ID()] = holder</span>
}

func (l *lruEngine) OpenCount() int <span class="cov8" title="1">{
        count := 0
        l.m.Lock()
        for elem := l.used.Front(); elem != nil; elem = elem.Next() </span><span class="cov8" title="1">{
                if entry, ok := elem.Value.(*lruEntry); ok &amp;&amp; entry.inUse == 1 </span><span class="cov8" title="1">{
                        count++
                }</span>
        }
        <span class="cov8" title="1">defer l.m.Unlock()
        return count</span>
}

func (l *lruEngine) containerLocation(vars map[string]string) string <span class="cov8" title="1">{
        h := md5.New()
        fmt.Fprintf(h, "%s/%s/%s%s", l.hashPathPrefix, vars["account"], vars["container"], l.hashPathSuffix)
        hexHash := fmt.Sprintf("%032x", h.Sum(nil))
        suffix := hexHash[29:32]
        return filepath.Join(l.deviceRoot, vars["device"], "containers", vars["partition"], suffix, hexHash, hexHash+".db")
}</span>

func (l *lruEngine) getbypath(containerFile string) (c Container, err error) <span class="cov8" title="1">{
        if !fs.Exists(containerFile) </span><span class="cov8" title="1">{
                return nil, ErrorNoSuchContainer
        }</span>
        <span class="cov8" title="1">ringHash := filepath.Base(filepath.Dir(containerFile))
        l.m.Lock()
        defer l.m.Unlock()
        if e := l.cache[ringHash]; e != nil </span><span class="cov8" title="1">{
                e.inUse++
                l.used.MoveToBack(e.elem)
                return e.c, nil
        }</span>
        <span class="cov8" title="1">if c, err = sqliteOpenContainer(containerFile); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">l.add(c)
        return c, nil</span>
}

// Get returns a database given the incoming vars.
func (l *lruEngine) Get(vars map[string]string) (c Container, err error) <span class="cov8" title="1">{
        return l.getbypath(l.containerLocation(vars))
}</span>

// Create creates a new container.
func (l *lruEngine) Create(vars map[string]string, putTimestamp string, metadata map[string][]string, policyIndex, defaultPolicyIndex int) (bool, Container, error) <span class="cov8" title="1">{
        containerFile := l.containerLocation(vars)
        created := false
        c, err := l.Get(vars)
        if err != nil </span><span class="cov8" title="1">{
                created = true
                if policyIndex &lt; 0 </span><span class="cov8" title="1">{
                        policyIndex = defaultPolicyIndex
                }</span>
                <span class="cov8" title="1">err = sqliteCreateContainer(containerFile, vars["account"], vars["container"], putTimestamp, metadata, policyIndex)
                if err == nil </span><span class="cov8" title="1">{
                        c, err = l.Get(vars)
                }</span>
        } else<span class="cov8" title="1"> {
                created, err = sqliteCreateExistingContainer(c, putTimestamp, metadata, policyIndex, defaultPolicyIndex)
                if err != nil </span><span class="cov8" title="1">{
                        l.Return(c)
                        c = nil
                }</span>
        }
        <span class="cov8" title="1">return created, c, err</span>
}

// Return returns a database object to the engine.
func (l *lruEngine) Return(c Container) <span class="cov8" title="1">{
        l.m.Lock()
        if e := l.cache[c.ID()]; e != nil &amp;&amp; e.c == c </span><span class="cov8" title="1">{
                e.inUse--
        }</span> else<span class="cov8" title="1"> {
                l.add(c)
        }</span>
        <span class="cov8" title="1">l.m.Unlock()</span>
}

// GetByHash returns a database given its device and ring hash.
func (l *lruEngine) GetByHash(device, hash, partition string) (ReplicableContainer, error) <span class="cov8" title="1">{
        containerFile := filepath.Join(l.deviceRoot, device, "containers", partition, hash[29:32], hash, hash+".db")
        c, err := l.getbypath(containerFile)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">rc, ok := c.(ReplicableContainer)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Container does not support replication.")
        }</span>
        <span class="cov8" title="1">return rc, nil</span>
}

// Invalidate removes any cached backend connections to the database.
func (l *lruEngine) Invalidate(c Container) <span class="cov8" title="1">{
        defer c.Close()
        l.m.Lock()
        if e := l.cache[c.ID()]; e != nil &amp;&amp; e.c == c </span><span class="cov8" title="1">{
                l.used.Remove(e.elem)
                delete(l.cache, c.ID())
        }</span>
        <span class="cov8" title="1">l.m.Unlock()</span>
}

// Close shuts down any backend container database connections and clears the caches.
func (l *lruEngine) Close() <span class="cov8" title="1">{
        for k, v := range l.cache </span><span class="cov8" title="1">{
                v.c.Close()
                delete(l.cache, k)
        }</span>
        <span class="cov8" title="1">l.used = l.used.Init()</span>
}

func newLRUEngine(deviceRoot, hashPathPrefix, hashPathSuffix string, containerCount int) *lruEngine <span class="cov8" title="1">{
        return &amp;lruEngine{
                deviceRoot:     deviceRoot,
                hashPathPrefix: hashPathPrefix,
                hashPathSuffix: hashPathSuffix,
                maxSize:        containerCount,
                cache:          make(map[string]*lruEntry),
                used:           list.New(),
        }
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">//  Copyright (c) 2016 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package containerserver

import (
        "encoding/json"
        "errors"
        "io"
        "net/http"
        "os"
        "path/filepath"

        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/srv"
        "go.uber.org/zap"
)

func isOkayFilename(s string) bool <span class="cov8" title="1">{
        if len(s) &lt; 5 || len(s) &gt; 100 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for _, c := range s </span><span class="cov8" title="1">{
                if !((c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= '0' &amp;&amp; c &lt;= '9') ||
                        (c == '-') || (c == '_') || (c == '.')) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// ContainerTmpUploadHandler handles uploading container files to the tmp directory for various replication strategies.
// This replaces the swift replicator's use of rsync.
func (server *ContainerServer) ContainerTmpUploadHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        if !isOkayFilename(vars["filename"]) </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">filename := filepath.Join(server.driveRoot, vars["device"], "tmp", vars["filename"])
        if err := os.MkdirAll(filepath.Dir(filename), 0755); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">fp, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to create file.",
                        zap.String("filename", filename),
                        zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer fp.Close()
        if _, err := io.Copy(fp, request.Body); err != nil </span><span class="cov0" title="0">{
                os.RemoveAll(filename)
                srv.GetLogger(request).Error("Error saving file contents.",
                        zap.String("filename", filename),
                        zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
        }</span> else<span class="cov8" title="1"> {
                srv.StandardResponse(writer, http.StatusCreated)
        }</span>
}

// ContainerReplicateHandler handles the REPLICATE call for containers.
func (server *ContainerServer) ContainerReplicateHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        // make sure there's a tmp dir to rsync to
        if err := os.MkdirAll(filepath.Join(server.driveRoot, vars["device"], "tmp"), 0777); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">message := []json.RawMessage{}
        decoder := json.NewDecoder(request.Body)
        if err := decoder.Decode(&amp;message); err != nil </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">var op string
        if err := json.Unmarshal(message[0], &amp;op); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">extractArgs := func(args ...interface{}) error </span><span class="cov8" title="1">{
                if len(message)-1 &lt; len(args) </span><span class="cov8" title="1">{
                        return errors.New("Not enough arguments in payload.")
                }</span>
                <span class="cov8" title="1">for i, arg := range args </span><span class="cov8" title="1">{
                        if err := json.Unmarshal(message[i+1], arg); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov8" title="1">switch op </span>{
        case "rsync_then_merge":<span class="cov8" title="1">
                var tmpFileName string
                if err := extractArgs(&amp;tmpFileName); err != nil </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                }</span> else<span class="cov8" title="1"> {
                        status := server.replicateRsyncThenMerge(request, vars, tmpFileName)
                        srv.StandardResponse(writer, status)
                }</span>
        case "complete_rsync":<span class="cov8" title="1">
                var tmpFileName string
                if err := extractArgs(&amp;tmpFileName); err != nil </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                }</span> else<span class="cov8" title="1"> {
                        status := server.replicateCompleteRsync(request, vars, tmpFileName)
                        srv.StandardResponse(writer, status)
                }</span>
        case "merge_items":<span class="cov8" title="1">
                var records []*ObjectRecord
                var remoteID string
                if err := extractArgs(&amp;records, &amp;remoteID); err != nil </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                }</span> else<span class="cov8" title="1"> {
                        status := server.replicateMergeItems(request, vars, records, remoteID)
                        srv.StandardResponse(writer, status)
                }</span>
        case "merge_syncs":<span class="cov8" title="1">
                var records []*SyncRecord
                if err := extractArgs(&amp;records); err != nil </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                }</span> else<span class="cov8" title="1"> {
                        status := server.replicateMergeSyncs(request, vars, records)
                        srv.StandardResponse(writer, status)
                }</span>
        case "sync":<span class="cov8" title="1">
                var maxRow int64
                var hash, id, createdAt, putTimestamp, deleteTimestamp, metadata string
                if err := extractArgs(&amp;maxRow, &amp;hash, &amp;id, &amp;createdAt, &amp;putTimestamp, &amp;deleteTimestamp, &amp;metadata); err != nil </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                }</span> else<span class="cov8" title="1"> if status, data := server.replicateSync(request, vars, maxRow, hash, id, createdAt, putTimestamp, deleteTimestamp, metadata); status == http.StatusOK </span><span class="cov8" title="1">{
                        writer.WriteHeader(http.StatusOK)
                        writer.Write(data)
                }</span> else<span class="cov8" title="1"> {
                        srv.StandardResponse(writer, status)
                }</span>
        default:<span class="cov8" title="1">
                srv.GetLogger(request).Error("Unknown replication op.", zap.String("op", op))
                srv.StandardResponse(writer, http.StatusBadRequest)</span>
        }
}

func (server *ContainerServer) replicateRsyncThenMerge(request *http.Request, vars map[string]string, tmpFileName string) int <span class="cov8" title="1">{
        containerFile := filepath.Join(server.driveRoot, vars["device"], "containers", vars["partition"], vars["hash"][29:32], vars["hash"], vars["hash"]+".db")
        tmpContainerFile := filepath.Join(server.driveRoot, vars["device"], "tmp", tmpFileName)
        tmpDb, err := sqliteOpenContainer(tmpContainerFile)
        if err != nil </span><span class="cov0" title="0">{
                return http.StatusNotFound
        }</span>
        <span class="cov8" title="1">defer tmpDb.Close()
        localDb, err := server.containerEngine.GetByHash(vars["device"], vars["hash"], vars["partition"])
        if err != nil </span><span class="cov0" title="0">{
                return http.StatusNotFound
        }</span>
        <span class="cov8" title="1">defer localDb.Close()
        point := int64(-1)
        for </span><span class="cov8" title="1">{
                records, err := localDb.ItemsSince(point, 10000)
                if err != nil </span><span class="cov0" title="0">{
                        srv.GetLogger(request).Error("Error fetching items.",
                                zap.String("containerFile", containerFile),
                                zap.Error(err))
                        return http.StatusInternalServerError
                }</span>
                <span class="cov8" title="1">if len(records) == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">point = records[len(records)-1].Rowid
                if err := tmpDb.MergeItems(records, ""); err != nil </span><span class="cov0" title="0">{
                        srv.GetLogger(request).Error("Error merging items.",
                                zap.String("tmpContainerFile", tmpContainerFile),
                                zap.Error(err))
                        return http.StatusInternalServerError
                }</span>
        }
        <span class="cov8" title="1">if err := tmpDb.NewID(); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error blessing new container db",
                        zap.String("containerFile", containerFile), zap.Error(err))
                return http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">if err := os.MkdirAll(filepath.Dir(containerFile), 0777); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error blessing new container db",
                        zap.String("containerFile", containerFile), zap.Error(err))
                return http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">if err := os.Rename(tmpContainerFile, containerFile); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error blessing new container db",
                        zap.String("containerFile", containerFile), zap.Error(err))
                return http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">server.containerEngine.Invalidate(localDb)
        return http.StatusNoContent</span>
}

func (server *ContainerServer) replicateCompleteRsync(request *http.Request, vars map[string]string, tmpFileName string) int <span class="cov8" title="1">{
        containerFile := filepath.Join(server.driveRoot, vars["device"], "containers", vars["partition"], vars["hash"][29:32], vars["hash"], vars["hash"]+".db")
        tmpContainerFile := filepath.Join(server.driveRoot, vars["device"], "tmp", tmpFileName)
        if !fs.Exists(tmpContainerFile) || fs.Exists(containerFile) </span><span class="cov8" title="1">{
                return http.StatusNotFound
        }</span>
        <span class="cov8" title="1">tmpDb, err := sqliteOpenContainer(tmpContainerFile)
        if err != nil </span><span class="cov0" title="0">{
                return http.StatusNotFound
        }</span>
        <span class="cov8" title="1">defer tmpDb.Close()
        if err := tmpDb.NewID(); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error blessing new container db",
                        zap.String("containerFile", containerFile), zap.Error(err))
                return http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">if err := os.MkdirAll(filepath.Dir(containerFile), 0777); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error blessing new container db",
                        zap.String("containerFile", containerFile), zap.Error(err))
                return http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">if err := os.Rename(tmpContainerFile, containerFile); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error blessing new container db",
                        zap.String("containerFile", containerFile), zap.Error(err))
                return http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">return http.StatusNoContent</span>
}

func (server *ContainerServer) replicateMergeItems(request *http.Request, vars map[string]string, records []*ObjectRecord, remoteID string) int <span class="cov8" title="1">{
        db, err := server.containerEngine.GetByHash(vars["device"], vars["hash"], vars["partition"])
        if err != nil </span><span class="cov8" title="1">{
                return http.StatusNotFound
        }</span>
        <span class="cov8" title="1">defer server.containerEngine.Return(db)
        if err := db.MergeItems(records, remoteID); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error merging records",
                        zap.String("RingHash", db.RingHash()),
                        zap.Error(err))
                return http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">return http.StatusAccepted</span>
}

func (server *ContainerServer) replicateMergeSyncs(request *http.Request, vars map[string]string, records []*SyncRecord) int <span class="cov8" title="1">{
        db, err := server.containerEngine.GetByHash(vars["device"], vars["hash"], vars["partition"])
        if err != nil </span><span class="cov8" title="1">{
                return http.StatusNotFound
        }</span>
        <span class="cov8" title="1">defer server.containerEngine.Return(db)
        if err := db.MergeSyncTable(records); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error merging sync table.",
                        zap.String("RingHash", db.RingHash()),
                        zap.Error(err))
                return http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">return http.StatusAccepted</span>
}

func (server *ContainerServer) replicateSync(request *http.Request, vars map[string]string, maxRow int64, hash, id, createdAt, putTimestamp, deleteTimestamp, metadata string) (int, []byte) <span class="cov8" title="1">{
        db, err := server.containerEngine.GetByHash(vars["device"], vars["hash"], vars["partition"])
        if err != nil </span><span class="cov8" title="1">{
                return http.StatusNotFound, nil
        }</span>
        <span class="cov8" title="1">defer server.containerEngine.Return(db)
        info, err := db.SyncRemoteData(maxRow, hash, id, createdAt, putTimestamp, deleteTimestamp, metadata)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error syncing remote data.",
                        zap.String("vars['hash']", vars["hash"]),
                        zap.Error(err))
                return http.StatusInternalServerError, nil
        }</span>
        <span class="cov8" title="1">response, err := json.Marshal(info)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error marshaling info.",
                        zap.String("vars['hash']", vars["hash"]),
                        zap.Error(err))
                return http.StatusInternalServerError, nil
        }</span>
        <span class="cov8" title="1">return http.StatusOK, response</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package containerserver

import (
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/ring"
)

type PriorityRepJob struct {
        Partition  uint64       `json:"partition"`
        FromDevice *ring.Device `json:"from_device"`
        ToDevice   *ring.Device `json:"to_device"`
}

// TODO
func SendPriRepJob(job *PriorityRepJob, client common.HTTPClient) (string, bool) <span class="cov0" title="0">{
        return "pretending to do priority replication; normal replication should be fast enough for now", true
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">//  Copyright (c) 2016 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

// NOTE: Replication requests use the standard ip and port as the
// container-replicator web service is just for metrics at this time.

package containerserver

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "flag"
        "fmt"
        "io"
        "io/ioutil"
        "net"
        "net/http"
        _ "net/http/pprof"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/justinas/alice"
        opentracing "github.com/opentracing/opentracing-go"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/troubling/hummingbird/client"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/common/tracing"
        "github.com/troubling/hummingbird/middleware"
        "github.com/uber-go/tally"
        promreporter "github.com/uber-go/tally/prometheus"
        "go.uber.org/zap"
        "golang.org/x/net/http2"
)

var (
        errDeviceNotMounted = errors.New("Remove drive was unmounted")
        deviceLockupTimeout = time.Hour
        // GetRing is a local pointer to the hummingbird function, for overriding in tests.
        GetRing = ring.GetRing
)

// Replicator is the container replicator daemon object
type Replicator struct {
        checkMounts       bool
        deviceRoot        string
        reconCachePath    string
        logger            srv.LowLevelLogger
        serverPort        int
        Ring              ring.Ring
        accountRing       ring.Ring
        perUsync          int64
        maxUsyncs         int
        concurrencySem    chan struct{}
        sendStat          chan statUpdate
        checkin           chan string
        startRun          chan string
        client            common.HTTPClient
        runningDevices    map[string]*replicationDevice
        reclaimAge        int64
        logLevel          zap.AtomicLevel
        metricsCloser     io.Closer
        traceCloser       io.Closer
        tracer            opentracing.Tracer
        clientTracer      opentracing.Tracer
        clientTraceCloser io.Closer
}

type statUpdate struct {
        device string
        stat   string
        value  int64
}

type replicationDevice struct {
        i interface {
                sendReplicationMessage(dev *ring.Device, part uint64, ringHash string, args ...interface{}) (int, []byte, error)
                sync(dev *ring.Device, part uint64, ringHash string, info *ContainerInfo) (*ContainerInfo, error)
                rsync(dev *ring.Device, c ReplicableContainer, part uint64, op string) error
                usync(dev *ring.Device, c ReplicableContainer, part uint64, localID string, point int64) error
                chooseReplicationStrategy(localInfo, remoteInfo *ContainerInfo, usyncThreshold int64) string
                replicateDatabaseToDevice(dev *ring.Device, c ReplicableContainer, part uint64, ringIndex int) error
                replicateDatabase(dbFile string) error
                findContainerDbs(devicePath string, results chan string)
                incrementStat(stat string)
        }
        r             *Replicator
        cancel        chan struct{}
        dev           *ring.Device
        stats         map[string]int64
        lifetimeStats map[string]int64
        lastCheckin   time.Time
        runStarted    time.Time
        deviceStarted time.Time
}

func (rd *replicationDevice) sendReplicationMessage(dev *ring.Device, part uint64, ringHash string, args ...interface{}) (int, []byte, error) <span class="cov8" title="1">{
        body, err := json.Marshal(args)
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>
        <span class="cov8" title="1">req, err := http.NewRequest("REPLICATE", fmt.Sprintf("%s://%s:%d/%s/%d/%s", dev.Scheme,
                dev.Ip, dev.Port, dev.Device, part, ringHash), bytes.NewBuffer(body))
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>
        <span class="cov8" title="1">req.Header.Set("X-Backend-Suppress-2xx-Logging", "t")
        req.Cancel = rd.cancel
        resp, err := rd.r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        respBody, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, err
        }</span>
        <span class="cov8" title="1">return resp.StatusCode, respBody, nil</span>
}

func (rd *replicationDevice) sync(dev *ring.Device, part uint64, ringHash string, info *ContainerInfo) (*ContainerInfo, error) <span class="cov8" title="1">{
        var remoteInfo ContainerInfo
        status, body, err := rd.i.sendReplicationMessage(dev, part, ringHash, "sync", info.MaxRow, info.Hash,
                info.ID, info.CreatedAt, info.PutTimestamp, info.DeleteTimestamp, info.RawMetadata)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("sending sync request to %s/%s: %v", dev.Ip, dev.Device, err)
        }</span> else<span class="cov8" title="1"> if status == http.StatusNotFound </span><span class="cov8" title="1">{
                return nil, nil
        }</span> else<span class="cov8" title="1"> if status == http.StatusInsufficientStorage </span><span class="cov8" title="1">{
                return nil, errDeviceNotMounted
        }</span> else<span class="cov8" title="1"> if status/100 != 2 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("bad status code %d", status)
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal(body, &amp;remoteInfo); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("unmarshalling sync response: %v", err)
        }</span>
        <span class="cov8" title="1">return &amp;remoteInfo, nil</span>
}

func (rd *replicationDevice) rsync(dev *ring.Device, c ReplicableContainer, part uint64, op string) error <span class="cov8" title="1">{
        tmpFilename := common.UUID()
        fp, release, err := c.OpenDatabaseFile()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Error opening databae: %v", err)
        }</span>
        <span class="cov8" title="1">defer release()
        req, err := http.NewRequest("PUT", fmt.Sprintf("%s://%s:%d/%s/tmp/%s", dev.Scheme, dev.Ip, dev.Port, dev.Device, tmpFilename), fp)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("creating request: %v", err)
        }</span>
        <span class="cov8" title="1">req.Cancel = rd.cancel
        resp, err := rd.r.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("putting database to %s/%s: %v", dev.Ip, dev.Device, err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("bad status code %d rsyncing file with %s/%s", resp.StatusCode, dev.Ip, dev.Device)
        }</span>
        <span class="cov8" title="1">status, _, err := rd.i.sendReplicationMessage(dev, part, c.RingHash(), op, tmpFilename)
        if err != nil || status/100 != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("sending %s message to %s/%s: status %d: %v", op, dev.Ip, dev.Device, status, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (rd *replicationDevice) usync(dev *ring.Device, c ReplicableContainer, part uint64, localID string, point int64) error <span class="cov8" title="1">{
        objects, err := c.ItemsSince(point, int(rd.r.perUsync))
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("getting object records from %s: %v", c.RingHash(), err)
        }</span>
        <span class="cov8" title="1">usyncs := 0
        syncTable, err := c.SyncTable()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Error getting sync table: %v", err)
        }</span>
        <span class="cov8" title="1">for len(objects) != 0 &amp;&amp; usyncs &lt; rd.r.maxUsyncs </span><span class="cov8" title="1">{
                status, _, err := rd.i.sendReplicationMessage(dev, part, c.RingHash(), "merge_items", objects, localID)
                if err != nil || status/100 != 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("Bad response to merge_items with %s/%s: status %d: %v", dev.Ip, dev.Device, status, err)
                }</span>
                <span class="cov8" title="1">point = objects[len(objects)-1].Rowid
                usyncs++
                if objects, err = c.ItemsSince(point, int(rd.r.perUsync)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("getting object records from database: %s, %v", c.RingHash(), err)
                }</span>
        }
        <span class="cov8" title="1">if usyncs &gt;= rd.r.maxUsyncs </span><span class="cov0" title="0">{
                rd.i.incrementStat("diff_capped")
                return fmt.Errorf("capping usync at %d requests", usyncs)
        }</span>
        <span class="cov8" title="1">status, _, err := rd.i.sendReplicationMessage(dev, part, c.RingHash(), "merge_syncs", syncTable)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if status/100 != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid status code from merge_syncs: %d", status)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (rd *replicationDevice) chooseReplicationStrategy(localInfo, remoteInfo *ContainerInfo, usyncThreshold int64) string <span class="cov8" title="1">{
        switch </span>{
        case remoteInfo == nil:<span class="cov8" title="1">
                return "complete_rsync"</span>
        case localInfo.MaxRow == -1:<span class="cov8" title="1">
                return "empty"</span>
        case localInfo.MaxRow == remoteInfo.Point:<span class="cov8" title="1">
                return "no_change"</span>
        case localInfo.Hash == remoteInfo.Hash:<span class="cov8" title="1">
                return "hashmatch"</span>
        case remoteInfo.MaxRow &lt; localInfo.MaxRow*2 &amp;&amp; localInfo.MaxRow-remoteInfo.MaxRow &gt; usyncThreshold:<span class="cov8" title="1">
                return "rsync_then_merge"</span>
        default:<span class="cov8" title="1">
                return "diff"</span>
        }
}

func (rd *replicationDevice) replicateDatabaseToDevice(dev *ring.Device, c ReplicableContainer, part uint64, ringIndex int) error <span class="cov8" title="1">{
        rd.i.incrementStat("attempted")
        info, err := c.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("getting local info from %s: %v", c.RingHash(), err)
        }</span>
        <span class="cov8" title="1">if rd.r.accountRing != nil </span><span class="cov0" title="0">{
                if info.PutTimestamp &gt; info.ReportedPutTimestamp ||
                        info.DeleteTimestamp &gt; info.ReportedDeleteTimestamp ||
                        info.ObjectCount != info.ReportedObjectCount ||
                        info.BytesUsed != info.ReportedBytesUsed </span><span class="cov0" title="0">{

                        accountPartition := rd.r.accountRing.GetPartition(info.Account, "", "")
                        accountNodes := rd.r.accountRing.GetNodes(accountPartition)
                        accountNode := accountNodes[ringIndex%len(accountNodes)]
                        if accountUpdateHelper(
                                context.Background(),
                                info,
                                accountNode.Scheme,
                                fmt.Sprintf("%s:%d", accountNode.Ip, accountNode.Port),
                                accountNode.Device,
                                fmt.Sprintf("%d", accountPartition),
                                info.Account,
                                info.Container,
                                common.GetTransactionId(),
                                false,
                                rd.r.client,
                        ) == nil </span><span class="cov0" title="0">{
                                if err = c.Reported(info.PutTimestamp, info.DeleteTimestamp, info.ObjectCount, info.BytesUsed); err != nil </span><span class="cov0" title="0">{
                                        rd.r.logger.Error("Could not update reported info", zap.Error(err), zap.String("RingHash", c.RingHash()))
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">remoteInfo, err := rd.i.sync(dev, part, c.RingHash(), info)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">strategy := rd.i.chooseReplicationStrategy(info, remoteInfo, rd.r.perUsync*3)
        rd.i.incrementStat(strategy)
        switch strategy </span>{
        case "empty", "hashmatch", "no_change":<span class="cov8" title="1">
                rd.r.logger.Debug("Not replicating anything.",
                        zap.String("strategy", strategy),
                        zap.String("RingHash", c.RingHash()))</span>
        case "complete_rsync", "rsync_then_merge":<span class="cov8" title="1">
                rd.r.logger.Debug("Replicating ringhash",
                        zap.String("RingHash", c.RingHash()),
                        zap.String("Ip", dev.Ip),
                        zap.String("Device", dev.Device),
                        zap.String("strategy", strategy))
                return rd.i.rsync(dev, c, part, strategy)</span>
        case "diff":<span class="cov8" title="1">
                rd.r.logger.Debug("Replicating ringhash",
                        zap.String("RingHash", c.RingHash()),
                        zap.String("Ip", dev.Ip),
                        zap.String("Device", dev.Device),
                        zap.String("strategy", strategy))
                return rd.i.usync(dev, c, part, info.ID, remoteInfo.Point)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (rd *replicationDevice) replicateDatabase(dbFile string) error <span class="cov8" title="1">{
        rd.r.logger.Debug("Replicating database.", zap.String("dbFile", filepath.Base(dbFile)))
        parts := filepath.Base(filepath.Dir(filepath.Dir(filepath.Dir(dbFile))))
        part, err := strconv.ParseUint(parts, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Bad partition: %s", parts)
        }</span>
        <span class="cov8" title="1">devices, handoff := rd.r.Ring.GetJobNodes(part, rd.dev.Id)
        moreNodes := rd.r.Ring.GetMoreNodes(part)
        c, err := sqliteOpenContainer(dbFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer c.Close()
        if err := c.CleanupTombstones(rd.r.reclaimAge); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := c.CheckSyncLink(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">successes := 0
        for i := 0; i &lt; len(devices); i++ </span><span class="cov8" title="1">{
                if err := rd.i.replicateDatabaseToDevice(devices[i], c, part, i); err == nil </span><span class="cov8" title="1">{
                        rd.i.incrementStat("success")
                        rd.r.logger.Debug("Succeeded replicating database.",
                                zap.String("dbFile", dbFile),
                                zap.String("Ip", devices[i].Ip),
                                zap.String("Device", devices[i].Device))
                        successes++
                }</span> else<span class="cov8" title="1"> {
                        rd.i.incrementStat("failure")
                        rd.r.logger.Error("Error replicating database.",
                                zap.String("dbFile", dbFile),
                                zap.String("Ip", devices[i].Ip),
                                zap.String("Device", devices[i].Device),
                                zap.Error(err))
                        if err == errDeviceNotMounted &amp;&amp; !handoff </span><span class="cov0" title="0">{
                                next := moreNodes.Next()
                                if next == nil </span><span class="cov0" title="0">{
                                        rd.r.logger.Error("Ran out of handoffs to talk to.",
                                                zap.String("dbFile", dbFile))
                                }</span> else<span class="cov0" title="0"> {
                                        devices = append(devices, moreNodes.Next())
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">if handoff &amp;&amp; successes == len(devices) </span><span class="cov8" title="1">{
                rd.i.incrementStat("remove")
                return os.RemoveAll(filepath.Dir(dbFile))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (rd *replicationDevice) findContainerDbs(devicePath string, results chan string) <span class="cov8" title="1">{
        defer close(results)
        containersDir := filepath.Join(devicePath, "containers")
        partitions, err := filepath.Glob(filepath.Join(containersDir, "[0-9]*"))
        if err != nil </span><span class="cov0" title="0">{
                rd.r.logger.Error("Error getting partitions.",
                        zap.String("containersDir", containersDir),
                        zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">for _, part := range partitions </span><span class="cov8" title="1">{
                suffixes, err := filepath.Glob(filepath.Join(part, "[a-f0-9][a-f0-9][a-f0-9]"))
                if err != nil </span><span class="cov0" title="0">{
                        rd.r.logger.Error("Error getting suffixes.",
                                zap.String("part", part),
                                zap.Error(err))
                        return
                }</span>
                <span class="cov8" title="1">for _, suff := range suffixes </span><span class="cov8" title="1">{
                        hashes, err := filepath.Glob(filepath.Join(suff, "????????????????????????????????"))
                        if err != nil </span><span class="cov0" title="0">{
                                rd.r.logger.Error("Error getting hashes",
                                        zap.String("suff", suff),
                                        zap.Error(err))
                                return
                        }</span>
                        <span class="cov8" title="1">for _, hash := range hashes </span><span class="cov8" title="1">{
                                dbFile := filepath.Join(hash, filepath.Base(hash)+".db")
                                if fs.Exists(dbFile) </span><span class="cov8" title="1">{
                                        select </span>{
                                        case results &lt;- dbFile:</span><span class="cov8" title="1">
                                        case &lt;-rd.cancel:<span class="cov8" title="1">
                                                return</span>
                                        }
                                }
                        }
                }
        }
}

func (rd *replicationDevice) replicate() <span class="cov8" title="1">{
        rd.r.logger.Info("Beginning replication for device.",
                zap.String("device", rd.dev.Device))
        rd.r.startRun &lt;- rd.dev.Device
        devicePath := filepath.Join(rd.r.deviceRoot, rd.dev.Device)
        stat, err := os.Stat(devicePath)
        if err != nil || !stat.IsDir() </span><span class="cov0" title="0">{
                rd.r.logger.Error("Device doesn't exist.",
                        zap.String("devicePath", devicePath), zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">if mount, err := fs.IsMount(devicePath); rd.r.checkMounts &amp;&amp; (err != nil || !mount) </span><span class="cov0" title="0">{
                rd.r.logger.Error("Device not mounted.",
                        zap.String("devicePath", devicePath), zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">results := make(chan string, 100)
        go rd.i.findContainerDbs(devicePath, results)
        for dbFile := range results </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-rd.cancel:<span class="cov0" title="0">
                        return</span>
                case rd.r.concurrencySem &lt;- struct{}{}:<span class="cov8" title="1">
                        rd.r.checkin &lt;- rd.dev.Device
                        if err := rd.i.replicateDatabase(dbFile); err != nil </span><span class="cov0" title="0">{
                                rd.r.logger.Error("Error replicating database file.",
                                        zap.String("dbFile", dbFile),
                                        zap.Error(err))
                        }</span>
                        <span class="cov8" title="1">&lt;-rd.r.concurrencySem</span>
                }
        }
        <span class="cov8" title="1">rd.r.logger.Info("Finished replication for device.",
                zap.String("device", rd.dev.Device))</span>
}

func (rd *replicationDevice) replicateLoop() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-rd.cancel:<span class="cov0" title="0">
                        return</span>
                default:<span class="cov8" title="1">
                        rd.replicate()</span>
                }
                <span class="cov0" title="0">time.Sleep(time.Second * 30)</span>
        }
}

func (rd *replicationDevice) incrementStat(stat string) <span class="cov8" title="1">{
        rd.r.sendStat &lt;- statUpdate{rd.dev.Device, stat, 1}
}</span>

func newReplicationDevice(dev *ring.Device, r *Replicator) *replicationDevice <span class="cov8" title="1">{
        rd := &amp;replicationDevice{
                r:             r,
                cancel:        make(chan struct{}),
                lastCheckin:   time.Now(),
                deviceStarted: time.Now(),
                dev:           dev,
                stats: map[string]int64{
                        "attempted":    0,
                        "success":      0,
                        "failure":      0,
                        "no_change":    0,
                        "hashmatch":    0,
                        "rsync":        0,
                        "diff":         0,
                        "remove":       0,
                        "empty":        0,
                        "remote_merge": 0,
                        "diff_capped":  0,
                },
                lifetimeStats: map[string]int64{
                        "attempted":    0,
                        "success":      0,
                        "failure":      0,
                        "no_change":    0,
                        "hashmatch":    0,
                        "rsync":        0,
                        "diff":         0,
                        "remove":       0,
                        "empty":        0,
                        "remote_merge": 0,
                        "diff_capped":  0,
                        "passes":       0,
                },
        }
        rd.i = rd
        return rd
}</span>

func (server *Replicator) Type() string <span class="cov0" title="0">{
        return "container-replicator"
}</span>

func (server *Replicator) Background(flags *flag.FlagSet) chan struct{} <span class="cov0" title="0">{
        once := false
        if f := flags.Lookup("once"); f != nil </span><span class="cov0" title="0">{
                once = f.Value.(flag.Getter).Get() == true
        }</span>
        <span class="cov0" title="0">if once </span><span class="cov0" title="0">{
                ch := make(chan struct{})
                go func() </span><span class="cov0" title="0">{
                        defer close(ch)
                        server.Run()
                }</span>()
                <span class="cov0" title="0">return ch</span>
        }
        <span class="cov0" title="0">go server.RunForever()
        return nil</span>
}

func (server *Replicator) GetHandler(config conf.Config, metricsPrefix string) http.Handler <span class="cov0" title="0">{
        var metricsScope tally.Scope
        metricsScope, server.metricsCloser = tally.NewRootScope(tally.ScopeOptions{
                Prefix:         metricsPrefix,
                Tags:           map[string]string{},
                CachedReporter: promreporter.NewReporter(promreporter.Options{}),
                Separator:      promreporter.DefaultSeparator,
        }, time.Second)
        commonHandlers := alice.New(
                middleware.NewDebugResponses(config.GetBool("debug", "debug_x_source_code", false)),
                server.LogRequest,
                middleware.RecoverHandler,
                middleware.ValidateRequest,
        )
        router := srv.NewRouter()
        router.Get("/metrics", prometheus.Handler())
        router.Get("/loglevel", server.logLevel)
        router.Put("/loglevel", server.logLevel)
        router.Get("/healthcheck", commonHandlers.ThenFunc(server.HealthcheckHandler))
        router.Get("/debug/pprof/:parm", http.DefaultServeMux)
        router.Post("/debug/pprof/:parm", http.DefaultServeMux)
        return alice.New(middleware.Metrics(metricsScope), middleware.ServerTracer(server.tracer)).Then(router)
}</span>

func (server *Replicator) Finalize() <span class="cov0" title="0">{
        if server.metricsCloser != nil </span><span class="cov0" title="0">{
                server.metricsCloser.Close()
        }</span>
        <span class="cov0" title="0">if server.traceCloser != nil </span><span class="cov0" title="0">{
                server.traceCloser.Close()
        }</span>
        <span class="cov0" title="0">if server.clientTraceCloser != nil </span><span class="cov0" title="0">{
                server.clientTraceCloser.Close()
        }</span>
}

func (server *Replicator) HealthcheckHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        writer.Header().Set("Content-Length", "2")
        writer.WriteHeader(http.StatusOK)
        writer.Write([]byte("OK"))
}</span>

func (server *Replicator) LogRequest(next http.Handler) http.Handler <span class="cov0" title="0">{
        return srv.LogRequest(server.logger, next)
}</span>

func (r *Replicator) verifyDevices() <span class="cov8" title="1">{
        // kill devices that haven't checked in for a while
        for key, rd := range r.runningDevices </span><span class="cov8" title="1">{
                if time.Since(rd.lastCheckin) &gt; deviceLockupTimeout </span><span class="cov8" title="1">{
                        close(rd.cancel)
                        delete(r.runningDevices, key)
                }</span>
        }
        <span class="cov8" title="1">ringDevices, err := r.Ring.LocalDevices(r.serverPort)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Error getting local devices from ring.",
                        zap.Error(err))
                return
        }</span>
        // look for devices that aren't running but should be
        <span class="cov8" title="1">for _, dev := range ringDevices </span><span class="cov8" title="1">{
                if _, ok := r.runningDevices[dev.Device]; !ok </span><span class="cov8" title="1">{
                        r.runningDevices[dev.Device] = newReplicationDevice(dev, r)
                        go r.runningDevices[dev.Device].replicateLoop()
                }</span>
        }
        // look for devices that are running but shouldn't be
        <span class="cov8" title="1">for key, rd := range r.runningDevices </span><span class="cov8" title="1">{
                found := false
                for _, dev := range ringDevices </span><span class="cov8" title="1">{
                        if dev.Device == key </span><span class="cov8" title="1">{
                                found = true
                        }</span>
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        close(rd.cancel)
                        delete(r.runningDevices, key)
                }</span>
        }
}

func (r *Replicator) reportStats() <span class="cov8" title="1">{
        var totalTime time.Duration
        aggStats := map[string]int64{"attempted": 0, "success": 0, "failure": 0, "remove": 0}
        for _, device := range r.runningDevices </span><span class="cov8" title="1">{
                totalTime += time.Since(device.runStarted)
                aggStats["attempted"] += device.stats["attempted"]
                aggStats["success"] += device.stats["success"]
                aggStats["failure"] += device.stats["failure"]
                aggStats["remove"] += device.stats["remove"]
        }</span>
        // there's no longer the concept of a single pass, so we report the average running time.
        <span class="cov8" title="1">if len(r.runningDevices) &gt; 0 </span><span class="cov8" title="1">{
                rate := 0.0
                runningTime := (totalTime / time.Duration(len(r.runningDevices))).Seconds()
                if runningTime &gt; 0 </span><span class="cov8" title="1">{
                        rate = float64(aggStats["attempted"]) / runningTime
                }</span>
                <span class="cov8" title="1">r.logger.Info("Attempted to replicate dbs",
                        zap.Int64("aggStats['attempted']", aggStats["attempted"]),
                        zap.Float64("runningTime", runningTime),
                        zap.Float64("rate", rate))

                r.logger.Info("Removed dbs",
                        zap.Int64("aggStats['remove']", aggStats["remove"]))
                r.logger.Info("Sucess &amp; Failure",
                        zap.Int64("success", aggStats["success"]),
                        zap.Int64("failure", aggStats["failure"]))</span>
        } else<span class="cov0" title="0"> {
                r.logger.Info("No devices replicating.")
        }</span>
}

func (r *Replicator) runLoopCheck(reportTimer &lt;-chan time.Time) <span class="cov8" title="1">{
        select </span>{
        case device := &lt;-r.checkin:<span class="cov8" title="1">
                if rd, ok := r.runningDevices[device]; ok </span><span class="cov8" title="1">{
                        rd.lastCheckin = time.Now()
                }</span>
        case device := &lt;-r.startRun:<span class="cov8" title="1">
                if rd, ok := r.runningDevices[device]; ok </span><span class="cov8" title="1">{
                        rd.runStarted = time.Now()
                        rd.lastCheckin = time.Now()
                        for k, v := range rd.stats </span><span class="cov8" title="1">{
                                rd.stats[k] = 0
                                rd.lifetimeStats[k] += v
                        }</span>
                        <span class="cov8" title="1">rd.lifetimeStats["passes"]++</span>
                }
        case update := &lt;-r.sendStat:<span class="cov8" title="1">
                if rd, ok := r.runningDevices[update.device]; ok </span><span class="cov8" title="1">{
                        rd.stats[update.stat] += update.value
                }</span>
        case &lt;-reportTimer:<span class="cov8" title="1">
                r.reportStats()
                r.verifyDevices()</span>
        }
}

// RunForever runs the replicator in a forever-loop.
func (r *Replicator) RunForever() <span class="cov0" title="0">{
        reportTimer := time.NewTimer(time.Minute * 15)
        r.verifyDevices()
        for </span><span class="cov0" title="0">{
                r.runLoopCheck(reportTimer.C)
        }</span>
}

// Run runs a pass of the replicator once.
func (r *Replicator) Run() <span class="cov8" title="1">{
        done := make(chan struct{})
        devices, err := r.Ring.LocalDevices(r.serverPort)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Error getting local devices from ring.",
                        zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">for _, dev := range devices </span><span class="cov8" title="1">{
                r.runningDevices[dev.Device] = newReplicationDevice(dev, r)
                go func(rd *replicationDevice) </span><span class="cov8" title="1">{
                        rd.replicate()
                        done &lt;- struct{}{}
                }</span>(r.runningDevices[dev.Device])
        }
        <span class="cov8" title="1">waitingFor := len(devices)
        for waitingFor &gt; 0 </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-r.checkin:</span><span class="cov0" title="0">
                case &lt;-r.startRun:</span><span class="cov8" title="1">
                case update := &lt;-r.sendStat:<span class="cov0" title="0">
                        if ctx, ok := r.runningDevices[update.device]; ok </span><span class="cov0" title="0">{
                                ctx.stats[update.stat] += update.value
                        }</span>
                case &lt;-done:<span class="cov8" title="1">
                        waitingFor--</span>
                }
        }
        <span class="cov8" title="1">r.reportStats()</span>
}

// NewReplicator uses the config settings and command-line flags to configure and return a replicator daemon struct.
func NewReplicator(serverconf conf.Config, flags *flag.FlagSet, cnf srv.ConfigLoader) (*srv.IpPort, srv.Server, srv.LowLevelLogger, error) <span class="cov8" title="1">{
        var ipPort *srv.IpPort
        var err error
        var logger srv.LowLevelLogger
        if !serverconf.HasSection("container-replicator") </span><span class="cov8" title="1">{
                return ipPort, nil, nil, fmt.Errorf("Unable to find container-replicator config section")
        }</span>
        <span class="cov8" title="1">hashPathPrefix, hashPathSuffix, err := cnf.GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov8" title="1">{
                return ipPort, nil, nil, fmt.Errorf("Unable to get hash prefix and suffix: %s", err)
        }</span>
        <span class="cov8" title="1">ring, err := cnf.GetRing("container", hashPathPrefix, hashPathSuffix, 0)
        if err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, fmt.Errorf("Error loading container ring: %s", err)
        }</span>
        <span class="cov8" title="1">accountRing, err := cnf.GetRing("account", hashPathPrefix, hashPathSuffix, 0)
        if err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, fmt.Errorf("Error loading account ring: %s", err)
        }</span>
        <span class="cov8" title="1">concurrency := int(serverconf.GetInt("container-replicator", "concurrency", 4))

        logLevelString := serverconf.GetDefault("container-replicator", "log_level", "INFO")
        logLevel := zap.NewAtomicLevel()
        logLevel.UnmarshalText([]byte(strings.ToLower(logLevelString)))

        if logger, err = srv.SetupLogger("container-replicator", &amp;logLevel, flags); err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, fmt.Errorf("Error setting up logger: %v", err)
        }</span>
        <span class="cov8" title="1">ip := serverconf.GetDefault("container-replicator", "bind_ip", "0.0.0.0")
        port := int(serverconf.GetInt("container-replicator", "bind_port", common.DefaultContainerReplicatorPort))
        certFile := serverconf.GetDefault("container-replicator", "cert_file", "")
        keyFile := serverconf.GetDefault("container-replicator", "key_file", "")

        transport := &amp;http.Transport{
                Dial:                (&amp;net.Dialer{Timeout: time.Second}).Dial,
                MaxIdleConnsPerHost: 100,
                MaxIdleConns:        0,
        }
        if certFile != "" &amp;&amp; keyFile != "" </span><span class="cov0" title="0">{
                tlsConf, err := common.NewClientTLSConfig(certFile, keyFile)
                if err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error getting TLS config: %v", err)
                }</span>
                <span class="cov0" title="0">transport.TLSClientConfig = tlsConf
                if err = http2.ConfigureTransport(transport); err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error setting up http2: %v", err)
                }</span>
        }
        <span class="cov8" title="1">c := &amp;http.Client{
                Timeout:   time.Minute * 15,
                Transport: transport,
        }
        server := &amp;Replicator{
                runningDevices: make(map[string]*replicationDevice),
                perUsync:       3000,
                maxUsyncs:      25,
                sendStat:       make(chan statUpdate),
                checkin:        make(chan string),
                startRun:       make(chan string),
                reconCachePath: serverconf.GetDefault("container-replicator", "recon_cache_path", "/var/cache/swift"),
                checkMounts:    serverconf.GetBool("container-replicator", "mount_check", true),
                deviceRoot:     serverconf.GetDefault("container-replicator", "devices", "/srv/node"),
                serverPort:     port,
                reclaimAge:     serverconf.GetInt("container-replicator", "reclaim_age", 604800),
                logger:         logger,
                concurrencySem: make(chan struct{}, concurrency),
                Ring:           ring,
                accountRing:    accountRing,
                client:         c,
                logLevel:       logLevel,
        }
        if serverconf.HasSection("tracing") </span><span class="cov0" title="0">{
                server.tracer, server.traceCloser, err = tracing.Init("container-replicator", server.logger, serverconf.GetSection("tracing"))
                if err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error setting up tracer: %v", err)
                }</span>
                <span class="cov0" title="0">server.clientTracer, server.clientTraceCloser, err = tracing.Init("account-replicator-client", server.logger, serverconf.GetSection("tracing"))
                if err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error setting up tracer: %v", err)
                }</span>
                <span class="cov0" title="0">enableHTTPTrace := serverconf.GetBool("tracing", "enable_httptrace", true)
                server.client, err = client.NewTracingClient(server.clientTracer, c, enableHTTPTrace)
                if err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error setting up tracing client: %v", err)
                }</span>
        }
        <span class="cov8" title="1">ipPort = &amp;srv.IpPort{Ip: ip, Port: port, CertFile: certFile, KeyFile: keyFile}
        return ipPort, server, logger, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">//  Copyright (c) 2016 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package containerserver

import (
        "database/sql"
        "fmt"
        "strings"
)

const (
        policyStatTableScript = `
                CREATE TABLE policy_stat (
                        storage_policy_index INTEGER PRIMARY KEY,
                        object_count INTEGER DEFAULT 0,
                        bytes_used INTEGER DEFAULT 0
                );`

        policyStatTriggerScript = `
                CREATE TRIGGER object_insert_policy_stat AFTER INSERT ON object
                BEGIN
                        UPDATE policy_stat
                        SET object_count = object_count + (1 - new.deleted),
                                bytes_used = bytes_used + new.size
                        WHERE storage_policy_index = new.storage_policy_index;
                        INSERT INTO policy_stat (
                                storage_policy_index, object_count, bytes_used)
                        SELECT new.storage_policy_index,
                                   (1 - new.deleted),
                                   new.size
                        WHERE NOT EXISTS(
                                SELECT changes() as change
                                FROM policy_stat
                                WHERE change &lt;&gt; 0
                        );
                        UPDATE container_info
                        SET hash = chexor(hash, new.name, new.created_at);
                END;
                CREATE TRIGGER object_delete_policy_stat AFTER DELETE ON object
                BEGIN
                        UPDATE policy_stat
                        SET object_count = object_count - (1 - old.deleted),
                                bytes_used = bytes_used - old.size
                        WHERE storage_policy_index = old.storage_policy_index;
                        UPDATE container_info
                        SET hash = chexor(hash, old.name, old.created_at);
                END;`

        containerInfoTableScript = `
                CREATE TABLE container_info (
                        account TEXT,
                        container TEXT,
                        created_at TEXT,
                        put_timestamp TEXT DEFAULT '0',
                        delete_timestamp TEXT DEFAULT '0',
                        reported_put_timestamp TEXT DEFAULT '0',
                        reported_delete_timestamp TEXT DEFAULT '0',
                        reported_object_count INTEGER DEFAULT 0,
                        reported_bytes_used INTEGER DEFAULT 0,
                        hash TEXT default '00000000000000000000000000000000',
                        id TEXT,
                        status TEXT DEFAULT '',
                        status_changed_at TEXT DEFAULT '0',
                        metadata TEXT DEFAULT '{}',
                        x_container_sync_point1 INTEGER DEFAULT -1,
                        x_container_sync_point2 INTEGER DEFAULT -1,
                        storage_policy_index INTEGER DEFAULT 0,
                        reconciler_sync_point INTEGER DEFAULT -1
                );`

        containerStatViewScript = `
                CREATE VIEW container_stat
                AS SELECT ci.account, ci.container, ci.created_at,
                        ci.put_timestamp, ci.delete_timestamp,
                        ci.reported_put_timestamp, ci.reported_delete_timestamp,
                        ci.reported_object_count, ci.reported_bytes_used, ci.hash,
                        ci.id, ci.status, ci.status_changed_at, ci.metadata,
                        ci.x_container_sync_point1, ci.x_container_sync_point2,
                        ci.reconciler_sync_point,
                        ci.storage_policy_index,
                        coalesce(ps.object_count, 0) AS object_count,
                        coalesce(ps.bytes_used, 0) AS bytes_used
                FROM container_info ci LEFT JOIN policy_stat ps
                ON ci.storage_policy_index = ps.storage_policy_index;
                CREATE TRIGGER container_stat_update
                INSTEAD OF UPDATE ON container_stat
                BEGIN
                        UPDATE container_info
                        SET account = NEW.account,
                                container = NEW.container,
                                created_at = NEW.created_at,
                                put_timestamp = NEW.put_timestamp,
                                delete_timestamp = NEW.delete_timestamp,
                                reported_put_timestamp = NEW.reported_put_timestamp,
                                reported_delete_timestamp = NEW.reported_delete_timestamp,
                                reported_object_count = NEW.reported_object_count,
                                reported_bytes_used = NEW.reported_bytes_used,
                                hash = NEW.hash,
                                id = NEW.id,
                                status = NEW.status,
                                status_changed_at = NEW.status_changed_at,
                                metadata = NEW.metadata,
                                x_container_sync_point1 = NEW.x_container_sync_point1,
                                x_container_sync_point2 = NEW.x_container_sync_point2,
                                storage_policy_index = NEW.storage_policy_index,
                                reconciler_sync_point = NEW.reconciler_sync_point;
                END;`

        objectTableScript = `
                CREATE TABLE object (
                                ROWID INTEGER PRIMARY KEY AUTOINCREMENT,
                                name TEXT,
                                created_at TEXT,
                                size INTEGER,
                                content_type TEXT,
                                etag TEXT,
                                deleted INTEGER DEFAULT 0,
                                storage_policy_index INTEGER DEFAULT 0,
                                expires INTEGER DEFAULT NULL
                        );
                CREATE INDEX ix_object_deleted_name ON object (deleted, name);
                CREATE INDEX ix_object_expires ON object(expires) WHERE expires IS NOT NULL;
                CREATE TRIGGER object_update BEFORE UPDATE ON object
                        BEGIN
                                SELECT RAISE(FAIL, 'UPDATE not allowed; DELETE and INSERT');
                        END;`

        syncTableScript = `        
                CREATE TABLE outgoing_sync (
                                remote_id TEXT UNIQUE,
                                sync_point INTEGER,
                                updated_at TEXT DEFAULT 0
                        );
                CREATE TABLE incoming_sync (
                                remote_id TEXT UNIQUE,
                                sync_point INTEGER,
                                updated_at TEXT DEFAULT 0
                        );
                CREATE TRIGGER outgoing_sync_insert AFTER INSERT ON outgoing_sync
                        BEGIN
                                UPDATE outgoing_sync
                                SET updated_at = STRFTIME('%s', 'NOW')
                                WHERE ROWID = new.ROWID;
                        END;
                CREATE TRIGGER outgoing_sync_update AFTER UPDATE ON outgoing_sync
                        BEGIN
                                UPDATE outgoing_sync
                                SET updated_at = STRFTIME('%s', 'NOW')
                                WHERE ROWID = new.ROWID;
                        END;
                CREATE TRIGGER incoming_sync_insert AFTER INSERT ON incoming_sync
                        BEGIN
                                UPDATE incoming_sync
                                SET updated_at = STRFTIME('%s', 'NOW')
                                WHERE ROWID = new.ROWID;
                        END;
                CREATE TRIGGER incoming_sync_update AFTER UPDATE ON incoming_sync
                        BEGIN
                                UPDATE incoming_sync
                                SET updated_at = STRFTIME('%s', 'NOW')
                                WHERE ROWID = new.ROWID;
                        END;`

        policyMigrateColumns = `account, container, created_at, put_timestamp, delete_timestamp, reported_put_timestamp,
                reported_object_count, reported_bytes_used, hash, id, status, status_changed_at, metadata,
                x_container_sync_point1, x_container_sync_point2`

        policyMigrateScript = policyStatTableScript +
                "INSERT INTO policy_stat (storage_policy_index, object_count, bytes_used) SELECT 0, object_count, bytes_used FROM container_stat;" +
                "ALTER TABLE object ADD COLUMN storage_policy_index INTEGER DEFAULT 0;" +
                "DROP TRIGGER object_insert;" +
                "DROP TRIGGER object_delete;" +
                policyStatTriggerScript +
                containerInfoTableScript +
                "INSERT INTO container_info (" + policyMigrateColumns + ") SELECT " + policyMigrateColumns + " FROM container_stat;" +
                "DROP TABLE IF EXISTS container_stat;" +
                containerStatViewScript

        syncPointMigrateScript = `
                ALTER TABLE container_stat ADD COLUMN x_container_sync_point1 INTEGER DEFAULT -1;
                ALTER TABLE container_stat ADD COLUMN x_container_sync_point2 INTEGER DEFAULT -1;`

        metadataMigrateScript = "ALTER TABLE container_stat ADD COLUMN metadata DEFAULT '{}';"

        pragmaScript = `
                PRAGMA synchronous = NORMAL;
                PRAGMA cache_size = -4096;
                PRAGMA temp_store = MEMORY;
                PRAGMA journal_mode = WAL;
                PRAGMA busy_timeout = 25000;`

        // There's no real reason that adding a column with a partial index on non-default values would
        // require a table scan, but I can't find any way to tell sqlite not to do it that isn't dark magic.
        xExpireMigrateScript = `
                ALTER TABLE object ADD COLUMN expires INTEGER DEFAULT NULL;
                CREATE INDEX ix_object_expires ON object(expires) WHERE expires IS NOT NULL;`
)

func schemaMigrate(db *sql.DB) (bool, error) <span class="cov8" title="1">{
        hasDeletedNameIndex := false
        hasSyncPoints := false
        hasMetadata := false
        hasPolicyStat := false
        hasExpireColumn := false

        tx, err := db.Begin()
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        // We just pull the schema out of sqlite_master and look at it to get the current state of the database.
        rows, err := tx.Query("SELECT name, sql FROM sqlite_master WHERE name in ('policy_stat', 'ix_object_deleted_name', 'container_stat')")
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                var name, sql string
                if err := rows.Scan(&amp;name, &amp;sql); err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">if name == "policy_stat" </span><span class="cov8" title="1">{
                        hasPolicyStat = true
                }</span> else<span class="cov8" title="1"> if name == "ix_object_deleted_name" </span><span class="cov8" title="1">{
                        hasDeletedNameIndex = true
                }</span> else<span class="cov8" title="1"> if name == "container_stat" </span><span class="cov8" title="1">{
                        hasSyncPoints = strings.Contains(sql, "x_container_sync_point1")
                        hasMetadata = strings.Contains(sql, "metadata")
                }</span> else<span class="cov0" title="0"> if name == "ix_object_expires" </span><span class="cov0" title="0">{
                        hasExpireColumn = true
                }</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return hasDeletedNameIndex, err
        }</span>
        <span class="cov8" title="1">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return hasDeletedNameIndex, err
        }</span>

        <span class="cov8" title="1">if hasSyncPoints &amp;&amp; hasMetadata &amp;&amp; hasPolicyStat </span><span class="cov8" title="1">{
                return hasDeletedNameIndex, nil
        }</span>

        <span class="cov8" title="1">if !hasSyncPoints </span><span class="cov8" title="1">{
                if _, err := tx.Exec(syncPointMigrateScript); err != nil </span><span class="cov0" title="0">{
                        return hasDeletedNameIndex, fmt.Errorf("Adding sync_point columns: %v", err)
                }</span>
        }
        <span class="cov8" title="1">if !hasMetadata </span><span class="cov8" title="1">{
                if _, err := tx.Exec(metadataMigrateScript); err != nil </span><span class="cov0" title="0">{
                        return hasDeletedNameIndex, fmt.Errorf("Adding metadata column: %v", err)
                }</span>
        }
        <span class="cov8" title="1">if !hasPolicyStat </span><span class="cov8" title="1">{
                if _, err = tx.Exec(policyMigrateScript); err != nil </span><span class="cov0" title="0">{
                        return hasDeletedNameIndex, fmt.Errorf("Performing policy migration: %v", err)
                }</span>
        }
        <span class="cov8" title="1">if !hasExpireColumn </span><span class="cov8" title="1">{
                if _, err = tx.Exec(xExpireMigrateScript); err != nil </span><span class="cov0" title="0">{
                        return hasDeletedNameIndex, fmt.Errorf("Performing expires migration: %v", err)
                }</span>
        }
        <span class="cov8" title="1">return hasDeletedNameIndex, tx.Commit()</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">//  Copyright (c) 2016 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package containerserver

import (
        "encoding/json"
        "encoding/xml"
        "flag"
        "fmt"
        "io"
        "net"
        "net/http"
        _ "net/http/pprof" // install pprof http handlers
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/justinas/alice"
        opentracing "github.com/opentracing/opentracing-go"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/troubling/hummingbird/client"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/common/tracing"
        "github.com/troubling/hummingbird/middleware"
        "github.com/uber-go/tally"
        promreporter "github.com/uber-go/tally/prometheus"
        "go.uber.org/zap"
        "golang.org/x/net/http2"
)

// ContainerServer contains all of the information for a running container server.
type ContainerServer struct {
        driveRoot               string
        hashPathPrefix          string
        hashPathSuffix          string
        reconCachePath          string
        logger                  srv.LowLevelLogger
        logLevel                zap.AtomicLevel
        diskInUse               *common.KeyedLimit
        checkMounts             bool
        containerEngine         ContainerEngine
        updateClient            common.HTTPClient
        updateClientTracer      opentracing.Tracer
        updateClientTraceCloser io.Closer
        autoCreatePrefix        string
        syncRealms              conf.SyncRealmList
        defaultPolicy           int
        policyList              conf.PolicyList
        metricsCloser           io.Closer
        traceCloser             io.Closer
        tracer                  opentracing.Tracer
}

var saveHeaders = map[string]bool{
        "X-Container-Read":     true,
        "X-Container-Write":    true,
        "X-Container-Sync-Key": true,
        "X-Container-Sync-To":  true,
        "X-Versions-Location":  true,
        "X-History-Location":   true,
}

func formatTimestamp(ts string) string <span class="cov8" title="1">{
        if len(ts) == 16 &amp;&amp; ts[10] == '.' </span><span class="cov8" title="1">{
                return ts
        }</span>
        <span class="cov8" title="1">t, err := strconv.ParseFloat(ts, 64)
        if err != nil </span><span class="cov8" title="1">{
                return "0000000000.00000"
        }</span>
        <span class="cov8" title="1">ret := strconv.FormatFloat(t, 'f', 5, 64)
        if len(ret) &lt; 16 </span><span class="cov8" title="1">{
                return strings.Repeat("0", 16-len(ret)) + ret
        }</span>
        <span class="cov8" title="1">return ret</span>
}

func (server *ContainerServer) Type() string <span class="cov0" title="0">{
        return "container"
}</span>

func (server *ContainerServer) Background(flags *flag.FlagSet) chan struct{} <span class="cov0" title="0">{
        return nil
}</span>

func (server *ContainerServer) Finalize() <span class="cov0" title="0">{
        if server.metricsCloser != nil </span><span class="cov0" title="0">{
                server.metricsCloser.Close()
        }</span>
        <span class="cov0" title="0">if server.traceCloser != nil </span><span class="cov0" title="0">{
                server.traceCloser.Close()
        }</span>
        <span class="cov0" title="0">if server.updateClientTraceCloser != nil </span><span class="cov0" title="0">{
                server.updateClientTraceCloser.Close()
        }</span>
}

// ContainerGetHandler handles GET and HEAD requests for a container.
func (server *ContainerServer) ContainerGetHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        if err := request.ParseForm(); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">db, err := server.containerEngine.Get(vars)
        if err == ErrorNoSuchContainer </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get container.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer server.containerEngine.Return(db)
        info, err := db.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get container info.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">headers := writer.Header()
        if lastModified, err := common.ParseDate(info.PutTimestamp); err == nil </span><span class="cov8" title="1">{
                headers.Set("Last-Modified", common.FormatLastModified(lastModified))
        }</span>
        <span class="cov8" title="1">if ts, err := common.GetEpochFromTimestamp(info.CreatedAt); err == nil </span><span class="cov8" title="1">{
                headers.Set("X-Backend-Timestamp", ts)
        }</span>
        <span class="cov8" title="1">if ts, err := common.GetEpochFromTimestamp(info.PutTimestamp); err == nil </span><span class="cov8" title="1">{
                headers.Set("X-Backend-Put-Timestamp", ts)
        }</span>
        <span class="cov8" title="1">if ts, err := common.GetEpochFromTimestamp(info.DeleteTimestamp); err == nil </span><span class="cov8" title="1">{
                headers.Set("X-Backend-Delete-Timestamp", ts)
        }</span>
        <span class="cov8" title="1">if ts, err := common.GetEpochFromTimestamp(info.StatusChangedAt); err == nil </span><span class="cov8" title="1">{
                headers.Set("X-Backend-Status-Changed-At", ts)
        }</span>
        <span class="cov8" title="1">headers.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(info.StoragePolicyIndex))
        if policy := server.policyList[info.StoragePolicyIndex]; policy != nil </span><span class="cov0" title="0">{
                headers.Set("X-Storage-Policy", policy.Name)
        }</span>
        <span class="cov8" title="1">metadata, err := db.GetMetadata()
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get metadata.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">for key, value := range metadata </span><span class="cov8" title="1">{
                headers.Set(key, value)
        }</span>
        <span class="cov8" title="1">if deleted, err := db.IsDeleted(); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error calling IsDeleted.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span> else<span class="cov8" title="1"> if deleted </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span> else<span class="cov8" title="1"> {
                headers.Set("X-Container-Object-Count", strconv.FormatInt(info.ObjectCount, 10))
                headers.Set("X-Container-Bytes-Used", strconv.FormatInt(info.BytesUsed, 10))
                if ts, err := common.GetEpochFromTimestamp(info.CreatedAt); err == nil </span><span class="cov8" title="1">{
                        headers.Set("X-Timestamp", ts)
                }</span>
                <span class="cov8" title="1">if ts, err := common.GetEpochFromTimestamp(info.PutTimestamp); err == nil </span><span class="cov8" title="1">{
                        headers.Set("X-Put-Timestamp", ts)
                }</span>
        }
        <span class="cov8" title="1">if request.Method == "HEAD" </span><span class="cov8" title="1">{
                headers.Set("Content-Type", "text/plain; charset=utf-8")
                writer.WriteHeader(http.StatusNoContent)
                writer.Write([]byte(""))
                return
        }</span>
        <span class="cov8" title="1">limit := int64(10000)
        limitStr := request.FormValue("limit")
        if limitStr != "" </span><span class="cov0" title="0">{
                limit, _ = strconv.ParseInt(limitStr, 10, 64)
                if limit &gt; 10000 </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, http.StatusPreconditionFailed)
                        return
                }</span> else<span class="cov0" title="0"> if limit &lt; 0 </span><span class="cov0" title="0">{
                        limit = 10000
                }</span>
        }
        <span class="cov8" title="1">marker := request.Form.Get("marker")
        delimiter := request.Form.Get("delimiter")
        endMarker := request.Form.Get("end_marker")
        prefix := request.Form.Get("prefix")
        var path *string
        if v, ok := request.Form["path"]; ok &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                path = &amp;v[0]
        }</span>
        <span class="cov8" title="1">policyIndex, err := strconv.Atoi(request.Header.Get("X-Backend-Storage-Policy-Index"))
        if err != nil </span><span class="cov8" title="1">{
                policyIndex = info.StoragePolicyIndex
        }</span>
        <span class="cov8" title="1">reverse := common.LooksTrue(request.Form.Get("reverse"))
        objects, err := db.ListObjects(int(limit), marker, endMarker, prefix, delimiter, path, reverse, policyIndex)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to list objects.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">format := request.Form.Get("format")
        if format == "" </span><span class="cov8" title="1">{ /* TODO: real accept parsing */
                accept := request.Header.Get("Accept")
                if strings.Contains(accept, "application/json") </span><span class="cov8" title="1">{
                        format = "json"
                }</span> else<span class="cov8" title="1"> if strings.Contains(accept, "application/xml") || strings.Contains(accept, "text/xml") </span><span class="cov0" title="0">{
                        format = "xml"
                }</span> else<span class="cov8" title="1"> {
                        format = "text"
                }</span>
        }
        <span class="cov8" title="1">if format == "text" </span><span class="cov8" title="1">{
                response := ""
                for _, obj := range objects </span><span class="cov8" title="1">{
                        if or, ok := obj.(*ObjectListingRecord); ok </span><span class="cov8" title="1">{
                                response += or.Name + "\n"
                        }</span> else<span class="cov0" title="0"> if sr, ok := obj.(*SubdirListingRecord); ok </span><span class="cov0" title="0">{
                                response += sr.Name + "\n"
                        }</span>
                }
                <span class="cov8" title="1">headers.Set("Content-Type", "text/plain; charset=utf-8")
                if len(response) &gt; 0 </span><span class="cov8" title="1">{
                        headers.Set("Content-Length", strconv.Itoa(len(response)))
                        writer.WriteHeader(200)
                        writer.Write([]byte(response))
                }</span> else<span class="cov8" title="1"> {
                        headers.Set("Content-Length", "0")
                        writer.WriteHeader(204)
                        writer.Write([]byte(""))
                }</span>
        } else<span class="cov8" title="1"> if format == "json" </span><span class="cov8" title="1">{
                output, err := json.Marshal(objects)
                if err != nil </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">headers.Set("Content-Type", "application/json; charset=utf-8")
                headers.Set("Content-Length", strconv.Itoa(len(output)))
                writer.WriteHeader(200)
                writer.Write(output)</span>
        } else<span class="cov8" title="1"> if format == "xml" </span><span class="cov8" title="1">{
                type Container struct {
                        XMLName xml.Name `xml:"container"`
                        Name    string   `xml:"name,attr"`
                        Objects []interface{}
                }
                container := &amp;Container{Name: vars["container"], Objects: objects}
                writer.Header().Set("Content-Type", "application/xml; charset=utf-8")
                output, _ := xml.Marshal(container)
                headers.Set("Content-Length", strconv.Itoa(len(output)+39))
                writer.WriteHeader(200)
                writer.Write([]byte("&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n"))
                writer.Write(output)
        }</span>
}

// ContainerPutHandler handles PUT requests for a container.
func (server *ContainerServer) ContainerPutHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        timestamp, err := common.StandardizeTimestamp(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if syncTo := request.Header.Get("X-Container-Sync-To"); syncTo != "" </span><span class="cov8" title="1">{
                if !server.syncRealms.ValidateSyncTo(syncTo) </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                        return
                }</span>
        }
        <span class="cov8" title="1">policyIndex, err := strconv.Atoi(request.Header.Get("X-Backend-Storage-Policy-Index"))
        if err != nil </span><span class="cov8" title="1">{
                policyIndex = -1
        }</span>
        <span class="cov8" title="1">defaultPolicyIndex, err := strconv.Atoi(request.Header.Get("X-Backend-Storage-Policy-Default"))
        if err != nil </span><span class="cov8" title="1">{
                defaultPolicyIndex = server.defaultPolicy
        }</span>
        <span class="cov8" title="1">metadata := make(map[string][]string)
        for key := range request.Header </span><span class="cov8" title="1">{
                if strings.HasPrefix(key, "X-Container-Meta-") || strings.HasPrefix(key, "X-Container-Sysmeta-") || saveHeaders[key] </span><span class="cov8" title="1">{
                        metadata[key] = []string{request.Header.Get(key), timestamp}
                }</span>
        }
        <span class="cov8" title="1">created, db, err := server.containerEngine.Create(vars, timestamp, metadata, policyIndex, defaultPolicyIndex)
        if err == ErrorPolicyConflict </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusConflict)
                return
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to create database.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer server.containerEngine.Return(db)
        if info, err := db.GetInfo(); err == nil </span><span class="cov8" title="1">{
                server.accountUpdate(writer, request, vars, info, srv.GetLogger(request))
        }</span> else<span class="cov0" title="0"> {
                srv.GetLogger(request).Error("could not GetInfo on cont create.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if created </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusCreated)
        }</span> else<span class="cov8" title="1"> {
                srv.StandardResponse(writer, http.StatusAccepted)
        }</span>
}

// ContainerDeleteHandler handles DELETE requests for the container.
func (server *ContainerServer) ContainerDeleteHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        db, err := server.containerEngine.Get(vars)
        if err == ErrorNoSuchContainer </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get container.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer server.containerEngine.Return(db)
        timestamp, err := common.StandardizeTimestamp(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">info, err := db.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get container info.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if info.ObjectCount &gt; 0 </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusConflict)
                return
        }</span>
        <span class="cov8" title="1">if err = db.Delete(timestamp); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to delete database.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">info, err = db.GetInfo()
        if err == nil </span><span class="cov8" title="1">{
                server.accountUpdate(writer, request, vars, info, srv.GetLogger(request))
        }</span> else<span class="cov0" title="0"> {
                srv.GetLogger(request).Error("could not GetInfo on cont delete.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">writer.WriteHeader(http.StatusNoContent)
        writer.Write([]byte(""))</span>
}

// ContainerPostHandler handles POST requests for a container.
func (server *ContainerServer) ContainerPostHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        timestamp, err := common.StandardizeTimestamp(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if syncTo := request.Header.Get("X-Container-Sync-To"); syncTo != "" </span><span class="cov8" title="1">{
                if !server.syncRealms.ValidateSyncTo(syncTo) </span><span class="cov8" title="1">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                        return
                }</span>
        }
        <span class="cov8" title="1">updates := make(map[string][]string)
        for key := range request.Header </span><span class="cov8" title="1">{
                if strings.HasPrefix(key, "X-Container-Meta-") || strings.HasPrefix(key, "X-Container-Sysmeta") || saveHeaders[key] </span><span class="cov8" title="1">{
                        updates[key] = []string{request.Header.Get(key), timestamp}
                }</span>
        }
        <span class="cov8" title="1">db, err := server.containerEngine.Get(vars)
        if err == ErrorNoSuchContainer </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get container", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer server.containerEngine.Return(db)
        if deleted, err := db.IsDeleted(); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error calling IsDeleted.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span> else<span class="cov8" title="1"> if deleted </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err := db.UpdateMetadata(updates, timestamp); err == ErrorInvalidMetadata </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusInternalServerError)
        }</span> else<span class="cov8" title="1"> {
                writer.WriteHeader(http.StatusNoContent)
                writer.Write([]byte(""))
        }</span>
}

// ObjPutHandler handles the PUT of object records to a container.
func (server *ContainerServer) ObjPutHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        timestamp, err := common.StandardizeTimestamp(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">contentType := request.Header.Get("X-Content-Type")
        etag := request.Header.Get("X-Etag")
        size, err := strconv.ParseInt(request.Header.Get("X-Size"), 10, 64)
        if err != nil || contentType == "" || etag == "" </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">policyIndex, err := strconv.Atoi(request.Header.Get("X-Backend-Storage-Policy-Index"))
        if err != nil </span><span class="cov8" title="1">{
                policyIndex = 0
        }</span>
        <span class="cov8" title="1">db, err := server.containerEngine.Get(vars)
        if err == ErrorNoSuchContainer </span><span class="cov8" title="1">{
                if strings.HasPrefix(vars["account"], server.autoCreatePrefix) </span><span class="cov8" title="1">{
                        if _, db, err = server.containerEngine.Create(vars, timestamp, map[string][]string{}, policyIndex, 0); err != nil </span><span class="cov0" title="0">{
                                srv.GetLogger(request).Error("Unable to auto-create container.", zap.Error(err))
                                srv.StandardResponse(writer, http.StatusInternalServerError)
                                return
                        }</span>
                } else<span class="cov8" title="1"> {
                        srv.StandardResponse(writer, http.StatusNotFound)
                        return
                }</span>
        } else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                srv.GetLogger(request).Error("Unable to get container.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer server.containerEngine.Return(db)
        expires := request.Header.Get("X-Delete-At")
        if err := db.PutObject(vars["obj"], timestamp, size, contentType, etag, policyIndex, expires); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error adding object to container.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">srv.StandardResponse(writer, http.StatusCreated)</span>
}

// ObjDeleteHandler handles the DELETE of object records in a container.
func (server *ContainerServer) ObjDeleteHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        timestamp, err := common.StandardizeTimestamp(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">policyIndex, err := strconv.Atoi(request.Header.Get("X-Backend-Storage-Policy-Index"))
        if err != nil </span><span class="cov8" title="1">{
                policyIndex = 0
        }</span>
        <span class="cov8" title="1">db, err := server.containerEngine.Get(vars)
        if err == ErrorNoSuchContainer </span><span class="cov8" title="1">{
                if strings.HasPrefix(vars["account"], server.autoCreatePrefix) </span><span class="cov8" title="1">{
                        if _, db, err = server.containerEngine.Create(vars, timestamp, map[string][]string{}, policyIndex, 0); err != nil </span><span class="cov0" title="0">{
                                srv.GetLogger(request).Error("Unable to auto-create container.", zap.Error(err))
                                srv.StandardResponse(writer, http.StatusInternalServerError)
                                return
                        }</span>
                } else<span class="cov8" title="1"> {
                        srv.StandardResponse(writer, http.StatusNotFound)
                        return
                }</span>
        } else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                srv.GetLogger(request).Error("Unable to get container.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer server.containerEngine.Return(db)
        if err := db.DeleteObject(vars["obj"], timestamp, policyIndex); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error adding object to container.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">writer.WriteHeader(http.StatusNoContent)
        writer.Write([]byte(""))</span>
}

// HealthcheckHandler implements a basic health check, that just returns "OK".
func (server *ContainerServer) HealthcheckHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        writer.Header().Set("Content-Length", "2")
        writer.WriteHeader(http.StatusOK)
        writer.Write([]byte("OK"))
}</span>

// ReconHandler delegates incoming /recon calls to the common recon handler.
func (server *ContainerServer) ReconHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        middleware.ReconHandler(server.driveRoot, server.reconCachePath, server.checkMounts, writer, request)
}</span>

//OptionsHandler delegates incoming OPTIONS calls to the common options handler.
func (server *ContainerServer) OptionsHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        middleware.OptionsHandler("container-server", writer, request)
        return
}</span>

// DiskUsageHandler returns information on the current outstanding HTTP requests per-disk.
func (server *ContainerServer) DiskUsageHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        if data, err := server.diskInUse.MarshalJSON(); err == nil </span><span class="cov8" title="1">{
                writer.WriteHeader(http.StatusOK)
                writer.Write(data)
        }</span> else<span class="cov0" title="0"> {
                writer.WriteHeader(http.StatusInternalServerError)
                writer.Write([]byte(err.Error()))
        }</span>
}

// LogRequest is a middleware that logs requests and also sets up a logger in the request context.
func (server *ContainerServer) LogRequest(next http.Handler) http.Handler <span class="cov8" title="1">{
        return srv.LogRequest(server.logger, next)
}</span>

// AcquireDevice is a middleware that makes sure the device is available - mounted and not beyond its max concurrency.
func (server *ContainerServer) AcquireDevice(next http.Handler) http.Handler <span class="cov8" title="1">{
        fn := func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                vars := srv.GetVars(request)
                if device, ok := vars["device"]; ok &amp;&amp; device != "" </span><span class="cov8" title="1">{
                        devicePath := filepath.Join(server.driveRoot, device)
                        if server.checkMounts </span><span class="cov0" title="0">{
                                if mounted, err := fs.IsMount(devicePath); err != nil || !mounted </span><span class="cov0" title="0">{
                                        vars["Method"] = request.Method
                                        srv.CustomErrorResponse(writer, 507, vars)
                                        return
                                }</span>
                        }

                        <span class="cov8" title="1">forceAcquire := request.Header.Get("X-Force-Acquire") == "true"
                        if concRequests := server.diskInUse.Acquire(device, forceAcquire); concRequests != 0 </span><span class="cov0" title="0">{
                                writer.Header().Set("X-Disk-Usage", strconv.FormatInt(concRequests, 10))
                                srv.StandardResponse(writer, 503)
                                return
                        }</span>
                        <span class="cov8" title="1">defer server.diskInUse.Release(device)</span>
                }
                <span class="cov8" title="1">next.ServeHTTP(writer, request)</span>
        }
        <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
}

func (server *ContainerServer) updateDeviceLocks(seconds int64) <span class="cov0" title="0">{
        reloadTime := time.Duration(seconds) * time.Second
        for </span><span class="cov0" title="0">{
                time.Sleep(reloadTime)
                for _, key := range server.diskInUse.Keys() </span><span class="cov0" title="0">{
                        lockPath := filepath.Join(server.driveRoot, key, "lock_device")
                        if fs.Exists(lockPath) </span><span class="cov0" title="0">{
                                server.diskInUse.Lock(key)
                        }</span> else<span class="cov0" title="0"> {
                                server.diskInUse.Unlock(key)
                        }</span>
                }
        }
}

// GetHandler returns the server's http handler - it sets up routes and instantiates middleware.
func (server *ContainerServer) GetHandler(config conf.Config, metricsPrefix string) http.Handler <span class="cov8" title="1">{
        var metricsScope tally.Scope
        metricsScope, server.metricsCloser = tally.NewRootScope(tally.ScopeOptions{
                Prefix:         metricsPrefix,
                Tags:           map[string]string{},
                CachedReporter: promreporter.NewReporter(promreporter.Options{}),
                Separator:      promreporter.DefaultSeparator,
        }, time.Second)
        commonHandlers := alice.New(
                middleware.NewDebugResponses(config.GetBool("debug", "debug_x_source_code", false)),
                server.LogRequest,
                middleware.RecoverHandler,
                middleware.ValidateRequest,
                server.AcquireDevice,
        )
        router := srv.NewRouter()
        router.Get("/metrics", prometheus.Handler())
        router.Get("/loglevel", server.logLevel)
        router.Put("/loglevel", server.logLevel)
        router.Get("/healthcheck", commonHandlers.ThenFunc(server.HealthcheckHandler))
        router.Get("/diskusage", commonHandlers.ThenFunc(server.DiskUsageHandler))
        router.Put("/ring/*ring_path", commonHandlers.ThenFunc(middleware.RingHandler))
        router.Get("/debug/pprof/:parm", http.DefaultServeMux)
        router.Post("/debug/pprof/:parm", http.DefaultServeMux)
        router.Get("/recon/:method/:recon_type", commonHandlers.ThenFunc(server.ReconHandler))
        router.Get("/recon/:method", commonHandlers.ThenFunc(server.ReconHandler))
        router.Delete("/recon/:device/:method/:recon_type/*item_path", commonHandlers.ThenFunc(server.ReconHandler))
        router.Put("/:device/tmp/:filename", commonHandlers.ThenFunc(server.ContainerTmpUploadHandler))
        router.Put("/:device/:partition/:account/:container/*obj", commonHandlers.ThenFunc(server.ObjPutHandler))
        router.Delete("/:device/:partition/:account/:container/*obj", commonHandlers.ThenFunc(server.ObjDeleteHandler))
        router.Put("/:device/:partition/:account/:container", commonHandlers.ThenFunc(server.ContainerPutHandler))
        router.Get("/:device/:partition/:account/:container", commonHandlers.ThenFunc(server.ContainerGetHandler))
        router.Head("/:device/:partition/:account/:container", commonHandlers.ThenFunc(server.ContainerGetHandler))
        router.Delete("/:device/:partition/:account/:container", commonHandlers.ThenFunc(server.ContainerDeleteHandler))
        router.Post("/:device/:partition/:account/:container", commonHandlers.ThenFunc(server.ContainerPostHandler))
        router.Replicate("/:device/:partition/:hash", commonHandlers.ThenFunc(server.ContainerReplicateHandler))
        router.Options("/", commonHandlers.ThenFunc(server.OptionsHandler))
        router.NotFoundHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Invalid path: %s", r.URL.Path), http.StatusBadRequest)
        }</span>)
        <span class="cov8" title="1">return alice.New(middleware.Metrics(metricsScope), middleware.GrepObject, middleware.ServerTracer(server.tracer)).Then(router)</span>
}

// NewServer parses configs and command-line flags, returning a configured server object and the ip and port it should bind on.
func NewServer(serverconf conf.Config, flags *flag.FlagSet, cnf srv.ConfigLoader) (*srv.IpPort, srv.Server, srv.LowLevelLogger, error) <span class="cov8" title="1">{
        var err error
        var ipPort *srv.IpPort
        server := &amp;ContainerServer{driveRoot: "/srv/node", hashPathPrefix: "", hashPathSuffix: ""}
        server.syncRealms, err = cnf.GetSyncRealms()
        if err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, err
        }</span>
        <span class="cov8" title="1">server.hashPathPrefix, server.hashPathSuffix, err = cnf.GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, err
        }</span>
        <span class="cov8" title="1">server.reconCachePath = serverconf.GetDefault("app:container-server", "recon_cache_path", "/var/cache/swift")
        policies, err := cnf.GetPolicies()
        if err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, err
        }</span>
        <span class="cov8" title="1">server.policyList = policies
        server.defaultPolicy = policies.Default()
        server.autoCreatePrefix = serverconf.GetDefault("app:container-server", "auto_create_account_prefix", ".")
        server.driveRoot = serverconf.GetDefault("app:container-server", "devices", "/srv/node")
        server.checkMounts = serverconf.GetBool("app:container-server", "mount_check", true)

        logLevelString := serverconf.GetDefault("app:container-server", "log_level", "INFO")
        server.logLevel = zap.NewAtomicLevel()
        server.logLevel.UnmarshalText([]byte(strings.ToLower(logLevelString)))

        if server.logger, err = srv.SetupLogger("container-server", &amp;server.logLevel, flags); err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, fmt.Errorf("Error setting up logger: %v", err)
        }</span>
        <span class="cov8" title="1">server.diskInUse = common.NewKeyedLimit(serverconf.GetLimit("app:container-server", "disk_limit", 0, 0))
        bindIP := serverconf.GetDefault("app:container-server", "bind_ip", "0.0.0.0")
        bindPort := int(serverconf.GetInt("app:container-server", "bind_port", common.DefaultContainerServerPort))
        certFile := serverconf.GetDefault("app:container-server", "cert_file", "")
        keyFile := serverconf.GetDefault("app:container-server", "key_file", "")
        server.containerEngine = newLRUEngine(server.driveRoot, server.hashPathPrefix, server.hashPathSuffix, 32)
        connTimeout := time.Duration(serverconf.GetFloat("app:container-server", "conn_timeout", 1.0) * float64(time.Second))
        nodeTimeout := time.Duration(serverconf.GetFloat("app:container-server", "node_timeout", 10.0) * float64(time.Second))
        transport := &amp;http.Transport{
                Dial:                (&amp;net.Dialer{Timeout: connTimeout}).Dial,
                MaxIdleConnsPerHost: 100,
                MaxIdleConns:        0,
                IdleConnTimeout:     5 * time.Second,
                DisableCompression:  true,
        }
        if certFile != "" &amp;&amp; keyFile != "" </span><span class="cov0" title="0">{
                tlsConf, err := common.NewClientTLSConfig(certFile, keyFile)
                if err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error getting TLS config: %v", err)
                }</span>
                <span class="cov0" title="0">transport.TLSClientConfig = tlsConf
                if err = http2.ConfigureTransport(transport); err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error setting up http2: %v", err)
                }</span>
        }
        <span class="cov8" title="1">c := &amp;http.Client{
                Timeout:   nodeTimeout,
                Transport: transport,
        }
        server.updateClient = c
        if serverconf.HasSection("tracing") </span><span class="cov0" title="0">{
                server.tracer, server.traceCloser, err = tracing.Init("containerserver", server.logger, serverconf.GetSection("tracing"))
                if err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error setting up tracer: %v", err)
                }</span>
                <span class="cov0" title="0">server.updateClientTracer, server.updateClientTraceCloser, err = tracing.Init("container-updateclient", server.logger, serverconf.GetSection("tracing"))
                if err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error setting up tracer: %v", err)
                }</span>
                <span class="cov0" title="0">enableHTTPTrace := serverconf.GetBool("tracing", "enable_httptrace", true)
                server.updateClient, err = client.NewTracingClient(server.updateClientTracer, c, enableHTTPTrace)
                if err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error setting up tracing client: %v", err)
                }</span>
        }
        <span class="cov8" title="1">ipPort = &amp;srv.IpPort{Ip: bindIP, Port: bindPort, CertFile: certFile, KeyFile: keyFile}
        return ipPort, server, server.logger, nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">//  Copyright (c) 2016 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package containerserver

import (
        "crypto/md5"
        "database/sql"
        "encoding/base64"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "math"
        "os"
        "path"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/mattn/go-sqlite3"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/pickle"
)

const (
        maxQueryArgs       = 990
        maxOpenConns       = 2
        maxIdleConns       = 2
        pendingCap         = 131072
        maxMetaCount       = 90
        maxMetaOverallSize = 4096
)

var infoCacheTimeout = time.Second * 10

func chexor(old, name, timestamp string) string <span class="cov8" title="1">{
        oldDigest, err := hex.DecodeString(old)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Error decoding hex: %v", err))</span>
        }
        <span class="cov8" title="1">h := md5.New()
        if _, err := io.WriteString(h, name+"-"+timestamp); err != nil </span><span class="cov0" title="0">{
                panic("THIS SHOULD NEVER HAPPEN")</span>
        }
        <span class="cov8" title="1">digest := h.Sum(nil)
        for i := range digest </span><span class="cov8" title="1">{
                digest[i] ^= oldDigest[i]
        }</span>
        <span class="cov8" title="1">return hex.EncodeToString(digest)</span>
}

func init() <span class="cov8" title="1">{
        // register our sql driver with user-defined chexor function
        sql.Register("sqlite3_hummingbird",
                &amp;sqlite3.SQLiteDriver{
                        ConnectHook: func(conn *sqlite3.SQLiteConn) error </span><span class="cov8" title="1">{
                                if err := conn.RegisterFunc("chexor", chexor, true); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">if _, err := conn.Exec(pragmaScript, nil); err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">if _, err := conn.Exec(`CREATE TEMPORARY VIEW IF NOT EXISTS maxrowid (max) AS
                                                                                  SELECT IFNULL(MAX(seq), -1) FROM sqlite_sequence WHERE name='object'`, nil); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">return nil</span>
                        },
                },
        )
}

// SqliteContainer wraps a connection to the underlying database and provides all of the operations on that database.
type sqliteContainer struct {
        connectLock sync.Mutex
        *sql.DB
        containerFile       string
        hasDeletedNameIndex bool
        infoCache           atomic.Value
        ringhash            string
}

var _ Container = &amp;sqliteContainer{}

func (db *sqliteContainer) connect() error <span class="cov8" title="1">{
        db.connectLock.Lock()
        defer db.connectLock.Unlock()
        if db.DB != nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">dbConn, err := sql.Open("sqlite3_hummingbird", "file:"+db.containerFile+"?psow=1&amp;_txlock=immediate&amp;mode=rw")
        if err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to open: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("Failed to open: %v", err)</span>
        }
        <span class="cov8" title="1">dbConn.SetMaxOpenConns(maxOpenConns)
        dbConn.SetMaxIdleConns(maxIdleConns)
        hasDeletedNameIndex, err := schemaMigrate(dbConn)
        if err != nil </span><span class="cov8" title="1">{
                db.closeAlreadyLocked()
                if common.IsCorruptDBError(err) </span><span class="cov8" title="1">{
                        return fmt.Errorf("Error migrating database: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("Error migrating database: %v", err)</span>
        }
        <span class="cov8" title="1">db.hasDeletedNameIndex = hasDeletedNameIndex
        db.DB = dbConn
        return nil</span>
}

// GetInfo returns the container's information as a ContainerInfo struct.
func (db *sqliteContainer) GetInfo() (*ContainerInfo, error) <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := db.flush(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if _, err := db.Exec("DELETE FROM object WHERE expires &lt; ?", time.Now().Unix()); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if info, ok := db.infoCache.Load().(*ContainerInfo); ok &amp;&amp; !info.invalid &amp;&amp; time.Since(info.updated) &lt; infoCacheTimeout </span><span class="cov8" title="1">{
                return info, nil
        }</span>
        <span class="cov8" title="1">info := &amp;ContainerInfo{updated: time.Now()}
        row := db.QueryRow(`SELECT cs.account, cs.container, cs.created_at, cs.put_timestamp,
                                                        cs.delete_timestamp, cs.status_changed_at,
                                                        cs.object_count, cs.bytes_used,
                                                        cs.reported_put_timestamp, cs.reported_delete_timestamp,
                                                        cs.reported_object_count, cs.reported_bytes_used, cs.hash,
                                                        cs.id, cs.x_container_sync_point1, cs.x_container_sync_point2,
                                                        cs.storage_policy_index, cs.metadata, maxrowid.max
                                                FROM container_stat cs, maxrowid`)
        if err := row.Scan(&amp;info.Account, &amp;info.Container, &amp;info.CreatedAt, &amp;info.PutTimestamp,
                &amp;info.DeleteTimestamp, &amp;info.StatusChangedAt, &amp;info.ObjectCount,
                &amp;info.BytesUsed, &amp;info.ReportedPutTimestamp, &amp;info.ReportedDeleteTimestamp,
                &amp;info.ReportedObjectCount, &amp;info.ReportedBytesUsed, &amp;info.Hash,
                &amp;info.ID, &amp;info.XContainerSyncPoint1, &amp;info.XContainerSyncPoint2,
                &amp;info.StoragePolicyIndex, &amp;info.RawMetadata, &amp;info.MaxRow); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to GetInfo: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">if info.RawMetadata == "" </span><span class="cov0" title="0">{
                info.Metadata = make(map[string][]string)
        }</span> else<span class="cov8" title="1"> if err := json.Unmarshal([]byte(info.RawMetadata), &amp;info.Metadata); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">db.infoCache.Store(info)
        return info, nil</span>
}

func (db *sqliteContainer) invalidateCache() <span class="cov8" title="1">{
        db.infoCache.Store(&amp;ContainerInfo{invalid: true})
}</span>

// IsDeleted returns true if the container is deleted - if its delete timestamp is later than its put timestamp.
func (db *sqliteContainer) IsDeleted() (bool, error) <span class="cov8" title="1">{
        info, err := db.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return info.DeleteTimestamp &gt; info.PutTimestamp, nil</span>
}

// Delete sets the container's deleted timestamp and tombstones any metadata older than that timestamp.
// This may or may not make the container "deleted".
func (db *sqliteContainer) Delete(timestamp string) error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        var metastr string
        var metadata map[string][]string
        if err := tx.QueryRow("SELECT metadata FROM container_info").Scan(&amp;metastr); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to Delete SELECT: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">if err := json.Unmarshal([]byte(metastr), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for key, value := range metadata </span><span class="cov8" title="1">{
                if value[1] &lt; timestamp </span><span class="cov8" title="1">{
                        metadata[key] = []string{"", timestamp}
                }</span>
        }
        <span class="cov8" title="1">serializedMetadata, err := json.Marshal(metadata)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err = tx.Exec("UPDATE container_info SET delete_timestamp = ?, metadata = ?", timestamp, string(serializedMetadata)); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to Delete UPDATE: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">defer db.invalidateCache()
        if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to Delete Commit: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// MergeItems merges ObjectRecords into the container.  If a remote id is provided (incoming replication), the incoming_sync table is updated.
func (db *sqliteContainer) MergeItems(records []*ObjectRecord, remoteID string) error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">type recordID struct {
                policy int
                name   string
        }
        names := make([]interface{}, len(records))
        existing := make(map[recordID]*ObjectRecord)
        toAdd := make(map[recordID]*ObjectRecord)
        tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        for i, record := range records </span><span class="cov8" title="1">{
                names[i] = record.Name
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; len(records); i += maxQueryArgs </span><span class="cov8" title="1">{
                j := i + maxQueryArgs
                if j &gt; len(records) </span><span class="cov8" title="1">{
                        j = len(records)
                }</span>
                <span class="cov8" title="1">batch := names[i:j]
                query := ""
                if db.hasDeletedNameIndex </span><span class="cov8" title="1">{
                        query = fmt.Sprintf("SELECT name, storage_policy_index, created_at, ROWID FROM object WHERE deleted IN (0, 1) AND name IN (%s)",
                                strings.TrimRight(strings.Repeat("?,", len(batch)), ","))
                }</span> else<span class="cov0" title="0"> {
                        query = fmt.Sprintf("SELECT name, storage_policy_index, created_at, ROWID FROM object WHERE name IN (%s)",
                                strings.TrimRight(strings.Repeat("?,", len(batch)), ","))
                }</span>
                <span class="cov8" title="1">rows, err := tx.Query(query, batch...)
                if err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf("Failed to MergeItems SELECT: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                        var name, timestamp string
                        var rowid int64
                        var policy int
                        if err := rows.Scan(&amp;name, &amp;policy, &amp;timestamp, &amp;rowid); err != nil </span><span class="cov0" title="0">{
                                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                        return fmt.Errorf("Failed to MergeItems SELECT Scan: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                                }</span>
                                <span class="cov0" title="0">return err</span>
                        }
                        <span class="cov8" title="1">existing[recordID{policy, name}] = &amp;ObjectRecord{CreatedAt: timestamp, Rowid: rowid}</span>
                }
                <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf("Failed to MergeItems SELECT Err: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov8" title="1">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf("Failed to MergeItems SELECT Close: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        }

        <span class="cov8" title="1">dst, err := tx.Prepare("DELETE FROM object WHERE ROWID=?")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer dst.Close()

        ast, err := tx.Prepare("INSERT INTO object (name, created_at, size, content_type, etag, deleted, storage_policy_index, expires) VALUES (?, ?, ?, ?, ?, ?, ?, ?)")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer ast.Close()

        var maxRowid int64 = -1
        for _, record := range records </span><span class="cov8" title="1">{
                if record.Rowid &gt; maxRowid </span><span class="cov8" title="1">{
                        maxRowid = record.Rowid
                }</span>
                <span class="cov8" title="1">rid := recordID{record.StoragePolicyIndex, record.Name}
                if alreadyIn, ok := toAdd[rid]; !ok || record.CreatedAt &gt; alreadyIn.CreatedAt </span><span class="cov8" title="1">{
                        current, inExisting := existing[rid]
                        if inExisting &amp;&amp; current.CreatedAt &lt; record.CreatedAt </span><span class="cov8" title="1">{
                                if _, err := dst.Exec(current.Rowid); err != nil </span><span class="cov0" title="0">{
                                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                                return fmt.Errorf("Failed to MergeItems DELETE: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                                        }</span>
                                        <span class="cov0" title="0">return err</span>
                                }
                                <span class="cov8" title="1">delete(existing, rid)
                                toAdd[rid] = record</span>
                        } else<span class="cov8" title="1"> if !inExisting </span><span class="cov8" title="1">{
                                toAdd[rid] = record
                        }</span>
                }
        }

        <span class="cov8" title="1">for _, record := range toAdd </span><span class="cov8" title="1">{
                if _, err := ast.Exec(record.Name, record.CreatedAt, record.Size, record.ContentType, record.ETag, record.Deleted, record.StoragePolicyIndex, record.Expires); err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf("Failed to MergeItems INSERT: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        }

        <span class="cov8" title="1">if remoteID != "" &amp;&amp; maxRowid &gt; -1 </span><span class="cov8" title="1">{
                if _, err := tx.Exec(`UPDATE incoming_sync SET sync_point = ? WHERE remote_id = ?;
                                                          INSERT INTO incoming_sync (remote_id, sync_point) SELECT ?, ? WHERE changes() == 0;`,
                        maxRowid, remoteID, remoteID, maxRowid); err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf("Failed to MergeItems UPDATE: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        }

        <span class="cov8" title="1">defer db.invalidateCache()
        if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to MergeItems Commit: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func indexAfter(s, sep string, after int) int <span class="cov8" title="1">{
        index := strings.Index(s[after:], sep)
        if index == -1 </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">return index + after</span>
}

func updateRecord(rec *ObjectListingRecord) error <span class="cov8" title="1">{
        f, err := strconv.ParseFloat(rec.LastModified, 64)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">whole, nans := math.Modf(f)
        rec.LastModified = time.Unix(int64(whole), int64(nans*1.0e9)).In(common.GMT).Format("2006-01-02T15:04:05.000000")

        rec.ContentType, rec.Size, err = common.ParseContentTypeForSlo(
                rec.ContentType, rec.Size)
        return err</span>
}

// ListObjects implements object listings.  Path is a string pointer because behavior is different for empty and missing path query parameters.
func (db *sqliteContainer) ListObjects(limit int, marker string, endMarker string, prefix string, delimiter string,
        pth *string, reverse bool, storagePolicyIndex int) ([]interface{}, error) <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var point, pointDirection, queryTail, queryStart string

        if pth != nil </span><span class="cov8" title="1">{
                if *pth != "" </span><span class="cov8" title="1">{
                        p := strings.TrimRight(*pth, "/") + "/"
                        pth = &amp;p
                }</span>
                <span class="cov8" title="1">delimiter = "/"
                prefix = *pth</span>
        }
        <span class="cov8" title="1">if db.hasDeletedNameIndex </span><span class="cov8" title="1">{
                queryStart = "SELECT name, created_at, size, content_type, etag FROM object WHERE deleted = 0 AND"
        }</span> else<span class="cov0" title="0"> {
                queryStart = "SELECT name, created_at, size, content_type, etag FROM object WHERE +deleted = 0 AND"
        }</span>
        <span class="cov8" title="1">if reverse </span><span class="cov8" title="1">{
                marker, endMarker = endMarker, marker
                queryTail = "ORDER BY name DESC LIMIT ?"
                pointDirection = "name &lt; ?"
        }</span> else<span class="cov8" title="1"> {
                queryTail = "ORDER BY name LIMIT ?"
                pointDirection = "name &gt; ?"
        }</span>

        <span class="cov8" title="1">results := []interface{}{}
        queryArgs := make([]interface{}, 8)
        wheres := make([]string, 8)
        gotResults := true

        for len(results) &lt; limit &amp;&amp; gotResults </span><span class="cov8" title="1">{
                wheres := append(wheres[:0], "storage_policy_index == ?")
                queryArgs := append(queryArgs[:0], storagePolicyIndex)
                if prefix != "" </span><span class="cov8" title="1">{
                        wheres = append(wheres, "name BETWEEN ? AND ?")
                        queryArgs = append(queryArgs, prefix, prefix+"\xFF")
                }</span>
                <span class="cov8" title="1">if marker != "" </span><span class="cov8" title="1">{
                        wheres = append(wheres, "name &gt; ?")
                        queryArgs = append(queryArgs, marker)
                }</span>
                <span class="cov8" title="1">if endMarker != "" </span><span class="cov8" title="1">{
                        wheres = append(wheres, "name &lt; ?")
                        queryArgs = append(queryArgs, endMarker)
                }</span>
                <span class="cov8" title="1">if point != "" </span><span class="cov8" title="1">{
                        wheres = append(wheres, pointDirection)
                        queryArgs = append(queryArgs, point)
                }</span>
                <span class="cov8" title="1">rows, err := db.Query(queryStart+" "+strings.Join(wheres, " AND ")+" "+queryTail,
                        append(queryArgs, limit-len(results))...)
                if err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Failed to ListObjects SELECT: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov8" title="1">gotResults = false
                for rows.Next() &amp;&amp; len(results) &lt; limit </span><span class="cov8" title="1">{
                        gotResults = true
                        record := &amp;ObjectListingRecord{}
                        if err := rows.Scan(&amp;record.Name, &amp;record.LastModified, &amp;record.Size, &amp;record.ContentType, &amp;record.ETag); err != nil </span><span class="cov0" title="0">{
                                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("Failed to ListObjects Scan: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                                }</span>
                                <span class="cov0" title="0">return nil, err</span>
                        }
                        <span class="cov8" title="1">point = record.Name
                        if delimiter != "" </span><span class="cov8" title="1">{
                                if pth != nil &amp;&amp; record.Name == *pth </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">end := indexAfter(record.Name, delimiter, len(prefix))
                                if end &gt;= 0 &amp;&amp; (pth == nil || len(record.Name) &gt; end+1) </span><span class="cov8" title="1">{
                                        dirName := record.Name[:end] + delimiter
                                        if reverse </span><span class="cov8" title="1">{
                                                point = record.Name[:end+len(delimiter)]
                                        }</span> else<span class="cov8" title="1"> {
                                                point = dirName + "\xFF"
                                        }</span>
                                        <span class="cov8" title="1">if pth == nil &amp;&amp; dirName != marker </span><span class="cov8" title="1">{
                                                results = append(results, &amp;SubdirListingRecord{Name2: dirName, Name: dirName})
                                        }</span>
                                        <span class="cov8" title="1">break</span>
                                }
                        }
                        <span class="cov8" title="1">if err := updateRecord(record); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">results = append(results, record)</span>
                }
                <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Failed to ListObjects Err: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov8" title="1">rows.Close()
                if delimiter == "" &amp;&amp; pth == nil </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return results, nil</span>
}

// NewID sets the container's ID to a new, random string.
func (db *sqliteContainer) NewID() error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        _, err = tx.Exec(`INSERT OR REPLACE INTO incoming_sync (remote_id, sync_point)
                                          SELECT container_info.id, maxrowid.max FROM container_info, maxrowid`)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err = tx.Exec("UPDATE container_info SET id = ?", common.UUID()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer db.invalidateCache()
        return tx.Commit()</span>
}

// ItemsSince returns (count) object records with a rowid greater than (start).
func (db *sqliteContainer) ItemsSince(start int64, count int) ([]*ObjectRecord, error) <span class="cov8" title="1">{
        db.flush()
        records := []*ObjectRecord{}
        rows, err := db.Query(`SELECT ROWID, name, created_at, size, content_type, etag, deleted, storage_policy_index, expires
                                                   FROM object WHERE ROWID &gt; ? ORDER BY ROWID ASC LIMIT ?`, start, count)
        if err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to ItemsSince SELECT: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                r := &amp;ObjectRecord{}
                if err := rows.Scan(&amp;r.Rowid, &amp;r.Name, &amp;r.CreatedAt, &amp;r.Size, &amp;r.ContentType, &amp;r.ETag, &amp;r.Deleted, &amp;r.StoragePolicyIndex, &amp;r.Expires); err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Failed to ItemsSince Scan: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov8" title="1">records = append(records, r)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to ItemsSince Err: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">rows.Close()
        return records, nil</span>
}

// GetMetadata returns the current container metadata as a simple map[string]string, i.e. it leaves out tombstones and timestamps.
func (db *sqliteContainer) GetMetadata() (map[string]string, error) <span class="cov8" title="1">{
        info, err := db.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">metadata := make(map[string]string)
        for key, value := range info.Metadata </span><span class="cov8" title="1">{
                if value[0] != "" </span><span class="cov8" title="1">{
                        metadata[key] = value[0]
                }</span>
        }
        <span class="cov8" title="1">return metadata, nil</span>
}

func (db *sqliteContainer) mergeMetas(a map[string][]string, b map[string][]string, deleteTimestamp string) (string, error) <span class="cov8" title="1">{
        newMeta := map[string][]string{}
        for k, v := range a </span><span class="cov8" title="1">{
                newMeta[k] = v
        }</span>
        <span class="cov8" title="1">for k, v := range b </span><span class="cov8" title="1">{
                if existing, ok := a[k]; ok </span><span class="cov8" title="1">{
                        if existing[1] &lt; v[1] </span><span class="cov8" title="1">{
                                newMeta[k] = v
                        }</span>
                } else<span class="cov8" title="1"> {
                        newMeta[k] = v
                }</span>
        }
        <span class="cov8" title="1">metaSize := 0
        metaCount := 0
        for k, v := range newMeta </span><span class="cov8" title="1">{
                if deleteTimestamp != "" &amp;&amp; v[1] &lt; deleteTimestamp </span><span class="cov8" title="1">{
                        newMeta[k] = []string{"", deleteTimestamp}
                }</span> else<span class="cov8" title="1"> if v[0] != "" &amp;&amp; strings.HasPrefix(strings.ToLower(k), "x-container-meta-") </span><span class="cov8" title="1">{
                        metaSize += len(k) - 17
                        metaSize += len(v[0])
                        metaCount++
                }</span>
        }
        <span class="cov8" title="1">if metaCount &gt; maxMetaCount || metaSize &gt; maxMetaOverallSize </span><span class="cov0" title="0">{
                return "", ErrorInvalidMetadata
        }</span>
        <span class="cov8" title="1">serMeta, err := json.Marshal(newMeta)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(serMeta), nil</span>
}

// UpdateMetadata merges the current container metadata with new incoming metadata.
func (db *sqliteContainer) UpdateMetadata(newMetadata map[string][]string, timestamp string) error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(newMetadata) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        var metadataValue, deleteTimestamp string
        if err := tx.QueryRow("SELECT metadata, delete_timestamp FROM container_info").Scan(&amp;metadataValue, &amp;deleteTimestamp); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to UpdateMetadata SELECT: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">var existingMetadata map[string][]string
        if metadataValue == "" </span><span class="cov0" title="0">{
                existingMetadata = map[string][]string{}
        }</span> else<span class="cov8" title="1"> if err := json.Unmarshal([]byte(metadataValue), &amp;existingMetadata); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">metastr, err := db.mergeMetas(existingMetadata, newMetadata, deleteTimestamp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err = tx.Exec("UPDATE container_info SET metadata=?, put_timestamp=MAX(put_timestamp, ?)", metastr, timestamp); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to UpdateMetadata UPDATE: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">defer db.invalidateCache()
        if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to UpdateMetadata Commit: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// MergeSyncTable updates the container's current incoming_sync table records.
func (db *sqliteContainer) MergeSyncTable(records []*SyncRecord) error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        for _, record := range records </span><span class="cov8" title="1">{
                if _, err := tx.Exec(`UPDATE incoming_sync SET sync_point = ? WHERE remote_id = ?;
                                                          INSERT INTO incoming_sync (remote_id, sync_point) SELECT ?, ? WHERE changes() == 0;`,
                        record.SyncPoint, record.RemoteID, record.RemoteID, record.SyncPoint); err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf("Failed to MergeSyncTable UPDATE: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        }
        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to MergeSyncTable Commit: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// CleanupTombstones removes any expired tombstoned objects or metadata.
func (db *sqliteContainer) CleanupTombstones(reclaimAge int64) error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">now := float64(time.Now().UnixNano()) / 1000000000.0
        reclaimTimestamp := common.CanonicalTimestamp(now - float64(reclaimAge))

        tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        if _, err = tx.Exec("DELETE FROM object WHERE deleted=1 AND created_at &lt; ?", reclaimTimestamp); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to CleanupTombstones DELETE: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">var metastr string
        if err := tx.QueryRow("SELECT metadata FROM container_info").Scan(&amp;metastr); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to CleanupTombstones SELECT: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">var metadata map[string][]string
        updated := false
        if metastr == "" </span><span class="cov0" title="0">{
                metadata = map[string][]string{}
                updated = true
        }</span> else<span class="cov8" title="1"> {
                if err := json.Unmarshal([]byte(metastr), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for k, v := range metadata </span><span class="cov8" title="1">{
                        if v[0] == "" </span><span class="cov8" title="1">{
                                if ts, err := common.GetEpochFromTimestamp(v[1]); err != nil || ts &lt; reclaimTimestamp </span><span class="cov8" title="1">{
                                        delete(metadata, k)
                                        updated = true
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">if updated </span><span class="cov8" title="1">{
                if mb, err := json.Marshal(metadata); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span> else<span class="cov8" title="1"> if _, err = tx.Exec("UPDATE container_info SET metadata = ?", string(mb)); err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf("Failed to CleanupTombstones UPDATE: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        }
        <span class="cov8" title="1">defer db.invalidateCache()
        if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to CleanupTombstones Commit: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// SyncTable returns the container's current incoming_sync table, and also includes the current container's id and max row as an entry.
func (db *sqliteContainer) SyncTable() ([]*SyncRecord, error) <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">records := []*SyncRecord{}
        rows, err := db.Query(`SELECT sync_point, remote_id FROM incoming_sync
                                                   WHERE remote_id NOT IN (SELECT id FROM container_info)
                                                   UNION
                                                   SELECT maxrowid.max AS sync_point, container_info.id AS remote_id
                                                   FROM container_info, maxrowid`)
        if err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to SyncTable SELECT: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                rec := &amp;SyncRecord{}
                if err := rows.Scan(&amp;rec.SyncPoint, &amp;rec.RemoteID); err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Failed to SyncTable Scan: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov8" title="1">records = append(records, rec)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to SyncTable Err: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">rows.Close()
        return records, nil</span>
}

// SyncRemoteData compares a remote container's info to the local info and updates any necessary replication bookkeeping, returning the current container's info.
func (db *sqliteContainer) SyncRemoteData(maxRow int64, hash, id, createdAt, putTimestamp, deleteTimestamp, metadata string) (*ContainerInfo, error) <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        var localMeta, localHash, localDeleteTimestamp string
        var localPoint int64
        if err := tx.QueryRow("SELECT hash, metadata, delete_timestamp FROM container_info").Scan(&amp;localHash, &amp;localMeta, &amp;localDeleteTimestamp); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to SyncRemoteData SELECT: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">var lm, rm map[string][]string
        if err := json.Unmarshal([]byte(metadata), &amp;rm); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal([]byte(localMeta), &amp;lm); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if deleteTimestamp &gt; localDeleteTimestamp </span><span class="cov8" title="1">{
                localDeleteTimestamp = deleteTimestamp
        }</span>
        <span class="cov8" title="1">metastr, err := db.mergeMetas(lm, rm, localDeleteTimestamp)
        if _, err = tx.Exec(`UPDATE container_info SET created_at=MIN(?, created_at), put_timestamp=MAX(?, put_timestamp),
                                                   delete_timestamp=MAX(?, delete_timestamp), metadata=?`,
                createdAt, putTimestamp, deleteTimestamp, metastr); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to SyncRemoteData UPDATE: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">if err := tx.QueryRow("SELECT IFNULL(MAX(sync_point), -1) FROM incoming_sync WHERE remote_id = ?", id).Scan(&amp;localPoint); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to SyncRemoteData SELECT2: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">if localHash == hash &amp;&amp; maxRow &gt; localPoint </span><span class="cov8" title="1">{
                localPoint = maxRow
                if _, err = tx.Exec("INSERT OR REPLACE INTO incoming_sync (remote_id, sync_point) VALUES (?, ?)", id, localPoint); err != nil </span><span class="cov0" title="0">{
                        if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Failed to SyncRemoteData INSERT: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
        }
        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Failed to SyncRemoteData Commit: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">db.invalidateCache()
        info, err := db.GetInfo()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">info.Point = localPoint
        return info, nil</span>
}

// CheckSyncLink makes sure the database's container sync symlink exists or doesn't exist, as in accordance with the existence of the X-Container-Sync-To header.
func (db *sqliteContainer) CheckSyncLink() error <span class="cov8" title="1">{
        metadata, err := db.GetMetadata()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">containersDir := filepath.Dir(filepath.Dir(filepath.Dir(filepath.Dir(db.containerFile))))
        deviceDir := filepath.Dir(containersDir)
        pathFromDataDir, err := filepath.Rel(containersDir, db.containerFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">symLoc := filepath.Join(deviceDir, "sync_containers", pathFromDataDir)
        if metadata["X-Container-Sync-To"] != "" </span><span class="cov8" title="1">{
                if fs.Exists(symLoc) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">if err := os.MkdirAll(filepath.Dir(symLoc), 0755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return os.Symlink(db.containerFile, symLoc)</span>
        } else<span class="cov8" title="1"> if fs.Exists(symLoc) </span><span class="cov8" title="1">{
                for err := error(nil); err == nil; symLoc = filepath.Dir(symLoc) </span><span class="cov8" title="1">{
                        err = os.Remove(symLoc)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// OpenDatabaseFile blocks updates and opens the underlying database file for reading, so it can be uploaded to a remote server.
func (db *sqliteContainer) OpenDatabaseFile() (*os.File, func(), error) <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">var fp *os.File
        if _, err := db.Exec(`
                PRAGMA locking_mode = EXCLUSIVE;      -- grab and hold a shared lock
                SELECT 1 FROM container_info LIMIT 1; -- it doesn't actually lock until you hit the database
                PRAGMA wal_checkpoint(TRUNCATE);      -- truncate the wal file, if it exists`,
        ); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("Failed to OpenDatabaseFile: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return nil, nil, fmt.Errorf("Error locking database%s: %v", db.containerFile, err)</span>
        }
        <span class="cov8" title="1">cleanup := func() </span><span class="cov8" title="1">{
                db.Exec(`
                        PRAGMA locking_mode = NORMAL;         -- release shared lock
                        SELECT 1 FROM container_info LIMIT 1; -- actually release shared lock
                `)
                if fp != nil </span><span class="cov8" title="1">{
                        fp.Close()
                }</span>
        }
        // make sure there aren't any journals lying around
        <span class="cov8" title="1">if stat, err := os.Stat(db.containerFile + "-wal"); err == nil &amp;&amp; stat.Size() != 0 </span><span class="cov0" title="0">{
                cleanup()
                return nil, nil, fmt.Errorf("Stubborn wal file still exists: %s", db.containerFile)
        }</span>
        <span class="cov8" title="1">if stat, err := os.Stat(db.containerFile + "-journal"); err == nil &amp;&amp; stat.Size() != 0 </span><span class="cov0" title="0">{
                cleanup()
                return nil, nil, fmt.Errorf("Stubborn journal file still exists: %s", db.containerFile)
        }</span>
        <span class="cov8" title="1">fp, err := os.Open(db.containerFile)
        if err != nil </span><span class="cov0" title="0">{
                fp = nil
                cleanup()
                return nil, nil, fmt.Errorf("Error opening %s: %v", db.containerFile, err)
        }</span>
        <span class="cov8" title="1">return fp, cleanup, nil</span>
}

// ID returns the container's ring hash as a unique identifier for it.
func (db *sqliteContainer) ID() string <span class="cov8" title="1">{
        return db.ringhash
}</span>

// RingHash returns the container's ring hash as a string.
func (db *sqliteContainer) RingHash() string <span class="cov8" title="1">{
        return db.ringhash
}</span>

func (db *sqliteContainer) flushAlreadyLocked() error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if stat, err := os.Stat(db.containerFile + ".pending"); err != nil || stat.Size() == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">contents, err := ioutil.ReadFile(db.containerFile + ".pending")
        if err != nil || len(contents) == 0 </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">var records []*ObjectRecord
        for _, base64ed := range strings.Split(string(contents), ":") </span><span class="cov8" title="1">{
                if len(base64ed) &lt; 1 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">serialized, err := base64.StdEncoding.DecodeString(base64ed)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if serialized[0] == '{' </span><span class="cov8" title="1">{
                        rec := &amp;ObjectRecord{}
                        if err = json.Unmarshal(serialized, &amp;rec); err == nil </span><span class="cov8" title="1">{
                                records = append(records, rec)
                        }</span> else<span class="cov0" title="0"> {
                                return fmt.Errorf("Invalid commit pending json record")
                        }</span>
                } else<span class="cov0" title="0"> {
                        r, err := pickle.PickleLoads(serialized)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">record, ok := r.([]interface{})
                        if !ok || len(record) &lt; 7 </span><span class="cov0" title="0">{
                                return fmt.Errorf("Invalid commit pending record")
                        }</span>
                        <span class="cov0" title="0">casts := make([]bool, 7)
                        var deleted, policy int64
                        rec := &amp;ObjectRecord{}
                        rec.Name, casts[0] = record[0].(string)
                        rec.CreatedAt, casts[1] = record[1].(string)
                        rec.Size, casts[2] = record[2].(int64)
                        rec.ContentType, casts[3] = record[3].(string)
                        rec.ETag, casts[4] = record[4].(string)
                        deleted, casts[5] = record[5].(int64)
                        policy, casts[6] = record[6].(int64)
                        rec.Deleted = int(deleted)
                        rec.StoragePolicyIndex = int(policy)
                        for i := 0; i &lt; 7; i++ </span><span class="cov0" title="0">{
                                if !casts[i] </span><span class="cov0" title="0">{
                                        return fmt.Errorf("Invalid commit pending record")
                                }</span>
                        }
                        <span class="cov0" title="0">records = append(records, rec)</span>
                }
        }
        <span class="cov8" title="1">err = db.MergeItems(records, "")
        if err == nil </span><span class="cov8" title="1">{
                err = os.Truncate(db.containerFile+".pending", 0)
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (db *sqliteContainer) flush() error <span class="cov8" title="1">{
        lock, err := fs.LockPath(filepath.Dir(db.containerFile), 10*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer lock.Close()
        return db.flushAlreadyLocked()</span>
}

func (db *sqliteContainer) addObject(name string, timestamp string, size int64, contentType string, etag string, deleted int, storagePolicyIndex int, expires string) error <span class="cov8" title="1">{
        lock, err := fs.LockPath(filepath.Dir(db.containerFile), 10*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer lock.Close()
        rec := ObjectRecord{
                Name:               name,
                CreatedAt:          timestamp,
                Size:               size,
                ContentType:        contentType,
                ETag:               etag,
                Deleted:            deleted,
                StoragePolicyIndex: storagePolicyIndex,
                Expires:            &amp;expires,
        }
        if expires == "" </span><span class="cov8" title="1">{
                rec.Expires = nil
        }</span>
        <span class="cov8" title="1">file, err := os.OpenFile(db.containerFile+".pending", os.O_RDWR|os.O_APPEND|os.O_CREATE, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        marshalled, err := json.Marshal(&amp;rec)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err := file.WriteString(":" + base64.StdEncoding.EncodeToString(marshalled)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if info, err := file.Stat(); err == nil &amp;&amp; info.Size() &gt; pendingCap </span><span class="cov0" title="0">{
                db.flushAlreadyLocked()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// PutObject adds an object to the container, by way of pending file.
func (db *sqliteContainer) PutObject(name string, timestamp string, size int64, contentType string, etag string, storagePolicyIndex int, expires string) error <span class="cov8" title="1">{
        return db.addObject(name, timestamp, size, contentType, etag, 0, storagePolicyIndex, expires)
}</span>

// DeleteObject removes an object from the container, by way of pending file.
func (db *sqliteContainer) DeleteObject(name string, timestamp string, storagePolicyIndex int) error <span class="cov8" title="1">{
        return db.addObject(name, timestamp, 0, "", "", 1, storagePolicyIndex, "")
}</span>

// Close closes the underlying sqlite database connection.
func (db *sqliteContainer) Close() error <span class="cov8" title="1">{
        db.connectLock.Lock()
        defer db.connectLock.Unlock()
        return db.closeAlreadyLocked()
}</span>

func (db *sqliteContainer) closeAlreadyLocked() error <span class="cov8" title="1">{
        if db.DB != nil </span><span class="cov8" title="1">{
                err := db.DB.Close()
                db.DB = nil
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func sqliteCreateExistingContainer(db Container, putTimestamp string, newMetadata map[string][]string, policyIndex, defaultPolicyIndex int) (bool, error) <span class="cov8" title="1">{
        cdb, ok := db.(*sqliteContainer)
        if !ok </span><span class="cov0" title="0">{
                return false, errors.New("Unable to work with non-sqliteContainer")
        }</span>
        <span class="cov8" title="1">if err := cdb.connect(); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">tx, err := cdb.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        var cDeleteTimestamp, cPutTimestamp, cMetadata string
        var cPolicyIndex int
        row := tx.QueryRow("SELECT put_timestamp, delete_timestamp, storage_policy_index, metadata FROM container_info")
        if err := row.Scan(&amp;cPutTimestamp, &amp;cDeleteTimestamp, &amp;cPolicyIndex, &amp;cMetadata); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("Failed to sqliteCreateExistingContainer SELECT: %v; %v", err, common.QuarantineDir(path.Dir(cdb.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        <span class="cov8" title="1">if cDeleteTimestamp &lt;= cPutTimestamp </span><span class="cov8" title="1">{ // not deleted
                if policyIndex &lt; 0 </span><span class="cov8" title="1">{
                        policyIndex = cPolicyIndex
                }</span> else<span class="cov8" title="1"> if cPolicyIndex != policyIndex </span><span class="cov8" title="1">{
                        return false, ErrorPolicyConflict
                }</span>
        } else<span class="cov0" title="0"> { // deleted
                if policyIndex &lt; 0 </span><span class="cov0" title="0">{
                        policyIndex = defaultPolicyIndex
                }</span>
        }
        <span class="cov8" title="1">var existingMetadata map[string][]string
        if cMetadata == "" </span><span class="cov0" title="0">{
                existingMetadata = make(map[string][]string)
        }</span> else<span class="cov8" title="1"> if err := json.Unmarshal([]byte(cMetadata), &amp;existingMetadata); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">metastr, err := cdb.mergeMetas(existingMetadata, newMetadata, cDeleteTimestamp)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if _, err := tx.Exec("UPDATE container_info SET put_timestamp = ?, storage_policy_index = ?, metadata = ?",
                putTimestamp, policyIndex, metastr); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("Failed to sqliteCreateExistingContainer UPDATE: %v; %v", err, common.QuarantineDir(path.Dir(cdb.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        <span class="cov8" title="1">defer cdb.invalidateCache()
        if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("Failed to sqliteCreateExistingContainer Commit: %v; %v", err, common.QuarantineDir(path.Dir(cdb.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        <span class="cov8" title="1">return (cDeleteTimestamp &gt; cPutTimestamp &amp;&amp; putTimestamp &gt; cDeleteTimestamp), nil</span>
}

func sqliteCreateContainer(containerFile string, account string, container string, putTimestamp string,
        metadata map[string][]string, policyIndex int) error <span class="cov8" title="1">{
        var serializedMetadata []byte
        var err error

        hashDir := filepath.Dir(containerFile)
        if err := os.MkdirAll(hashDir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">lock, err := fs.LockPath(filepath.Dir(hashDir), 10*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer lock.Close()

        if fs.Exists(containerFile) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if metadata == nil </span><span class="cov8" title="1">{
                serializedMetadata = []byte("{}")
        }</span> else<span class="cov8" title="1"> if serializedMetadata, err = json.Marshal(metadata); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">tfp, err := ioutil.TempFile(hashDir, ".newdb")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := tfp.Chmod(0644); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tfp.Close()
        tempFile := tfp.Name()
        dbConn, err := sql.Open("sqlite3_hummingbird", "file:"+tempFile+"?psow=1&amp;_txlock=immediate&amp;mode=rwc")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer dbConn.Close()
        tx, err := dbConn.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        if _, err := tx.Exec(objectTableScript + policyStatTableScript + policyStatTriggerScript +
                containerInfoTableScript + containerStatViewScript + syncTableScript); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err := tx.Exec(`INSERT INTO container_info (account, container, created_at, id, put_timestamp,
                                                  status_changed_at, storage_policy_index, metadata) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
                account, container, common.GetTimestamp(), common.UUID(), putTimestamp,
                putTimestamp, policyIndex, string(serializedMetadata)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err := tx.Exec("INSERT INTO policy_stat (storage_policy_index) VALUES (?)", policyIndex); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := os.Rename(tempFile, containerFile); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func sqliteOpenContainer(containerFile string) (ReplicableContainer, error) <span class="cov8" title="1">{
        if !fs.Exists(containerFile) </span><span class="cov0" title="0">{
                return nil, ErrorNoSuchContainer
        }</span>
        <span class="cov8" title="1">db := &amp;sqliteContainer{
                containerFile:       containerFile,
                hasDeletedNameIndex: false,
                ringhash:            filepath.Base(filepath.Dir(containerFile)),
        }
        return db, nil</span>
}

func (db *sqliteContainer) Reported(putTimestamp, deleteTimestamp string, objectCount, bytesUsed int64) error <span class="cov8" title="1">{
        if err := db.connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        if _, err = tx.Exec("UPDATE container_info SET reported_put_timestamp = ?, reported_delete_timestamp = ?, reported_object_count = ?, reported_bytes_used = ?", putTimestamp, deleteTimestamp, objectCount, bytesUsed); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to Reported UPDATE: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">defer db.invalidateCache()
        if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                if common.IsCorruptDBError(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to Reported Commit: %v; %v", err, common.QuarantineDir(path.Dir(db.containerFile), 4, "containers"))
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">//  Copyright (c) 2016 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package containerserver

import (
        "context"
        "fmt"
        "io"
        "io/ioutil"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/common/tracing"
        "github.com/troubling/hummingbird/middleware"
        "go.uber.org/zap"
)

var waitForAccountUpdate = time.Second * 5

func splitHeader(header string) []string <span class="cov8" title="1">{
        if header == "" </span><span class="cov8" title="1">{
                return []string{}
        }</span>
        <span class="cov8" title="1">return strings.Split(header, ",")</span>
}

func (server *ContainerServer) accountUpdate(writer http.ResponseWriter, request *http.Request, vars map[string]string, info *ContainerInfo, logger srv.LowLevelLogger) <span class="cov8" title="1">{
        done := make(chan struct{}, 1)
        go func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{ done &lt;- struct{}{} }</span>()
                <span class="cov8" title="1">defer middleware.Recover(writer, request, "PANIC WHILE UPDATING ACCOUNT")
                accpartition := request.Header.Get("X-Account-Partition")
                if accpartition == "" </span><span class="cov8" title="1">{
                        logger.Error("Account update failed: bad partition")
                        return
                }</span>
                <span class="cov8" title="1">hosts := splitHeader(request.Header.Get("X-Account-Host"))
                devices := splitHeader(request.Header.Get("X-Account-Device"))

                if len(hosts) != len(devices) </span><span class="cov8" title="1">{
                        logger.Error("Account update failed: different numbers of hosts and devices in request")
                        return
                }</span>
                <span class="cov8" title="1">schemes := splitHeader(request.Header.Get("X-Account-Scheme"))
                for len(schemes) &lt; len(hosts) </span><span class="cov8" title="1">{
                        schemes = append(schemes, "http")
                }</span>
                <span class="cov8" title="1">ctx := tracing.CopySpanFromContext(request.Context())
                for index, host := range hosts </span><span class="cov8" title="1">{
                        if err := accountUpdateHelper(ctx, info, schemes[index], host, devices[index], accpartition, vars["account"], vars["container"], request.Header.Get("X-Trans-Id"), request.Header.Get("X-Account-Override-Deleted") == "yes", server.updateClient); err != nil </span><span class="cov0" title="0">{
                                logger.Error(
                                        "Account update failed:", zap.Error(err),
                                        zap.String("schemes[index]", schemes[index]),
                                        zap.String("hosts[index]", hosts[index]),
                                        zap.String("devices[index]", devices[index]),
                                )
                        }</span>
                }
        }()
        <span class="cov8" title="1">select </span>{
        case &lt;-time.After(waitForAccountUpdate):</span><span class="cov8" title="1">
        case &lt;-done:</span><span class="cov8" title="1">
        }
}

func accountUpdateHelper(ctx context.Context, info *ContainerInfo, scheme, host, device, accpartition, account, container, transID string, accountOverrideDeleted bool, updateClient common.HTTPClient) error <span class="cov8" title="1">{
        url := fmt.Sprintf("%s://%s/%s/%s/%s/%s", scheme, host, device, accpartition,
                common.Urlencode(account), common.Urlencode(container))
        req, err := http.NewRequest("PUT", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">req = req.WithContext(ctx)
        req.Header.Add("X-Backend-Suppress-2xx-Logging", "t")
        req.Header.Add("X-Put-Timestamp", info.PutTimestamp)
        req.Header.Add("X-Delete-Timestamp", info.DeleteTimestamp)
        req.Header.Add("X-Object-Count", strconv.FormatInt(info.ObjectCount, 10))
        req.Header.Add("X-Bytes-Used", strconv.FormatInt(info.BytesUsed, 10))
        req.Header.Add("X-Trans-Id", transID)
        req.Header.Add("X-Backend-Storage-Policy-Index", strconv.Itoa(info.StoragePolicyIndex))
        if accountOverrideDeleted </span><span class="cov0" title="0">{
                req.Header.Add("X-Account-Override-Deleted", "yes")
        }</span>
        <span class="cov8" title="1">resp, err := updateClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">io.Copy(ioutil.Discard, resp.Body)
        resp.Body.Close()
        if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("%d response status code", resp.StatusCode)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package functional

import (
        "fmt"
        "io/ioutil"
        "math/rand"
        "net/http"
        "os"
        "strconv"
        "sync"
        "testing"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/nectar"
)

var run = common.LooksTrue(os.Getenv("HUMMINGBIRD_FUNCTIONAL_TESTS"))

var defaultClient nectar.Client
var defaultClientOnce sync.Once

func getDefaultClient(t *testing.T) nectar.Client <span class="cov0" title="0">{
        defaultClientOnce.Do(func() </span><span class="cov0" title="0">{
                internal, _ := strconv.ParseBool(os.Getenv("STORAGE_INTERNAL"))
                defaultClient = getClient(t, os.Getenv("AUTH_TENANT"), os.Getenv("AUTH_USER"), os.Getenv("AUTH_PASSWORD"), os.Getenv("AUTH_KEY"), os.Getenv("STORAGE_REGION"), os.Getenv("AUTH_URL"), internal)
        }</span>)
        <span class="cov0" title="0">return defaultClient</span>
}

func getClient(t *testing.T, tenant, user, password, key, region, authURL string, internal bool) nectar.Client <span class="cov0" title="0">{
        t.Log("CREATING CLIENT!")
        c, resp := nectar.NewClient(tenant, user, password, key, region, authURL, internal)
        if resp != nil </span><span class="cov0" title="0">{
                bodyBytes, _ := ioutil.ReadAll(resp.Body)
                resp.Body.Close()
                t.Fatalf("Auth responded with %d %s - %s\n", resp.StatusCode, http.StatusText(resp.StatusCode), string(bodyBytes))
        }</span>
        <span class="cov0" title="0">return c</span>
}

var rander = rand.New(rand.NewSource(time.Now().UnixNano()))
var randerLock sync.Mutex

func getRandomContainerName() string <span class="cov0" title="0">{
        randerLock.Lock()
        defer randerLock.Unlock()
        return fmt.Sprintf("hummingbird-functional-test-%016x", rander.Uint64())
}</span>

func emptyAndDeleteContainer(c nectar.Client, container string) *http.Response <span class="cov0" title="0">{
        if resp := c.DeleteContainer(container, nil); resp.StatusCode != http.StatusConflict </span><span class="cov0" title="0">{
                return resp
        }</span>
        <span class="cov0" title="0">listing, resp := c.GetContainer(container, "", "", 0, "", "", false, nil)
        if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                return resp
        }</span>
        <span class="cov0" title="0">for _, item := range listing </span><span class="cov0" title="0">{
                // Don't care about errors; we're just attempting to empty the container.
                c.DeleteObject(container, item.Name, nil)
        }</span>
        <span class="cov0" title="0">return c.DeleteContainer(container, nil)</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "net/http"
        "runtime/debug"

        "github.com/troubling/hummingbird/common/srv"
)

func NewDebugResponses(debugHeader bool) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                if debugHeader </span><span class="cov0" title="0">{
                        return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                                next.ServeHTTP(srv.NewCustomWriter(writer, func(w http.ResponseWriter, status int) int </span><span class="cov0" title="0">{
                                        if status/100 != 2 </span><span class="cov0" title="0">{
                                                buf := debug.Stack()
                                                w.Header().Set("X-Source-Code", string(buf))
                                        }</span>
                                        <span class="cov0" title="0">return status</span>
                                }), request)
                        })
                }
                <span class="cov8" title="1">return next</span>
        }
}
</pre>
		
		<pre class="file" id="file50" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "bufio"
        "compress/bzip2"
        "compress/gzip"
        "io"
        "net/http"
        "regexp"
)

type grepWriter struct {
        w      io.Writer
        h      http.Header
        status int
}

func (g *grepWriter) Header() http.Header <span class="cov8" title="1">{
        return g.h
}</span>

func (g *grepWriter) Write(buf []byte) (int, error) <span class="cov8" title="1">{
        return g.w.Write(buf)
}</span>

func (g *grepWriter) WriteHeader(status int) <span class="cov8" title="1">{
        g.status = status
}</span>

// GrepObject is an http middleware that searches objects line-by-line on the object server, similar to grep(1).
func GrepObject(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                if request.Method != "GREP" </span><span class="cov8" title="1">{
                        next.ServeHTTP(writer, request)
                        return
                }</span>
                <span class="cov8" title="1">pr, pw := io.Pipe()
                defer pr.Close()
                defer pw.Close()
                newWriter := &amp;grepWriter{w: pw, h: make(http.Header), status: 200}
                newRequest, _ := http.NewRequest("GET", request.URL.String(), nil)
                newRequest.Header = request.Header
                go func() </span><span class="cov8" title="1">{
                        defer pw.Close()
                        next.ServeHTTP(newWriter, newRequest)
                }</span>()
                <span class="cov8" title="1">q := request.URL.Query().Get("e")
                if q == "" </span><span class="cov8" title="1">{
                        writer.WriteHeader(400)
                        return
                }</span>
                <span class="cov8" title="1">re, err := regexp.Compile(q)
                if err != nil </span><span class="cov8" title="1">{
                        writer.WriteHeader(400)
                        return
                }</span>
                // peek at response data first to make sure the downstream handler has set a status code
                <span class="cov8" title="1">br := bufio.NewReader(pr)
                magic, err := br.Peek(4)
                if newWriter.status == 200 </span><span class="cov8" title="1">{
                        var scanner *bufio.Scanner
                        if err == nil &amp;&amp; magic[0] == 0x1f &amp;&amp; magic[1] == 0x8b </span><span class="cov8" title="1">{
                                if gzr, err := gzip.NewReader(br); err != nil </span><span class="cov8" title="1">{
                                        writer.WriteHeader(500)
                                        return
                                }</span> else<span class="cov8" title="1"> {
                                        scanner = bufio.NewScanner(gzr)
                                }</span>
                        } else<span class="cov8" title="1"> if err == nil &amp;&amp; magic[0] == 'B' &amp;&amp; magic[1] == 'Z' &amp;&amp; magic[2] == 'h' &amp;&amp; magic[3] &gt;= '1' &amp;&amp; magic[3] &lt;= '9' </span><span class="cov8" title="1">{
                                scanner = bufio.NewScanner(bzip2.NewReader(br))
                        }</span> else<span class="cov8" title="1"> {
                                scanner = bufio.NewScanner(br)
                        }</span>
                        <span class="cov8" title="1">writer.WriteHeader(200)
                        for scanner.Scan() </span><span class="cov8" title="1">{
                                if line := scanner.Bytes(); re.Match(line) </span><span class="cov8" title="1">{
                                        writer.Write(line)
                                        writer.Write([]byte{'\n'})
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        writer.WriteHeader(newWriter.status)
                        io.Copy(writer, br)
                }</span>
        })
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package middleware

import (
        "bufio"
        "fmt"
        "net"
        "net/http"

        "github.com/uber-go/tally"
)

type recordStatusWriter struct {
        http.ResponseWriter
        status int
}

func (mw *recordStatusWriter) WriteHeader(status int) <span class="cov8" title="1">{
        mw.status = status
        mw.ResponseWriter.WriteHeader(status)
}</span>

func (mw *recordStatusWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) <span class="cov8" title="1">{
        return mw.ResponseWriter.(http.Hijacker).Hijack()
}</span>

func Metrics(metricsScope tally.Scope) func(http.Handler) http.Handler <span class="cov8" title="1">{
        requestsMetric := metricsScope.Counter("requests")
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                        w := &amp;recordStatusWriter{ResponseWriter: writer}
                        next.ServeHTTP(w, request)
                        requestsMetric.Inc(1)
                        metricsScope.Counter(request.Method + "_requests").Inc(1)
                        metricsScope.Counter(fmt.Sprintf("%d_responses", w.status)).Inc(1)
                }</span>)
        }
}
</pre>
		
		<pre class="file" id="file52" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "fmt"
        "net/http"

        "github.com/troubling/hummingbird/common"
)

func OptionsHandler(serverType string, writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        server := fmt.Sprintf("%s/%s", serverType, common.Version)
        //We could use introspection in future to figure out the Allow Header.
        writer.Header().Set("Allow", "HEAD,GET,PUT,POST,DELETE,OPTIONS")
        writer.Header().Set("Server", server)
        writer.WriteHeader(http.StatusOK)
        return
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "bufio"
        "database/sql"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "os"
        "path"
        "path/filepath"
        "strconv"
        "strings"
        "syscall"
        "time"

        _ "github.com/mattn/go-sqlite3"
        "github.com/shirou/gopsutil/disk"
        "github.com/shirou/gopsutil/load"
        "github.com/shirou/gopsutil/mem"
        "github.com/shirou/gopsutil/process"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/srv"
)

func DumpReconCache(reconCachePath string, source string, cacheData map[string]interface{}) error <span class="cov8" title="1">{
        reconFile := filepath.Join(reconCachePath, source+".recon")

        if lock, err := fs.LockPath(filepath.Dir(reconFile), 5*time.Second); err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov8" title="1"> {
                defer lock.Close()
        }</span>

        <span class="cov8" title="1">filedata, _ := ioutil.ReadFile(reconFile)
        var reconData = make(map[string]interface{})
        if filedata != nil &amp;&amp; len(filedata) &gt; 0 </span><span class="cov8" title="1">{
                var data interface{}
                if json.Unmarshal(filedata, &amp;data) == nil </span><span class="cov8" title="1">{
                        if _, ok := data.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                reconData = data.(map[string]interface{})
                        }</span>
                }
        }
        <span class="cov8" title="1">for key, item := range cacheData </span><span class="cov8" title="1">{
                switch item := item.(type) </span>{
                case map[string]interface{}:<span class="cov8" title="1">
                        if len(item) == 0 </span><span class="cov8" title="1">{
                                delete(reconData, key)
                                continue</span>
                        }
                        <span class="cov8" title="1">if _, ok := reconData[key].(map[string]interface{}); !ok </span><span class="cov8" title="1">{
                                reconData[key] = make(map[string]interface{})
                        }</span>
                        <span class="cov8" title="1">for itemk, itemv := range item </span><span class="cov8" title="1">{
                                if itemvmap, ok := itemv.(map[string]interface{}); ok &amp;&amp; len(itemvmap) == 0 </span><span class="cov8" title="1">{
                                        delete(reconData[key].(map[string]interface{}), itemk)
                                }</span> else<span class="cov8" title="1"> if itemv == nil </span><span class="cov8" title="1">{
                                        delete(reconData[key].(map[string]interface{}), itemk)
                                }</span> else<span class="cov8" title="1"> {
                                        reconData[key].(map[string]interface{})[itemk] = itemv
                                }</span>
                        }
                case nil:<span class="cov8" title="1">
                        delete(reconData, key)</span>
                default:<span class="cov8" title="1">
                        reconData[key] = item</span>
                }
        }
        <span class="cov8" title="1">newdata, err := json.Marshal(reconData)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">f, err := fs.NewAtomicFileWriter(reconCachePath, reconCachePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer f.Abandon()
        f.Write(newdata)
        return f.Save(reconFile)</span>
}

// getMem dumps the contents of /proc/meminfo if it's available, otherwise it pulls what it can from gopsutil/mem
func getMem() interface{} <span class="cov8" title="1">{
        if fp, err := os.Open("/proc/meminfo"); err == nil </span><span class="cov8" title="1">{
                defer fp.Close()
                results := make(map[string]string)
                scanner := bufio.NewScanner(fp)
                for scanner.Scan() </span><span class="cov8" title="1">{
                        vals := strings.Split(scanner.Text(), ":")
                        results[strings.TrimSpace(vals[0])] = strings.TrimSpace(vals[1])
                }</span>
                <span class="cov8" title="1">return results</span>
        } else<span class="cov0" title="0"> {
                vmem, err := mem.VirtualMemory()
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">swap, err := mem.SwapMemory()
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return map[string]string{
                        "MemTotal":  strconv.FormatUint(vmem.Total, 10),
                        "MemFree":   strconv.FormatUint(vmem.Available, 10),
                        "Buffers":   strconv.FormatUint(vmem.Buffers, 10),
                        "Cached":    strconv.FormatUint(vmem.Cached, 10),
                        "SwapTotal": strconv.FormatUint(swap.Total, 10),
                        "SwapFree":  strconv.FormatUint(swap.Free, 10),
                }</span>
        }
}

func getSockstats() interface{} <span class="cov0" title="0">{
        results := make(map[string]int64)

        fp, err := os.Open("/proc/net/sockstat")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">defer fp.Close()
        scanner := bufio.NewScanner(fp)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                if strings.HasPrefix(line, "TCP: inuse") </span><span class="cov0" title="0">{
                        parts := strings.Split(line, " ")
                        results["tcp_in_use"], _ = strconv.ParseInt(parts[2], 10, 64)
                        results["orphan"], _ = strconv.ParseInt(parts[4], 10, 64)
                        results["time_wait"], _ = strconv.ParseInt(parts[6], 10, 64)
                        results["tcp_mem_allocated_bytes"], _ = strconv.ParseInt(parts[10], 10, 64)
                        results["tcp_mem_allocated_bytes"] *= int64(os.Getpagesize())
                }</span>
        }

        <span class="cov0" title="0">fp, err = os.Open("/proc/net/sockstat6")
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">defer fp.Close()
        scanner = bufio.NewScanner(fp)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                if strings.HasPrefix(line, "TCP6: inuse") </span><span class="cov0" title="0">{
                        parts := strings.Split(line, " ")
                        results["tcp6_in_use"], _ = strconv.ParseInt(parts[2], 10, 64)
                }</span>
        }

        <span class="cov0" title="0">return results</span>
}

func getLoad() interface{} <span class="cov8" title="1">{
        results := make(map[string]interface{})
        avg, err := load.Avg()
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">misc, err := load.Misc()
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">pids, err := process.Pids()
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">results["1m"] = avg.Load1
        results["5m"] = avg.Load5
        results["15m"] = avg.Load15
        results["tasks"] = fmt.Sprintf("%d/%d", misc.ProcsRunning, len(pids))
        // swift's recon puts the pid of the last created process in this field, which seems kind of useless.
        // I'm making it the number of processes, which seems like what it was meant to be.
        results["processes"] = len(pids)
        // also adding these two fields, since they might be useful.
        results["running"] = misc.ProcsRunning
        results["blocked"] = misc.ProcsBlocked
        return results</span>
}

func getMounts() interface{} <span class="cov8" title="1">{
        results := make([]map[string]string, 0)
        partitions, err := disk.Partitions(true)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">for _, part := range partitions </span><span class="cov8" title="1">{
                results = append(results, map[string]string{"device": part.Device, "path": part.Mountpoint})
        }</span>
        <span class="cov8" title="1">return results</span>
}

func fromReconCache(reconCachePath string, source string, keys ...string) (interface{}, error) <span class="cov0" title="0">{
        results := make(map[string]interface{})
        for _, key := range keys </span><span class="cov0" title="0">{
                results[key] = nil
        }</span>
        <span class="cov0" title="0">filedata, err := ioutil.ReadFile(filepath.Join(reconCachePath, fmt.Sprintf("%s.recon", source)))
        if err != nil </span><span class="cov0" title="0">{
                results["recon_error"] = fmt.Sprintf("Error: %s", err)
                return results, nil
        }</span>
        <span class="cov0" title="0">var data interface{}
        json.Unmarshal(filedata, &amp;data)
        switch data := data.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                for _, key := range keys </span><span class="cov0" title="0">{
                        results[key] = data[key]
                }</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("Unexpected data type %T in recon file.", data)</span>
        }
        <span class="cov0" title="0">return results, nil</span>
}

func getUnmounted(driveRoot string, mountCheck bool) (interface{}, error) <span class="cov0" title="0">{
        unmounted := make([]map[string]interface{}, 0)
        dirInfo, err := os.Stat(driveRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">fileInfo, _ := ioutil.ReadDir(driveRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, info := range fileInfo </span><span class="cov0" title="0">{
                m := true
                if mountCheck </span><span class="cov0" title="0">{
                        m = info.Sys().(*syscall.Stat_t).Dev != dirInfo.Sys().(*syscall.Stat_t).Dev
                }</span>
                <span class="cov0" title="0">if m </span><span class="cov0" title="0">{
                        if _, err = os.Stat(filepath.Join(driveRoot, info.Name(), "unmount")); err == nil </span><span class="cov0" title="0">{
                                m = false
                        }</span> else<span class="cov0" title="0"> if _, err = os.Stat(filepath.Join(driveRoot, info.Name(), "unmounted")); err == nil </span><span class="cov0" title="0">{
                                m = false
                        }</span>
                }
                <span class="cov0" title="0">unmounted = append(unmounted, map[string]interface{}{"device": info.Name(), "mounted": m})</span>
        }
        <span class="cov0" title="0">return unmounted, nil</span>
}

func getTotalAsyncs(driveRoot, reconCachePath string) (interface{}, error) <span class="cov0" title="0">{
        asyncs := map[string]int64{}
        _, err := os.Stat(driveRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">fileInfo, _ := ioutil.ReadDir(driveRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">total := int64(0)
        for _, info := range fileInfo </span><span class="cov0" title="0">{
                rKey := fmt.Sprintf("async_pending_%s", info.Name())
                content, err := fromReconCache(reconCachePath, "object", rKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">amap, ok := content.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid recon map data: %v", content)
                }</span>
                <span class="cov0" title="0">cnt, ok := amap[rKey].(float64)
                if !ok </span><span class="cov0" title="0">{
                        cnt = 0
                }</span>
                <span class="cov0" title="0">asyncs[rKey] = int64(cnt)
                total += int64(cnt)</span>
        }
        <span class="cov0" title="0">asyncs["async_pending"] = total
        return asyncs, nil</span>
}

func ListDevices(driveRoot string) (map[string][]string, error) <span class="cov0" title="0">{
        fileInfo, err := ioutil.ReadDir(driveRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">fileList := make([]string, 0)
        for _, info := range fileInfo </span><span class="cov0" title="0">{
                fileList = append(fileList, info.Name())
        }</span>
        <span class="cov0" title="0">return map[string][]string{driveRoot: fileList}, nil</span>
}

func quarantineCounts(driveRoot string) (map[string]interface{}, error) <span class="cov0" title="0">{
        qcounts := map[string]interface{}{"objects": 0, "containers": 0, "accounts": 0, "policies": map[string]map[string]uint64{}}
        deviceList, err := ioutil.ReadDir(driveRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, info := range deviceList </span><span class="cov0" title="0">{
                qTypeList, err := ioutil.ReadDir(filepath.Join(driveRoot, info.Name(), "quarantined"))
                if err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                return qcounts, nil
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov0" title="0">policyDict := map[string]map[string]uint64{}
                oCnt := uint64(0)
                for _, qType := range qTypeList </span><span class="cov0" title="0">{
                        key := qType.Name()
                        if strings.HasPrefix(key, "objects") </span><span class="cov0" title="0">{
                                if stat, err := os.Stat(filepath.Join(driveRoot, info.Name(), "quarantined", key)); err == nil </span><span class="cov0" title="0">{
                                        pIndex := "0"
                                        if qarr := strings.SplitN(key, "-", 2); len(qarr) &gt; 1 </span><span class="cov0" title="0">{
                                                pIndex = qarr[1]
                                        }</span>
                                        <span class="cov0" title="0">if _, err := strconv.ParseInt(pIndex, 10, 64); err == nil </span><span class="cov0" title="0">{
                                                cnt := stat.Sys().(*syscall.Stat_t).Nlink - 2
                                                policyDict[pIndex] = map[string]uint64{
                                                        "objects": cnt}
                                                oCnt += cnt

                                        }</span> else<span class="cov0" title="0"> {
                                                return nil, err
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        return nil, err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                if _, ok := qcounts[key]; ok </span><span class="cov0" title="0">{
                                        if stat, err := os.Stat(filepath.Join(driveRoot, info.Name(), "quarantined", key)); err == nil </span><span class="cov0" title="0">{
                                                qcounts[key] = stat.Sys().(*syscall.Stat_t).Nlink - 2
                                        }</span> else<span class="cov0" title="0"> {
                                                return nil, err
                                        }</span>
                                }

                        }
                }
                <span class="cov0" title="0">if len(policyDict) &gt; 0 </span><span class="cov0" title="0">{
                        qcounts["policies"] = policyDict
                }</span>
                <span class="cov0" title="0">qcounts["objects"] = oCnt</span>
        }
        <span class="cov0" title="0">return qcounts, nil</span>
}

func quarantineDelete(driveRoot, deviceName, reconType, itemPath string) (map[string]interface{}, error) <span class="cov8" title="1">{
        cleanedDeviceName := path.Clean(deviceName)
        // don't allow full paths, empty paths ".", nor up paths ".."
        if cleanedDeviceName[0] == '/' || cleanedDeviceName[0] == '.' </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid device name given: %q", deviceName)
        }</span>
        <span class="cov8" title="1">deviceName = cleanedDeviceName
        if reconType != "accounts" &amp;&amp; reconType != "containers" &amp;&amp; reconType != "objects" &amp;&amp; !strings.HasPrefix(reconType, "objects-") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid recon type: %q", reconType)
        }</span>
        <span class="cov8" title="1">cleanedItemPath := path.Clean(itemPath)
        // don't allow full paths, empty paths ".", nor up paths ".."
        if cleanedItemPath[0] == '/' || cleanedItemPath[0] == '.' </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid item path given: %q", itemPath)
        }</span>
        <span class="cov8" title="1">fromPath := path.Join(driveRoot, deviceName, "quarantined", reconType, cleanedItemPath)
        toDir := path.Join(driveRoot, deviceName, "quarantined-history", reconType)
        toPath := path.Join(toDir, cleanedItemPath)
        if err := os.MkdirAll(toDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := os.Rename(fromPath, toPath); err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">if err := os.Chtimes(toPath, time.Now(), time.Now()); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

func quarantineHistoryDelete(driveRoot, deviceName, reconType, trailingPath string) (map[string]interface{}, error) <span class="cov8" title="1">{
        cleanedDeviceName := path.Clean(deviceName)
        // don't allow full paths, empty paths ".", nor up paths ".."
        if cleanedDeviceName[0] == '/' || cleanedDeviceName[0] == '.' </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid device name given: %q", deviceName)
        }</span>
        <span class="cov8" title="1">deviceName = cleanedDeviceName
        if reconType != "accounts" &amp;&amp; reconType != "containers" &amp;&amp; reconType != "objects" &amp;&amp; !strings.HasPrefix(reconType, "objects-") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid recon type: %q", reconType)
        }</span>
        <span class="cov8" title="1">days, err := strconv.Atoi(trailingPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not parse days value: %q", trailingPath)
        }</span>
        <span class="cov8" title="1">historyPath := path.Join(driveRoot, deviceName, "quarantined-history", reconType)
        items, err := ioutil.ReadDir(historyPath)
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">checkTime := time.Now().Add(-time.Hour * time.Duration(24*days))
        itemsPurged := 0
        itemsLeft := 0
        for _, item := range items </span><span class="cov8" title="1">{
                if item.ModTime().Before(checkTime) </span><span class="cov8" title="1">{
                        os.RemoveAll(path.Join(historyPath, item.Name())) // ignoring any error
                        itemsPurged++
                }</span> else<span class="cov8" title="1"> {
                        itemsLeft++
                }</span>
        }
        <span class="cov8" title="1">return map[string]interface{}{
                "message":      "history deletion complete",
                "days":         days,
                "items_purged": itemsPurged,
                "items_left":   itemsLeft,
        }, nil</span>
}

type QuarantineDetailEntry struct {
        NameOnDevice string
        NameInURL    string
}

func handleIdbMeta(metaPath string, entry *QuarantineDetailEntry) bool <span class="cov8" title="1">{
        file, err := os.Open(metaPath)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov0" title="0">defer file.Close()
        data := make([]byte, 4096)
        count, err := file.Read(data)
        if err == nil &amp;&amp; count &lt; 4096 </span><span class="cov0" title="0">{
                metadata := map[string]string{}
                if err = json.Unmarshal(data[:count], &amp;metadata); err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">name, ok := metadata["name"]
                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">entry.NameInURL = name
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

func quarantineDetail(driveRoot string) (interface{}, error) <span class="cov8" title="1">{
        // Map of type to device to entries; type is accounts, containers, objects,
        // objects-1, etc.
        typeToDeviceToEntries := map[string]map[string][]*QuarantineDetailEntry{}
        deviceList, err := ioutil.ReadDir(driveRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for _, device := range deviceList </span><span class="cov8" title="1">{
                qTypeList, err := ioutil.ReadDir(filepath.Join(driveRoot, device.Name(), "quarantined"))
                if err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                return typeToDeviceToEntries, nil
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov8" title="1">for _, qType := range qTypeList </span><span class="cov8" title="1">{
                        key := qType.Name()
                        if key == "accounts" || key == "containers" || strings.HasPrefix(key, "objects") </span><span class="cov8" title="1">{
                                listing, err := ioutil.ReadDir(filepath.Join(driveRoot, device.Name(), "quarantined", key))
                                if err != nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">for count, listingItem := range listing </span><span class="cov8" title="1">{
                                        if count &gt; 100 </span><span class="cov0" title="0">{
                                                // We only show detail for the first 100. As they get
                                                // repaired, the remaining items will be shown.
                                                break</span>
                                        }
                                        <span class="cov8" title="1">ent := &amp;QuarantineDetailEntry{NameOnDevice: listingItem.Name()}
                                        if typeToDeviceToEntries[key] == nil </span><span class="cov8" title="1">{
                                                typeToDeviceToEntries[key] = map[string][]*QuarantineDetailEntry{}
                                        }</span>
                                        <span class="cov8" title="1">typeToDeviceToEntries[key][device.Name()] = append(typeToDeviceToEntries[key][device.Name()], ent)
                                        if key == "accounts" || key == "containers" </span><span class="cov8" title="1">{
                                                parts := strings.SplitN(listingItem.Name(), "-", 2)
                                                if len(parts) != 2 </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                                <span class="cov8" title="1">db, err := sql.Open("sqlite3", filepath.Join(driveRoot, device.Name(), "quarantined", key, listingItem.Name(), parts[0]+".db"))
                                                if err != nil </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                                <span class="cov8" title="1">var a, c string
                                                if key == "accounts" </span><span class="cov8" title="1">{
                                                        if db.QueryRow("select account from account_stat").Scan(&amp;a) == nil </span><span class="cov8" title="1">{
                                                                ent.NameInURL = "/" + a
                                                        }</span>
                                                } else<span class="cov8" title="1"> {
                                                        if db.QueryRow("select account, container from container_info").Scan(&amp;a, &amp;c) == nil </span><span class="cov8" title="1">{
                                                                ent.NameInURL = "/" + path.Join(a, c)
                                                        }</span>
                                                }
                                                <span class="cov8" title="1">db.Close()</span>
                                        } else<span class="cov8" title="1"> { // strings.HasPrefix(key, "objects")
                                                // Check EC first (really index db items)
                                                idbMeta := filepath.Join(driveRoot, device.Name(), "quarantined", key, listingItem.Name(), listingItem.Name()+".idbmeta")
                                                if handleIdbMeta(idbMeta, ent) </span><span class="cov0" title="0">{
                                                        break</span>
                                                }
                                                <span class="cov8" title="1">listing2, err := ioutil.ReadDir(filepath.Join(driveRoot, device.Name(), "quarantined", key, listingItem.Name()))
                                                if err != nil </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                                <span class="cov8" title="1">for _, listing2Item := range listing2 </span><span class="cov8" title="1">{
                                                        metadata, err := common.SwiftObjectReadMetadata(filepath.Join(driveRoot, device.Name(), "quarantined", key, listingItem.Name(), listing2Item.Name()))
                                                        if err != nil </span><span class="cov8" title="1">{
                                                                continue</span>
                                                        }
                                                        <span class="cov0" title="0">ent.NameInURL = metadata["name"]
                                                        if ent.NameInURL != "" </span><span class="cov0" title="0">{
                                                                break</span>
                                                        }
                                                }
                                        }
                                }
                        }
                }
        }
        <span class="cov8" title="1">return typeToDeviceToEntries, nil</span>
}

func diskUsage(driveRoot string, mountCheck bool) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        devices := make([]map[string]interface{}, 0)
        dirInfo, err := os.Stat(driveRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">fileInfo, _ := ioutil.ReadDir(driveRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, info := range fileInfo </span><span class="cov0" title="0">{
                mounted := true
                if mountCheck </span><span class="cov0" title="0">{
                        mounted = info.Sys().(*syscall.Stat_t).Dev != dirInfo.Sys().(*syscall.Stat_t).Dev
                }</span>
                <span class="cov0" title="0">if mounted </span><span class="cov0" title="0">{
                        if _, err = os.Stat(filepath.Join(driveRoot, info.Name(), "unmount")); err == nil </span><span class="cov0" title="0">{
                                mounted = false
                        }</span> else<span class="cov0" title="0"> if _, err = os.Stat(filepath.Join(driveRoot, info.Name(), "unmounted")); err == nil </span><span class="cov0" title="0">{
                                mounted = false
                        }</span>
                }
                <span class="cov0" title="0">var capacity, used, available int64
                if mounted </span><span class="cov0" title="0">{
                        var fsinfo syscall.Statfs_t
                        err := syscall.Statfs(filepath.Join(driveRoot, info.Name()), &amp;fsinfo)
                        if err == nil </span><span class="cov0" title="0">{
                                capacity = int64(fsinfo.Bsize) * int64(fsinfo.Blocks)
                                used = int64(fsinfo.Bsize) * (int64(fsinfo.Blocks) - int64(fsinfo.Bavail))
                                available = int64(fsinfo.Bsize) * int64(fsinfo.Bavail)
                        }</span>
                }
                <span class="cov0" title="0">devices = append(devices, map[string]interface{}{
                        "device":  info.Name(),
                        "mounted": mounted,
                        "size":    capacity,
                        "used":    used,
                        "avail":   available,
                })</span>
        }
        <span class="cov0" title="0">return devices, nil</span>
}

func ReconHandler(driveRoot string, reconCachePath string, mountCheck bool, writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        var content interface{} = nil

        vars := srv.GetVars(request)
        var err error

        switch vars["method"] </span>{
        case "mem":<span class="cov8" title="1">
                content = getMem()</span>
        case "load":<span class="cov8" title="1">
                content = getLoad()</span>
        case "async":<span class="cov0" title="0">
                content, err = getTotalAsyncs(driveRoot, reconCachePath)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        return
                }</span>
        case "replication":<span class="cov0" title="0">
                if vars["recon_type"] == "account" </span><span class="cov0" title="0">{
                        content, err = fromReconCache(reconCachePath, "account", "replication_time", "replication_stats", "replication_last")
                }</span> else<span class="cov0" title="0"> if vars["recon_type"] == "container" </span><span class="cov0" title="0">{
                        content, err = fromReconCache(reconCachePath, "container", "replication_time", "replication_stats", "replication_last")
                }</span> else<span class="cov0" title="0"> if vars["recon_type"] == "object" </span><span class="cov0" title="0">{
                        content, err = fromReconCache(reconCachePath, "object", "object_replication_time", "object_replication_last")
                }</span> else<span class="cov0" title="0"> if vars["recon_type"] == "" </span><span class="cov0" title="0">{
                        // handle old style object replication requests
                        content, err = fromReconCache(reconCachePath, "object", "object_replication_time", "object_replication_last")
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        return
                }</span>
        case "devices":<span class="cov0" title="0">
                content, err = ListDevices(driveRoot)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        return
                }</span>
        case "updater":<span class="cov0" title="0">
                if vars["recon_type"] == "container" </span><span class="cov0" title="0">{
                        content, err = fromReconCache(reconCachePath, "container", "container_updater_sweep")
                }</span> else<span class="cov0" title="0"> if vars["recon_type"] == "object" </span><span class="cov0" title="0">{
                        content, err = fromReconCache(reconCachePath, "object", "object_updater_sweep")
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        return
                }</span>
        case "auditor":<span class="cov0" title="0">
                if vars["recon_type"] == "account" </span><span class="cov0" title="0">{
                        content, err = fromReconCache(reconCachePath, "account", "account_audits_passed", "account_auditor_pass_completed", "account_audits_since", "account_audits_failed")
                }</span> else<span class="cov0" title="0"> if vars["recon_type"] == "container" </span><span class="cov0" title="0">{
                        content, err = fromReconCache(reconCachePath, "container", "container_audits_passed", "container_auditor_pass_completed", "container_audits_since", "container_audits_failed")
                }</span> else<span class="cov0" title="0"> if vars["recon_type"] == "object" </span><span class="cov0" title="0">{
                        content, err = fromReconCache(reconCachePath, "object", "object_auditor_stats_ALL", "object_auditor_stats_ZBF")
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        return
                }</span>
        case "expirer":<span class="cov0" title="0">
                content, err = fromReconCache(reconCachePath, "object", "object_expiration_pass", "expired_last_pass")
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        return
                }</span>
        case "mounted":<span class="cov0" title="0">
                content = getMounts()</span>
        case "unmounted":<span class="cov0" title="0">
                content, err = getUnmounted(driveRoot, mountCheck)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        return
                }</span>
        case "ringmd5":<span class="cov0" title="0">
                if content, err = common.GetAllRingFileMd5s(); err != nil </span><span class="cov0" title="0">{
                        http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        return
                }</span>
        case "swiftconfmd5":<span class="cov0" title="0">
                content, err = common.FileMD5("/etc/hummingbird/hummingbird.conf")
                if err != nil </span><span class="cov0" title="0">{
                        content, err = common.FileMD5("/etc/swift/swift.conf")
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                                return
                        }</span>
                }
        case "hummingbirdconfmd5":<span class="cov0" title="0">
                content, err = common.FileMD5("/etc/hummingbird/hummingbird.conf")
                if err != nil </span><span class="cov0" title="0">{
                        content, err = common.FileMD5("/etc/swift/swift.conf")
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                                return
                        }</span>
                }
        case "hummingbirdmd5":<span class="cov0" title="0">
                if exe, err := os.Executable(); err == nil </span><span class="cov0" title="0">{
                        content, err = common.FileMD5(exe)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        return
                }</span>
        case "quarantined":<span class="cov0" title="0">
                if request.Method == "DELETE" </span><span class="cov0" title="0">{
                        content, err = quarantineDelete(driveRoot, vars["device"], vars["recon_type"], vars["item_path"])
                }</span> else<span class="cov0" title="0"> {
                        content, err = quarantineCounts(driveRoot)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        return
                }</span>
        case "quarantineddetail":<span class="cov0" title="0">
                content, err = quarantineDetail(driveRoot)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        return
                }</span>
        case "quarantinedhistory":<span class="cov0" title="0">
                if request.Method == "DELETE" </span><span class="cov0" title="0">{
                        content, err = quarantineHistoryDelete(driveRoot, vars["device"], vars["recon_type"], vars["item_path"])
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        return
                }</span>
        case "sockstat":<span class="cov0" title="0">
                content = getSockstats()</span>
        case "version":<span class="cov0" title="0">
                content = map[string]string{"version": "idunno"}</span>
        case "diskusage":<span class="cov0" title="0">
                content, err = diskUsage(driveRoot, mountCheck)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        return
                }</span>
        case "time":<span class="cov0" title="0">
                //Similar to python time.time()
                content = float64(time.Now().UnixNano()) / float64(time.Second)</span>
        case "hummingbirdtime":<span class="cov0" title="0">
                content = map[string]time.Time{"time": time.Now()}</span>
        case "driveaudit":<span class="cov0" title="0">
                content, err = fromReconCache(reconCachePath, "drive", "drive_audit_errors")
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                        return
                }</span>
        default:<span class="cov0" title="0">
                http.Error(writer, http.StatusText(http.StatusNotFound), http.StatusNotFound)
                return</span>
        }
        <span class="cov8" title="1">if content == nil </span><span class="cov0" title="0">{
                http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">writer.WriteHeader(200)
        serialized, _ := json.MarshalIndent(content, "", "  ")
        writer.Write(serialized)</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "net/http"

        "go.uber.org/zap"

        "github.com/troubling/hummingbird/common/srv"
)

func Recover(w http.ResponseWriter, r *http.Request, msg string) <span class="cov8" title="1">{
        if err := recover(); err != nil </span><span class="cov0" title="0">{
                transactionId := r.Header.Get("X-Trans-Id")
                srv.GetLogger(r).Error(msg, zap.Any("err", err), zap.String("txn", transactionId))
                // if we haven't set a status code yet, we can send a 500 response.
                if started, _ := w.(srv.WebWriterInterface).Response(); started.IsZero() </span><span class="cov0" title="0">{
                        srv.StandardResponse(w, http.StatusInternalServerError)
                }</span>
        }
}

func RecoverHandler(next http.Handler) http.Handler <span class="cov8" title="1">{
        fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                defer Recover(w, r, "PANIC")
                next.ServeHTTP(w, r)
        }</span>

        <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package middleware

import (
        "crypto/md5"
        "fmt"
        "io"
        "io/ioutil"
        "net/http"
        "os"
        "path"
        "strings"

        "github.com/troubling/hummingbird/common/srv"
        "go.uber.org/zap"
)

func RingHandler(w http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        if req.Method != "PUT" </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(w, http.StatusBadRequest, "PUT only\n")
                return
        }</span>
        <span class="cov0" title="0">ringPath := "/" + srv.GetVars(req)["ring_path"]
        if ringPath == "" </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(w, http.StatusBadRequest, "No ring path\n")
                return
        }</span>
        <span class="cov0" title="0">dir, file := path.Split(ringPath)
        if dir != "/etc/hummingbird/" &amp;&amp; dir != "/etc/swift/" </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(w, http.StatusBadRequest, "Invalid ring directory\n")
                return
        }</span>
        <span class="cov0" title="0">if !strings.HasSuffix(file, ".ring.gz") </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(w, http.StatusBadRequest, "Invalid ring extension\n")
                return
        }</span>
        <span class="cov0" title="0">typ := strings.SplitN(strings.SplitN(file, ".", 2)[0], "-", 2)[0]
        if typ != "account" &amp;&amp; typ != "container" &amp;&amp; typ != "object" </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(w, http.StatusBadRequest, "Invalid ring type\n")
                return
        }</span>
        <span class="cov0" title="0">etag := req.Header.Get("Etag")
        if etag == "" </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(w, http.StatusBadRequest, "No ETag\n")
                return
        }</span>
        <span class="cov0" title="0">f, err := ioutil.TempFile(dir, file)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("middleware.RingHandler TempFile error", zap.String("dir", dir), zap.String("file", file), zap.Error(err))
                srv.StandardResponse(w, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">defer f.Close()
        tempPath := f.Name()
        _, err = io.Copy(f, req.Body)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("middleware.RingHandler Copy", zap.String("temp path", tempPath), zap.Error(err))
                srv.StandardResponse(w, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">f.Close()
        f, err = os.Open(tempPath)
        defer f.Close()
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("middleware.RingHandler Open", zap.String("temp path", tempPath), zap.Error(err))
                srv.StandardResponse(w, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">hsh := md5.New()
        io.Copy(hsh, f)
        tempEtag := fmt.Sprintf("%x", hsh.Sum(nil))
        f.Close()
        if tempEtag != etag </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(w, http.StatusBadRequest, fmt.Sprintf("Etag mismatch: calculated %s but was given %s", tempEtag, etag))
                return
        }</span>
        <span class="cov0" title="0">err = os.Rename(tempPath, ringPath)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("middleware.RingHandler Rename", zap.String("temp path", tempPath), zap.String("ring path", ringPath), zap.Error(err))
                srv.StandardResponse(w, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">srv.StandardResponse(w, http.StatusCreated)</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">//  Copyright (c) 2018 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "fmt"
        "net/http"

        opentracing "github.com/opentracing/opentracing-go"
        "github.com/opentracing/opentracing-go/ext"
        "github.com/troubling/hummingbird/common/srv"
        "go.uber.org/zap"
)

// ServerTracer is a Middleware  that tries to join with an
// OpenTracing trace found in the HTTP request headers and starts a new Span.
// If no trace could be found in the HTTP request headers, the Span will be a trace root.
func ServerTracer(tracer opentracing.Tracer,
) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                        if tracer != nil </span><span class="cov0" title="0">{
                                // Try to join to a trace propagated in `req`.
                                wireContext, err := tracer.Extract(
                                        opentracing.TextMap,
                                        opentracing.HTTPHeadersCarrier(req.Header),
                                )
                                if err != nil &amp;&amp; err != opentracing.ErrSpanContextNotFound </span><span class="cov0" title="0">{
                                        srv.GetLogger(req).Error("error encountered while trying to extract span", zap.Any("err", err))
                                }</span>

                                // create span
                                <span class="cov0" title="0">span := tracer.StartSpan(fmt.Sprintf("HTTP %s", req.Method), ext.RPCServerOption(wireContext))
                                defer span.Finish()
                                ext.HTTPMethod.Set(span, req.Method)
                                ext.HTTPUrl.Set(span, req.URL.String())
                                // store span in context
                                ctx := opentracing.ContextWithSpan(req.Context(), span)

                                // update request context to include our new span
                                req = req.WithContext(ctx)</span>
                        }
                        // next middleware or actual request handler
                        <span class="cov8" title="1">next.ServeHTTP(w, req)</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file57" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "net/http"

        "github.com/troubling/hummingbird/common/srv"
)

func ValidateRequest(next http.Handler) http.Handler <span class="cov8" title="1">{
        fn := func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                if !srv.ValidateRequest(writer, request) </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">next.ServeHTTP(writer, request)</span>
        }
        <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package objectserver

import (
        "crypto/md5"
        "encoding/hex"
        "encoding/json"
        "flag"
        "fmt"
        "io"
        "math/bits"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/middleware"
        "go.uber.org/zap"
)

// AuditForeverInterval represents how often a auditor check should be performed.
var AuditForeverInterval = 30 * time.Second
var expiredObject = fmt.Errorf("Expired Object")

// AuditorDaemon keeps track of object specific audit data.
type AuditorDaemon struct {
        checkMounts       bool
        driveRoot         string
        policies          conf.PolicyList
        idbAuditors       map[int]IndexDBAuditor
        logger            srv.LowLevelLogger
        bytesPerSecond    int64
        logTime           int64
        regFilesPerSecond int64
        zbFilesPerSecond  int64
        reconCachePath    string
        hashPathPrefix    string
        hashPathSuffix    string
}

// Auditor keeps track of general audit data.
type Auditor struct {
        *AuditorDaemon
        auditorType                   string
        mode                          string
        filesPerSecond                int64
        passStart, lastLog            time.Time
        passes, totalPasses           int64
        bytesProcessed, totalBytes    int64
        quarantines, totalQuarantines int64
        errors, totalErrors           int64
}

func slowCopyMd5(file *os.File, bps int64) (int64, string, error) <span class="cov8" title="1">{
        h := md5.New()
        st := time.Now()
        bytesRead := int64(0)
        for </span><span class="cov8" title="1">{
                if b, err := io.CopyN(h, file, 64*1024); err != nil </span><span class="cov8" title="1">{
                        if err != io.EOF </span><span class="cov0" title="0">{
                                return bytesRead, "", err
                        }</span>
                        <span class="cov8" title="1">bytesRead += b
                        break</span>
                } else<span class="cov0" title="0"> {
                        bytesRead += b
                        rateLimitSleep(st, bytesRead, bps)
                }</span>
        }
        <span class="cov8" title="1">return bytesRead, hex.EncodeToString(h.Sum(nil)), nil</span>
}

type IndexDBAuditor interface {
        AuditItem(path string, item *IndexDBItem, md5BytesPerSec int64) (int64, error)
}

type ecAuditor struct{}

func (ecAuditor) AuditItem(path string, item *IndexDBItem, md5BytesPerSec int64) (int64, error) <span class="cov8" title="1">{
        finfo, err := os.Stat(path)
        if err != nil || !finfo.Mode().IsRegular() </span><span class="cov0" title="0">{
                if item.Nursery </span><span class="cov0" title="0">{
                        // We're not going to do any quarantining here. It's likely the object
                        // simply got stabilized and is gone.
                        return 0, nil
                }</span> else<span class="cov0" title="0"> {
                        return 0, fmt.Errorf("Object file isn't a normal file: %s", err)
                }</span>
        }
        <span class="cov8" title="1">var hsh string
        var fBytes int64
        var ok bool
        metadata := map[string]string{}
        if err = json.Unmarshal(item.Metabytes, &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Error decoding metadata: %s", err)
        }</span>
        <span class="cov8" title="1">contentLength, err := strconv.ParseInt(metadata["Content-Length"], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Error parsing content-length from metadata: %q %v", metadata["Content-Length"], err)
        }</span>
        <span class="cov8" title="1">if item.Nursery </span><span class="cov8" title="1">{
                hsh, ok = metadata["ETag"]
                if !ok </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("Metadata missing ETag: %s", metadata)
                }</span>
                <span class="cov8" title="1">fBytes = contentLength</span>
        } else<span class="cov8" title="1"> {
                hsh = item.ShardHash
                if _, ds, _, _, err := parseECScheme(metadata["Ec-Scheme"]); err == nil </span><span class="cov8" title="1">{
                        fBytes = ecShardLength(contentLength, ds)
                }</span> else<span class="cov0" title="0"> {
                        return 0, fmt.Errorf("Error decoding ec-scheme: %s", err)
                }</span>
        }
        <span class="cov8" title="1">if fBytes != finfo.Size() </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("File size (%d) doesn't match metadata (%d)", finfo.Size(), fBytes)
        }</span>
        <span class="cov8" title="1">if md5BytesPerSec &gt; 0 </span><span class="cov8" title="1">{
                file, err := os.Open(path)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("Error opening file: %s", err)
                }</span>
                <span class="cov8" title="1">defer file.Close()
                bytesRead, calcHsh, err := slowCopyMd5(file, md5BytesPerSec)
                if err != nil </span><span class="cov0" title="0">{
                        return bytesRead, fmt.Errorf("Error calc md5 file: %s", err)
                }</span>
                <span class="cov8" title="1">if bytesRead != fBytes </span><span class="cov0" title="0">{
                        return bytesRead, fmt.Errorf("did not read in entire file")
                }</span>
                <span class="cov8" title="1">if calcHsh != hsh </span><span class="cov8" title="1">{
                        return bytesRead, fmt.Errorf("File contents don't match object hash")
                }</span>
                <span class="cov8" title="1">return bytesRead, nil</span>
        }
        <span class="cov0" title="0">return 0, nil</span>
}

type repAuditor struct{}

func (repAuditor) AuditItem(path string, item *IndexDBItem, md5BytesPerSec int64) (int64, error) <span class="cov0" title="0">{
        finfo, err := os.Stat(path)
        if err != nil || !finfo.Mode().IsRegular() </span><span class="cov0" title="0">{
                if item.Nursery </span><span class="cov0" title="0">{
                        // We're not going to do any quarantining here. It's likely the object
                        // simply got stabilized and is gone.
                        return 0, nil
                }</span> else<span class="cov0" title="0"> {
                        return 0, fmt.Errorf("Object file isn't a normal file: %s", err)
                }</span>
        }
        <span class="cov0" title="0">metadata := map[string]string{}
        if err = json.Unmarshal(item.Metabytes, &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Error decoding metadata: %s", err)
        }</span>
        <span class="cov0" title="0">fBytes, err := strconv.ParseInt(metadata["Content-Length"], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Error parsing content-length from metadata: %q %v", metadata["Content-Length"], err)
        }</span>
        <span class="cov0" title="0">hsh, ok := metadata["ETag"]
        if !ok </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Metadata missing ETag: %s", metadata)
        }</span>
        <span class="cov0" title="0">if fBytes != finfo.Size() </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("File size (%d) doesn't match metadata (%d)", finfo.Size(), fBytes)
        }</span>
        <span class="cov0" title="0">if md5BytesPerSec &gt; 0 </span><span class="cov0" title="0">{
                file, err := os.Open(path)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("Error opening file: %s", err)
                }</span>
                <span class="cov0" title="0">defer file.Close()
                bytesRead, calcHsh, err := slowCopyMd5(file, md5BytesPerSec)
                if err != nil </span><span class="cov0" title="0">{
                        return bytesRead, fmt.Errorf("Error calc md5 file: %s", err)
                }</span>
                <span class="cov0" title="0">if bytesRead != fBytes </span><span class="cov0" title="0">{
                        return bytesRead, fmt.Errorf("did not read in entire file")
                }</span>
                <span class="cov0" title="0">if calcHsh != hsh </span><span class="cov0" title="0">{
                        return bytesRead, fmt.Errorf("File contents don't match object hash")
                }</span>
                <span class="cov0" title="0">return bytesRead, nil</span>
        }
        <span class="cov0" title="0">return 0, nil</span>
}

func QuarantineItem(db *IndexDB, item *IndexDBItem) error <span class="cov8" title="1">{
        itemPath, err := db.WholeObjectPath(item.Hash, item.Shard, item.Timestamp, item.Nursery)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">itemName := filepath.Base(itemPath)
        objsDir := filepath.Dir(filepath.Dir(filepath.Dir(itemPath)))
        driveDir := filepath.Dir(objsDir)
        quarantineDir := filepath.Join(driveDir, "quarantined", filepath.Base(objsDir), itemName)
        if err := os.MkdirAll(quarantineDir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">dest := filepath.Join(quarantineDir, itemName)
        var rerr error
        if err = os.Rename(itemPath, dest); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                rerr = err
        }</span>
        <span class="cov8" title="1">metaName := filepath.Join(quarantineDir, itemName+".idbmeta")
        f, err := os.OpenFile(metaName, os.O_RDWR|os.O_CREATE, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">_, err = f.Write(item.Metabytes)
        f.Close()
        if err != nil </span><span class="cov0" title="0">{
                if rmErr := os.Remove(metaName); rmErr != nil </span><span class="cov0" title="0">{
                        return rmErr
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">err = db.Remove(item.Hash, item.Shard, item.Timestamp, item.Nursery)
        if err == nil &amp;&amp; rerr != nil </span><span class="cov0" title="0">{
                return rerr
        }</span>
        <span class="cov8" title="1">return err</span>
}

// OneTimeChan returns a channel that will yield the current time once, then is closed.
func OneTimeChan() chan time.Time <span class="cov8" title="1">{
        c := make(chan time.Time, 1)
        c &lt;- time.Now()
        close(c)
        return c
}</span>

// rateLimitSleep long enough to achieve the target rate limit.
func rateLimitSleep(startTime time.Time, done int64, rate int64) <span class="cov8" title="1">{
        shouldHaveDone := int64(time.Since(startTime)/time.Second) * rate
        if done &gt; shouldHaveDone </span><span class="cov8" title="1">{
                time.Sleep(time.Second * time.Duration((done-shouldHaveDone)/rate))
        }</span>
}

// auditHash of object hash dir. if md5BytesPerSec == 0 then it will not calc md5
func auditHash(hashPath string, md5BytesPerSec int64) (bytesProcessed int64, err error) <span class="cov8" title="1">{
        objFiles, err := fs.ReadDirNames(hashPath)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Error reading hash dir")
        }</span>
        <span class="cov8" title="1">for _, file := range objFiles </span><span class="cov8" title="1">{
                filePath := filepath.Join(hashPath, file)

                ext := filepath.Ext(filePath)
                if ext != ".data" &amp;&amp; ext != ".ts" &amp;&amp; ext != ".meta" </span><span class="cov8" title="1">{
                        return bytesProcessed, fmt.Errorf("Object file has invalid extension %s", ext)
                }</span>

                <span class="cov8" title="1">finfo, err := os.Stat(filePath)
                if err != nil || !finfo.Mode().IsRegular() </span><span class="cov8" title="1">{
                        return bytesProcessed, fmt.Errorf("Object file isn't a normal file: %s", err)
                }</span>

                <span class="cov8" title="1">metadata, err := common.SwiftObjectReadMetadata(filePath)
                if err != nil </span><span class="cov8" title="1">{
                        return bytesProcessed, fmt.Errorf("Error getting file metadata: %v", err)
                }</span>
                <span class="cov8" title="1">if Expired(metadata) </span><span class="cov0" title="0">{
                        return 0, expiredObject
                }</span>

                <span class="cov8" title="1">if ext == ".data" </span><span class="cov8" title="1">{
                        for _, reqEntry := range []string{"Content-Length", "Content-Type", "name", "ETag", "X-Timestamp"} </span><span class="cov8" title="1">{
                                if _, ok := metadata[reqEntry]; !ok </span><span class="cov8" title="1">{
                                        return bytesProcessed, fmt.Errorf("Required metadata entry %s not found", reqEntry)
                                }</span>
                        }
                        <span class="cov8" title="1">contentLength, err := strconv.ParseInt(metadata["Content-Length"], 10, 64)
                        if err != nil </span><span class="cov8" title="1">{
                                return bytesProcessed, fmt.Errorf("Error parsing content-length from metadata: %q %v", metadata["Content-Length"], err)
                        }</span>
                        <span class="cov8" title="1">if contentLength != finfo.Size() </span><span class="cov8" title="1">{
                                return bytesProcessed, fmt.Errorf("File size (%d) doesn't match metadata (%d)", finfo.Size(), contentLength)
                        }</span>
                        <span class="cov8" title="1">if md5BytesPerSec &gt; 0 </span><span class="cov8" title="1">{
                                file, err := os.Open(filePath)
                                if err != nil </span><span class="cov0" title="0">{
                                        return bytesProcessed, fmt.Errorf("Error opening file: %s", err)
                                }</span>
                                <span class="cov8" title="1">bytesRead, calcHsh, err := slowCopyMd5(file, md5BytesPerSec)
                                if err != nil </span><span class="cov0" title="0">{
                                        return bytesRead, fmt.Errorf("Error calc md5 file: %s", err)
                                }</span>
                                <span class="cov8" title="1">bytesProcessed += bytesRead
                                if calcHsh != metadata["ETag"] </span><span class="cov8" title="1">{
                                        return bytesProcessed, fmt.Errorf("File contents don't match etag")
                                }</span>
                        }
                } else<span class="cov8" title="1"> if ext == ".ts" </span><span class="cov8" title="1">{
                        for _, reqEntry := range []string{"name", "X-Timestamp"} </span><span class="cov8" title="1">{
                                if _, ok := metadata[reqEntry]; !ok </span><span class="cov8" title="1">{
                                        return bytesProcessed, fmt.Errorf("Required metadata entry %s not found", reqEntry)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return bytesProcessed, nil</span>
}

// if there is more recent entry in indexdb for hash of given item, return true, nil
// if no object is found in index.db it will also return true, nil
func (a *Auditor) isOverwritten(db *IndexDB, item *IndexDBItem) (bool, error) <span class="cov0" title="0">{
        if fitem, err := db.Lookup(item.Hash, shardAny, false); err == nil </span><span class="cov0" title="0">{
                if fitem == nil </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
                <span class="cov0" title="0">if fitem.Timestamp &gt; item.Timestamp </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        } else<span class="cov0" title="0"> {
                return false, err
        }</span>
        <span class="cov0" title="0">return false, nil</span>
}

// auditDB.  Runs auditFunc on all objects in the given DB.
func (a *Auditor) auditDB(devPath string, objRing ring.Ring, policy *conf.Policy) <span class="cov8" title="1">{
        dbpath := filepath.Join(devPath, PolicyDir(policy.Index), fmt.Sprintf("%s.db", policy.Type))
        if _, err := os.Stat(dbpath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                a.logger.Debug("policy dbpath not found ", zap.String("policytype", policy.Type))
                return
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                a.errors++
                a.totalErrors++
                a.logger.Error("Couldn't open indexdb", zap.String("dbBasePath", dbpath), zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">policyDir := filepath.Dir(dbpath)
        path := filepath.Join(policyDir, policy.Type)
        temppath := filepath.Join(filepath.Dir(policyDir), "tmp")
        ringPartPower := bits.Len64(objRing.PartitionCount() - 1)
        zapLogger, ok := a.logger.(*zap.Logger)
        if !ok </span><span class="cov0" title="0">{
                a.logger.Error("Logger type assertion failed")
                zapLogger = zap.L()
        }</span>
        <span class="cov8" title="1">dbPartPower, err := policy.GetDbPartPower()
        if err != nil </span><span class="cov0" title="0">{
                a.logger.Error("Could not GetDbPartPower", zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">subdirs, err := policy.GetDbSubDirs()
        if err != nil </span><span class="cov0" title="0">{
                a.logger.Error("could not GetDbSubDirs", zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">if _, ok := a.idbAuditors[policy.Index]; !ok </span><span class="cov0" title="0">{
                a.logger.Error("No auditor set policy", zap.String("policy-type", policy.Type), zap.Int("policy-index", policy.Index))
                return
        }</span>
        <span class="cov8" title="1">db, err := NewIndexDB(dbpath, path, temppath, ringPartPower, int(dbPartPower), subdirs, 0, zapLogger, a.idbAuditors[policy.Index])
        if err != nil </span><span class="cov0" title="0">{
                a.errors++
                a.totalErrors++
                a.logger.Error("Couldn't open indexdb", zap.String("dbBasePath", dbpath), zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">defer db.Close()

        marker := ""
        for </span><span class="cov8" title="1">{
                items, err := db.List("", "", marker, 1000)
                if err != nil </span><span class="cov0" title="0">{
                        a.logger.Error("db.List failed", zap.String("dbpath", dbpath), zap.Error(err))
                        return
                }</span>
                <span class="cov8" title="1">for _, item := range items </span><span class="cov8" title="1">{
                        itemPath, err := db.WholeObjectPath(item.Hash, item.Shard, item.Timestamp, item.Nursery)
                        if err != nil </span><span class="cov0" title="0">{
                                a.logger.Error("Error getting indexdb path for hash",
                                        zap.String("hash", item.Hash), zap.Error(err))
                                continue</span>
                        }
                        <span class="cov8" title="1">a.passes++
                        a.totalPasses++
                        var bytesPerSecond int64
                        if a.auditorType != "ZBF" </span><span class="cov8" title="1">{
                                bytesPerSecond = a.bytesPerSecond
                        }</span>
                        <span class="cov8" title="1">bytes, err := a.idbAuditors[policy.Index].AuditItem(itemPath, item, bytesPerSecond)
                        if err != nil </span><span class="cov0" title="0">{
                                if overwritten, oerr := a.isOverwritten(db, item); !(oerr == nil &amp;&amp; overwritten) </span><span class="cov0" title="0">{
                                        a.logger.Error("Failed audit and is being quarantined",
                                                zap.String("itemPath", itemPath), zap.String("auditorType", a.auditorType), zap.Error(err))
                                        err = QuarantineItem(db, item)
                                        if err != nil </span><span class="cov0" title="0">{
                                                a.logger.Error("Failed to quarantine indexdb item", zap.String("auditorType", a.auditorType), zap.String("itemPath", itemPath), zap.Error(err))
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">a.quarantines++
                                        a.totalQuarantines++</span>
                                }
                        }
                        <span class="cov8" title="1">a.bytesProcessed += bytes
                        a.totalBytes += bytes
                        rateLimitSleep(a.passStart, a.totalPasses, a.filesPerSecond)
                        rateLimitSleep(a.passStart, a.totalBytes, a.bytesPerSecond)

                        if time.Since(a.lastLog) &gt; (time.Duration(a.logTime) * time.Second) </span><span class="cov8" title="1">{
                                a.statsReport()
                        }</span>
                }
                <span class="cov8" title="1">if len(items) == 0 </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">marker = items[len(items)-1].Hash</span>
        }
}

// auditSuffix directory.  Lists hash dirs, calls auditHash() for each, and quarantines any with errors.
func (a *Auditor) auditSuffix(suffixDir string) <span class="cov8" title="1">{
        hashes, err := fs.ReadDirNames(suffixDir)
        if err != nil </span><span class="cov8" title="1">{
                a.errors++
                a.totalErrors++
                a.logger.Error("Error reading suffix dir", zap.String("suffixDir", suffixDir), zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">for _, hash := range hashes </span><span class="cov8" title="1">{
                _, hexErr := hex.DecodeString(hash)
                hashDir := filepath.Join(suffixDir, hash)
                if finfo, err := os.Stat(hashDir); err != nil || len(hash) != 32 || hexErr != nil || !finfo.Mode().IsDir() </span><span class="cov8" title="1">{
                        a.logger.Error("Skipping invalid file in suffix", zap.String("hashDir", hashDir), zap.Error(err))
                        continue</span>
                }
                <span class="cov8" title="1">a.passes++
                a.totalPasses++
                var bps int64
                if a.auditorType != "ZBF" </span><span class="cov8" title="1">{
                        bps = a.bytesPerSecond
                }</span>
                <span class="cov8" title="1">bytesProcessed, err := auditHash(hashDir, bps)
                a.bytesProcessed += bytesProcessed
                a.totalBytes += bytesProcessed
                rateLimitSleep(a.passStart, a.totalPasses, a.filesPerSecond)
                rateLimitSleep(a.passStart, a.totalBytes, a.bytesPerSecond)
                if err == expiredObject </span><span class="cov0" title="0">{
                        a.logger.Debug("Removing expired object", zap.String("hashDir", hashDir))
                        os.RemoveAll(hashDir)
                }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                        a.logger.Error("Failed audit and is being quarantined",
                                zap.String("hashDir", hashDir),
                                zap.Error(err))
                        QuarantineHash(hashDir)
                        InvalidateHash(hashDir)
                        a.quarantines++
                        a.totalQuarantines++
                }</span>
        }
}

// auditPartition directory.  Lists suffixes in the partition and calls auditSuffix() for each.
func (a *Auditor) auditPartition(partitionDir string) <span class="cov8" title="1">{
        suffixes, err := fs.ReadDirNames(partitionDir)
        if err != nil </span><span class="cov8" title="1">{
                a.errors++
                a.totalErrors++
                a.logger.Error("Error reading partition dir ", zap.String("partitionDir", partitionDir), zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">for _, suffix := range suffixes </span><span class="cov8" title="1">{
                suffixDir := filepath.Join(partitionDir, suffix)
                if suffix == ".lock" || suffix == "hashes.pkl" || suffix == "hashes.invalid" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">_, hexErr := strconv.ParseInt(suffix, 16, 64)
                if finfo, err := os.Stat(suffixDir); err != nil || len(suffix) != 3 || hexErr != nil || !finfo.Mode().IsDir() </span><span class="cov8" title="1">{
                        a.logger.Error("Skipping invalid file in partition.", zap.String("suffixDir", suffixDir), zap.Error(err))
                        continue</span>
                }
                <span class="cov8" title="1">a.auditSuffix(suffixDir)
                if time.Since(a.lastLog) &gt; (time.Duration(a.logTime) * time.Second) </span><span class="cov8" title="1">{
                        a.statsReport()
                }</span>
        }
}

// auditDevice, checking for mount, list partitions, then call auditPartition() for each.
func (a *Auditor) auditDevice(devPath string) <span class="cov8" title="1">{
        defer srv.LogPanics(a.logger, "PANIC WHILE AUDITING DEVICE")

        if mounted, err := fs.IsMount(devPath); a.checkMounts &amp;&amp; (err != nil || mounted != true) </span><span class="cov8" title="1">{
                a.logger.Error("Skipping unmounted device", zap.String("devPath", devPath), zap.Error(err))
                return
        }</span>

        <span class="cov8" title="1">for _, policy := range a.policies </span><span class="cov8" title="1">{
                if policy.Type == "replication" </span><span class="cov8" title="1">{
                        objPath := filepath.Join(devPath, PolicyDir(policy.Index))
                        partitions, err := fs.ReadDirNames(objPath)
                        if err != nil </span><span class="cov8" title="1">{
                                if !os.IsNotExist(err) </span><span class="cov8" title="1">{
                                        a.errors++
                                        a.totalErrors++
                                        a.logger.Error("Error reading objects dir", zap.String("objPath", objPath), zap.Error(err))
                                }</span>
                                <span class="cov8" title="1">continue</span>
                        }
                        <span class="cov8" title="1">for _, partition := range partitions </span><span class="cov8" title="1">{
                                _, intErr := strconv.ParseInt(partition, 10, 64)
                                partitionDir := filepath.Join(objPath, partition)
                                if finfo, err := os.Stat(partitionDir); err != nil || intErr != nil || !finfo.Mode().IsDir() </span><span class="cov8" title="1">{
                                        a.logger.Error("Skipping invalid file in objects directory",
                                                zap.String("partitionDir", partitionDir), zap.Error(err))
                                        continue</span>
                                }
                                <span class="cov8" title="1">a.auditPartition(partitionDir)</span>
                        }
                } else<span class="cov8" title="1"> {
                        r, err := ring.GetRing("object", a.hashPathPrefix, a.hashPathSuffix, policy.Index)
                        if err != nil </span><span class="cov0" title="0">{
                                a.logger.Error("Error getting object ring", zap.Int("policyindex", policy.Index))
                                continue</span>
                        }
                        <span class="cov8" title="1">a.auditDB(devPath, r, policy)</span>
                }
        }
}

// statsReport logs auditing stats and dump recon cache.  Called periodically by auditPartition().
func (a *Auditor) statsReport() <span class="cov8" title="1">{
        now := time.Now()
        total := float64(now.Sub(a.passStart)) / float64(time.Second)
        sinceLast := float64(now.Sub(a.lastLog)) / float64(time.Second)
        frate := float64(a.passes) / sinceLast
        brate := float64(a.bytesProcessed) / sinceLast
        audit := 0.0      // TODO maybe
        audit_rate := 0.0 // TODO maybe
        a.logger.Info("statsReport",
                zap.String("Object audit", a.auditorType),
                zap.String("Since", a.lastLog.Format(time.ANSIC)),
                zap.Int64("Locally passed", a.passes),
                zap.Int64("Locally quarantined", a.quarantines),
                zap.Int64("Locally errored", a.errors),
                zap.Float64("files/sec", frate),
                zap.Float64("bytes/sec", brate),
                zap.Float64("Total time", total),
                zap.Float64("Auditing Time", audit),
                zap.Float64("Auditing Rate", audit_rate))

        middleware.DumpReconCache(a.reconCachePath, "object",
                map[string]interface{}{"object_auditor_stats_" + a.auditorType: map[string]interface{}{
                        "errors":          a.errors,
                        "passes":          a.passes,
                        "quarantined":     a.quarantines,
                        "bytes_processed": a.bytesProcessed,
                        "start_time":      float64(a.passStart.UnixNano()) / float64(time.Second), //???
                        "audit_time":      audit,
                }})
        a.passes = 0
        a.quarantines = 0
        a.errors = 0
        a.bytesProcessed = 0
        a.lastLog = now
}</span>

// finalLog final stats summary for the audit pass.
func (a *Auditor) finalLog() <span class="cov8" title="1">{
        elapsed := float64(time.Since(a.passStart)) / float64(time.Second)
        frate := float64(a.totalPasses) / elapsed
        brate := float64(a.totalBytes) / elapsed
        audit := 0.0      // TODO maybe
        audit_rate := 0.0 // TODO maybe
        a.logger.Info("Object Audit",
                zap.String("Auditor type", a.auditorType),
                zap.String("Mode", a.mode),
                zap.Float64("completed", elapsed),
                zap.Int64("Total quarantined", a.totalQuarantines),
                zap.Int64("Total errors", a.totalErrors),
                zap.Float64("Total files/sec", frate),
                zap.Float64("Total bytes/sec", brate),
                zap.Float64("Auditing time", audit),
                zap.Float64("Auditing rate", audit_rate))
}</span>

// run audit passes of the whole server until c is closed.
func (a *Auditor) run(c &lt;-chan time.Time) <span class="cov8" title="1">{
        for a.passStart = range c </span><span class="cov8" title="1">{
                middleware.DumpReconCache(a.reconCachePath, "object",
                        map[string]interface{}{"object_auditor_stats_" + a.auditorType: nil})
                a.passes = 0
                a.bytesProcessed = 0
                a.quarantines = 0
                a.errors = 0
                a.totalPasses = 0
                a.totalBytes = 0
                a.totalQuarantines = 0
                a.totalErrors = 0
                a.logger.Info("Begin object audit",
                        zap.String("mode", a.mode),
                        zap.String("auditorType", a.auditorType),
                        zap.String("driveRoot", a.driveRoot))
                devices, err := fs.ReadDirNames(a.driveRoot)
                if err != nil </span><span class="cov0" title="0">{
                        a.logger.Error("Unable to list devices", zap.String("driveRoot", a.driveRoot), zap.Error(err))
                        continue</span>
                }
                <span class="cov8" title="1">for _, dev := range devices </span><span class="cov8" title="1">{
                        a.auditDevice(filepath.Join(a.driveRoot, dev))
                }</span>
                <span class="cov8" title="1">a.finalLog()</span>
        }
}

// Run a single audit pass.
func (d *AuditorDaemon) Run() <span class="cov8" title="1">{
        wg := sync.WaitGroup{}
        if d.zbFilesPerSecond &gt; 0 </span><span class="cov8" title="1">{
                wg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        zba := Auditor{AuditorDaemon: d, auditorType: "ZBF", mode: "once", filesPerSecond: d.zbFilesPerSecond}
                        zba.run(OneTimeChan())
                        wg.Done()
                }</span>()
        }
        <span class="cov8" title="1">reg := Auditor{AuditorDaemon: d, auditorType: "ALL", mode: "once", filesPerSecond: d.regFilesPerSecond}
        reg.run(OneTimeChan())
        wg.Wait()</span>
}

// RunForever triggering audit passes every time AuditForeverInterval has passed.
func (d *AuditorDaemon) RunForever() <span class="cov0" title="0">{
        if d.zbFilesPerSecond &gt; 0 </span><span class="cov0" title="0">{
                zba := Auditor{AuditorDaemon: d, auditorType: "ZBF", mode: "forever", filesPerSecond: d.zbFilesPerSecond}
                go zba.run(time.Tick(AuditForeverInterval))
        }</span>
        <span class="cov0" title="0">reg := Auditor{AuditorDaemon: d, auditorType: "ALL", mode: "forever", filesPerSecond: d.regFilesPerSecond}
        reg.run(time.Tick(AuditForeverInterval))</span>
}

// NewAuditor returns a new AuditorDaemon with the given conf.
func NewAuditorDaemon(serverconf conf.Config, flags *flag.FlagSet, cnf srv.ConfigLoader) (*AuditorDaemon, error) <span class="cov8" title="1">{
        var err error
        if !serverconf.HasSection("object-auditor") </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Unable to find object-auditor config section")
        }</span>
        <span class="cov8" title="1">d := &amp;AuditorDaemon{}
        if d.policies, err = cnf.GetPolicies(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">d.idbAuditors = map[int]IndexDBAuditor{}
        for _, policy := range d.policies </span><span class="cov8" title="1">{
                switch policy.Type </span>{
                case "hec":<span class="cov8" title="1">
                        d.idbAuditors[policy.Index] = ecAuditor{}</span>
                case "rep":<span class="cov0" title="0">
                        d.idbAuditors[policy.Index] = repAuditor{}</span>
                }
        }
        <span class="cov8" title="1">d.hashPathPrefix, d.hashPathSuffix, err = cnf.GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Unable to load hashpath prefix and suffix")
        }</span>
        <span class="cov8" title="1">d.driveRoot = serverconf.GetDefault("object-auditor", "devices", "/srv/node")
        d.checkMounts = serverconf.GetBool("object-auditor", "mount_check", true)

        logLevelString := serverconf.GetDefault("object-auditor", "log_level", "INFO")
        logLevel := zap.NewAtomicLevel()
        logLevel.UnmarshalText([]byte(strings.ToLower(logLevelString)))
        if d.logger, err = srv.SetupLogger("object-auditor", &amp;logLevel, flags); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Error setting up logger: %v", err)
        }</span>
        <span class="cov8" title="1">d.bytesPerSecond = serverconf.GetInt("object-auditor", "bytes_per_second", 10000000)
        d.regFilesPerSecond = serverconf.GetInt("object-auditor", "files_per_second", 20)
        d.zbFilesPerSecond = serverconf.GetInt("object-auditor", "zero_byte_files_per_second", 50)
        d.reconCachePath = serverconf.GetDefault("object-auditor", "recon_cache_path", "/var/cache/swift")
        d.logTime = serverconf.GetInt("object-auditor", "log_time", 3600)
        return d, nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package objectserver

import (
        "encoding/json"
        "errors"
        "flag"
        "fmt"
        "io"
        "io/ioutil"
        "math/bits"
        "net"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "time"

        "go.uber.org/zap"

        "github.com/troubling/hummingbird/client"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/common/tracing"
        "golang.org/x/net/http2"
)

// ContentLength parses and returns the Content-Length for the object.
type ecEngine struct {
        driveRoot       string
        hashPathPrefix  string
        hashPathSuffix  string
        reserve         int64
        policy          int
        ring            ring.Ring
        idbs            map[string]*IndexDB
        idbm            sync.Mutex
        logger          srv.LowLevelLogger
        dataShards      int
        parityShards    int
        chunkSize       int
        client          common.HTTPClient
        nurseryReplicas int
        dbPartPower     int
        numSubDirs      int
}

func (f *ecEngine) getDB(device string) (*IndexDB, error) <span class="cov8" title="1">{
        f.idbm.Lock()
        defer f.idbm.Unlock()
        if idb, ok := f.idbs[device]; ok &amp;&amp; idb != nil </span><span class="cov8" title="1">{
                return idb, nil
        }</span>
        <span class="cov8" title="1">var err error
        dbpath := filepath.Join(f.driveRoot, device, PolicyDir(f.policy), "hec.db")
        path := filepath.Join(f.driveRoot, device, PolicyDir(f.policy), "hec")
        temppath := filepath.Join(f.driveRoot, device, "tmp")
        ringPartPower := bits.Len64(f.ring.PartitionCount() - 1)
        f.idbs[device], err = NewIndexDB(dbpath, path, temppath, ringPartPower, f.dbPartPower, f.numSubDirs, f.reserve, f.logger, ecAuditor{})
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return f.idbs[device], nil</span>
}

// New returns an instance of ecObject with the given parameters. Metadata is read in and if needData is true, the file is opened.  AsyncWG is a waitgroup if the object spawns any async operations
func (f *ecEngine) New(vars map[string]string, needData bool, asyncWG *sync.WaitGroup) (Object, error) <span class="cov0" title="0">{
        hash := ObjHash(vars, f.hashPathPrefix, f.hashPathSuffix)

        obj := &amp;ecObject{
                IndexDBItem: IndexDBItem{
                        Hash:    hash,
                        Nursery: true,
                },
                dataShards:      f.dataShards, /* TODO: consider just putting a reference to the engine in the object */
                parityShards:    f.parityShards,
                chunkSize:       f.chunkSize,
                reserve:         f.reserve,
                ring:            f.ring,
                logger:          f.logger,
                policy:          f.policy,
                client:          f.client,
                metadata:        map[string]string{},
                nurseryReplicas: f.nurseryReplicas,
                txnId:           vars["txnId"],
        }
        if idb, err := f.getDB(vars["device"]); err == nil </span><span class="cov0" title="0">{
                obj.idb = idb
                if item, err := idb.Lookup(hash, shardAny, false); err == nil &amp;&amp; item != nil </span><span class="cov0" title="0">{
                        obj.IndexDBItem = *item
                        if err = json.Unmarshal(item.Metabytes, &amp;obj.metadata); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Error parsing metadata: %v", err)
                        }</span>
                        <span class="cov0" title="0">if !item.Deletion </span><span class="cov0" title="0">{
                                if _, err := os.Stat(item.Path); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        }
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return obj, nil</span>
        }
        <span class="cov0" title="0">return nil, errors.New("Unable to open database")</span>
}

func (f *ecEngine) GetReplicationDevice(oring ring.Ring, dev *ring.Device, r *Replicator) (ReplicationDevice, error) <span class="cov8" title="1">{
        return GetNurseryDevice(oring, dev, f.policy, r, f)
}</span>

func (f *ecEngine) ecShardGetHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        idb, err := f.getDB(vars["device"])
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">shardIndex, err := strconv.Atoi(vars["index"])
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">item, err := idb.Lookup(vars["hash"], shardIndex, false)
        if err != nil || item == nil || item.Deletion </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span>
        <span class="cov0" title="0">metadata := map[string]string{}
        if err = json.Unmarshal(item.Metabytes, &amp;metadata); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">writer.Header().Set("Ec-Shard-Index", metadata["Ec-Shard-Index"])
        fl, err := os.Open(item.Path)
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">defer fl.Close()
        http.ServeContent(writer, request, item.Path, time.Unix(item.Timestamp, 0), fl)</span>
}

func (f *ecEngine) ecShardPostHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        idb, err := f.getDB(vars["device"])
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">shardIndex, err := strconv.Atoi(vars["index"])
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">rStatus, err := idb.StablePost(vars["hash"], shardIndex, request)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("error in StablePost", zap.Error(err))
        }</span>
        <span class="cov0" title="0">srv.StandardResponse(writer, rStatus)
        return</span>
}

func (f *ecEngine) ecShardPutHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        idb, err := f.getDB(vars["device"])
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">shardIndex, err := strconv.Atoi(vars["index"])
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">rStatus, err := idb.StablePut(vars["hash"], shardIndex, request)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("error in StablePut", zap.Error(err))
        }</span>
        <span class="cov0" title="0">srv.StandardResponse(writer, rStatus)
        return</span>
}

func (f *ecEngine) ecNurseryPutHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        idb, err := f.getDB(vars["device"])
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">timestampTime, err := common.ParseDate(request.Header.Get("Meta-X-Timestamp"))
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">timestamp := timestampTime.UnixNano()

        deletion, err := strconv.ParseBool(request.Header.Get("Deletion"))
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">method := "PUT"
        if deletion </span><span class="cov0" title="0">{
                method = "DELETE"
        }</span>

        <span class="cov0" title="0">metadata := make(map[string]string)
        for key := range request.Header </span><span class="cov0" title="0">{
                if strings.HasPrefix(key, "Meta-") </span><span class="cov0" title="0">{
                        if key == "Meta-Name" </span><span class="cov0" title="0">{
                                metadata["name"] = request.Header.Get(key)
                        }</span> else<span class="cov0" title="0"> if key == "Meta-Etag" </span><span class="cov0" title="0">{
                                metadata["ETag"] = request.Header.Get(key)
                        }</span> else<span class="cov0" title="0"> {
                                metadata[http.CanonicalHeaderKey(key[5:])] = request.Header.Get(key)
                        }</span>
                }
        }

        <span class="cov0" title="0">var atm fs.AtomicFileWriter
        if !deletion </span><span class="cov0" title="0">{
                atm, err = idb.TempFile(vars["hash"], 0, timestamp, 0, true)
                if err != nil </span><span class="cov0" title="0">{
                        srv.GetLogger(request).Error("Error opening file for writing", zap.Error(err))
                        srv.StandardResponse(writer, http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov0" title="0">if atm == nil </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, http.StatusCreated)
                        return
                }</span>
                <span class="cov0" title="0">defer atm.Abandon()

                n, err := common.Copy(request.Body, atm)
                if err == io.ErrUnexpectedEOF || (request.ContentLength &gt;= 0 &amp;&amp; n != request.ContentLength) </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, 499)
                        return
                }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        srv.GetLogger(request).Error("Error writing to file", zap.Error(err))
                        srv.StandardResponse(writer, http.StatusInternalServerError)
                        return
                }</span>
        }
        <span class="cov0" title="0">if err := idb.Commit(atm, vars["hash"], 0, timestamp, method, metadata, true, ""); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error committing object to index", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
        }</span> else<span class="cov0" title="0"> {
                srv.StandardResponse(writer, http.StatusCreated)
        }</span>
}

func (f *ecEngine) ecReconstructHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        o, err := f.New(vars, false, nil)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to open object.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">eco, ok := o.(*ecObject)
        if !ok </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Type assertion failed.")
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">err = eco.Reconstruct()
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to reconstruct.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">srv.StandardResponse(writer, http.StatusOK)</span>
}

func (f *ecEngine) ecShardDeleteHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        idb, err := f.getDB(vars["device"])
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">shardIndex, err := strconv.Atoi(vars["index"])
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">item, err := idb.Lookup(vars["hash"], shardIndex, true)
        if err != nil || item == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span>

        <span class="cov8" title="1">timestampTime, err := common.ParseDate(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">timestamp := timestampTime.UnixNano()
        if timestamp &lt;= item.Timestamp </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusConflict)
                return
        }</span>
        <span class="cov8" title="1">if err := idb.Remove(item.Hash, item.Shard, item.Timestamp, item.Nursery); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusInternalServerError)
        }</span> else<span class="cov8" title="1"> {
                srv.StandardResponse(writer, http.StatusNoContent)
        }</span>
}

func (f *ecEngine) GetObjectsToReplicate(prirep PriorityRepJob, c chan ObjectStabilizer, cancel chan struct{}) <span class="cov8" title="1">{
        defer close(c)
        idb, err := f.getDB(prirep.FromDevice.Device)
        if err != nil </span><span class="cov0" title="0">{
                f.logger.Error("error getting local db", zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">startHash, stopHash := idb.RingPartRange(int(prirep.Partition))
        items, err := idb.List(startHash, stopHash, "", 0)
        if len(items) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">url := fmt.Sprintf("%s://%s:%d/ec-partition/%s/%d", prirep.ToDevice.Scheme, prirep.ToDevice.Ip, prirep.ToDevice.Port, prirep.ToDevice.Device, prirep.Partition)
        req, err := http.NewRequest("GET", url, nil)
        req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(prirep.Policy))
        req.Header.Set("User-Agent", "nursery-stabilizer")
        resp, err := f.client.Do(req)

        var remoteItems []*IndexDBItem
        if err == nil &amp;&amp; (resp.StatusCode/100 == 2 || resp.StatusCode == 404) </span><span class="cov8" title="1">{
                if data, err := ioutil.ReadAll(resp.Body); err == nil </span><span class="cov8" title="1">{
                        if err = json.Unmarshal(data, &amp;remoteItems); err != nil </span><span class="cov0" title="0">{
                                f.logger.Error("error unmarshaling partition list", zap.Error(err))
                        }</span>
                } else<span class="cov0" title="0"> {
                        f.logger.Error("error reading partition list", zap.Error(err))
                }</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                f.logger.Error("error getting local partition list", zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">rii := 0
        for _, item := range items </span><span class="cov8" title="1">{
                if item.Nursery </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">sendItem := true
                for rii &lt; len(remoteItems) </span><span class="cov8" title="1">{
                        if remoteItems[rii].Hash &gt; item.Hash </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov8" title="1">if remoteItems[rii].Hash &lt; item.Hash </span><span class="cov0" title="0">{
                                rii++
                                continue</span>
                        }
                        <span class="cov8" title="1">if remoteItems[rii].Hash == item.Hash &amp;&amp;
                                remoteItems[rii].Timestamp == item.Timestamp &amp;&amp;
                                remoteItems[rii].Nursery == item.Nursery &amp;&amp;
                                remoteItems[rii].Deletion == item.Deletion </span><span class="cov8" title="1">{
                                sendItem = false
                        }</span>
                        <span class="cov8" title="1">rii++
                        break</span>
                }
                <span class="cov8" title="1">if sendItem </span><span class="cov8" title="1">{
                        obj := &amp;ecObject{
                                IndexDBItem:  *item,
                                idb:          idb,
                                dataShards:   f.dataShards,
                                parityShards: f.parityShards,
                                chunkSize:    f.chunkSize,
                                reserve:      f.reserve,
                                ring:         f.ring,
                                logger:       f.logger,
                                policy:       f.policy,
                                client:       f.client,
                                metadata:     map[string]string{},
                                txnId:        fmt.Sprintf("%s-%s", common.UUID(), prirep.FromDevice.Device),
                        }
                        if err = json.Unmarshal(item.Metabytes, &amp;obj.metadata); err != nil </span><span class="cov0" title="0">{
                                //TODO: this should quarantine right?
                                f.logger.Error("error unmarshal metabytes", zap.Error(err))
                                continue</span>
                        }
                        <span class="cov8" title="1">if obj.Path, err = idb.WholeObjectPath(obj.Hash, obj.Shard, obj.Timestamp, obj.Nursery); err != nil </span><span class="cov0" title="0">{
                                //TODO: this should quarantine right?
                                f.logger.Error("error building obj path", zap.Error(err))
                                continue</span>
                        }
                        <span class="cov8" title="1">select </span>{
                        case c &lt;- obj:</span><span class="cov8" title="1">
                        case &lt;-cancel:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }
}

func (f *ecEngine) listPartitionHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        idb, err := f.getDB(vars["device"])
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">part, err := strconv.Atoi(vars["partition"])
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">startHash, stopHash := idb.RingPartRange(part)
        items, err := idb.List(startHash, stopHash, "", 0)
        if err != nil </span><span class="cov0" title="0">{
                f.logger.Error("error listing idb", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">if data, err := json.Marshal(items); err == nil </span><span class="cov0" title="0">{
                writer.WriteHeader(http.StatusOK)
                writer.Write(data)
                return
        }</span> else<span class="cov0" title="0"> {
                f.logger.Error("error marshaling listing idb", zap.Error(err))
        }</span>
        <span class="cov0" title="0">srv.StandardResponse(writer, http.StatusInternalServerError)
        return</span>
}

func (f *ecEngine) RegisterHandlers(addRoute func(method, path string, handler http.HandlerFunc)) <span class="cov8" title="1">{
        addRoute("PUT", "/ec-nursery/:device/:hash", f.ecNurseryPutHandler)
        addRoute("GET", "/ec-shard/:device/:hash/:index", f.ecShardGetHandler)
        addRoute("PUT", "/ec-shard/:device/:hash/:index", f.ecShardPutHandler)
        addRoute("DELETE", "/ec-shard/:device/:hash/:index", f.ecShardDeleteHandler)
        addRoute("POST", "/ec-shard/:device/:hash/:index", f.ecShardPostHandler)
        addRoute("GET", "/ec-partition/:device/:partition", f.listPartitionHandler)
        addRoute("PUT", "/ec-reconstruct/:device/:account/:container/*obj", f.ecReconstructHandler)
}</span>

func (f *ecEngine) GetObjectsToStabilize(device string, c chan ObjectStabilizer, cancel chan struct{}) <span class="cov8" title="1">{
        defer close(c)
        idb, err := f.getDB(device)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">idb.ExpireObjects()

        items, err := idb.ListObjectsToStabilize()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">for _, item := range items </span><span class="cov0" title="0">{
                obj := &amp;ecObject{
                        IndexDBItem:     *item,
                        idb:             idb,
                        policy:          f.policy,
                        metadata:        map[string]string{},
                        ring:            f.ring,
                        logger:          f.logger,
                        reserve:         f.reserve,
                        dataShards:      f.dataShards,
                        parityShards:    f.parityShards,
                        chunkSize:       f.chunkSize,
                        client:          f.client,
                        nurseryReplicas: f.nurseryReplicas,
                        txnId:           fmt.Sprintf("%s-%s", common.UUID(), device),
                }
                if err = json.Unmarshal(item.Metabytes, &amp;obj.metadata); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">select </span>{
                case c &lt;- obj:</span><span class="cov0" title="0">
                case &lt;-cancel:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// ecEngineConstructor creates a ecEngine given the object server configs.
func ecEngineConstructor(config conf.Config, policy *conf.Policy, flags *flag.FlagSet) (ObjectEngine, error) <span class="cov8" title="1">{
        driveRoot := config.GetDefault("app:object-server", "devices", "/srv/node")
        reserve := config.GetInt("app:object-server", "fallocate_reserve", 0)
        hashPathPrefix, hashPathSuffix, err := conf.GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("Unable to load hashpath prefix and suffix")
        }</span>
        <span class="cov8" title="1">r, err := ring.GetRing("object", hashPathPrefix, hashPathSuffix, policy.Index)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">dbPartPower, err := policy.GetDbPartPower()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">subdirs, err := policy.GetDbSubDirs()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">certFile := config.GetDefault("app:object-server", "cert_file", "")
        keyFile := config.GetDefault("app:object-server", "key_file", "")
        transport := &amp;http.Transport{
                MaxIdleConnsPerHost: 256,
                MaxIdleConns:        0,
                IdleConnTimeout:     5 * time.Second,
                DisableCompression:  true,
                Dial: (&amp;net.Dialer{
                        Timeout:   10 * time.Second,
                        KeepAlive: 5 * time.Second,
                }).Dial,
                ExpectContinueTimeout: 10 * time.Minute,
        }
        if certFile != "" &amp;&amp; keyFile != "" </span><span class="cov0" title="0">{
                tlsConf, err := common.NewClientTLSConfig(certFile, keyFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">transport.TLSClientConfig = tlsConf
                if err = http2.ConfigureTransport(transport); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">logLevelString := config.GetDefault("app:object-server", "log_level", "INFO")
        logLevel := zap.NewAtomicLevel()
        logLevel.UnmarshalText([]byte(strings.ToLower(logLevelString)))
        httpClient := &amp;http.Client{
                Timeout:   120 * time.Minute,
                Transport: transport,
        }
        engine := &amp;ecEngine{
                driveRoot:      driveRoot,
                hashPathPrefix: hashPathPrefix,
                hashPathSuffix: hashPathSuffix,
                reserve:        reserve,
                policy:         policy.Index,
                ring:           r,
                idbs:           map[string]*IndexDB{},
                dbPartPower:    int(dbPartPower),
                numSubDirs:     subdirs,
                client:         httpClient,
        }
        if engine.logger, err = srv.SetupLogger("ecengine", &amp;logLevel, flags); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Error setting up logger: %v", err)
        }</span>
        <span class="cov8" title="1">if config.HasSection("tracing") </span><span class="cov0" title="0">{
                clientTracer, _, err := tracing.Init("ecengine-client", engine.logger, config.GetSection("tracing"))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Error setting up tracer: %v", err)
                }</span>
                <span class="cov0" title="0">enableHTTPTrace := config.GetBool("tracing", "enable_httptrace", true)
                engine.client, err = client.NewTracingClient(clientTracer, httpClient, enableHTTPTrace)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Error setting up tracing client: %v", err)
                }</span>
        }
        <span class="cov8" title="1">if engine.dataShards, err = strconv.Atoi(policy.Config["data_shards"]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if engine.parityShards, err = strconv.Atoi(policy.Config["parity_shards"]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if engine.chunkSize, err = strconv.Atoi(policy.Config["chunk_size"]); err != nil </span><span class="cov8" title="1">{
                engine.chunkSize = 1 &lt;&lt; 20
        }</span>
        <span class="cov8" title="1">if engine.nurseryReplicas, err = strconv.Atoi(policy.Config["nursery_replicas"]); err != nil </span><span class="cov8" title="1">{
                engine.nurseryReplicas = 3
        }</span>
        <span class="cov8" title="1">return engine, nil</span>
}

func init() <span class="cov8" title="1">{
        RegisterObjectEngine("hec", ecEngineConstructor)
}</span>

// make sure these things satisfy interfaces at compile time
var _ ObjectEngineConstructor = ecEngineConstructor
var _ ObjectEngine = &amp;ecEngine{}
var _ PolicyHandlerRegistrator = &amp;ecEngine{}
</pre>
		
		<pre class="file" id="file60" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package objectserver

import (
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "math"
        "net/http"
        "os"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "go.uber.org/zap"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
)

type ecObject struct {
        IndexDBItem
        afw             fs.AtomicFileWriter
        idb             *IndexDB
        policy          int
        metadata        map[string]string
        ring            ring.Ring
        logger          srv.LowLevelLogger
        reserve         int64
        dataShards      int
        parityShards    int
        chunkSize       int
        client          common.HTTPClient
        nurseryReplicas int
        txnId           string
}

func (o *ecObject) Metadata() map[string]string <span class="cov8" title="1">{
        return o.metadata
}</span>

func (o *ecObject) ContentLength() int64 <span class="cov8" title="1">{
        if contentLength, err := strconv.ParseInt(o.metadata["Content-Length"], 10, 64); err != nil </span><span class="cov0" title="0">{
                return -1
        }</span> else<span class="cov8" title="1"> {
                return contentLength
        }</span>
}

func (o *ecObject) Quarantine() error <span class="cov0" title="0">{
        return QuarantineItem(o.idb, &amp;o.IndexDBItem)
}</span>

func (o *ecObject) Exists() bool <span class="cov0" title="0">{
        if o.Deletion == true </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return o.Path != ""</span>
}

func parseECScheme(scheme string) (algo string, dataShards, parityShards, chunkSize int, err error) <span class="cov8" title="1">{
        sections := strings.Split(scheme, "/")
        if len(sections) != 4 </span><span class="cov8" title="1">{
                return "", 0, 0, 0, fmt.Errorf("%d scheme sections", len(sections))
        }</span>
        <span class="cov8" title="1">algo = sections[0]
        if dataShards, err = strconv.Atoi(sections[1]); err != nil </span><span class="cov0" title="0">{
                return "", 0, 0, 0, errors.New("Invalid data shard count")
        }</span>
        <span class="cov8" title="1">if parityShards, err = strconv.Atoi(sections[2]); err != nil </span><span class="cov0" title="0">{
                return "", 0, 0, 0, errors.New("Invalid parity shard count")
        }</span>
        <span class="cov8" title="1">if chunkSize, err = strconv.Atoi(sections[3]); err != nil </span><span class="cov8" title="1">{
                return "", 0, 0, 0, errors.New("Invalid chunk size")
        }</span>
        <span class="cov8" title="1">return algo, dataShards, parityShards, chunkSize, nil</span>
}

func (o *ecObject) Copy(dsts ...io.Writer) (written int64, err error) <span class="cov0" title="0">{
        if !o.Exists() </span><span class="cov0" title="0">{
                return 0, errors.New("Doesn't exist")
        }</span>
        <span class="cov0" title="0">contentLength := o.ContentLength()
        if contentLength == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">if o.Nursery </span><span class="cov0" title="0">{
                file, err := os.Open(o.Path)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">defer file.Close()
                return common.Copy(file, dsts...)</span>
        }

        <span class="cov0" title="0">algo, dataShards, parityShards, chunkSize, err := parseECScheme(o.metadata["Ec-Scheme"])
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Invalid scheme: %v", err)
        }</span>
        <span class="cov0" title="0">if algo != "reedsolomon" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Attempt to read EC object with unknown algorithm '%s'", algo)
        }</span>
        <span class="cov0" title="0">partition, err := o.ring.PartitionForHash(o.Hash)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid Hash: %s", o.Hash)
        }</span>
        <span class="cov0" title="0">nodes := o.ring.GetNodes(partition)
        if len(nodes) &lt; dataShards+parityShards </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Not enough nodes (%d) for scheme (%d)", len(nodes), dataShards+parityShards)
        }</span>
        <span class="cov0" title="0">bodies := make([]io.Reader, len(nodes))
        // TODO: This could be parallelized, and we can probably stop looking once we have dataShards bodies available.
        for i, node := range nodes </span><span class="cov0" title="0">{
                req, err := http.NewRequest("GET", fmt.Sprintf("%s://%s:%d/ec-shard/%s/%s/%d", node.Scheme, node.Ip, node.Port, node.Device, o.Hash, i), nil)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(o.policy))
                req.Header.Set("X-Trans-Id", o.txnId)
                resp, err := o.client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">defer resp.Body.Close()
                if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">bodies[i] = resp.Body</span>
        }
        <span class="cov0" title="0">ecGlue(dataShards, parityShards, bodies, chunkSize, contentLength, dsts...)
        return contentLength, nil</span>
}

// CopyRange copies a range of bytes from the object to the writer.
func (o *ecObject) CopyRange(w io.Writer, start int64, end int64) (int64, error) <span class="cov0" title="0">{
        if !o.Exists() </span><span class="cov0" title="0">{
                return 0, errors.New("Doesn't exist")
        }</span>

        <span class="cov0" title="0">if o.Nursery </span><span class="cov0" title="0">{
                file, err := os.Open(o.Path)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">defer file.Close()
                file.Seek(start, os.SEEK_SET)
                return common.Copy(io.LimitReader(file, end-start), w)</span>
        }

        <span class="cov0" title="0">algo, dataShards, parityShards, chunkSize, err := parseECScheme(o.metadata["Ec-Scheme"])
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Invalid scheme: %v", err)
        }</span>
        <span class="cov0" title="0">if algo != "reedsolomon" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Attempt to read EC object with unknown algorithm '%s'", algo)
        }</span>
        <span class="cov0" title="0">contentLength := o.ContentLength()
        partition, err := o.ring.PartitionForHash(o.Hash)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid Hash: %s", o.Hash)
        }</span>
        <span class="cov0" title="0">nodes := o.ring.GetNodes(partition)
        if len(nodes) &lt; dataShards+parityShards </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Not enough nodes (%d) for scheme (%d)", len(nodes), dataShards+parityShards)
        }</span>
        // round the range start(down) and end(up) to chunk boundaries
        <span class="cov0" title="0">shardStart, shardEnd := rangeChunkAlign(start, end, int64(chunkSize), dataShards)
        if shardEnd &gt; contentLength </span><span class="cov0" title="0">{
                shardEnd = contentLength
        }</span>
        <span class="cov0" title="0">bodies := make([]io.Reader, len(nodes))
        // TODO: This could be parallelized, and we can probably stop looking once we have dataShards bodies available.
        for i, node := range nodes </span><span class="cov0" title="0">{
                req, err := http.NewRequest("GET", fmt.Sprintf("%s://%s:%d/ec-shard/%s/%s/%d", node.Scheme, node.Ip, node.Port, node.Device, o.Hash, i), nil)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(o.policy))
                req.Header.Set("Range", fmt.Sprintf("bytes=%d-%d", shardStart, shardEnd))
                req.Header.Set("X-Trans-Id", o.txnId)
                resp, err := o.client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">defer resp.Body.Close()
                if resp.StatusCode != http.StatusOK &amp;&amp; resp.StatusCode != http.StatusPartialContent </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">bodies[i] = resp.Body</span>
        }
        <span class="cov0" title="0">err = ecGlue(dataShards, parityShards, bodies, chunkSize, shardEnd-shardStart,
                &amp;rangeBytesWriter{startOffset: start % int64(chunkSize), length: end - start, writer: w})
        return end - start, nil</span>
}

func (o *ecObject) Repr() string <span class="cov0" title="0">{
        return fmt.Sprintf("ecObject(%s)", o.Hash)
}</span>

func (o *ecObject) SetData(size int64) (io.Writer, error) <span class="cov0" title="0">{
        var err error
        o.Close()
        if o.afw, err = o.idb.TempFile(o.Hash, 0, math.MaxInt64, size, true); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Error creating temp file: %v", err)
        }</span>
        <span class="cov0" title="0">if err := o.afw.Preallocate(size, o.reserve); err != nil </span><span class="cov0" title="0">{
                o.afw.Abandon()
                return nil, DriveFullError
        }</span>
        <span class="cov0" title="0">return o.afw, nil</span>
}

func (o *ecObject) commit(metadata map[string]string, method string, nursery bool) error <span class="cov0" title="0">{
        defer o.Close()
        timestampStr, ok := metadata["X-Timestamp"]
        if !ok </span><span class="cov0" title="0">{
                return errors.New("no timestamp in metadata")
        }</span>
        <span class="cov0" title="0">timestampTime, err := common.ParseDate(timestampStr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">timestamp := timestampTime.UnixNano()
        shard := 0
        if !nursery </span><span class="cov0" title="0">{
                shard = o.Shard
        }</span>
        <span class="cov0" title="0">return o.idb.Commit(o.afw, o.Hash, shard, timestamp, method, metadata, nursery, "")</span>
}

func (o *ecObject) Commit(metadata map[string]string) error <span class="cov0" title="0">{
        return o.commit(metadata, "PUT", true)
}</span>

func (o *ecObject) Delete(metadata map[string]string) error <span class="cov0" title="0">{
        return o.commit(metadata, "DELETE", true)
}</span>

func (o *ecObject) CommitMetadata(metadata map[string]string) error <span class="cov0" title="0">{
        return o.commit(metadata, "POST", o.Nursery)
}</span>

func (o *ecObject) Close() error <span class="cov0" title="0">{
        if o.afw != nil </span><span class="cov0" title="0">{
                defer o.afw.Abandon()
                o.afw = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (o *ecObject) Reconstruct() error <span class="cov0" title="0">{
        success := true
        algo, dataShards, parityShards, chunkSize, err := parseECScheme(o.metadata["Ec-Scheme"])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid scheme: %v", err)
        }</span>
        <span class="cov0" title="0">if algo != "reedsolomon" </span><span class="cov0" title="0">{
                return fmt.Errorf("Attempt to read EC object with unknown algorithm '%s'", algo)
        }</span>
        <span class="cov0" title="0">contentLength := o.ContentLength()
        partition, err := o.ring.PartitionForHash(o.Hash)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid Hash: %s", o.Hash)
        }</span>
        <span class="cov0" title="0">nodes := o.ring.GetNodes(partition)
        if len(nodes) &lt; dataShards+parityShards </span><span class="cov0" title="0">{
                return fmt.Errorf("Not enough nodes (%d) for scheme (%d)", len(nodes), dataShards+parityShards)
        }</span>
        <span class="cov0" title="0">bodies := make([]io.Reader, len(nodes))
        readSuccesses := 0
        readFails := 0
        failed := make([]*ring.Device, len(nodes))
        for i, node := range nodes </span><span class="cov0" title="0">{
                url := fmt.Sprintf("%s://%s:%d/ec-shard/%s/%s/%d", node.Scheme, node.Ip, node.Port, node.Device, o.Hash, i)
                req, err := http.NewRequest("GET", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        o.logger.Error("NewRequest failed", zap.String("url", url))
                        failed[i] = node
                        readFails++
                        continue</span>
                }
                <span class="cov0" title="0">req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(o.policy))
                req.Header.Set("X-Trans-Id", o.txnId)
                resp, err := o.client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        o.logger.Error("client.Do failed", zap.String("url", url))
                        failed[i] = node
                        readFails++
                        continue</span>
                }
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        io.Copy(ioutil.Discard, resp.Body)
                        resp.Body.Close()
                }</span>()
                <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                        o.logger.Error("Non OK response", zap.String("url", url), zap.Int("code", resp.StatusCode))
                        failed[i] = node
                        readFails++
                        continue</span>
                }
                <span class="cov0" title="0">bodies[i] = resp.Body
                readSuccesses++</span>
        }
        <span class="cov0" title="0">if readSuccesses &lt; dataShards </span><span class="cov0" title="0">{
                return fmt.Errorf("Not enough nodes (%d) to reconstruct from (%d)", readSuccesses, dataShards)
        }</span>

        <span class="cov0" title="0">var writers []io.Writer
        var writeClosers []io.WriteCloser
        var shardsToFix []int
        writeSuccess := make(chan bool)

        nodeFails := 0
        for i, node := range failed </span><span class="cov0" title="0">{
                if node == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">rp, wp := io.Pipe()
                defer wp.Close()
                defer rp.Close()
                url := fmt.Sprintf("%s://%s:%d/ec-shard/%s/%s/%d", node.Scheme, node.Ip, node.Port, node.Device, o.Hash, i)
                req, err := http.NewRequest("PUT", url, rp)
                if err != nil </span><span class="cov0" title="0">{
                        nodeFails++
                        o.logger.Info("PUT NewRequest failed", zap.String("url", url), zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">req.ContentLength = ecShardLength(o.ContentLength(), o.dataShards)
                req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(o.policy))
                req.Header.Set("X-Trans-Id", o.txnId)
                req.Header.Set("Meta-Ec-Scheme", fmt.Sprintf("reedsolomon/%d/%d/%d", o.dataShards, o.parityShards, o.chunkSize))
                for k, v := range o.metadata </span><span class="cov0" title="0">{
                        req.Header.Set("Meta-"+k, v)
                }</span>
                <span class="cov0" title="0">writers = append(writers, io.Writer(wp))
                writeClosers = append(writeClosers, io.WriteCloser(wp))
                shardsToFix = append(shardsToFix, i)
                go func(req *http.Request) </span><span class="cov0" title="0">{
                        if resp, err := o.client.Do(req); err != nil </span><span class="cov0" title="0">{
                                o.logger.Error("client.Do Failed", zap.String("url", url), zap.Error(err))
                                writeSuccess &lt;- false
                        }</span> else<span class="cov0" title="0"> {
                                io.Copy(ioutil.Discard, resp.Body)
                                resp.Body.Close()
                                if !(resp.StatusCode/100 == 2 || resp.StatusCode == 409) </span><span class="cov0" title="0">{
                                        o.logger.Info("PUT StatusCode failed", zap.String("url", url), zap.Int("code", resp.StatusCode))
                                        writeSuccess &lt;- false
                                        return
                                }</span>
                                <span class="cov0" title="0">writeSuccess &lt;- true</span>
                        }
                }(req)
        }
        <span class="cov0" title="0">err = ecReconstruct(dataShards, parityShards, bodies, chunkSize, contentLength, writers, shardsToFix, o.logger)
        if err != nil </span><span class="cov0" title="0">{
                o.logger.Error("ecReconstruct failed", zap.Error(err))
        }</span>
        <span class="cov0" title="0">waitingFor := dataShards + parityShards - readSuccesses - nodeFails
        for _, writer := range writeClosers </span><span class="cov0" title="0">{
                writer.Close()
        }</span>
        <span class="cov0" title="0">for waitingFor &gt; 0 </span><span class="cov0" title="0">{
                select </span>{
                case result := &lt;-writeSuccess:<span class="cov0" title="0">
                        if result == false </span><span class="cov0" title="0">{
                                success = false
                        }</span>
                        <span class="cov0" title="0">waitingFor--</span>
                }
        }
        <span class="cov0" title="0">if !success </span><span class="cov0" title="0">{
                return fmt.Errorf("Failed to reconstruct")
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (o *ecObject) Replicate(prirep PriorityRepJob) error <span class="cov0" title="0">{
        // If we are handoff, just replicate the shard and delete local shard
        if o.Nursery </span><span class="cov0" title="0">{
                return fmt.Errorf("not replicating object in nursery")
        }</span>
        <span class="cov0" title="0">if _, handoff := o.ring.GetJobNodes(prirep.Partition, prirep.FromDevice.Id); handoff </span><span class="cov0" title="0">{
                fp, err := os.Open(o.Path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer fp.Close()
                req, err := http.NewRequest("PUT", fmt.Sprintf("%s://%s:%d/ec-shard/%s/%s/%d", prirep.ToDevice.Scheme, prirep.ToDevice.Ip, prirep.ToDevice.Port, prirep.ToDevice.Device, o.Hash, o.Shard), fp)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">req.ContentLength = ecShardLength(o.ContentLength(), o.dataShards)
                req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(o.policy))
                req.Header.Set("X-Trans-Id", o.txnId)
                req.Header.Set("User-Agent", "nursery-stabilizer")
                req.Header.Set("Meta-Ec-Scheme", fmt.Sprintf("reedsolomon/%d/%d/%d", o.dataShards, o.parityShards, o.chunkSize))
                for k, v := range o.metadata </span><span class="cov0" title="0">{
                        req.Header.Set("Meta-"+k, v)
                }</span>
                <span class="cov0" title="0">resp, err := o.client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error syncing shard %s/%d: %v", o.Hash, o.Shard, err)
                }</span>
                <span class="cov0" title="0">defer resp.Body.Close()
                if !(resp.StatusCode/100 == 2 || resp.StatusCode == 409) </span><span class="cov0" title="0">{
                        return fmt.Errorf("bad status code %d syncing shard with  %s/%d", resp.StatusCode, o.Hash, o.Shard)
                }</span>
                <span class="cov0" title="0">return o.idb.Remove(o.Hash, o.Shard, o.Timestamp, o.Nursery)</span>
        }
        <span class="cov0" title="0">return o.Reconstruct()</span>
}

func (o *ecObject) nurseryReplicate(partition uint64, dev *ring.Device) error <span class="cov8" title="1">{
        nodes, handoff := o.ring.GetJobNodes(partition, dev.Id)
        more := o.ring.GetMoreNodes(partition)
        var node *ring.Device
        e := common.NewExpector(o.client)
        defer e.Close()
        wrs := make([]io.WriteCloser, 0)
        successReadyCount := 0
        var responses []*http.Response
        var ready []bool
        nurseryReplicaCount := o.nurseryReplicas
        if !handoff </span><span class="cov8" title="1">{ // we don't need to replicate to ourselves.
                nurseryReplicaCount -= 1
        }</span>
        <span class="cov8" title="1">for i := 0; successReadyCount &lt; nurseryReplicaCount; i++ </span><span class="cov8" title="1">{
                if i &lt; len(nodes) </span><span class="cov8" title="1">{
                        node = nodes[i]
                }</span> else<span class="cov0" title="0"> if node = more.Next(); node == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">rp, wp := io.Pipe()
                defer rp.Close()
                defer wp.Close()
                wrs = append(wrs, wp)
                req, err := http.NewRequest("PUT", fmt.Sprintf("%s://%s:%d/ec-nursery/%s/%s",
                        node.Scheme, node.ReplicationIp, node.ReplicationPort, node.Device, o.Hash), rp)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(o.policy))
                req.Header.Set("X-Trans-Id", o.txnId)
                req.Header.Set("User-Agent", "nursery-stabilizer")
                req.Header.Set("Deletion", strconv.FormatBool(o.Deletion))
                req.Header.Set("Content-Length", o.metadata["Content-Length"])
                for k, v := range o.metadata </span><span class="cov8" title="1">{
                        req.Header.Set("Meta-"+k, v)
                }</span>
                <span class="cov8" title="1">e.AddRequest(req)

                if i &gt;= nurseryReplicaCount-1 </span><span class="cov8" title="1">{
                        successReadyCount = 0
                        responses, ready = e.Wait(time.Second * 15)
                        for i := 0; i &lt; len(responses); i++ </span><span class="cov8" title="1">{
                                if (responses[i] != nil &amp;&amp; responses[i].StatusCode/100 == 2) || ready[i] == true </span><span class="cov8" title="1">{
                                        successReadyCount++
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if o.Path != "" </span><span class="cov8" title="1">{
                writers := make([]io.Writer, 0)
                for i, ready := range ready </span><span class="cov8" title="1">{
                        if ready </span><span class="cov8" title="1">{
                                writers = append(writers, wrs[i])
                        }</span>
                }
                <span class="cov8" title="1">fp, err := os.Open(o.Path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">defer fp.Close()
                common.Copy(fp, writers...)</span>
        }
        <span class="cov8" title="1">for _, wr := range wrs </span><span class="cov8" title="1">{
                if wr != nil </span><span class="cov8" title="1">{
                        wr.Close()
                }</span>
        }

        <span class="cov8" title="1">sts := []int{2, 409}
        if o.Deletion </span><span class="cov0" title="0">{
                sts = append(sts, 404)
        }</span>
        <span class="cov8" title="1">successes := e.Successes(time.Second*15, sts...)
        if handoff &amp;&amp; successes &gt;= nurseryReplicaCount &amp;&amp; successes &gt; 0 </span><span class="cov0" title="0">{
                return o.idb.Remove(o.Hash, o.Shard, o.Timestamp, true)
        }</span> else<span class="cov8" title="1"> if successes &lt; nurseryReplicaCount </span><span class="cov0" title="0">{
                return errors.New("Unable to fully nursery-replicate object.")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (o *ecObject) restabilize(dev *ring.Device) error <span class="cov0" title="0">{
        partition, err := o.ring.PartitionForHash(o.Hash)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid Hash: %s", o.Hash)
        }</span>
        <span class="cov0" title="0">wg := sync.WaitGroup{}
        var successes int64
        nodes := o.ring.GetNodes(partition)
        if len(nodes) != o.dataShards+o.parityShards </span><span class="cov0" title="0">{
                return fmt.Errorf("Ring doesn't match EC scheme (%d != %d).", len(nodes), o.dataShards+o.parityShards)
        }</span>
        <span class="cov0" title="0">for i, node := range nodes </span><span class="cov0" title="0">{
                req, err := http.NewRequest("POST", fmt.Sprintf("%s://%s:%d/ec-shard/%s/%s/%d", node.Scheme, node.Ip, node.Port, node.Device, o.Hash, i), nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">req.Header.Set("X-Timestamp", o.metadata["X-Timestamp"])
                req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(o.policy))
                req.Header.Set("X-Trans-Id", o.txnId)
                req.Header.Set("User-Agent", "nursery-stabilizer")
                for k, v := range o.metadata </span><span class="cov0" title="0">{
                        req.Header.Set("Meta-"+k, v)
                }</span>
                <span class="cov0" title="0">wg.Add(1)
                go func(req *http.Request) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        if resp, err := o.client.Do(req); err == nil </span><span class="cov0" title="0">{
                                io.Copy(ioutil.Discard, resp.Body)
                                resp.Body.Close()
                                if resp.StatusCode/100 == 2 || resp.StatusCode == http.StatusConflict </span><span class="cov0" title="0">{
                                        atomic.AddInt64(&amp;successes, 1)
                                }</span>
                        }
                }(req)
        }
        <span class="cov0" title="0">wg.Wait()
        if successes != int64(len(nodes)) </span><span class="cov0" title="0">{
                return fmt.Errorf("could not restabilize all primaries %d/%d", successes, len(nodes))
        }</span>
        <span class="cov0" title="0">return o.idb.SetStabilized(o.Hash, o.Shard, o.Timestamp, false)</span>
}

func (o *ecObject) Stabilize(dev *ring.Device) error <span class="cov8" title="1">{
        if o.Restabilize </span><span class="cov0" title="0">{
                return o.restabilize(dev)
        }</span>
        <span class="cov8" title="1">partition, err := o.ring.PartitionForHash(o.Hash)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid Hash: %s", o.Hash)
        }</span>
        <span class="cov8" title="1">nodes := o.ring.GetNodes(partition)
        if len(nodes) != o.dataShards+o.parityShards </span><span class="cov0" title="0">{
                return fmt.Errorf("Ring doesn't match EC scheme (%d != %d).", len(nodes), o.dataShards+o.parityShards)
        }</span>
        <span class="cov8" title="1">wrs := make([]io.WriteCloser, len(nodes))
        e := common.NewExpector(o.client)
        defer e.Close()
        for i, node := range nodes </span><span class="cov8" title="1">{
                rp, wp := io.Pipe()
                defer rp.Close()
                defer wp.Close()
                wrs[i] = wp
                url := fmt.Sprintf("%s://%s:%d/ec-shard/%s/%s/%d", node.Scheme, node.ReplicationIp,
                        node.ReplicationPort, node.Device, o.Hash, i)
                method := "PUT"
                if o.Deletion </span><span class="cov8" title="1">{
                        method = "DELETE"
                }</span>
                <span class="cov8" title="1">req, err := http.NewRequest(method, url, rp)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if !o.Deletion </span><span class="cov8" title="1">{
                        req.ContentLength = ecShardLength(o.ContentLength(), o.dataShards)
                }</span>
                <span class="cov8" title="1">req.Header.Set("X-Timestamp", o.metadata["X-Timestamp"])
                req.Header.Set("Deletion", strconv.FormatBool(o.Deletion)) //TODO: this can be removed right?
                req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(o.policy))
                req.Header.Set("X-Trans-Id", o.txnId)
                req.Header.Set("User-Agent", "nursery-stabilizer")
                req.Header.Set("Meta-Ec-Scheme", fmt.Sprintf("reedsolomon/%d/%d/%d", o.dataShards, o.parityShards, o.chunkSize))
                for k, v := range o.metadata </span><span class="cov8" title="1">{
                        req.Header.Set("Meta-"+k, v)
                }</span>
                <span class="cov8" title="1">e.AddRequest(req)</span>
        }

        <span class="cov8" title="1">responses, ready := e.Wait(time.Second * 15)
        writers := make([]io.WriteCloser, len(nodes))
        needUpload := false
        success := true
        for i := range responses </span><span class="cov8" title="1">{
                if responses[i] != nil </span><span class="cov8" title="1">{
                        if responses[i].StatusCode/100 == 2 || responses[i].StatusCode == 409 || (o.Deletion &amp;&amp; responses[i].StatusCode == 404) </span>{<span class="cov0" title="0">
                        }</span> else<span class="cov8" title="1"> {
                                success = false
                                o.logger.Debug("stabilize req failed", zap.Int("status", responses[i].StatusCode), zap.String("resp", fmt.Sprintf("%v", responses[i])))
                        }</span>
                } else<span class="cov8" title="1"> if ready[i] == true </span><span class="cov8" title="1">{
                        if !o.Deletion </span><span class="cov8" title="1">{
                                needUpload = true
                                writers[i] = wrs[i]
                        }</span>
                } else<span class="cov0" title="0"> {
                        o.logger.Debug("stabilize req failed: nil response")
                        success = false
                }</span>
        }
        <span class="cov8" title="1">if success </span><span class="cov8" title="1">{
                if needUpload </span><span class="cov8" title="1">{
                        fp, err := os.Open(o.Path)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">defer fp.Close()

                        contentLength := int64(0) // TODO: check this against metadata
                        if fi, err := fp.Stat(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span> else<span class="cov8" title="1"> {
                                contentLength = fi.Size()
                        }</span>

                        <span class="cov8" title="1">ecSplit(o.dataShards, o.parityShards, fp, o.chunkSize, contentLength, writers)</span>
                }
                <span class="cov8" title="1">for _, w := range wrs </span><span class="cov8" title="1">{
                        w.Close()
                }</span>
                <span class="cov8" title="1">sts := []int{2, 409}
                if o.Deletion </span><span class="cov8" title="1">{
                        sts = append(sts, 404)
                }</span>
                <span class="cov8" title="1">if e.Successes(time.Second*15, sts...) &lt; len(nodes) </span><span class="cov0" title="0">{
                        success = false
                }</span>
        }

        <span class="cov8" title="1">if !success </span><span class="cov8" title="1">{
                o.nurseryReplicate(partition, dev)
                return fmt.Errorf("Failed to stabilize object: %s", o.txnId)
        }</span> else<span class="cov8" title="1"> if o.idb != nil </span><span class="cov0" title="0">{
                return o.idb.Remove(o.Hash, o.Shard, o.Timestamp, true)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// rangeChunkAlign calculates the range to request of shards to get a given range of the final file.
func rangeChunkAlign(start, end, chunkSize int64, dataShards int) (int64, int64) <span class="cov8" title="1">{
        startChunk := start / (chunkSize * int64(dataShards))
        endChunk := end / (chunkSize * int64(dataShards))
        start = startChunk * chunkSize
        if end%(chunkSize*int64(dataShards)) == 0 </span><span class="cov8" title="1">{
                end = (endChunk) * chunkSize
        }</span> else<span class="cov8" title="1"> {
                end = (endChunk + 1) * chunkSize
        }</span>
        <span class="cov8" title="1">return start, end</span>
}

// rangeBytesWriter proxies a range of its received bytes to the underlying writer, discarding anything before `start` or after `length`
type rangeBytesWriter struct {
        startOffset int64
        length      int64
        writer      io.Writer
}

func (r *rangeBytesWriter) Write(b []byte) (written int, err error) <span class="cov8" title="1">{
        written = len(b)
        if r.startOffset &gt; int64(len(b)) </span><span class="cov0" title="0">{
                r.startOffset -= int64(len(b))
                return written, nil
        }</span>
        <span class="cov8" title="1">if r.length &lt;= 0 </span><span class="cov0" title="0">{
                return written, nil
        }</span>
        <span class="cov8" title="1">b = b[r.startOffset:]
        r.startOffset = 0
        if int64(len(b)) &gt; r.length </span><span class="cov8" title="1">{
                b = b[:r.length]
        }</span>
        <span class="cov8" title="1">r.length -= int64(len(b))
        _, err = r.writer.Write(b[r.startOffset:])
        return written, err</span>
}

// make sure these things satisfy interfaces at compile time
var _ Object = &amp;ecObject{}
var _ ObjectStabilizer = &amp;ecObject{}
</pre>
		
		<pre class="file" id="file61" style="display: none">//  Copyright (c) 2016 Rackspace

package objectserver

import (
        "fmt"
        "io"

        "github.com/klauspost/reedsolomon"
        "github.com/troubling/hummingbird/common/srv"
        "go.uber.org/zap"
)

func ecShardLength(length int64, dataShards int) int64 <span class="cov8" title="1">{
        if length &lt; 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">shards := int64(dataShards)
        shardLength := length / shards
        if length%shards &gt; 0 </span><span class="cov8" title="1">{
                shardLength += 1
        }</span>
        <span class="cov8" title="1">return shardLength</span>
}

func ecSplit(dataChunks, parityChunks int, fp io.Reader, chunkSize int, contentLength int64, writers []io.WriteCloser) error <span class="cov8" title="1">{
        enc, err := reedsolomon.New(dataChunks, parityChunks)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">data := make([][]byte, dataChunks+parityChunks)
        databuf := make([]byte, (dataChunks+parityChunks)*chunkSize)
        for i := range data </span><span class="cov8" title="1">{
                data[i] = databuf[i*chunkSize : (i+1)*chunkSize]
        }</span>
        <span class="cov8" title="1">totalRead := int64(0)
        failed := make([]bool, len(writers))
        for totalRead &lt; contentLength </span><span class="cov8" title="1">{
                expectedRead := dataChunks * chunkSize
                if contentLength-totalRead &lt; int64(expectedRead) </span><span class="cov8" title="1">{
                        expectedRead = int(contentLength - totalRead)
                }</span>
                <span class="cov8" title="1">read, err := io.ReadFull(fp, databuf[:expectedRead])
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if read == 0 </span><span class="cov0" title="0">{
                        return io.ErrUnexpectedEOF
                }</span>
                <span class="cov8" title="1">totalRead += int64(read)
                for read%dataChunks != 0 </span><span class="cov8" title="1">{ // pad data with 0s to a multiple of dataChunks
                        databuf[read] = 0
                        read++
                }</span>
                <span class="cov8" title="1">thisChunkSize := read / dataChunks
                for i := range data </span><span class="cov8" title="1">{ // assign data chunks
                        data[i] = databuf[i*thisChunkSize : (i+1)*thisChunkSize]
                }</span>
                <span class="cov8" title="1">if err := enc.Encode(data); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for i := range data </span><span class="cov8" title="1">{
                        if writers[i] != nil &amp;&amp; !failed[i] </span><span class="cov8" title="1">{
                                _, err := writers[i].Write(data[i])
                                if err != nil </span><span class="cov0" title="0">{
                                        failed[i] = true
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func ecReconstruct(dataChunks, parityChunks int, bodies []io.Reader, chunkSize int, contentLength int64, dsts []io.Writer, dstChunkNum []int, logger srv.LowLevelLogger) error <span class="cov0" title="0">{
        logger.Info(fmt.Sprintf("ecReconstruct, dsts: %+v", dsts))
        logger.Info(fmt.Sprintf("ecReconstruct, dstChunkNum: %+v", dstChunkNum))
        enc, err := reedsolomon.New(dataChunks, parityChunks)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">data := make([][]byte, dataChunks+parityChunks)
        databuf := make([]byte, (dataChunks+parityChunks)*chunkSize)
        totalDatabytes := int64(0)
        failed := make([]bool, len(bodies))
        for totalDatabytes &lt; contentLength </span><span class="cov0" title="0">{
                expectedChunkSize := chunkSize
                if contentLength-totalDatabytes &lt; int64(chunkSize*dataChunks) </span><span class="cov0" title="0">{
                        expectedChunkSize = int((contentLength - totalDatabytes) / int64(dataChunks))
                        if (contentLength-totalDatabytes)%int64(dataChunks) != 0 </span><span class="cov0" title="0">{
                                expectedChunkSize++
                        }</span>
                }

                <span class="cov0" title="0">for i := range data </span><span class="cov0" title="0">{
                        if bodies[i] != nil &amp;&amp; !failed[i] </span><span class="cov0" title="0">{
                                data[i] = databuf[i*expectedChunkSize : (i+1)*expectedChunkSize]
                        }</span> else<span class="cov0" title="0"> {
                                // assign a slice with the proper offset and cap with 0 length
                                shardOffset := i * expectedChunkSize
                                data[i] = databuf[shardOffset:shardOffset]
                        }</span>
                }
                <span class="cov0" title="0">for i := range bodies </span><span class="cov0" title="0">{
                        if bodies[i] != nil &amp;&amp; !failed[i] </span><span class="cov0" title="0">{
                                if _, err := io.ReadFull(bodies[i], data[i]); err != nil </span><span class="cov0" title="0">{
                                        data[i] = data[i][:0]
                                }</span>
                        }
                }

                <span class="cov0" title="0">if err := enc.Reconstruct(data); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">for i, dst := range dsts </span><span class="cov0" title="0">{
                        chunkNum := dstChunkNum[i]
                        if _, err := dst.Write(data[chunkNum]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">for i := 0; i &lt; dataChunks; i++ </span><span class="cov0" title="0">{
                        datalen := int64(len(data[i]))
                        if contentLength-totalDatabytes &lt; datalen </span><span class="cov0" title="0">{
                                datalen = contentLength - totalDatabytes
                        }</span>
                        <span class="cov0" title="0">totalDatabytes += datalen</span>
                }
        }
        <span class="cov0" title="0">logger.Info("reconstructed totalDatabytes", zap.Int64("totalDatabytes", totalDatabytes))
        return nil</span>
}

func ecGlue(dataChunks, parityChunks int, bodies []io.Reader, chunkSize int, contentLength int64, dsts ...io.Writer) error <span class="cov0" title="0">{
        enc, err := reedsolomon.New(dataChunks, parityChunks)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">data := make([][]byte, dataChunks+parityChunks)
        databuf := make([]byte, (dataChunks+parityChunks)*chunkSize)
        totalWritten := int64(0)
        failed := make([]bool, len(bodies))
        for totalWritten &lt; contentLength </span><span class="cov0" title="0">{
                expectedChunkSize := chunkSize
                if contentLength-totalWritten &lt; int64(chunkSize*dataChunks) </span><span class="cov0" title="0">{
                        expectedChunkSize = int((contentLength - totalWritten) / int64(dataChunks))
                        if (contentLength-totalWritten)%int64(dataChunks) != 0 </span><span class="cov0" title="0">{
                                expectedChunkSize++
                        }</span>
                }
                <span class="cov0" title="0">for i := range data </span><span class="cov0" title="0">{
                        if bodies[i] != nil &amp;&amp; !failed[i] </span><span class="cov0" title="0">{
                                data[i] = databuf[i*expectedChunkSize : (i+1)*expectedChunkSize]
                        }</span> else<span class="cov0" title="0"> {
                                // assign a slice with the proper offset and cap with 0 length
                                shardOffset := i * expectedChunkSize
                                data[i] = databuf[shardOffset:shardOffset]
                        }</span>
                }
                <span class="cov0" title="0">for i := range bodies </span><span class="cov0" title="0">{
                        if bodies[i] != nil &amp;&amp; !failed[i] </span><span class="cov0" title="0">{
                                if _, err := io.ReadFull(bodies[i], data[i]); err != nil </span><span class="cov0" title="0">{
                                        data[i] = data[i][:0]
                                        failed[i] = true
                                }</span>
                        }
                }
                <span class="cov0" title="0">if err := enc.ReconstructData(data); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">for i := 0; i &lt; dataChunks; i++ </span><span class="cov0" title="0">{
                        if contentLength-totalWritten &lt; int64(len(data[i])) </span><span class="cov0" title="0">{ // strip off any padding
                                data[i] = data[i][:contentLength-totalWritten]
                        }</span>
                        <span class="cov0" title="0">for j, d := range dsts </span><span class="cov0" title="0">{
                                if d != nil </span><span class="cov0" title="0">{
                                        if _, err := d.Write(data[i]); err != nil </span><span class="cov0" title="0">{
                                                dsts[j] = nil
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">totalWritten += int64(len(data[i]))</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package objectserver

import (
        "crypto/md5"
        "database/sql"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "path"
        "strings"
        "time"

        _ "github.com/mattn/go-sqlite3"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/srv"
        "go.uber.org/zap"
)

const (
        shardAny = -1
)

// IndexDBItem is a single item returned by List.
type IndexDBItem struct {
        Hash        string
        Shard       int
        Timestamp   int64
        Metahash    string `json:"-"`
        Nursery     bool
        Metabytes   []byte `json:"-"`
        Deletion    bool
        Path        string
        ShardHash   string
        Restabilize bool
        Expires     *int64
}

// IndexDB will track a set of objects.
//
// This is the "index.db" per disk. Right now it just handles whole objects,
// but eventually we'd like to add either slab support or direct database
// embedding for small objects. But, those details should be transparent from
// users of a IndexDB.
//
// This is different from the standard Swift full replica object tracking in
// that the directory structure is much shallower, there are a configurable
// number of databases per drive instead of a ton of hashes.pkl files, and the
// version tracking / consolidation is much simpler.
//
// The IndexDB stores the newest object contents it knows about and
// discards any older ones, like the standard Swift's .data files. It does not
// have .meta files at all, and certainly not stacked to infinity .meta files.
// Instead the metadata is stored in the database as JSON.
//
// A given IndexDB may not even store any metadata, such as in an EC
// system, with just "key" IndexDBs storing the metadata.
type IndexDB struct {
        dbpath        string
        filepath      string
        RingPartPower uint // GLH: Temp exported for fakelist
        dbPartPower   uint
        subdirs       int
        temppath      string
        reserve       int64
        dbs           []*sql.DB
        logger        srv.LowLevelLogger
        auditor       IndexDBAuditor
}

// NewIndexDB creates a IndexDB to manage a set of objects.
//
// The ringPartPower is defined by the ring in use, but should be greater than
// the dbPartPower. The dbPartPower will define how many
// databases are created (e.g. dbPartPower = 6 gives 64 databases). The
// subdirs value will define how many subdirectories are created where object
// content files are placed.
func NewIndexDB(dbpath, filepath, temppath string, ringPartPower, dbPartPower, subdirs int, reserve int64, logger srv.LowLevelLogger, auditor IndexDBAuditor) (*IndexDB, error) <span class="cov8" title="1">{
        if ringPartPower &lt;= dbPartPower </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ringPartPower must be greater than dbPartPower: %d is not greater than %d", ringPartPower, dbPartPower)
        }</span>
        <span class="cov8" title="1">if subdirs &lt; 1 || subdirs &gt; 256 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("subdirs must be between 1 and 256; it was %d", subdirs)
        }</span>
        <span class="cov8" title="1">ot := &amp;IndexDB{
                dbpath:        dbpath,
                filepath:      filepath,
                temppath:      temppath,
                RingPartPower: uint(ringPartPower),
                dbPartPower:   uint(dbPartPower),
                subdirs:       subdirs,
                dbs:           make([]*sql.DB, 1&lt;&lt;uint(dbPartPower)),
                logger:        logger,
                reserve:       reserve,
                auditor:       auditor,
        }
        err := os.MkdirAll(ot.dbpath, 0700)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = os.MkdirAll(ot.filepath, 0700)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = os.MkdirAll(ot.temppath, 0700)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; 1&lt;&lt;ot.dbPartPower; i++ </span><span class="cov8" title="1">{
                ot.dbs[i], err = sql.Open("sqlite3", "file:"+path.Join(ot.dbpath, fmt.Sprintf("index.db.%02x", i))+"?psow=1&amp;_txlock=immediate&amp;mode=rwc")
                if err == nil </span><span class="cov8" title="1">{
                        ot.dbs[i].SetMaxOpenConns(2)
                        ot.dbs[i].SetMaxIdleConns(2)
                        err = ot.init(i)
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        for j := 0; j &lt; i; j++ </span><span class="cov0" title="0">{
                                ot.dbs[j].Close()
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
        }
        <span class="cov8" title="1">for i := 0; i &lt; ot.subdirs; i++ </span><span class="cov8" title="1">{
                err := os.MkdirAll(path.Join(ot.filepath, fmt.Sprintf("index.db.dir.%02x", i)), 0700)
                if err != nil </span><span class="cov0" title="0">{
                        for j := 0; j &lt; 1&lt;&lt;ot.dbPartPower; j++ </span><span class="cov0" title="0">{
                                ot.dbs[j].Close()
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
        }
        <span class="cov8" title="1">return ot, nil</span>
}

func (ot *IndexDB) init(dbi int) error <span class="cov8" title="1">{
        db := ot.dbs[dbi]
        if _, err := db.Exec(`
        PRAGMA synchronous = NORMAL;
        PRAGMA cache_size = -4096;
        PRAGMA temp_store = MEMORY;
        PRAGMA journal_mode = WAL;
        PRAGMA busy_timeout = 25000;
    `, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        _, err = tx.Exec(`
                CREATE TABLE IF NOT EXISTS objects (
                        hash TEXT NOT NULL,
                        shard INTEGER NOT NULL,
                        timestamp INTEGER NOT NULL,
                        nursery BOOLEAN NOT NULL,
                        deletion BOOLEAN NOT NULL,
                        metahash TEXT, -- NULLable because not everyone stores the metadata
                        metadata TEXT, -- NULLable because not everyone stores the metadata
                        shardhash TEXT, -- NULLable because not every object is a shard
                        restabilize BOOLEAN NOT NULL,
                        expires INTEGER DEFAULT NULL,
                        CONSTRAINT ix_objects_hash_shard_timestamp PRIMARY KEY (hash, shard, timestamp, nursery)
                ) WITHOUT ROWID;
        `)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err = tx.Exec("CREATE INDEX IF NOT EXISTS ix_nursery_items ON objects (nursery) WHERE nursery = 1"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err = tx.Exec("CREATE INDEX IF NOT EXISTS ix_nursery_restabilize_items ON objects (restabilize) WHERE restabilize = 1"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err = tx.Exec("CREATE INDEX IF NOT EXISTS ix_object_expires ON objects(expires) WHERE expires IS NOT NULL"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return tx.Commit()</span>
}

// Close closes all the underlying databases for the IndexDB; you should
// discard the IndexDB instance after this call.
func (ot *IndexDB) Close() <span class="cov8" title="1">{
        for _, db := range ot.dbs </span><span class="cov8" title="1">{
                db.Close()
        }</span>
}

// TempFile returns a temporary file to write to for eventually adding the
// hash:shard to the IndexDB with Commit; may return (nil, nil) if there
// is already a newer or equal timestamp in place for the hash:shard.
func (ot *IndexDB) TempFile(hsh string, shard int, timestamp int64, sizeHint int64, newWriteToNursery bool) (fs.AtomicFileWriter, error) <span class="cov8" title="1">{
        item, err := ot.Lookup(hsh, shard, false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if item != nil &amp;&amp; item.Timestamp &gt;= timestamp </span><span class="cov8" title="1">{
                if item.Timestamp &gt; timestamp || !item.Nursery || newWriteToNursery </span><span class="cov8" title="1">{
                        // quick audit on disk object before returning all clear
                        itemPath, err := ot.WholeObjectPath(
                                item.Hash, item.Shard, item.Timestamp, item.Nursery)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if _, err = ot.auditor.AuditItem(itemPath, item, 0); err != nil </span><span class="cov0" title="0">{
                                if qerr := QuarantineItem(ot, item); qerr != nil </span><span class="cov0" title="0">{
                                        return nil, qerr
                                }</span>
                                <span class="cov0" title="0">return nil, err</span>
                        }
                        <span class="cov8" title="1">return nil, nil</span>
                }
        }
        <span class="cov8" title="1">dir, err := ot.wholeObjectDir(hsh)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">afw, err := fs.NewAtomicFileWriter(ot.temppath, dir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := afw.Preallocate(sizeHint, ot.reserve); err != nil </span><span class="cov0" title="0">{
                afw.Abandon()
                return nil, err
        }</span>
        <span class="cov8" title="1">return afw, nil</span>
}

// Commit moves the temporary file (from TempFile) into place and records its
// information in the database. It may actually discard it completely if there
// is already a newer object information in place for the hash:shard.
//
// Shard is mostly for EC type policies; just use 0 if you're using a full
// replica policy.
//
// Timestamp is the timestamp for the object contents, not necessarily the
// metadata.
func (ot *IndexDB) Commit(f fs.AtomicFileWriter, hsh string, shard int, timestamp int64, method string, metadata map[string]string, nursery bool, shardhash string) error <span class="cov8" title="1">{
        hsh, _, dbPart, _, err := ValidateHash(hsh, ot.RingPartPower, ot.dbPartPower, ot.subdirs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">metabytes := []byte{}
        metahash := ""
        expires := (*string)(nil)

        if len(metadata) &gt; 0 </span><span class="cov8" title="1">{
                metabytes, err = json.Marshal(metadata)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error marshalling metadata: %v", err)
                }</span>
                <span class="cov8" title="1">metahash = MetadataHash(metadata)
                if xda, ok := metadata["X-Delete-At"]; ok </span><span class="cov8" title="1">{
                        expires = &amp;xda
                }</span>
        }

        <span class="cov8" title="1">if f != nil </span><span class="cov8" title="1">{
                if err = f.Sync(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">var tx *sql.Tx
        var rows *sql.Rows
        // Single defer so we can control the order of the tear down.
        defer func() </span><span class="cov8" title="1">{
                if rows != nil </span><span class="cov8" title="1">{
                        rows.Close()
                }</span>
                <span class="cov8" title="1">if tx != nil </span><span class="cov8" title="1">{
                        // If tx.Commit() was already called, this is a No-Op.
                        tx.Rollback()
                }</span>
                <span class="cov8" title="1">if f != nil </span><span class="cov8" title="1">{
                        // If f.Save() was already called, this is a No-Op.
                        f.Abandon()
                }</span>
        }()
        <span class="cov8" title="1">db := ot.dbs[dbPart]
        tx, err = db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">deletion := method == "DELETE"
        rows, err = tx.Query(`
        SELECT timestamp, metahash, metadata, shardhash
        FROM objects
        WHERE hash = ? AND shard = ? AND nursery = ?
        ORDER BY timestamp DESC
    `, hsh, shard, nursery)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">var dbWholeObjectPath string
        var dbTimestamp int64
        if !rows.Next() </span><span class="cov8" title="1">{
                rows.Close()
                if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if f == nil &amp;&amp; !deletion </span><span class="cov0" title="0">{
                        return fmt.Errorf("no existing entry for %s and so refusing to store just a metadata update", hsh)
                }</span>
        } else<span class="cov8" title="1"> {
                var dbMetahash, dbShardHash string
                var dbMetadata []byte
                if err = rows.Scan(&amp;dbTimestamp, &amp;dbMetahash, &amp;dbMetadata, &amp;dbShardHash); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if f == nil &amp;&amp; !deletion </span><span class="cov0" title="0">{
                        // We keep the original file's timestamp if just committing new metadata. (not the x-timestamp header)
                        timestamp = dbTimestamp
                }</span>
                <span class="cov8" title="1">dbWholeObjectPath, err = ot.WholeObjectPath(hsh, shard, dbTimestamp, nursery)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if metahash == dbMetahash &amp;&amp; ((f == nil &amp;&amp; !deletion) || dbTimestamp &gt; timestamp) </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">if shardhash == "" </span><span class="cov0" title="0">{
                        shardhash = dbShardHash
                }</span>
                <span class="cov8" title="1">if metahash != dbMetahash </span><span class="cov0" title="0">{
                        dbMetadataMap := map[string]string{}
                        if err = json.Unmarshal(dbMetadata, &amp;dbMetadataMap); err != nil </span><span class="cov0" title="0">{
                                ot.logger.Error(
                                        "error decoding metadata from db; discarding",
                                        zap.Error(err),
                                        zap.String("hsh", hsh),
                                        zap.Int("shard", shard),
                                        zap.Int64("dbTimestamp", dbTimestamp),
                                        zap.String("dbMetahash", dbMetahash),
                                        zap.Binary("dbMetadata", dbMetadata),
                                )
                        }</span> else<span class="cov0" title="0"> {
                                if f == nil </span><span class="cov0" title="0">{
                                        delete(metadata, "Content-Length")
                                        delete(metadata, "ETag")
                                }</span>
                                <span class="cov0" title="0">metadata = MetadataMerge(metadata, dbMetadataMap)
                                var newMetabytes []byte
                                if newMetabytes, err = json.Marshal(metadata); err != nil </span><span class="cov0" title="0">{
                                        if _, err2 := json.Marshal(dbMetadataMap); err2 != nil </span><span class="cov0" title="0">{
                                                ot.logger.Error(
                                                        "error reencoding metadata from db; discarding",
                                                        zap.Error(err2),
                                                        zap.String("hsh", hsh),
                                                        zap.Int("shard", shard),
                                                        zap.Int64("dbTimestamp", dbTimestamp),
                                                        zap.String("dbMetahash", dbMetahash),
                                                        zap.Binary("dbMetadata", dbMetadata),
                                                        zap.String("metahash", metahash),
                                                        zap.Binary("metadata", metabytes),
                                                )
                                        }</span> else<span class="cov0" title="0"> {
                                                // We return this error because the caller (presumably)
                                                // gave us bad metadata.
                                                return err
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        metahash = MetadataHash(metadata)
                                        metabytes = newMetabytes
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">rows.Close()
        var pth string
        pth, err = ot.WholeObjectPath(hsh, shard, timestamp, nursery)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">restabilize := false
        if dbWholeObjectPath == "" </span><span class="cov8" title="1">{
                _, err = tx.Exec(`
            INSERT INTO objects (hash, shard, timestamp, deletion, metahash, metadata, nursery, shardhash, restabilize, expires)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `, hsh, shard, timestamp, deletion, metahash, metabytes, nursery, shardhash, restabilize, expires)
        }</span> else<span class="cov8" title="1"> {
                if !nursery &amp;&amp; method == "POST" </span><span class="cov0" title="0">{
                        restabilize = true
                }</span>
                <span class="cov8" title="1">_, err = tx.Exec(`
            UPDATE objects
            SET timestamp = ?, deletion = ?, metahash = ?, metadata = ?, nursery = ?, shardhash = ?, restabilize = ?, expires = ?
            WHERE hash = ? AND shard = ? AND nursery = ?
        `, timestamp, deletion, metahash, metabytes, nursery, shardhash, restabilize, expires, hsh, shard, nursery)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">if f != nil </span><span class="cov8" title="1">{
                if err = f.Finalize(pth); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                err = tx.Commit()
        }</span>
        <span class="cov8" title="1">if err == nil &amp;&amp; dbWholeObjectPath != "" &amp;&amp; (f != nil || deletion) &amp;&amp; timestamp &gt; dbTimestamp </span><span class="cov8" title="1">{
                if err2 := os.Remove(dbWholeObjectPath); err2 != nil </span><span class="cov0" title="0">{
                        ot.logger.Error(
                                "error removing older file",
                                zap.Error(err2),
                                zap.String("dbWholeObjectPath", dbWholeObjectPath),
                        )
                }</span>
        }
        <span class="cov8" title="1">return err</span>
}

func (ot *IndexDB) SetStabilized(hsh string, shard int, timestamp int64, stabilizePath bool) error <span class="cov8" title="1">{
        hsh, _, dbPart, _, err := ValidateHash(hsh, ot.RingPartPower, ot.dbPartPower, ot.subdirs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">db := ot.dbs[dbPart]
        tx, err := db.Begin()
        defer tx.Rollback()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">_, err = tx.Exec(`
            UPDATE objects SET nursery = 0, restabilize = 0
                WHERE hash = ? AND shard = ? AND timestamp = ?
                `, hsh, shard, timestamp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if stabilizePath </span><span class="cov8" title="1">{
                var wasPath, toPath string
                if wasPath, err = ot.WholeObjectPath(hsh, shard, timestamp, true); err == nil </span><span class="cov8" title="1">{
                        if toPath, err = ot.WholeObjectPath(hsh, shard, timestamp, false); err == nil </span><span class="cov8" title="1">{
                                err = os.Rename(wasPath, toPath)
                        }</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return tx.Commit()</span>
}

func (ot *IndexDB) wholeObjectDir(hsh string) (string, error) <span class="cov8" title="1">{
        hsh, _, _, dirNm, err := ValidateHash(hsh, ot.RingPartPower, ot.dbPartPower, ot.subdirs)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return path.Join(ot.filepath, fmt.Sprintf("index.db.dir.%02x", dirNm)), nil</span>
}

func (ot *IndexDB) WholeObjectPath(hsh string, shard int, timestamp int64, nursery bool) (string, error) <span class="cov8" title="1">{
        hsh, _, _, dirNm, err := ValidateHash(hsh, ot.RingPartPower, ot.dbPartPower, ot.subdirs)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">if nursery </span><span class="cov8" title="1">{
                return path.Join(ot.filepath, fmt.Sprintf("index.db.dir.%02x/%s.n.%019d", dirNm, hsh, timestamp)), nil
        }</span>
        <span class="cov8" title="1">return path.Join(ot.filepath, fmt.Sprintf("index.db.dir.%02x/%s.%02x.%019d", dirNm, hsh, shard, timestamp)), nil</span>
}

// Remove removes an entry from the database and its backing disk file.
func (ot *IndexDB) Remove(hsh string, shard int, timestamp int64, nursery bool) error <span class="cov8" title="1">{
        hsh, _, dbPart, _, err := ValidateHash(hsh, ot.RingPartPower, ot.dbPartPower, ot.subdirs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">db := ot.dbs[dbPart]
        res, err := db.Exec(`
        DELETE
                FROM objects
        WHERE hash = ? AND shard = ? AND timestamp = ? AND nursery = ?
    `, hsh, shard, timestamp, nursery)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if af, err := res.RowsAffected(); err == nil &amp;&amp; af &gt; 0 </span><span class="cov8" title="1">{
                path, err := ot.WholeObjectPath(hsh, shard, timestamp, nursery)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">os.Remove(path)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Lookup returns the stored information for the hsh and shard.
// Will return (nil, error) if there is an error. (nil, nil) if not found
func (ot *IndexDB) Lookup(hsh string, shard int, justStable bool) (*IndexDBItem, error) <span class="cov8" title="1">{
        var err error
        hsh, _, dbPart, _, err := ValidateHash(hsh, ot.RingPartPower, ot.dbPartPower, ot.subdirs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">db := ot.dbs[dbPart]
        var rows *sql.Rows
        if justStable </span><span class="cov8" title="1">{
                rows, err = db.Query(`
                        SELECT timestamp, deletion, metahash, metadata, nursery, shard, shardhash, restabilize, expires
                        FROM objects
                        WHERE hash = ? AND shard = ? AND nursery = 0
                `, hsh, shard)
        }</span> else<span class="cov8" title="1"> if shard == shardAny </span><span class="cov0" title="0">{
                rows, err = db.Query(`
                        SELECT timestamp, deletion, metahash, metadata, nursery, shard, shardhash, restabilize, expires
                        FROM objects
                        WHERE hash = ? AND metadata IS NOT NULL
                        ORDER BY nursery DESC, shard ASC
                `, hsh)
        }</span> else<span class="cov8" title="1"> {
                rows, err = db.Query(`
                        SELECT timestamp, deletion, metahash, metadata, nursery, shard, shardhash, restabilize, expires
                        FROM objects
                        WHERE hash = ? AND shard = ?
                        ORDER BY nursery DESC
                `, hsh, shard)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        if !rows.Next() </span><span class="cov8" title="1">{
                return nil, rows.Err()
        }</span>
        <span class="cov8" title="1">item := &amp;IndexDBItem{Hash: hsh}
        if err = rows.Scan(&amp;item.Timestamp, &amp;item.Deletion, &amp;item.Metahash,
                &amp;item.Metabytes, &amp;item.Nursery, &amp;item.Shard, &amp;item.ShardHash, &amp;item.Restabilize, &amp;item.Expires); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">item.Path, err = ot.WholeObjectPath(item.Hash, item.Shard, item.Timestamp, item.Nursery)
        return item, err</span>
}

// ListObjectsToStabilize lists all objects that are in the nursery or set to restabilzed
func (ot *IndexDB) ListObjectsToStabilize() ([]*IndexDBItem, error) <span class="cov8" title="1">{
        listing := []*IndexDBItem{}
        for _, db := range ot.dbs </span><span class="cov8" title="1">{
                if err := func() error </span><span class="cov8" title="1">{
                        rows, err := db.Query(`
                                SELECT hash, shard, timestamp, deletion, metahash, metadata, nursery, restabilize, expires
                                FROM objects
                                WHERE nursery = 1 OR restabilize = 1`)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">defer rows.Close()
                        for rows.Next() </span><span class="cov0" title="0">{
                                item := &amp;IndexDBItem{}
                                if err = rows.Scan(&amp;item.Hash, &amp;item.Shard, &amp;item.Timestamp, &amp;item.Deletion, &amp;item.Metahash,
                                        &amp;item.Metabytes, &amp;item.Nursery, &amp;item.Restabilize, &amp;item.Expires); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">item.Path, err = ot.WholeObjectPath(item.Hash, item.Shard, item.Timestamp, item.Nursery)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">listing = append(listing, item)</span>
                        }
                        <span class="cov8" title="1">return rows.Err()</span>
                }(); err != nil <span class="cov0" title="0">{
                        return listing, err
                }</span>
        }
        <span class="cov8" title="1">return listing, nil</span>
}

// List returns the items for the ringPart given.
//
// This is for replication, auditing, that sort of thing.
// NOTE: List does not populate item.Path for some reason- maybe
// size of listing? Maybe we should change that later.
func (ot *IndexDB) List(startHash, stopHash, marker string, limit int) ([]*IndexDBItem, error) <span class="cov8" title="1">{
        if startHash == "" </span><span class="cov8" title="1">{
                startHash = "00000000000000000000000000000000"
        }</span>
        <span class="cov8" title="1">if stopHash == "" </span><span class="cov8" title="1">{
                stopHash = "ffffffffffffffffffffffffffffffff"
        }</span>
        <span class="cov8" title="1">_, _, startDBPart, _, err := ValidateHash(startHash, ot.RingPartPower, ot.dbPartPower, ot.subdirs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">_, _, stopDBPart, _, err := ValidateHash(stopHash, ot.RingPartPower, ot.dbPartPower, ot.subdirs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">listing := []*IndexDBItem{}
        for dbPart := startDBPart; dbPart &lt;= stopDBPart; dbPart++ </span><span class="cov8" title="1">{
                db := ot.dbs[dbPart]
                var rows *sql.Rows
                if limit &gt; 0 </span><span class="cov8" title="1">{
                        rows, err = db.Query(`
                                SELECT hash, shard, timestamp, deletion, metahash, metadata, nursery, shardhash, restabilize, expires
                        FROM objects
                        WHERE hash BETWEEN ? AND ? AND hash &gt; ?
                        ORDER BY hash
                        LIMIT ?
                    `, startHash, stopHash, marker, limit)
                }</span> else<span class="cov8" title="1"> {
                        rows, err = db.Query(`
                                SELECT hash, shard, timestamp, deletion, metahash, metadata, nursery, shardhash, restabilize, expires
                        FROM objects
                        WHERE hash BETWEEN ? AND ? AND hash &gt; ?
                        ORDER BY hash
                    `, startHash, stopHash, marker)
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                        item := &amp;IndexDBItem{}
                        if err = rows.Scan(&amp;item.Hash, &amp;item.Shard, &amp;item.Timestamp, &amp;item.Deletion, &amp;item.Metahash,
                                &amp;item.Metabytes, &amp;item.Nursery, &amp;item.ShardHash, &amp;item.Restabilize, &amp;item.Expires); err != nil </span><span class="cov0" title="0">{
                                return listing, err
                        }</span>
                        <span class="cov8" title="1">listing = append(listing, item)</span>
                }
                <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                        return listing, err
                }</span>
        }
        <span class="cov8" title="1">return listing, nil</span>
}

func (ot *IndexDB) ExpireObjects() error <span class="cov8" title="1">{
        type result struct {
                hash      string
                timestamp int64
                shard     int
                nursery   bool
        }
        for dbIndex, db := range ot.dbs </span><span class="cov8" title="1">{
                rows, err := db.Query("SELECT hash, shard, timestamp, nursery FROM objects WHERE expires &lt; ?", time.Now().Unix())
                if err != nil </span><span class="cov0" title="0">{
                        ot.logger.Error("database error", zap.Error(err), zap.Int("db", dbIndex))
                        return err
                }</span>
                <span class="cov8" title="1">defer rows.Close()
                remove := []result{}
                for i := 0; rows.Next(); i++ </span><span class="cov8" title="1">{
                        var r result
                        if err = rows.Scan(&amp;r.hash, &amp;r.shard, &amp;r.timestamp, &amp;r.nursery); err != nil </span><span class="cov0" title="0">{
                                ot.logger.Error("database error", zap.Error(err), zap.Int("db", dbIndex))
                                return err
                        }</span>
                        <span class="cov8" title="1">if path, err := ot.WholeObjectPath(r.hash, r.shard, r.timestamp, r.nursery); err == nil </span><span class="cov8" title="1">{
                                if err := os.Remove(path); err == nil || os.IsNotExist(err) </span><span class="cov8" title="1">{
                                        remove = append(remove, r)
                                }</span> else<span class="cov0" title="0"> {
                                        ot.logger.Error("remove error", zap.Error(err), zap.String("path", path))
                                }</span>
                        }
                }
                <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                        ot.logger.Error("database error", zap.Error(err), zap.Int("db", dbIndex))
                        return err
                }</span>
                <span class="cov8" title="1">rows.Close()

                if len(remove) &gt; 0 </span><span class="cov8" title="1">{
                        tx, err := db.Begin()
                        if err != nil </span><span class="cov0" title="0">{
                                ot.logger.Error("database error", zap.Error(err), zap.Int("db", dbIndex))
                                return err
                        }</span>
                        <span class="cov8" title="1">defer tx.Rollback()
                        for _, r := range remove </span><span class="cov8" title="1">{
                                if _, err := tx.Exec("DELETE FROM objects WHERE hash=? AND shard=? AND timestamp=? AND nursery=?",
                                        r.hash, r.shard, r.timestamp, r.nursery); err != nil </span><span class="cov0" title="0">{
                                        ot.logger.Error("database error", zap.Error(err), zap.Int("db", dbIndex))
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                                ot.logger.Error("database error", zap.Error(err), zap.Int("db", dbIndex))
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func ValidateHash(hsh string, ringPartPower, dbPartPower uint, subdirs int) (hshOut string, ringPart, dbPart, dirNm int, err error) <span class="cov8" title="1">{
        hsh = strings.ToLower(hsh)
        if len(hsh) != 32 </span><span class="cov0" title="0">{
                return "", 0, 0, 0, fmt.Errorf("invalid hash %q; length was %d not 32", hsh, len(hsh))
        }</span>
        <span class="cov8" title="1">hashBytes, err := hex.DecodeString(hsh)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, 0, 0, fmt.Errorf("invalid hash %q; decoding error: %s", hsh, err)
        }</span>
        <span class="cov8" title="1">upper := uint64(hashBytes[0])&lt;&lt;24 | uint64(hashBytes[1])&lt;&lt;16 | uint64(hashBytes[2])&lt;&lt;8 | uint64(hashBytes[3])
        return hsh, int(upper &gt;&gt; (32 - ringPartPower)), int(hashBytes[0] &gt;&gt; (8 - dbPartPower)), int(hashBytes[15]) % subdirs, nil</span>
}

func (ot *IndexDB) RingPartRange(ringPart int) (string, string) <span class="cov8" title="1">{
        start := uint64(ringPart &lt;&lt; (64 - ot.RingPartPower))
        stop := uint64((ringPart+1)&lt;&lt;(64-ot.RingPartPower)) - 1
        return fmt.Sprintf("%016x0000000000000000", start), fmt.Sprintf("%016xffffffffffffffff", stop)
}</span>

func (ot *IndexDB) StablePut(hsh string, shardIndex int, request *http.Request) (int, error) <span class="cov0" title="0">{

        timestampTime, err := common.ParseDate(request.Header.Get("Meta-X-Timestamp"))
        if err != nil </span><span class="cov0" title="0">{
                return http.StatusBadRequest, err
        }</span>
        <span class="cov0" title="0">timestamp := timestampTime.UnixNano()
        atm, err := ot.TempFile(hsh, shardIndex, timestamp, request.ContentLength, false)
        if err != nil </span><span class="cov0" title="0">{
                return http.StatusInternalServerError, err
        }</span>
        <span class="cov0" title="0">if atm == nil </span><span class="cov0" title="0">{
                ot.logger.Debug("could not make a tempfile", zap.String("hash", hsh))
                return http.StatusConflict, nil
        }</span>
        <span class="cov0" title="0">defer atm.Abandon()
        metadata := make(map[string]string)
        for key := range request.Header </span><span class="cov0" title="0">{
                if strings.HasPrefix(key, "Meta-") </span><span class="cov0" title="0">{
                        if key == "Meta-Name" </span><span class="cov0" title="0">{
                                metadata["name"] = request.Header.Get(key)
                        }</span> else<span class="cov0" title="0"> if key == "Meta-Etag" </span><span class="cov0" title="0">{
                                metadata["ETag"] = request.Header.Get(key)
                        }</span> else<span class="cov0" title="0"> {
                                metadata[http.CanonicalHeaderKey(key[5:])] = request.Header.Get(key)
                        }</span>
                }
        }

        <span class="cov0" title="0">sHash := md5.New() // TODO: this is wasteful to calc this for whole objects
        n, err := common.Copy(request.Body, atm, sHash)
        if err == io.ErrUnexpectedEOF || (request.ContentLength &gt;= 0 &amp;&amp; n != request.ContentLength) </span><span class="cov0" title="0">{
                return 499, err
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return http.StatusInternalServerError, err
        }</span>
        <span class="cov0" title="0">shardHash := hex.EncodeToString(sHash.Sum(nil))
        if err := ot.Commit(atm, hsh, shardIndex, timestamp, "PUT", metadata, false, shardHash); err != nil </span><span class="cov0" title="0">{
                return http.StatusInternalServerError, err
        }</span>
        <span class="cov0" title="0">return http.StatusCreated, nil</span>
}

func (ot *IndexDB) StablePost(hsh string, shardIndex int, request *http.Request) (int, error) <span class="cov0" title="0">{
        item, err := ot.Lookup(hsh, shardIndex, false)
        if err != nil || item == nil || item.Deletion </span><span class="cov0" title="0">{
                return http.StatusNotFound, err
        }</span>
        <span class="cov0" title="0">timestampTime, err := common.ParseDate(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov0" title="0">{
                return http.StatusBadRequest, fmt.Errorf("invalid timestamp")
        }</span>
        <span class="cov0" title="0">timestamp := timestampTime.UnixNano()
        if timestamp &lt;= item.Timestamp </span><span class="cov0" title="0">{
                return http.StatusConflict, nil
        }</span>
        <span class="cov0" title="0">metadata := make(map[string]string)
        for key := range request.Header </span><span class="cov0" title="0">{
                if strings.HasPrefix(key, "Meta-") </span><span class="cov0" title="0">{
                        if key == "Meta-Name" </span><span class="cov0" title="0">{
                                metadata["name"] = request.Header.Get(key)
                        }</span> else<span class="cov0" title="0"> if key == "Meta-Etag" </span><span class="cov0" title="0">{
                                metadata["ETag"] = request.Header.Get(key)
                        }</span> else<span class="cov0" title="0"> {
                                metadata[http.CanonicalHeaderKey(key[5:])] = request.Header.Get(key)
                        }</span>
                }
        }
        <span class="cov0" title="0">if err = ot.Commit(nil, hsh, shardIndex, timestamp, "POST", metadata, false, ""); err != nil </span><span class="cov0" title="0">{
                return http.StatusInternalServerError, err
        }</span>
        <span class="cov0" title="0">return http.StatusAccepted, nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package objectserver

import (
        "crypto/md5"
        "encoding/hex"
        "flag"
        "fmt"
        "io"
        "net"
        "net/http"
        _ "net/http/pprof"
        "net/textproto"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/justinas/alice"
        opentracing "github.com/opentracing/opentracing-go"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/troubling/hummingbird/client"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/common/tracing"
        "github.com/troubling/hummingbird/middleware"
        "github.com/uber-go/tally"
        promreporter "github.com/uber-go/tally/prometheus"
        "go.uber.org/zap"
        "golang.org/x/net/http2"
)

type ObjectServer struct {
        driveRoot          string
        hashPathPrefix     string
        hashPathSuffix     string
        reconCachePath     string
        checkEtags         bool
        checkMounts        bool
        allowedHeaders     map[string]bool
        logger             srv.LowLevelLogger
        logLevel           zap.AtomicLevel
        diskInUse          *common.KeyedLimit
        accountDiskInUse   *common.KeyedLimit
        expiringDivisor    int64
        updateClient       common.HTTPClient
        objEngines         map[int]ObjectEngine
        updateTimeout      time.Duration
        asyncWG            sync.WaitGroup // Used to wait on async goroutines
        metricsCloser      io.Closer
        traceCloser        io.Closer
        tracer             opentracing.Tracer
        updateClientCloser io.Closer
}

func (server *ObjectServer) Type() string <span class="cov0" title="0">{
        return "object"
}</span>

func (server *ObjectServer) Background(flags *flag.FlagSet) chan struct{} <span class="cov0" title="0">{
        return nil
}</span>

func (server *ObjectServer) Finalize() <span class="cov0" title="0">{
        server.asyncWG.Wait()
        if server.metricsCloser != nil </span><span class="cov0" title="0">{
                server.metricsCloser.Close()
        }</span>
        <span class="cov0" title="0">if server.traceCloser != nil </span><span class="cov0" title="0">{
                server.traceCloser.Close()
        }</span>
        <span class="cov0" title="0">if server.updateClientCloser != nil </span><span class="cov0" title="0">{
                server.updateClientCloser.Close()
        }</span>
}

func (server *ObjectServer) newObject(req *http.Request, vars map[string]string, needData bool) (Object, error) <span class="cov8" title="1">{
        policy, err := strconv.Atoi(req.Header.Get("X-Backend-Storage-Policy-Index"))
        if err != nil </span><span class="cov8" title="1">{
                policy = 0
        }</span>
        <span class="cov8" title="1">engine, ok := server.objEngines[policy]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Engine for policy index %d not found.", policy)
        }</span>
        <span class="cov8" title="1">return engine.New(vars, needData, &amp;server.asyncWG)</span>
}

func resolveEtag(req *http.Request, metadata map[string]string) string <span class="cov8" title="1">{
        etag := metadata["ETag"]
        for _, ph := range strings.Split(req.Header.Get("X-Backend-Etag-Is-At"), ",") </span><span class="cov8" title="1">{
                ph = strings.Trim(ph, " ")
                if altEtag, exists := metadata[http.CanonicalHeaderKey(ph)]; exists &amp;&amp; ph != "" </span><span class="cov0" title="0">{
                        etag = altEtag
                }</span>
        }
        <span class="cov8" title="1">return etag</span>
}

func (server *ObjectServer) ObjGetHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        headers := writer.Header()
        obj, err := server.newObject(request, vars, request.Method == "GET")
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to open object.", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer obj.Close()

        ifMatches := common.ParseIfMatch(request.Header.Get("If-Match"))
        ifNoneMatches := common.ParseIfMatch(request.Header.Get("If-None-Match"))

        metadata := obj.Metadata()
        headers.Set("X-Backend-Timestamp", metadata["X-Timestamp"])
        headers.Set("X-Backend-Data-Timestamp", metadata["X-Backend-Data-Timestamp"])
        headers.Set("X-Backend-Meta-Timestamp", metadata["X-Backend-Meta-Timestamp"])
        if !obj.Exists() </span><span class="cov8" title="1">{
                if ifMatches["*"] </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, http.StatusPreconditionFailed)
                }</span> else<span class="cov8" title="1"> {
                        srv.StandardResponse(writer, http.StatusNotFound)
                }</span>
                <span class="cov8" title="1">return</span>
        }
        <span class="cov8" title="1">etag := resolveEtag(request, metadata)

        if Expired(metadata) </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span>

        <span class="cov8" title="1">lastModified, err := common.ParseDate(metadata["X-Timestamp"])
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error getting timestamp",
                        zap.String("timestamp", metadata["X-Timestamp"]), zap.String("obj", obj.Repr()), zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">headers.Set("Last-Modified", common.FormatLastModified(lastModified))
        headers.Set("ETag", "\""+etag+"\"")
        xTimestamp, err := common.GetEpochFromTimestamp(metadata["X-Timestamp"])
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error getting the epoch time from x-timestamp", zap.Error(err))
                http.Error(writer, "Invalid X-Timestamp header", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">headers.Set("X-Timestamp", xTimestamp)
        for key, value := range metadata </span><span class="cov8" title="1">{
                if allowed, ok := server.allowedHeaders[key]; (ok &amp;&amp; allowed) ||
                        strings.HasPrefix(key, "X-Object-Meta-") ||
                        strings.HasPrefix(key, "X-Object-Sysmeta-") </span><span class="cov8" title="1">{
                        headers.Set(key, value)
                }</span>
        }

        <span class="cov8" title="1">if len(ifMatches) &gt; 0 &amp;&amp; !ifMatches[etag] &amp;&amp; !ifMatches["*"] </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusPreconditionFailed)
                return
        }</span>

        <span class="cov8" title="1">if len(ifNoneMatches) &gt; 0 &amp;&amp; (ifNoneMatches[etag] || ifNoneMatches["*"]) </span><span class="cov0" title="0">{
                writer.WriteHeader(http.StatusNotModified)
                return
        }</span>

        <span class="cov8" title="1">if ius, err := common.ParseDate(request.Header.Get("If-Unmodified-Since")); err == nil &amp;&amp; lastModified.After(ius) </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusPreconditionFailed)
                return
        }</span>

        <span class="cov8" title="1">if ims, err := common.ParseDate(request.Header.Get("If-Modified-Since")); err == nil &amp;&amp; lastModified.Before(ims) </span><span class="cov0" title="0">{
                writer.WriteHeader(http.StatusNotModified)
                return
        }</span>

        <span class="cov8" title="1">headers.Set("Accept-Ranges", "bytes")
        headers.Set("Content-Type", metadata["Content-Type"])
        headers.Set("Content-Length", metadata["Content-Length"])

        if rangeHeader := request.Header.Get("Range"); rangeHeader != "" </span><span class="cov8" title="1">{
                ranges, err := common.ParseRange(rangeHeader, obj.ContentLength())
                if err != nil </span><span class="cov8" title="1">{
                        headers.Set("Content-Length", "0")
                        headers.Set("Content-Range", fmt.Sprintf("bytes */%d", obj.ContentLength()))
                        writer.WriteHeader(http.StatusRequestedRangeNotSatisfiable)
                        return
                }</span> else<span class="cov8" title="1"> if ranges != nil &amp;&amp; len(ranges) == 1 </span><span class="cov8" title="1">{
                        headers.Set("Content-Length", strconv.FormatInt(int64(ranges[0].End-ranges[0].Start), 10))
                        headers.Set("Content-Range", fmt.Sprintf("bytes %d-%d/%d", ranges[0].Start, ranges[0].End-1, obj.ContentLength()))
                        writer.WriteHeader(http.StatusPartialContent)
                        obj.CopyRange(writer, ranges[0].Start, ranges[0].End)
                        return
                }</span> else<span class="cov8" title="1"> if ranges != nil &amp;&amp; len(ranges) &gt; 1 </span><span class="cov8" title="1">{
                        w := common.NewMultiWriter(writer, metadata["Content-Type"], obj.ContentLength())
                        for _, rng := range ranges </span><span class="cov8" title="1">{
                                w.Expect(rng.Start, rng.End)
                        }</span>
                        <span class="cov8" title="1">headers.Set("Content-Length", strconv.FormatInt(w.ContentLength(), 10))
                        headers.Set("Content-Type", "multipart/byteranges;boundary="+w.Boundary())
                        writer.WriteHeader(http.StatusPartialContent)
                        for _, rng := range ranges </span><span class="cov8" title="1">{
                                part, err := w.CreatePart(rng.Start, rng.End)
                                if err != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov8" title="1">obj.CopyRange(part, rng.Start, rng.End)</span>
                        }
                        <span class="cov8" title="1">w.Close()
                        return</span>
                }
        }
        <span class="cov8" title="1">writer.WriteHeader(http.StatusOK)
        if request.Method == "GET" </span><span class="cov8" title="1">{
                if server.checkEtags </span><span class="cov0" title="0">{
                        hash := md5.New()
                        _, err := obj.Copy(writer, hash)
                        if err != nil </span><span class="cov0" title="0">{
                                srv.GetLogger(request).Error("Error copying body", zap.Error(err))
                        }</span> else<span class="cov0" title="0"> if hex.EncodeToString(hash.Sum(nil)) != metadata["ETag"] </span><span class="cov0" title="0">{
                                obj.Quarantine()
                        }</span>
                } else<span class="cov8" title="1"> {
                        _, err := obj.Copy(writer)
                        if err != nil </span><span class="cov0" title="0">{
                                srv.GetLogger(request).Error("Error copying body", zap.Error(err))
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                writer.Write([]byte{})
        }</span>
}

func (server *ObjectServer) ObjPutHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        outHeaders := writer.Header()

        requestTimestamp, err := common.StandardizeTimestamp(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov8" title="1">{
                srv.GetLogger(request).Error("Error standardizing request X-Timestamp", zap.Error(err))
                http.Error(writer, "Invalid X-Timestamp header", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if vars["obj"] == "" </span><span class="cov0" title="0">{
                http.Error(writer, fmt.Sprintf("Invalid path: %s", request.URL.Path), http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if request.Header.Get("Content-Type") == "" </span><span class="cov0" title="0">{
                http.Error(writer, "No content type", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if deleteAt := request.Header.Get("X-Delete-At"); deleteAt != "" </span><span class="cov8" title="1">{
                if deleteTime, err := common.ParseDate(deleteAt); err != nil || deleteTime.Before(time.Now()) </span><span class="cov0" title="0">{
                        http.Error(writer, "X-Delete-At in past", 400)
                        return
                }</span>
        }

        <span class="cov8" title="1">obj, err := server.newObject(request, vars, false)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error getting obj", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer obj.Close()

        if obj.Exists() </span><span class="cov0" title="0">{
                if inm := request.Header.Get("If-None-Match"); inm == "*" </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, http.StatusPreconditionFailed)
                        return
                }</span>
                <span class="cov0" title="0">metadata := obj.Metadata()
                if requestTime, err := common.ParseDate(requestTimestamp); err == nil </span><span class="cov0" title="0">{
                        if lastModified, err := common.ParseDate(metadata["X-Timestamp"]); err == nil &amp;&amp; !requestTime.After(lastModified) </span><span class="cov0" title="0">{
                                outHeaders.Set("X-Backend-Timestamp", metadata["X-Timestamp"])
                                srv.StandardResponse(writer, http.StatusConflict)
                                return
                        }</span>
                }
                <span class="cov0" title="0">if inm := request.Header.Get("If-None-Match"); inm != "*" &amp;&amp; strings.Contains(inm, metadata["ETag"]) </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, http.StatusPreconditionFailed)
                        return
                }</span>
        }

        <span class="cov8" title="1">tempFile, err := obj.SetData(request.ContentLength)
        if err == DriveFullError </span><span class="cov0" title="0">{
                srv.GetLogger(request).Debug("Not enough space available")
                srv.CustomErrorResponse(writer, 507, vars)
                return
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error making new file", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">hash := md5.New()
        totalSize, err := common.Copy(request.Body, tempFile, hash)
        if err == io.ErrUnexpectedEOF || (request.ContentLength &gt;= 0 &amp;&amp; totalSize != request.ContentLength) </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, 499)
                return
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error writing to file", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">metadata := map[string]string{
                "name":           "/" + vars["account"] + "/" + vars["container"] + "/" + vars["obj"],
                "X-Timestamp":    requestTimestamp,
                "Content-Type":   request.Header.Get("Content-Type"),
                "Content-Length": strconv.FormatInt(totalSize, 10),
                "ETag":           hex.EncodeToString(hash.Sum(nil)),
        }
        for key := range request.Header </span><span class="cov8" title="1">{
                if allowed, ok := server.allowedHeaders[key]; (ok &amp;&amp; allowed) ||
                        strings.HasPrefix(key, "X-Object-Meta-") ||
                        strings.HasPrefix(key, "X-Object-Sysmeta-") </span><span class="cov8" title="1">{
                        metadata[key] = request.Header.Get(key)
                }</span>
        }
        <span class="cov8" title="1">requestEtag := strings.Trim(strings.ToLower(request.Header.Get("ETag")), "\"")
        if requestEtag != "" &amp;&amp; requestEtag != metadata["ETag"] </span><span class="cov8" title="1">{
                http.Error(writer, "Unprocessable Entity", 422)
                return
        }</span>
        <span class="cov8" title="1">outHeaders.Set("ETag", metadata["ETag"])

        if err := obj.Commit(metadata); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error saving object", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">server.containerUpdates(writer, request, metadata, request.Header.Get("X-Delete-At"), vars, srv.GetLogger(request))
        srv.StandardResponse(writer, http.StatusCreated)</span>
}

func (server *ObjectServer) ObjPostHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)

        requestTimestamp, err := common.StandardizeTimestamp(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error standardizing request X-Timestamp", zap.Error(err))
                http.Error(writer, "Invalid X-Timestamp header", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if vars["obj"] == "" </span><span class="cov0" title="0">{
                http.Error(writer, fmt.Sprintf("Invalid path: %s", request.URL.Path), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">obj, err := server.newObject(request, vars, false)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error getting obj", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer obj.Close()
        if !obj.Exists() </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span>

        <span class="cov8" title="1">origMetadata := obj.Metadata()
        if requestTime, err := common.ParseDate(requestTimestamp); err == nil </span><span class="cov8" title="1">{
                if origLastModified, err := common.ParseDate(origMetadata["X-Timestamp"]); err == nil &amp;&amp; !requestTime.After(origLastModified) </span><span class="cov0" title="0">{
                        writer.Header().Set("X-Backend-Timestamp", origMetadata["X-Timestamp"])
                        srv.StandardResponse(writer, http.StatusConflict)
                        return
                }</span>
        }
        <span class="cov8" title="1">if t := request.Header.Get("X-Delete-At"); t != "" &amp;&amp; t != origMetadata["X-Delete-At"] </span><span class="cov0" title="0">{
                http.Error(writer, fmt.Sprintf("X-Delete-At may not be sent with object POST: %q", t), http.StatusConflict)
                return
        }</span>
        <span class="cov8" title="1">if t := request.Header.Get("Content-Type"); t != "" &amp;&amp; t != origMetadata["Content-Type"] </span><span class="cov8" title="1">{
                http.Error(writer, fmt.Sprintf("Content-Type may not be sent with object POST: %q", t), http.StatusConflict)
                return
        }</span>

        <span class="cov8" title="1">metadata := make(map[string]string)
        if v, ok := origMetadata["X-Static-Large-Object"]; ok </span><span class="cov0" title="0">{
                metadata["X-Static-Large-Object"] = v
        }</span>
        <span class="cov8" title="1">if v, ok := origMetadata["Ec-Scheme"]; ok </span><span class="cov0" title="0">{
                metadata["Ec-Scheme"] = v
        }</span>
        <span class="cov8" title="1">copyHdrs := map[string]bool{"Content-Disposition": true, "Content-Encoding": true, "X-Delete-At": true, "X-Object-Manifest": true, "X-Static-Large-Object": true}
        for _, v := range strings.Fields(request.Header.Get("X-Backend-Replication-Headers")) </span><span class="cov0" title="0">{
                copyHdrs[v] = true
        }</span>
        <span class="cov8" title="1">for key := range request.Header </span><span class="cov8" title="1">{
                if allowed, ok := server.allowedHeaders[key]; (ok &amp;&amp; allowed) ||
                        copyHdrs[key] ||
                        strings.HasPrefix(key, "X-Object-Meta-") ||
                        strings.HasPrefix(key, "X-Object-Transient-Sysmeta-") </span><span class="cov8" title="1">{
                        metadata[key] = request.Header.Get(key)
                }</span>
        }
        <span class="cov8" title="1">metadata["name"] = "/" + vars["account"] + "/" + vars["container"] + "/" + vars["obj"]
        metadata["X-Timestamp"] = requestTimestamp

        if err := obj.CommitMetadata(metadata); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error saving object meta file", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">srv.StandardResponse(writer, http.StatusAccepted)</span>
}

func (server *ObjectServer) ObjDeleteHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        headers := writer.Header()
        requestTimestamp, err := common.StandardizeTimestamp(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error standardizing request X-Timestamp", zap.Error(err))
                http.Error(writer, "Invalid X-Timestamp header", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">responseStatus := http.StatusNotFound

        obj, err := server.newObject(request, vars, false)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error getting obj", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer obj.Close()

        if ida := request.Header.Get("X-If-Delete-At"); ida != "" </span><span class="cov8" title="1">{
                _, err = strconv.ParseInt(ida, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">if !obj.Exists() </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, http.StatusPreconditionFailed)
                        return
                }</span>
                <span class="cov8" title="1">metadata := obj.Metadata()
                if _, ok := metadata["X-Delete-At"]; ok </span><span class="cov8" title="1">{
                        if ida != metadata["X-Delete-At"] </span><span class="cov0" title="0">{
                                srv.StandardResponse(writer, http.StatusPreconditionFailed)
                                return
                        }</span>
                } else<span class="cov8" title="1"> {
                        srv.StandardResponse(writer, http.StatusPreconditionFailed)
                        return
                }</span>
        }

        <span class="cov8" title="1">deleteAt := ""
        if obj.Exists() </span><span class="cov8" title="1">{
                responseStatus = http.StatusNoContent
                metadata := obj.Metadata()
                if xda, ok := metadata["X-Delete-At"]; ok </span><span class="cov8" title="1">{
                        deleteAt = xda
                }</span>
                <span class="cov8" title="1">if origTimestamp, ok := metadata["X-Timestamp"]; ok &amp;&amp; origTimestamp &gt;= requestTimestamp </span><span class="cov0" title="0">{
                        headers.Set("X-Backend-Timestamp", origTimestamp)
                        srv.StandardResponse(writer, http.StatusConflict)
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                responseStatus = http.StatusNotFound
        }</span>

        <span class="cov8" title="1">metadata := map[string]string{
                "X-Timestamp": requestTimestamp,
                "name":        "/" + vars["account"] + "/" + vars["container"] + "/" + vars["obj"],
        }
        if err := obj.Delete(metadata); err == DriveFullError </span><span class="cov0" title="0">{
                srv.GetLogger(request).Debug("Not enough space available")
                srv.CustomErrorResponse(writer, 507, vars)
                return
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Error deleting object", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">headers.Set("X-Backend-Timestamp", metadata["X-Timestamp"])
        server.containerUpdates(writer, request, metadata, deleteAt, vars, srv.GetLogger(request))
        srv.StandardResponse(writer, responseStatus)</span>
}

func (server *ObjectServer) HealthcheckHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        writer.Header().Set("Content-Length", "2")
        writer.WriteHeader(http.StatusOK)
        writer.Write([]byte("OK"))
        return
}</span>

func (server *ObjectServer) ReconHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        middleware.ReconHandler(server.driveRoot, server.reconCachePath, server.checkMounts, writer, request)
        return
}</span>

func (server *ObjectServer) OptionsHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        middleware.OptionsHandler("object-server", writer, request)
        return
}</span>

func (server *ObjectServer) DiskUsageHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        data, err := server.diskInUse.MarshalJSON()
        if err == nil </span><span class="cov0" title="0">{
                writer.WriteHeader(http.StatusOK)
                writer.Write(data)
        }</span> else<span class="cov0" title="0"> {
                writer.WriteHeader(http.StatusInternalServerError)
                writer.Write([]byte(err.Error()))
        }</span>
        <span class="cov0" title="0">return</span>
}

func (server *ObjectServer) LogRequest(next http.Handler) http.Handler <span class="cov8" title="1">{
        return srv.LogRequest(server.logger, next)
}</span>

func (server *ObjectServer) AcquireDevice(next http.Handler) http.Handler <span class="cov8" title="1">{
        fn := func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                vars := srv.GetVars(request)
                if device, ok := vars["device"]; ok &amp;&amp; device != "" </span><span class="cov8" title="1">{
                        devicePath := filepath.Join(server.driveRoot, device)
                        if server.checkMounts </span><span class="cov0" title="0">{
                                if mounted, err := fs.IsMount(devicePath); err != nil || mounted != true </span><span class="cov0" title="0">{
                                        vars["Method"] = request.Method
                                        srv.CustomErrorResponse(writer, 507, vars)
                                        return
                                }</span>
                        }

                        <span class="cov8" title="1">forceAcquire := request.Header.Get("X-Force-Acquire") == "true"
                        if concRequests := server.diskInUse.Acquire(device, forceAcquire); concRequests != 0 </span><span class="cov8" title="1">{
                                writer.Header().Set("X-Disk-Usage", strconv.FormatInt(concRequests, 10))
                                srv.StandardResponse(writer, 503)
                                return
                        }</span>
                        <span class="cov8" title="1">defer server.diskInUse.Release(device)

                        if account, ok := vars["account"]; ok &amp;&amp; account != "" </span><span class="cov8" title="1">{
                                limitKey := fmt.Sprintf("%s/%s", device, account)
                                if concRequests := server.accountDiskInUse.Acquire(limitKey, false); concRequests != 0 </span><span class="cov8" title="1">{
                                        srv.StandardResponse(writer, 498)
                                        return
                                }</span>
                                <span class="cov8" title="1">defer server.accountDiskInUse.Release(limitKey)</span>
                        }
                }
                <span class="cov8" title="1">next.ServeHTTP(writer, request)</span>
        }
        <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
}

func (server *ObjectServer) updateDeviceLocks(seconds int64) <span class="cov0" title="0">{
        reloadTime := time.Duration(seconds) * time.Second
        for </span><span class="cov0" title="0">{
                time.Sleep(reloadTime)
                for _, key := range server.diskInUse.Keys() </span><span class="cov0" title="0">{
                        lockPath := filepath.Join(server.driveRoot, key, "lock_device")
                        if fs.Exists(lockPath) </span><span class="cov0" title="0">{
                                server.diskInUse.Lock(key)
                        }</span> else<span class="cov0" title="0"> {
                                server.diskInUse.Unlock(key)
                        }</span>
                }
        }
}

func (server *ObjectServer) GetHandler(config conf.Config, metricsPrefix string) http.Handler <span class="cov8" title="1">{
        var metricsScope tally.Scope
        metricsScope, server.metricsCloser = tally.NewRootScope(tally.ScopeOptions{
                Prefix:         metricsPrefix,
                Tags:           map[string]string{},
                CachedReporter: promreporter.NewReporter(promreporter.Options{}),
                Separator:      promreporter.DefaultSeparator,
        }, time.Second)
        commonHandlers := alice.New(
                middleware.NewDebugResponses(config.GetBool("debug", "debug_x_source_code", false)),
                server.LogRequest,
                middleware.RecoverHandler,
                middleware.ValidateRequest,
                server.AcquireDevice,
        )
        router := srv.NewRouter()
        router.Get("/metrics", prometheus.Handler())
        router.Get("/loglevel", server.logLevel)
        router.Put("/loglevel", server.logLevel)
        router.Get("/healthcheck", commonHandlers.ThenFunc(server.HealthcheckHandler))
        router.Get("/diskusage", commonHandlers.ThenFunc(server.DiskUsageHandler))
        router.Put("/ring/*ring_path", commonHandlers.ThenFunc(middleware.RingHandler))
        router.Get("/recon/:method/:recon_type", commonHandlers.ThenFunc(server.ReconHandler))
        router.Get("/recon/:method", commonHandlers.ThenFunc(server.ReconHandler))
        router.Delete("/recon/:device/:method/:recon_type/*item_path", commonHandlers.ThenFunc(server.ReconHandler))
        router.Get("/:device/:partition/:account/:container/*obj", commonHandlers.ThenFunc(server.ObjGetHandler))
        router.Head("/:device/:partition/:account/:container/*obj", commonHandlers.ThenFunc(server.ObjGetHandler))
        router.Put("/:device/:partition/:account/:container/*obj", commonHandlers.ThenFunc(server.ObjPutHandler))
        router.Post("/:device/:partition/:account/:container/*obj", commonHandlers.ThenFunc(server.ObjPostHandler))
        router.Delete("/:device/:partition/:account/:container/*obj", commonHandlers.ThenFunc(server.ObjDeleteHandler))
        router.Options("/", commonHandlers.ThenFunc(server.OptionsHandler))
        router.Get("/debug/pprof/:parm", http.DefaultServeMux)
        router.Post("/debug/pprof/:parm", http.DefaultServeMux)
        router.NotFoundHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                http.Error(w, fmt.Sprintf("Invalid path: %s", r.URL.Path), http.StatusBadRequest)
        }</span>)
        <span class="cov8" title="1">for policy, objEngine := range server.objEngines </span><span class="cov8" title="1">{
                if rhoe, ok := objEngine.(PolicyHandlerRegistrator); ok </span><span class="cov8" title="1">{
                        rhoe.RegisterHandlers(func(method, path string, handler http.HandlerFunc) </span><span class="cov8" title="1">{
                                router.HandlePolicy(method, path, policy, commonHandlers.ThenFunc(handler))
                        }</span>)
                }
        }
        <span class="cov8" title="1">return alice.New(middleware.Metrics(metricsScope), middleware.GrepObject, middleware.ServerTracer(server.tracer)).Then(router)</span>
}

func NewServer(serverconf conf.Config, flags *flag.FlagSet, cnf srv.ConfigLoader) (*srv.IpPort, srv.Server, srv.LowLevelLogger, error) <span class="cov8" title="1">{
        var ipPort *srv.IpPort
        var err error
        server := &amp;ObjectServer{driveRoot: "/srv/node", hashPathPrefix: "", hashPathSuffix: "",
                allowedHeaders: map[string]bool{
                        "Content-Disposition":   true,
                        "Content-Encoding":      true,
                        "X-Delete-At":           true,
                        "X-Object-Manifest":     true,
                        "X-Static-Large-Object": true,
                },
        }
        server.hashPathPrefix, server.hashPathSuffix, err = cnf.GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, err
        }</span>
        <span class="cov8" title="1">if server.objEngines, err = buildEngines(serverconf, flags, cnf); err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, err
        }</span>

        <span class="cov8" title="1">server.driveRoot = serverconf.GetDefault("app:object-server", "devices", "/srv/node")
        server.reconCachePath = serverconf.GetDefault("app:object-server", "recon_cache_path", "/var/cache/swift")
        server.checkMounts = serverconf.GetBool("app:object-server", "mount_check", true)
        server.checkEtags = serverconf.GetBool("app:object-server", "check_etags", false)
        server.diskInUse = common.NewKeyedLimit(serverconf.GetLimit("app:object-server", "disk_limit", 25, 0))
        server.accountDiskInUse = common.NewKeyedLimit(serverconf.GetLimit("app:object-server", "account_rate_limit", 0, 0))
        server.expiringDivisor = serverconf.GetInt("app:object-server", "expiring_objects_container_divisor", 86400)
        bindIP := serverconf.GetDefault("app:object-server", "bind_ip", "0.0.0.0")
        bindPort := int(serverconf.GetInt("app:object-server", "bind_port", common.DefaultObjectServerPort))
        certFile := serverconf.GetDefault("app:object-server", "cert_file", "")
        keyFile := serverconf.GetDefault("app:object-server", "key_file", "")
        if allowedHeaders, ok := serverconf.Get("app:object-server", "allowed_headers"); ok </span><span class="cov0" title="0">{
                headers := strings.Split(allowedHeaders, ",")
                for i := range headers </span><span class="cov0" title="0">{
                        server.allowedHeaders[textproto.CanonicalMIMEHeaderKey(strings.TrimSpace(headers[i]))] = true
                }</span>
        }
        <span class="cov8" title="1">logLevelString := serverconf.GetDefault("app:object-server", "log_level", "INFO")
        server.logLevel = zap.NewAtomicLevel()
        server.logLevel.UnmarshalText([]byte(strings.ToLower(logLevelString)))
        if server.logger, err = srv.SetupLogger("object-server", &amp;server.logLevel, flags); err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, fmt.Errorf("Error setting up logger: %v", err)
        }</span>
        <span class="cov8" title="1">server.updateTimeout = time.Duration(serverconf.GetFloat("app:object-server", "container_update_timeout", 0.25) * float64(time.Second))
        connTimeout := time.Duration(serverconf.GetFloat("app:object-server", "conn_timeout", 1.0) * float64(time.Second))
        nodeTimeout := time.Duration(serverconf.GetFloat("app:object-server", "node_timeout", 10.0) * float64(time.Second))
        transport := &amp;http.Transport{
                Dial:                (&amp;net.Dialer{Timeout: connTimeout}).Dial,
                MaxIdleConnsPerHost: 100,
                MaxIdleConns:        0,
                IdleConnTimeout:     5 * time.Second,
                DisableCompression:  true,
        }
        if certFile != "" &amp;&amp; keyFile != "" </span><span class="cov0" title="0">{
                tlsConf, err := common.NewClientTLSConfig(certFile, keyFile)
                if err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error getting TLS config: %v", err)
                }</span>
                <span class="cov0" title="0">transport.TLSClientConfig = tlsConf
                if err = http2.ConfigureTransport(transport); err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error setting up http2: %v", err)
                }</span>
        }
        <span class="cov8" title="1">httpClient := &amp;http.Client{
                Timeout:   nodeTimeout,
                Transport: transport,
        }
        server.updateClient = httpClient
        if serverconf.HasSection("tracing") </span><span class="cov0" title="0">{
                server.tracer, server.traceCloser, err = tracing.Init("objectserver", server.logger, serverconf.GetSection("tracing"))
                if err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error setting up tracer: %v", err)
                }</span>
                <span class="cov0" title="0">updateClientTracer, updateClientCloser, err := tracing.Init("objectserver-client", server.logger, serverconf.GetSection("tracing"))
                if err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error setting up tracer: %v", err)
                }</span>
                <span class="cov0" title="0">if updateClientCloser != nil </span><span class="cov0" title="0">{
                        server.updateClientCloser = updateClientCloser
                }</span>
                <span class="cov0" title="0">enableHTTPTrace := serverconf.GetBool("tracing", "enable_httptrace", true)
                server.updateClient, err = client.NewTracingClient(updateClientTracer, httpClient, enableHTTPTrace)
                if err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error setting up tracing client: %v", err)
                }</span>
        }
        <span class="cov8" title="1">deviceLockUpdateSeconds := serverconf.GetInt("app:object-server", "device_lock_update_seconds", 0)
        if deviceLockUpdateSeconds &gt; 0 </span><span class="cov0" title="0">{
                go server.updateDeviceLocks(deviceLockUpdateSeconds)
        }</span>
        <span class="cov8" title="1">ipPort = &amp;srv.IpPort{Ip: bindIP, Port: bindPort, CertFile: certFile, KeyFile: keyFile}
        return ipPort, server, server.logger, nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package objectserver

import (
        "fmt"
        "hash/fnv"
        "sort"
        "strings"
)

// MetadataHash returns a hash of the contents of the metadata.
func MetadataHash(metadata map[string]string) string <span class="cov8" title="1">{
        keys := make([]string, 0, len(metadata))
        for key := range metadata </span><span class="cov8" title="1">{
                keys = append(keys, key)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)
        hasher := fnv.New64a()
        for _, key := range keys </span><span class="cov8" title="1">{
                hasher.Write([]byte(key))
                hasher.Write([]byte{0})
                hasher.Write([]byte(metadata[key]))
                hasher.Write([]byte{0})
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%016x", hasher.Sum64())</span>
}

// MetadataMerge will return the result of merging the a and b metadata sets;
// neither a nor b should be used after calling this method.
func MetadataMerge(a map[string]string, b map[string]string) map[string]string <span class="cov0" title="0">{
        if a["X-Timestamp"] &lt; b["X-Timestamp"] </span><span class="cov0" title="0">{
                a, b = b, a
        }</span>
        <span class="cov0" title="0">for _, key := range []string{"Content-Length", "Content-Type", "deleted", "ETag"} </span><span class="cov0" title="0">{
                if _, ok := a[key]; !ok </span><span class="cov0" title="0">{
                        if value, ok := b[key]; ok </span><span class="cov0" title="0">{
                                a[key] = value
                        }</span>
                }
        }
        <span class="cov0" title="0">for key, value := range b </span><span class="cov0" title="0">{
                if strings.HasPrefix(key, "X-Object-Sysmeta-") </span><span class="cov0" title="0">{
                        if _, ok := a[key]; !ok </span><span class="cov0" title="0">{
                                a[key] = value
                        }</span>
                }
        }
        <span class="cov0" title="0">return a</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package objectserver

import (
        "encoding/json"
        "fmt"
        "net/http"
        "path/filepath"
        "time"

        "go.uber.org/zap"

        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/uber-go/tally"
)

const nurseryObjectSleep = 10 * time.Millisecond

type nurseryDevice struct {
        r         *Replicator
        passStart time.Time
        dev       *ring.Device
        policy    int
        oring     ring.Ring
        canchan   chan struct{}
        objEngine NurseryObjectEngine

        stabilizationAttemptsMetric         tally.Counter
        stabilizationSuccessesMetric        tally.Counter
        stabilizationFailuresMetric         tally.Counter
        stabilizationLastPassCountMetric    tally.Gauge
        stabilizationLastPassDurationMetric tally.Timer
}

type PriorityReplicationResult struct {
        ObjectsReplicated int64
        ObjectsErrored    int64
        Success           bool
        ErrorMsg          string
}

func (nrd *nurseryDevice) UpdateStat(stat string, amount int64) <span class="cov8" title="1">{
        nrd.r.updateStat &lt;- statUpdate{nrd.Type(), nrd.Key(), stat, amount}
}</span>

func (nrd *nurseryDevice) Scan() <span class="cov8" title="1">{
        nrd.UpdateStat("startRun", 1)
        if mounted, err := fs.IsMount(filepath.Join(nrd.r.deviceRoot, nrd.dev.Device)); nrd.r.checkMounts &amp;&amp; (err != nil || mounted != true) </span><span class="cov0" title="0">{
                nrd.r.logger.Error("[stabilizeDevice] Drive not mounted", zap.String("Device", nrd.dev.Device), zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">start := time.Now()
        c := make(chan ObjectStabilizer, 100)
        cancel := make(chan struct{})
        defer close(cancel)
        go nrd.objEngine.GetObjectsToStabilize(nrd.dev.Device, c, cancel)
        count := 0
        for o := range c </span><span class="cov0" title="0">{
                count++
                nrd.stabilizationAttemptsMetric.Inc(1)
                nrd.UpdateStat("checkin", 1)
                func() </span><span class="cov0" title="0">{
                        nrd.r.nurseryConcurrencySem &lt;- struct{}{}
                        defer func() </span><span class="cov0" title="0">{
                                &lt;-nrd.r.nurseryConcurrencySem
                        }</span>()
                        <span class="cov0" title="0">if err := o.Stabilize(nrd.dev); err == nil </span><span class="cov0" title="0">{
                                nrd.stabilizationSuccessesMetric.Inc(1)
                                nrd.UpdateStat("ObjectsStabilizedSuccess", 1)
                                nrd.UpdateStat("ObjectsStabilizedBytes", o.ContentLength())
                        }</span> else<span class="cov0" title="0"> {
                                nrd.stabilizationFailuresMetric.Inc(1)
                                nrd.r.logger.Debug("[stabilizeDevice] error Stabilize obj", zap.String("Object", o.Repr()), zap.Error(err))
                                nrd.UpdateStat("ObjectsStabilizedError", 1)
                        }</span>
                }()
                <span class="cov0" title="0">select </span>{
                case &lt;-time.After(nurseryObjectSleep):</span><span class="cov0" title="0">
                case &lt;-nrd.canchan:<span class="cov0" title="0">
                        return</span>
                }
        }
        <span class="cov8" title="1">nrd.stabilizationLastPassCountMetric.Update(float64(count))
        // We don't use Tally's Timer Start().Stop() since we don't want to record canceled passes.
        nrd.stabilizationLastPassDurationMetric.Record(time.Since(start))
        nrd.UpdateStat("PassComplete", 1)
        nrd.r.logger.Info("[stabilizeDevice] Pass complete.")</span>
}

func (nrd *nurseryDevice) ScanLoop() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-nrd.canchan:<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        nrd.Scan()
                        time.Sleep(10 * time.Second)</span>
                }
        }
}

func (nrd *nurseryDevice) Cancel() <span class="cov0" title="0">{
        close(nrd.canchan)
}</span>

func (nrd *nurseryDevice) Key() string <span class="cov8" title="1">{
        return deviceKeyId(nrd.dev.Device, nrd.policy)
}</span>

func (nrd *nurseryDevice) Type() string <span class="cov8" title="1">{
        return "object-nursery"
}</span>

func (nrd *nurseryDevice) PriorityReplicate(w http.ResponseWriter, pri PriorityRepJob) <span class="cov0" title="0">{
        objc := make(chan ObjectStabilizer)
        canchan := make(chan struct{})

        go nrd.objEngine.GetObjectsToReplicate(pri, objc, canchan)
        //TODO: add concurrency to this
        w.WriteHeader(http.StatusOK)
        t := time.Now()
        prr := PriorityReplicationResult{}
        for o := range objc </span><span class="cov0" title="0">{
                if err := o.Replicate(pri); err != nil </span><span class="cov0" title="0">{
                        nrd.r.logger.Error("error prirep Replicate", zap.Error(err))
                        prr.ObjectsErrored++
                        nrd.UpdateStat("ObjectsReplicatedError", 1)
                }</span> else<span class="cov0" title="0"> {
                        prr.ObjectsReplicated++
                        nrd.UpdateStat("ObjectsReplicatedSuccess", 1)
                        nrd.UpdateStat("ObjectsReplicatedBytes", o.ContentLength())
                        if time.Since(t) &gt; time.Minute </span><span class="cov0" title="0">{
                                w.Write([]byte(" "))
                                t = time.Now()
                        }</span>
                }
        }
        <span class="cov0" title="0">prr.Success = prr.ObjectsErrored == 0
        if !prr.Success </span><span class="cov0" title="0">{
                prr.ErrorMsg = fmt.Sprintf("%d objects failed to replicate", prr.ObjectsErrored)
        }</span>
        <span class="cov0" title="0">b, err := json.Marshal(prr)
        if err != nil </span><span class="cov0" title="0">{
                nrd.r.logger.Error("error prirep jsoning", zap.Error(err))
                b = []byte("There was an internal server error generating JSON.")
        }</span>
        <span class="cov0" title="0">w.Write(b)
        w.Write([]byte("\n"))
        nrd.UpdateStat("PriorityRepsDone", 1)</span>
}

func GetNurseryDevice(oring ring.Ring, dev *ring.Device, policy int, r *Replicator, f NurseryObjectEngine) (ReplicationDevice, error) <span class="cov8" title="1">{
        nrd := &amp;nurseryDevice{
                r:         r,
                dev:       dev,
                policy:    policy,
                oring:     oring,
                passStart: time.Now(),
                canchan:   make(chan struct{}),
                objEngine: f,
        }
        nrd.stabilizationAttemptsMetric = r.metricsScope.Counter(fmt.Sprintf("%d_%s_stabilization_attempts", policy, dev.Device))
        nrd.stabilizationSuccessesMetric = r.metricsScope.Counter(fmt.Sprintf("%d_%s_stabilization_successes", policy, dev.Device))
        nrd.stabilizationFailuresMetric = r.metricsScope.Counter(fmt.Sprintf("%d_%s_stabilization_failures", policy, dev.Device))
        nrd.stabilizationLastPassCountMetric = r.metricsScope.Gauge(fmt.Sprintf("%d_%s_stabilization_last_pass_count", policy, dev.Device))
        nrd.stabilizationLastPassDurationMetric = r.metricsScope.Timer(fmt.Sprintf("%d_%s_stabilization_last_pass_duration", policy, dev.Device))
        return nrd, nil
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package objectserver

import (
        "errors"
        "flag"
        "fmt"
        "io"
        "net/http"
        "sync"

        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
)

// DriveFullError can be returned by Object.SetData and Object.Delete if the disk is too full for the operation.
var DriveFullError = errors.New("Drive Full")

type Object interface {
        // Exists determines whether or not there is an object to serve. Deleted objects do not exist, even if there is a tombstone.
        Exists() bool
        // Quarantine removes the file's data, presumably after determining it's been corrupted.
        Quarantine() error
        // Metadata returns the object's metadata.  Will be nil if the object doesn't exist.
        Metadata() map[string]string
        // ContentLength returns the object's content-length.
        ContentLength() int64
        // CopyRange copies a range of data from the object to the writer.
        CopyRange(io.Writer, int64, int64) (int64, error)
        // Copy copies an object's entire contents to the writer(s).
        Copy(...io.Writer) (int64, error)
        // SetData sets the data for the object, given the size (if known).  It returns a writer and an error if any.
        SetData(size int64) (io.Writer, error)
        // Commit saves a new object data that was started with SetData.
        Commit(metadata map[string]string) error
        // CommitMetadata updates the object's metadata.
        CommitMetadata(metadata map[string]string) error
        // Delete deletes the object.
        Delete(metadata map[string]string) error
        // Close releases any resources held by the Object instance.
        Close() error
        // Repr returns a representation of the object, used for logging.
        Repr() string
}

type ObjectStabilizer interface {
        Object
        // Stabilize object- move to stable location / erasure code / do nothing / etc
        Stabilize(*ring.Device) error
        Replicate(PriorityRepJob) error
}

type ReplicationDevice interface {
        Scan()
        ScanLoop()
        Key() string
        Cancel()
        PriorityReplicate(w http.ResponseWriter, pri PriorityRepJob)
        UpdateStat(string, int64)
        Type() string
}

// ObjectEngine is the type you have to give hummingbird to create a new object engine.
type ObjectEngine interface {
        // New creates a new instance of the Object, for interacting with a single object.
        New(vars map[string]string, needData bool, asyncWG *sync.WaitGroup) (Object, error)
        GetReplicationDevice(oring ring.Ring, dev *ring.Device, r *Replicator) (ReplicationDevice, error)
        // Replicator here needs to be something else- it mostly needs logger, updateStat thing, and certs. not whole object- maybe an interface that gives those things
}

type NurseryObjectEngine interface {
        ObjectEngine
        GetObjectsToStabilize(device string, c chan ObjectStabilizer, cancel chan struct{})
        GetObjectsToReplicate(prirep PriorityRepJob, c chan ObjectStabilizer, cancel chan struct{})
}

type PolicyHandlerRegistrator interface {
        RegisterHandlers(addRoute func(method, path string, handler http.HandlerFunc))
}

// ObjectEngineConstructor&gt; is a function that, given configs and flags, returns an ObjectEngine
type ObjectEngineConstructor func(conf.Config, *conf.Policy, *flag.FlagSet) (ObjectEngine, error)

type engineFactoryEntry struct {
        name        string
        constructor ObjectEngineConstructor
}

var engineFactories = []engineFactoryEntry{}

// RegisterObjectEngine lets you tell hummingbird about a new object engine.
func RegisterObjectEngine(name string, newEngine ObjectEngineConstructor) <span class="cov8" title="1">{
        for _, e := range engineFactories </span><span class="cov8" title="1">{
                if e.name == name </span><span class="cov0" title="0">{
                        e.constructor = newEngine
                        return
                }</span>
        }
        <span class="cov8" title="1">engineFactories = append(engineFactories, engineFactoryEntry{name, newEngine})</span>
}

// FindEngine returns the registered object engine with the given name.
func FindEngine(name string) (ObjectEngineConstructor, error) <span class="cov8" title="1">{
        for _, e := range engineFactories </span><span class="cov8" title="1">{
                if e.name == name </span><span class="cov8" title="1">{
                        return e.constructor, nil
                }</span>
        }
        <span class="cov8" title="1">return nil, errors.New("Not found")</span>
}

func buildEngines(serverconf conf.Config, flags *flag.FlagSet, cnf srv.ConfigLoader) (map[int]ObjectEngine, error) <span class="cov8" title="1">{
        objEngines := make(map[int]ObjectEngine)
        policies, err := cnf.GetPolicies()
        if err != nil </span><span class="cov0" title="0">{
                return objEngines, err
        }</span>
        <span class="cov8" title="1">for _, policy := range policies </span><span class="cov8" title="1">{
                if newEngine, err := FindEngine(policy.Type); err != nil </span><span class="cov0" title="0">{
                        return objEngines, fmt.Errorf("Unable to find object engine type %s: %v", policy.Type, err)
                }</span> else<span class="cov8" title="1"> {
                        objEngines[policy.Index], err = newEngine(serverconf, policy, flags)
                        if err != nil </span><span class="cov0" title="0">{
                                return objEngines, fmt.Errorf("Error instantiating object engine type %s: %v", policy.Type, err)
                        }</span>
                }
        }
        <span class="cov8" title="1">return objEngines, nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package objectserver

import (
        "bytes"
        "encoding/json"
        "flag"
        "fmt"
        "io/ioutil"
        "math/rand"
        "net/http"
        "os"
        "regexp"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
        "golang.org/x/net/http2"
)

type devLimiter struct {
        inUse             map[int]int
        m                 sync.Mutex
        max               int
        somethingFinished chan struct{}
}

func (d *devLimiter) start(j *PriorityRepJob) bool <span class="cov8" title="1">{
        d.m.Lock()
        doable := d.inUse[j.FromDevice.Id] &lt; d.max
        doable = doable &amp;&amp; d.inUse[j.ToDevice.Id] &lt; d.max
        if doable </span><span class="cov8" title="1">{
                d.inUse[j.FromDevice.Id] += 1
                d.inUse[j.ToDevice.Id] += 1
        }</span>
        <span class="cov8" title="1">d.m.Unlock()
        return doable</span>
}

func (d *devLimiter) finished(j *PriorityRepJob) <span class="cov8" title="1">{
        d.m.Lock()
        d.inUse[j.FromDevice.Id] -= 1
        d.inUse[j.ToDevice.Id] -= 1
        d.m.Unlock()
        select </span>{
        case d.somethingFinished &lt;- struct{}{}:</span><span class="cov8" title="1">
        default:</span><span class="cov0" title="0">
        }
}

func (d *devLimiter) waitForSomethingToFinish() <span class="cov0" title="0">{
        &lt;-d.somethingFinished
}</span>

func SendPriRepJob(job *PriorityRepJob, client common.HTTPClient) (string, bool) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s://%s:%d/priorityrep", job.FromDevice.Scheme, job.FromDevice.ReplicationIp, job.FromDevice.ReplicationPort)
        jsonned, err := json.Marshal(job)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Failed to serialize job for some reason: %s", err), false
        }</span>
        <span class="cov8" title="1">req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonned))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Failed to create request for some reason: %s", err), false
        }</span>
        <span class="cov8" title="1">req.ContentLength = int64(len(jsonned))
        req.Header.Set("Content-Type", "application/json")
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Error moving partition %d: %v",
                        job.Partition, err), false
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        if resp.StatusCode/100 == 2 </span><span class="cov8" title="1">{
                if data, err := ioutil.ReadAll(resp.Body); err == nil </span><span class="cov8" title="1">{
                        prp := PriorityReplicationResult{}
                        if err = json.Unmarshal(data, &amp;prp); err == nil </span><span class="cov0" title="0">{
                                return fmt.Sprintf("Replicating partition %d from %s/%s to %s/%s replicated %d objects with %d errors",
                                        job.Partition, job.FromDevice.Ip, job.FromDevice.Device, job.ToDevice.Ip, job.ToDevice.Device,
                                        prp.ObjectsReplicated, prp.ObjectsErrored), prp.Success
                        }</span> else<span class="cov8" title="1"> {
                                return fmt.Sprintf("could not get valid response for partition %d: %v",
                                        job.Partition, err), false
                        }</span>
                } else<span class="cov0" title="0"> {
                        return fmt.Sprintf("could not  read body forpartition %d: %v",
                                job.Partition, err), false
                }</span>
        } else<span class="cov0" title="0"> if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                return fmt.Sprintf("partition %d: not found on %s/%s",
                        job.Partition, job.FromDevice.Ip, job.FromDevice.Device), true
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("Bad status code moving partition %d: %d",
                job.Partition, resp.StatusCode), false</span>
}

// doPriRepJobs executes a list of PriorityRepJobs, limiting concurrent jobs per device to deviceMax.
func doPriRepJobs(jobs []*PriorityRepJob, deviceMax int, client common.HTTPClient) []uint64 <span class="cov8" title="1">{
        limiter := &amp;devLimiter{inUse: make(map[int]int), max: deviceMax, somethingFinished: make(chan struct{}, 1)}
        wg := sync.WaitGroup{}
        badParts := []uint64{}
        var badPartsLock sync.Mutex
        for len(jobs) &gt; 0 </span><span class="cov8" title="1">{
                foundDoable := false
                for i := range jobs </span><span class="cov8" title="1">{
                        if !limiter.start(jobs[i]) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">foundDoable = true
                        wg.Add(1)
                        go func(job *PriorityRepJob) </span><span class="cov8" title="1">{
                                defer wg.Done()
                                defer limiter.finished(job)
                                res, ok := SendPriRepJob(job, client)
                                fmt.Println(res)
                                if !ok </span><span class="cov8" title="1">{
                                        badPartsLock.Lock()
                                        badParts = append(badParts, job.Partition)
                                        badPartsLock.Unlock()
                                }</span>
                        }(jobs[i])
                        <span class="cov8" title="1">jobs = append(jobs[:i], jobs[i+1:]...)
                        break</span>
                }
                <span class="cov8" title="1">if !foundDoable </span><span class="cov0" title="0">{
                        limiter.waitForSomethingToFinish()
                }</span>
        }
        <span class="cov8" title="1">wg.Wait()
        return badParts</span>
}

// getPartMoveJobs takes two rings and creates a list of jobs for any partition moves between them.
func getPartMoveJobs(oldRing, newRing ring.Ring, overrideParts []uint64, policy int) []*PriorityRepJob <span class="cov8" title="1">{
        allNewDevices := map[string]bool{}
        for _, dev := range newRing.AllDevices() </span><span class="cov8" title="1">{
                if dev == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">allNewDevices[fmt.Sprintf("%s:%d/%s", dev.Ip, dev.Port, dev.Device)] = true</span>
        }
        <span class="cov8" title="1">jobs := make([]*PriorityRepJob, 0)
        for i := uint64(0); true; i++ </span><span class="cov8" title="1">{
                partition := i
                if len(overrideParts) &gt; 0 </span><span class="cov0" title="0">{
                        if int(partition) &lt; len(overrideParts) </span><span class="cov0" title="0">{
                                partition = overrideParts[partition]
                        }</span> else<span class="cov0" title="0"> {
                                break</span>
                        }
                }
                <span class="cov8" title="1">olddevs := oldRing.GetNodes(partition)
                newdevs := newRing.GetNodes(partition)
                if olddevs == nil || newdevs == nil </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">for i := range olddevs </span><span class="cov8" title="1">{
                        if olddevs[i].Id != newdevs[i].Id </span><span class="cov8" title="1">{
                                // TODO: handle if a node just changes positions, which doesn't happen, but isn't against the contract.
                                fromDev := olddevs[i]
                                if _, ok := allNewDevices[fmt.Sprintf("%s:%d/%s", fromDev.Ip, fromDev.Port, fromDev.Device)]; !ok </span><span class="cov0" title="0">{
                                        fromDev = olddevs[(i+1)%len(olddevs)]
                                }</span>
                                <span class="cov8" title="1">jobs = append(jobs, &amp;PriorityRepJob{
                                        Partition:  partition,
                                        FromDevice: fromDev,
                                        ToDevice:   newdevs[i],
                                        Policy:     policy,
                                })</span>
                        }
                }
        }
        <span class="cov8" title="1">return jobs</span>
}

func objectRingPolicyIndex(s string) (int, error) <span class="cov0" title="0">{
        if !strings.Contains(s, "object") </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("object not in string: %v", s)
        }</span>
        <span class="cov0" title="0">re := regexp.MustCompile(`object-(\d*)`)
        match := re.FindStringSubmatch(s)
        if match == nil </span><span class="cov0" title="0">{
                return 0, nil
        }</span> else<span class="cov0" title="0"> {
                policyIdx, err := strconv.Atoi(match[1])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("invalid policy index: %v\n", match[1])
                }</span>
                <span class="cov0" title="0">return policyIdx, nil</span>
        }
}

func doMoveParts(args []string, cnf srv.ConfigLoader) int <span class="cov8" title="1">{
        flags := flag.NewFlagSet("moveparts", flag.ExitOnError)
        policyName := flags.String("P", "", "policy to use")
        certFile := flags.String("certfile", "", "Cert file to use for setting up https client")
        keyFile := flags.String("keyfile", "", "Key file to use for setting up https client")
        flags.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "USAGE: hummingbird moveparts [old ringfile]\n")
                flags.PrintDefaults()
        }</span>
        <span class="cov8" title="1">flags.Parse(args)
        if len(flags.Args()) != 1 </span><span class="cov0" title="0">{
                flags.Usage()
                return 1
        }</span>
        <span class="cov8" title="1">policyIndex := 0
        if *policyName != "" </span><span class="cov8" title="1">{
                policies, err := conf.GetPolicies()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintln(os.Stderr, "Unable to load policies:", err)
                        return 1
                }</span>
                <span class="cov8" title="1">p := policies.NameLookup(*policyName)
                if p == nil </span><span class="cov8" title="1">{
                        fmt.Fprintf(os.Stderr, "Unknown policy named %q\n", *policyName)
                        return 1
                }</span>
                <span class="cov0" title="0">policyIndex = p.Index</span>
        }
        <span class="cov0" title="0">oldPolicy, policyErr := objectRingPolicyIndex(flags.Arg(0))
        if policyErr != nil </span><span class="cov0" title="0">{
                fmt.Println("Invalid ring:", policyErr)
                return 1
        }</span>

        <span class="cov0" title="0">if oldPolicy != policyIndex </span><span class="cov0" title="0">{
                fmt.Printf("Old policy: %v doesn't match specified policy: %v\n", oldPolicy, policyIndex)
                return 1
        }</span>

        <span class="cov0" title="0">hashPathPrefix, hashPathSuffix, err := cnf.GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Unable to load hash path prefix and suffix:", err)
                return 1
        }</span>
        <span class="cov0" title="0">oldRing, err := ring.LoadRing(flags.Arg(0), hashPathPrefix, hashPathSuffix)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Unable to load old ring:", err)
                return 1
        }</span>
        <span class="cov0" title="0">curRing, err := ring.GetRing("object", hashPathPrefix, hashPathSuffix, policyIndex)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Unable to load current ring:", err)
                return 1
        }</span>
        <span class="cov0" title="0">transport := &amp;http.Transport{
                MaxIdleConnsPerHost: 100,
                MaxIdleConns:        0,
        }
        if *certFile != "" &amp;&amp; *keyFile != "" </span><span class="cov0" title="0">{
                tlsConf, err := common.NewClientTLSConfig(*certFile, *keyFile)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error getting TLS config:", err)
                        return 1
                }</span>
                <span class="cov0" title="0">transport.TLSClientConfig = tlsConf
                if err = http2.ConfigureTransport(transport); err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error setting up http2:", err)
                        return 1
                }</span>
        }
        // TODO: Do we want to trace requests with this client?
        <span class="cov0" title="0">client := &amp;http.Client{Timeout: time.Hour,
                Transport: transport,
        }
        badParts := []uint64{}
        for </span><span class="cov0" title="0">{
                jobs := getPartMoveJobs(oldRing, curRing, badParts, policyIndex)
                lastRun := len(jobs)
                for i := len(jobs) - 1; i &gt; 0; i-- </span><span class="cov0" title="0">{ // shuffle jobs list
                        j := rand.Intn(i + 1)
                        jobs[j], jobs[i] = jobs[i], jobs[j]
                }</span>
                <span class="cov0" title="0">fmt.Println("Job count:", len(jobs))
                badParts = doPriRepJobs(jobs, 2, client)
                if len(badParts) == 0 </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> {
                        fmt.Printf("Finished run of partitions. retrying %d.\n", len(badParts))
                        fmt.Println("NOTE: This will loop on any partitions not found on any primary")
                        if lastRun == len(badParts) </span><span class="cov0" title="0">{
                                time.Sleep(time.Minute * 5)
                        }</span> else<span class="cov0" title="0"> {
                                time.Sleep(time.Second * 5)
                        }</span>
                }
        }
        <span class="cov0" title="0">fmt.Println("Done sending jobs.")
        return 0</span>
}

// MoveParts takes two object .ring.gz files as []string{oldRing, newRing} and dispatches priority replication jobs to rebalance data in line with any ring changes.
func MoveParts(args []string, cnf srv.ConfigLoader) <span class="cov0" title="0">{
        ret := doMoveParts(args, cnf)
        os.Exit(ret)
}</span>

// getRestoreDeviceJobs takes an ip address and device name, and creates a list of jobs to restore that device's data from peers.
func getRestoreDeviceJobs(theRing ring.Ring, ip string, devName string, srcRegionOnly int, allPeers bool, overrideParts []uint64, policy int) []*PriorityRepJob <span class="cov8" title="1">{
        jobs := make([]*PriorityRepJob, 0)
        for i := uint64(0); true; i++ </span><span class="cov8" title="1">{
                partition := i
                if len(overrideParts) &gt; 0 </span><span class="cov0" title="0">{
                        if int(partition) &lt; len(overrideParts) </span><span class="cov0" title="0">{
                                partition = overrideParts[partition]
                        }</span> else<span class="cov0" title="0"> {
                                break</span>
                        }
                }
                <span class="cov8" title="1">devs := theRing.GetNodes(partition)
                if devs == nil </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">var toDev *ring.Device
                for _, dev := range devs </span><span class="cov8" title="1">{
                        if dev.Device == devName &amp;&amp; (dev.Ip == ip || dev.ReplicationIp == ip) </span><span class="cov8" title="1">{
                                toDev = dev
                                break</span>
                        }
                }
                <span class="cov8" title="1">if toDev != nil </span><span class="cov8" title="1">{
                        foundJob := false
                        for len(devs) &gt; 0 </span><span class="cov8" title="1">{
                                rd := rand.Intn(len(devs))
                                src := devs[rd]
                                devs = append(devs[:rd], devs[rd+1:]...)
                                if src.Device == toDev.Device &amp;&amp; (src.Ip == toDev.Ip || src.ReplicationIp == toDev.ReplicationIp) </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">if srcRegionOnly &gt;= 0 &amp;&amp; src.Region != srcRegionOnly </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">jobs = append(jobs, &amp;PriorityRepJob{
                                        Partition:  partition,
                                        FromDevice: src,
                                        ToDevice:   toDev,
                                        Policy:     policy,
                                })
                                foundJob = true
                                if !allPeers </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !foundJob </span><span class="cov8" title="1">{
                                fmt.Printf("Could not find job for partition: %d\n", partition)
                        }</span>
                }
        }
        <span class="cov8" title="1">return jobs</span>
}

// RestoreDevice takes an IP address and device name such as []string{"172.24.0.1", "sda1"} and attempts to restores its data from peers.
func RestoreDevice(args []string, cnf srv.ConfigLoader) <span class="cov0" title="0">{
        flags := flag.NewFlagSet("restoredevice", flag.ExitOnError)
        policyName := flags.String("P", "", "policy to use")
        region := flags.Int("region", -1, "restore device only from peers in specified region")
        ringLoc := flags.String("r", "", "Specify which ring file to use")
        conc := flags.Int("c", 2, "limit of per device concurrency priority repl calls")
        full := flags.Bool("f", false, "send priority replicate calls to every qualifying peer primary (slow)")
        certFile := flags.String("certfile", "", "Cert file to use for setting up https client")
        keyFile := flags.String("keyfile", "", "Key file to use for setting up https client")
        flags.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "USAGE: hummingbird restoredevice [ip] [device]\n")
                flags.PrintDefaults()
        }</span>
        <span class="cov0" title="0">flags.Parse(args)
        if len(flags.Args()) != 2 </span><span class="cov0" title="0">{
                flags.Usage()
                return
        }</span>
        <span class="cov0" title="0">policyIndex := 0
        if *policyName != "" </span><span class="cov0" title="0">{
                policies, err := conf.GetPolicies()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintln(os.Stderr, "Unable to load policies:", err)
                        return
                }</span>
                <span class="cov0" title="0">p := policies.NameLookup(*policyName)
                if p == nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Unknown policy named %q\n", *policyName)
                        return
                }</span>
                <span class="cov0" title="0">policyIndex = p.Index</span>
        }
        <span class="cov0" title="0">hashPathPrefix, hashPathSuffix, err := cnf.GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Unable to load hash path prefix and suffix:", err)
                return
        }</span>
        <span class="cov0" title="0">var objRing ring.Ring
        if *ringLoc == "" </span><span class="cov0" title="0">{
                objRing, err = ring.GetRing("object", hashPathPrefix, hashPathSuffix, policyIndex)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Unable to load ring:", err)
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                objRing, err = ring.LoadRing(*ringLoc, hashPathPrefix, hashPathSuffix)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Unable to load ring:", err)
                        return
                }</span>

        }
        <span class="cov0" title="0">transport := &amp;http.Transport{
                MaxIdleConnsPerHost: 100,
                MaxIdleConns:        0,
        }
        if *certFile != "" &amp;&amp; *keyFile != "" </span><span class="cov0" title="0">{
                tlsConf, err := common.NewClientTLSConfig(*certFile, *keyFile)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error getting TLS config:", err)
                        return
                }</span>
                <span class="cov0" title="0">transport.TLSClientConfig = tlsConf
                if err = http2.ConfigureTransport(transport); err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error setting up http2:", err)
                        return
                }</span>
        }
        // TODO: Do we want to trace requests with this client?
        <span class="cov0" title="0">client := &amp;http.Client{
                Timeout:   time.Hour * 4,
                Transport: transport,
        }
        badParts := []uint64{}
        for </span><span class="cov0" title="0">{
                jobs := getRestoreDeviceJobs(objRing, flags.Arg(0), flags.Arg(1), *region, *full, badParts, policyIndex)
                lastRun := len(jobs)
                fmt.Println("Job count:", len(jobs))
                for i := len(jobs) - 1; i &gt; 0; i-- </span><span class="cov0" title="0">{ // shuffle jobs list
                        j := rand.Intn(i + 1)
                        jobs[j], jobs[i] = jobs[i], jobs[j]
                }</span>
                <span class="cov0" title="0">badParts = doPriRepJobs(jobs, *conc, client)
                if len(badParts) == 0 </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> {
                        fmt.Printf("Finished run of partitions. retrying %d.\n", len(badParts))
                        fmt.Println("NOTE: This will loop on any partitions not found on any primary")
                        if lastRun == len(badParts) </span><span class="cov0" title="0">{
                                time.Sleep(time.Minute * 5)
                        }</span> else<span class="cov0" title="0"> {
                                time.Sleep(time.Second * 5)
                        }</span>
                }
        }
        <span class="cov0" title="0">fmt.Println("Done sending jobs.")</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package objectserver

import (
        "bufio"
        "crypto/tls"
        "encoding/binary"
        "encoding/json"
        "fmt"
        "io"
        "net"
        "net/http"
        "net/http/httputil"
        "strconv"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/ring"
)

var RepUnmountedError = fmt.Errorf("Device unmounted")
var repDialer = (&amp;net.Dialer{Timeout: 5 * time.Second, KeepAlive: 30 * time.Second}).Dial

const repConnBufferSize = 32768

type BeginReplicationRequest struct {
        Device     string
        Partition  string
        NeedHashes bool
}

type BeginReplicationResponse struct {
        Hashes map[string]string
}

type SyncFileRequest struct {
        Path   string
        Xattrs string
        Size   int64
        Check  bool
        Ping   bool
        Done   bool
}

type SyncFileResponse struct {
        Exists      bool
        NewerExists bool
        GoAhead     bool
        Msg         string
}

type FileUploadResponse struct {
        Success bool
        Msg     string
}

type RepConn interface {
        SendMessage(v interface{}) error
        RecvMessage(v interface{}) error
        Write(data []byte) (l int, err error)
        Flush() error
        Read(data []byte) (l int, err error)
        Disconnected() bool
        Close()
}

type repConn struct {
        rw           *bufio.ReadWriter
        c            net.Conn
        disconnected bool
        rcTimeout    time.Duration
}

func (r *repConn) iTimeout() time.Duration <span class="cov8" title="1">{
        if r.rcTimeout &gt; 0 </span><span class="cov0" title="0">{
                return r.rcTimeout
        }</span>
        <span class="cov8" title="1">return time.Minute * 10</span>
}

func (r *repConn) oTimeout() time.Duration <span class="cov8" title="1">{
        if r.rcTimeout &gt; 0 </span><span class="cov0" title="0">{
                return r.rcTimeout
        }</span>
        <span class="cov8" title="1">return time.Minute</span>
}

func (r *repConn) Disconnected() bool <span class="cov8" title="1">{
        return r.disconnected
}</span>

func (r *repConn) SendMessage(v interface{}) error <span class="cov8" title="1">{
        jsoned, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                r.Close()
                return err
        }</span>
        <span class="cov8" title="1">if err := binary.Write(r, binary.BigEndian, uint32(len(jsoned))); err != nil </span><span class="cov0" title="0">{
                r.Close()
                return err
        }</span>
        <span class="cov8" title="1">if _, err := r.Write(jsoned); err != nil </span><span class="cov0" title="0">{
                r.Close()
                return err
        }</span>
        <span class="cov8" title="1">if err := r.Flush(); err != nil </span><span class="cov0" title="0">{
                r.Close()
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *repConn) RecvMessage(v interface{}) (err error) <span class="cov8" title="1">{
        r.c.SetDeadline(time.Now().Add(r.iTimeout()))
        var length uint32
        if err = binary.Read(r, binary.BigEndian, &amp;length); err != nil </span><span class="cov0" title="0">{
                r.Close()
                return
        }</span>
        <span class="cov8" title="1">data := make([]byte, length)
        if _, err = io.ReadFull(r, data); err != nil </span><span class="cov0" title="0">{
                r.Close()
                return
        }</span>
        <span class="cov8" title="1">if err = json.Unmarshal(data, v); err != nil </span><span class="cov0" title="0">{
                r.Close()
                return
        }</span>
        <span class="cov8" title="1">return</span>
}

func (r *repConn) Write(data []byte) (l int, err error) <span class="cov8" title="1">{
        r.c.SetDeadline(time.Now().Add(r.oTimeout()))
        if l, err = r.rw.Write(data); err != nil </span><span class="cov0" title="0">{
                r.Close()
        }</span>
        <span class="cov8" title="1">return</span>
}

func (r *repConn) Flush() (err error) <span class="cov8" title="1">{
        r.c.SetDeadline(time.Now().Add(r.oTimeout()))
        if err = r.rw.Flush(); err != nil </span><span class="cov0" title="0">{
                r.Close()
        }</span>
        <span class="cov8" title="1">return</span>
}

func (r *repConn) Read(data []byte) (l int, err error) <span class="cov8" title="1">{
        r.c.SetDeadline(time.Now().Add(r.iTimeout()))
        if l, err = io.ReadFull(r.rw, data); err != nil </span><span class="cov0" title="0">{
                r.Close()
        }</span>
        <span class="cov8" title="1">return</span>
}

func (r *repConn) Close() <span class="cov8" title="1">{
        r.disconnected = true
        r.c.Close()
}</span>

func NewRepConn(dev *ring.Device, partition string, policy int, headers map[string]string, certFile, keyFile string, rcTimeout time.Duration) (RepConn, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s://%s:%d/%s/%s", dev.Scheme, dev.ReplicationIp, dev.ReplicationPort, dev.Device, partition)
        req, err := http.NewRequest("REPCONN", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">req.Header.Set("X-Backend-Suppress-2xx-Logging", "t")
        // left policy as an arg instead of a header to make it harder to forget to set it.
        req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(policy))
        for k, v := range headers </span><span class="cov8" title="1">{
                req.Header.Set(k, v)
        }</span>
        <span class="cov8" title="1">conn, err := repDialer("tcp", req.URL.Host)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if certFile != "" &amp;&amp; keyFile != "" </span><span class="cov0" title="0">{
                tlsConf, err := common.NewClientTLSConfig(certFile, keyFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">tlsConf.ServerName = dev.ReplicationIp
                conn = tls.Client(conn, tlsConf)</span>
        }
        <span class="cov8" title="1">hc := httputil.NewClientConn(conn, nil)
        resp, err := hc.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if resp.StatusCode/100 != 2 </span><span class="cov8" title="1">{
                return nil, RepUnmountedError
        }</span>
        <span class="cov8" title="1">newc, _ := hc.Hijack()
        if newc, ok := newc.(*net.TCPConn); ok </span><span class="cov8" title="1">{
                newc.SetNoDelay(true)
        }</span>
        <span class="cov8" title="1">return &amp;repConn{
                rw: bufio.NewReadWriter(
                        bufio.NewReaderSize(newc, repConnBufferSize),
                        bufio.NewWriterSize(newc, repConnBufferSize)),
                c:         newc,
                rcTimeout: rcTimeout,
        }, nil</span>
}

func NewIncomingRepConn(rw *bufio.ReadWriter, c net.Conn, rcTimeout time.Duration) RepConn <span class="cov8" title="1">{
        return &amp;repConn{rw: rw, c: c, rcTimeout: rcTimeout}
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package objectserver

import (
        "flag"
        "fmt"
        "io"
        "net/http"
        _ "net/http/pprof"
        "strings"
        "sync"
        "time"

        opentracing "github.com/opentracing/opentracing-go"
        "github.com/troubling/hummingbird/client"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/common/tracing"
        "github.com/troubling/hummingbird/middleware"
        "github.com/uber-go/tally"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "golang.org/x/net/http2"
)

const (
        tmpEmptyTime                 = 24 * time.Hour
        replicateStatsReportInterval = 10 * time.Minute
        replicateDeviceTimeout       = 4 * time.Hour
        replicateIncomingTimeout     = time.Minute
        replicateLoopSleepTime       = time.Second * 30
        replicatePartSleepTime       = time.Millisecond * 10
        handoffListDirFreq           = time.Minute * 10
        handoffToAllMod              = 5
        priorityReplicateTimeout     = time.Hour
)

type PriorityRepJob struct {
        Partition  uint64       `json:"partition"`
        FromDevice *ring.Device `json:"from_device"`
        ToDevice   *ring.Device `json:"to_device"`
        Policy     int          `json:"policy"`
}

func deviceKeyId(dev string, policy int) string <span class="cov8" title="1">{
        if policy == 0 </span><span class="cov8" title="1">{
                return dev
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s-%d", dev, policy)</span>
}

type DeviceStats struct {
        Stats              map[string]int64
        LastCheckin        time.Time
        PassStarted        time.Time
        DeviceStarted      time.Time
        LastPassFinishDate time.Time
        LastPassDuration   time.Duration
        CancelCount        int64
        FilesSent          int64
        BytesSent          int64
        PartitionsDone     int64
        PartitionsTotal    int64
        TotalPasses        int64
        PriorityRepsDone   int64
}

type statUpdate struct {
        service   string
        deviceKey string
        stat      string
        value     int64
}

// Object replicator daemon object
type Replicator struct {
        checkMounts         bool
        deviceRoot          string
        reconCachePath      string
        port                int
        bindIp              string
        CertFile            string
        KeyFile             string
        devices             map[string]bool
        partitions          map[string]bool
        quorumDelete        bool
        reclaimAge          int64
        reserve             int64
        incomingLimitPerDev int64
        policies            conf.PolicyList
        logLevel            zap.AtomicLevel
        metricsScope        tally.Scope
        metricsCloser       io.Closer
        traceCloser         io.Closer
        clientTraceCloser   io.Closer
        tracer              opentracing.Tracer
        auditor             *AuditorDaemon

        stats                   map[string]map[string]*DeviceStats
        runningDevices          map[string]ReplicationDevice
        updatingDevices         map[string]*updateDevice
        runningDevicesLock      sync.Mutex
        logger                  srv.LowLevelLogger
        objectRings             map[int]ring.Ring
        objEngines              map[int]ObjectEngine
        containerRing           ring.Ring
        replicateConcurrencySem chan struct{}
        updateConcurrencySem    chan struct{}
        nurseryConcurrencySem   chan struct{}
        updateStat              chan statUpdate
        onceDone                chan struct{}
        onceWaiting             int64
        client                  common.HTTPClient
        incomingSemLock         sync.Mutex
        incomingSem             map[string]chan struct{}
        asyncWG                 sync.WaitGroup // Used to wait on async goroutines
        rcTimeout               time.Duration
}

func (server *Replicator) Type() string <span class="cov0" title="0">{
        return "object-replicator"
}</span>

func (server *Replicator) Background(flags *flag.FlagSet) chan struct{} <span class="cov0" title="0">{
        once := false
        if f := flags.Lookup("once"); f != nil </span><span class="cov0" title="0">{
                once = f.Value.(flag.Getter).Get() == true
        }</span>
        <span class="cov0" title="0">if once </span><span class="cov0" title="0">{
                ch := make(chan struct{})
                go func() </span><span class="cov0" title="0">{
                        defer close(ch)
                        server.Run()
                }</span>()
                <span class="cov0" title="0">return ch</span>
        }
        <span class="cov0" title="0">go server.RunForever()
        if server.auditor != nil </span><span class="cov0" title="0">{
                go server.auditor.RunForever()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (server *Replicator) Finalize() <span class="cov0" title="0">{
        if server.metricsCloser != nil </span><span class="cov0" title="0">{
                server.metricsCloser.Close()
        }</span>
        <span class="cov0" title="0">if server.traceCloser != nil </span><span class="cov0" title="0">{
                server.traceCloser.Close()
        }</span>
        <span class="cov0" title="0">if server.clientTraceCloser != nil </span><span class="cov0" title="0">{
                server.clientTraceCloser.Close()
        }</span>
}

func (server *Replicator) HealthcheckHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        writer.Header().Set("Content-Length", "2")
        writer.WriteHeader(http.StatusOK)
        writer.Write([]byte("OK"))
}</span>

func (r *Replicator) cancelStalledDevices() <span class="cov8" title="1">{
        r.runningDevicesLock.Lock()
        defer r.runningDevicesLock.Unlock()
        for key, rd := range r.runningDevices </span><span class="cov8" title="1">{
                stats, ok := r.stats["object-replicator"][key]
                if ok &amp;&amp; time.Since(stats.LastCheckin) &gt; replicateDeviceTimeout </span><span class="cov8" title="1">{
                        rd.Cancel()
                        delete(r.runningDevices, key)
                        delete(r.stats["object-replicator"], key)
                }</span>
        }
        <span class="cov8" title="1">for key, ud := range r.updatingDevices </span><span class="cov0" title="0">{
                stats, ok := r.stats["object-updater"][key]
                if ok &amp;&amp; time.Since(stats.LastCheckin) &gt; replicateDeviceTimeout </span><span class="cov0" title="0">{
                        ud.cancel()
                        delete(r.updatingDevices, key)
                        delete(r.stats["object-updater"], key)
                }</span>
        }
}

func (r *Replicator) verifyRunningDevices() <span class="cov8" title="1">{
        r.runningDevicesLock.Lock()
        defer r.runningDevicesLock.Unlock()
        expectedDevices := make(map[string]bool)
        for policy, oring := range r.objectRings </span><span class="cov8" title="1">{
                ringDevices, err := oring.LocalDevices(r.port)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Error getting local devices from ring", zap.Error(err))
                        return
                }</span>
                <span class="cov8" title="1">objEngine, ok := r.objEngines[policy]
                if !ok </span><span class="cov0" title="0">{
                        r.logger.Error("Error finding engine for policy", zap.Int("policy", policy), zap.Error(err))
                        return
                }</span>
                // look for devices that aren't running but should be
                <span class="cov8" title="1">for _, dev := range ringDevices </span><span class="cov8" title="1">{
                        key := deviceKeyId(dev.Device, policy)
                        expectedDevices[key] = true
                        if len(r.devices) &gt; 0 &amp;&amp; !r.devices[dev.Device] </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if _, ok := r.runningDevices[key]; !ok </span><span class="cov8" title="1">{
                                if rd, err := objEngine.GetReplicationDevice(oring, dev, r); err == nil </span><span class="cov8" title="1">{
                                        r.runningDevices[key] = rd
                                        r.stats[rd.Type()][key] = &amp;DeviceStats{
                                                LastCheckin: time.Now(), DeviceStarted: time.Now(),
                                                Stats: map[string]int64{},
                                        }
                                        go r.runningDevices[key].ScanLoop()
                                }</span> else<span class="cov0" title="0"> {
                                        r.logger.Error("building replication device", zap.String("device", key), zap.Int("policy", policy), zap.Error(err))
                                }</span>
                        }
                        <span class="cov8" title="1">if _, ok := r.updatingDevices[key]; !ok </span><span class="cov8" title="1">{
                                r.updatingDevices[key] = newUpdateDevice(dev, policy, r)
                                r.stats["object-updater"][key] = &amp;DeviceStats{
                                        LastCheckin: time.Now(), DeviceStarted: time.Now(),
                                        Stats: map[string]int64{"Success": 0, "Failure": 0},
                                }
                                go r.updatingDevices[key].updateLoop()
                        }</span>
                }
        }
        // look for devices that are running but shouldn't be
        <span class="cov8" title="1">for key, rd := range r.runningDevices </span><span class="cov8" title="1">{
                if _, found := expectedDevices[key]; !found </span><span class="cov8" title="1">{
                        rd.Cancel()
                        delete(r.runningDevices, key)
                }</span>
        }
        <span class="cov8" title="1">for key, ud := range r.updatingDevices </span><span class="cov8" title="1">{
                if _, found := expectedDevices[key]; !found </span><span class="cov0" title="0">{
                        ud.cancel()
                        delete(r.updatingDevices, key)
                }</span>
        }
}

func (r *Replicator) reportStats() <span class="cov8" title="1">{
        r.runningDevicesLock.Lock()
        defer r.runningDevicesLock.Unlock()
        minLastPass := time.Now()
        allHaveCompleted := true
        for key := range r.runningDevices </span><span class="cov8" title="1">{
                stats, ok := r.stats["object-replicator"][key]
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if stats.TotalPasses &lt;= 1 </span><span class="cov8" title="1">{
                        allHaveCompleted = false
                }</span>
                <span class="cov8" title="1">if stats.LastPassFinishDate.Before(minLastPass) </span><span class="cov8" title="1">{
                        minLastPass = stats.LastPassFinishDate
                }</span>
                <span class="cov8" title="1">processingTimeSec := time.Since(stats.PassStarted).Seconds()
                doneParts := stats.Stats["PartitionsDone"]
                totalParts := stats.Stats["PartitionsTotal"]
                partsPerSecond := float64(doneParts) / processingTimeSec

                remaining := time.Duration(
                        int64(float64(totalParts-doneParts)/partsPerSecond)) * time.Second
                var remainingStr string
                if remaining &gt;= time.Hour </span><span class="cov8" title="1">{
                        remainingStr = fmt.Sprintf("%.0fh", remaining.Hours())
                }</span> else<span class="cov8" title="1"> if remaining &gt;= time.Minute </span><span class="cov0" title="0">{
                        remainingStr = fmt.Sprintf("%.0fm", remaining.Minutes())
                }</span> else<span class="cov8" title="1"> {
                        remainingStr = fmt.Sprintf("%.0fs", remaining.Seconds())
                }</span>
                <span class="cov8" title="1">r.logger.Info("Partition Replicated",
                        zap.String("Device", key),
                        zap.Int64("doneParts", doneParts),
                        zap.Int64("totalParts", totalParts),
                        zap.Float64("DoneParts/TotalParts", float64(100*doneParts)/float64(totalParts)),
                        zap.Float64("processingTimeSec", processingTimeSec),
                        zap.Float64("partsPerSecond", partsPerSecond),
                        zap.String("remainingStr", remainingStr))</span>
        }
        <span class="cov8" title="1">if allHaveCompleted </span><span class="cov0" title="0">{
                // this is a mess but object_replication_time (in old way) is # minutes
                // passed since 1 complete pass of all devices started.
                // replication_last is unix time stamp when last complete pass was finished
                // now "last pass" means oldest device lastPass
                maxLastPassComplete := time.Since(minLastPass).Minutes()
                middleware.DumpReconCache(r.reconCachePath, "object",
                        map[string]interface{}{
                                "object_replication_time": maxLastPassComplete,
                                "object_replication_last": float64(minLastPass.UnixNano()) / float64(time.Second),
                        })
        }</span>
}

func (r *Replicator) getDeviceProgress(name string) map[string]*DeviceStats <span class="cov8" title="1">{
        r.runningDevicesLock.Lock()
        defer r.runningDevicesLock.Unlock()
        deviceProgress := make(map[string]*DeviceStats)
        for key, stats := range r.stats[name] </span><span class="cov8" title="1">{
                deviceProgress[key] = stats
        }</span>
        <span class="cov8" title="1">return deviceProgress</span>
}

func (r *Replicator) runLoopCheck(reportTimer &lt;-chan time.Time) <span class="cov8" title="1">{
        select </span>{
        case update := &lt;-r.updateStat:<span class="cov8" title="1">
                r.runningDevicesLock.Lock()
                defer r.runningDevicesLock.Unlock()
                stats, ok := r.stats[update.service][update.deviceKey]
                if !ok </span><span class="cov8" title="1">{
                        stats = &amp;DeviceStats{LastCheckin: time.Now(), DeviceStarted: time.Now(),
                                Stats: map[string]int64{}}
                        r.stats[update.service][update.deviceKey] = stats
                }</span>
                <span class="cov8" title="1">stats.LastCheckin = time.Now()
                switch update.stat </span>{
                case "checkin":</span><span class="cov8" title="1">
                case "startRun":<span class="cov8" title="1">
                        stats.PassStarted = time.Now()
                        stats.PartitionsDone = 0
                        stats.FilesSent = 0
                        stats.BytesSent = 0
                        stats.PriorityRepsDone = 0
                        stats.LastPassFinishDate = time.Time{}
                        for k := range stats.Stats </span><span class="cov0" title="0">{
                                stats.Stats[k] = 0
                        }</span>
                case "FullReplicateCount":<span class="cov8" title="1">
                        stats.LastPassDuration = time.Since(stats.PassStarted)
                        stats.LastPassFinishDate = time.Now()
                        stats.TotalPasses++
                        stats.Stats[update.stat] += update.value

                        lf := []zapcore.Field{
                                zap.String("service", update.service),
                                zap.String("device", update.deviceKey),
                                zap.Duration("duration", stats.LastPassDuration),
                        }
                        for k, v := range stats.Stats </span><span class="cov8" title="1">{
                                lf = append(lf, zap.Int64(k, v))
                        }</span>
                        <span class="cov8" title="1">r.logger.Info("Service pass complete", lf...)</span>
                case "cancel":<span class="cov0" title="0">
                        stats.CancelCount += update.value</span>
                case "FilesSent":<span class="cov8" title="1">
                        stats.FilesSent += update.value</span>
                case "BytesSent":<span class="cov8" title="1">
                        stats.BytesSent += update.value</span>
                case "PartitionsDone":<span class="cov8" title="1">
                        stats.PartitionsDone += update.value</span>
                case "PartitionsTotal":<span class="cov8" title="1">
                        stats.PartitionsTotal = update.value</span>
                case "PriorityRepsDone":<span class="cov0" title="0">
                        stats.PriorityRepsDone += update.value</span>
                default:<span class="cov8" title="1">
                        stats.Stats[update.stat] += update.value</span>
                }
        case &lt;-reportTimer:<span class="cov0" title="0">
                r.cancelStalledDevices()
                r.verifyRunningDevices()
                r.reportStats()</span>
        case &lt;-r.onceDone:<span class="cov8" title="1">
                r.onceWaiting--</span>
        }
}

// Run replication passes in a loop until forever.
func (r *Replicator) RunForever() <span class="cov0" title="0">{
        reportTimer := time.NewTimer(replicateStatsReportInterval)
        r.verifyRunningDevices()
        for </span><span class="cov0" title="0">{
                r.runLoopCheck(reportTimer.C)
        }</span>
}

// Run a single replication pass. (NOTE: we will prob get rid of this because of priorityRepl)
func (r *Replicator) Run() <span class="cov8" title="1">{
        for policy, theRing := range r.objectRings </span><span class="cov8" title="1">{
                devices, err := theRing.LocalDevices(r.port)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Error getting local devices from ring", zap.Error(err))
                        return
                }</span>
                <span class="cov8" title="1">objEngine, ok := r.objEngines[policy]
                if !ok </span><span class="cov0" title="0">{
                        r.logger.Error("Error finding engine for policy", zap.Int("policy", policy), zap.Error(err))
                        return
                }</span>
                <span class="cov8" title="1">for _, dev := range devices </span><span class="cov8" title="1">{
                        rd, err := objEngine.GetReplicationDevice(theRing, dev, r)
                        if err != nil </span><span class="cov0" title="0">{
                                r.logger.Error("building replication device", zap.String("device", dev.Device), zap.Int("policy", policy), zap.Error(err))
                                continue</span>
                        }
                        <span class="cov8" title="1">key := rd.Key()
                        r.runningDevices[key] = rd
                        go func(rd ReplicationDevice) </span><span class="cov8" title="1">{
                                rd.Scan()
                                r.onceDone &lt;- struct{}{}
                        }</span>(rd)

                        <span class="cov8" title="1">r.updatingDevices[key] = newUpdateDevice(dev, policy, r)
                        go func(ud *updateDevice) </span><span class="cov8" title="1">{
                                ud.update()
                                r.onceDone &lt;- struct{}{}
                        }</span>(r.updatingDevices[key])

                        <span class="cov8" title="1">r.onceWaiting += 2</span>
                }
        }
        <span class="cov8" title="1">for r.onceWaiting &gt; 0 </span><span class="cov8" title="1">{
                r.runLoopCheck(make(chan time.Time))
        }</span>
        <span class="cov8" title="1">r.reportStats()</span>
}

func NewReplicator(serverconf conf.Config, flags *flag.FlagSet, cnf srv.ConfigLoader) (ipPort *srv.IpPort, server srv.Server, logger srv.LowLevelLogger, err error) <span class="cov8" title="1">{
        if !serverconf.HasSection("object-replicator") </span><span class="cov0" title="0">{
                return ipPort, nil, nil, fmt.Errorf("Unable to find object-replicator config section")
        }</span>
        <span class="cov8" title="1">concurrency := int(serverconf.GetInt("object-replicator", "concurrency", 1))
        updaterConcurrency := int(serverconf.GetInt("object-updater", "concurrency", 2))
        nurseryConcurrency := int(serverconf.GetInt("object-nursery", "concurrency", 2))

        logLevelString := serverconf.GetDefault("object-replicator", "log_level", "INFO")
        logLevel := zap.NewAtomicLevel()
        logLevel.UnmarshalText([]byte(strings.ToLower(logLevelString)))
        certFile := serverconf.GetDefault("object-replicator", "cert_file", "")
        keyFile := serverconf.GetDefault("object-replicator", "key_file", "")
        transport := &amp;http.Transport{
                MaxIdleConnsPerHost: 100,
                MaxIdleConns:        0,
        }
        if certFile != "" &amp;&amp; keyFile != "" </span><span class="cov0" title="0">{
                tlsConf, err := common.NewClientTLSConfig(certFile, keyFile)
                if err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error getting TLS config: %v", err)
                }</span>
                <span class="cov0" title="0">transport.TLSClientConfig = tlsConf
                if err = http2.ConfigureTransport(transport); err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error setting up http2: %v", err)
                }</span>
        }
        <span class="cov8" title="1">httpClient := &amp;http.Client{
                Timeout:   time.Second * 60,
                Transport: transport,
        }
        replicator := &amp;Replicator{
                reserve:             serverconf.GetInt("object-replicator", "fallocate_reserve", 0),
                reconCachePath:      serverconf.GetDefault("object-replicator", "recon_cache_path", "/var/cache/swift"),
                checkMounts:         serverconf.GetBool("object-replicator", "mount_check", true),
                deviceRoot:          serverconf.GetDefault("object-replicator", "devices", "/srv/node"),
                port:                int(serverconf.GetInt("object-replicator", "bind_port", common.DefaultObjectReplicatorPort)),
                bindIp:              serverconf.GetDefault("object-replicator", "bind_ip", "0.0.0.0"),
                CertFile:            certFile,
                KeyFile:             keyFile,
                quorumDelete:        serverconf.GetBool("object-replicator", "quorum_delete", false),
                reclaimAge:          int64(serverconf.GetInt("object-replicator", "reclaim_age", int64(common.ONE_WEEK))),
                incomingLimitPerDev: int64(serverconf.GetInt("object-replicator", "incoming_limit", 3)),

                runningDevices:          make(map[string]ReplicationDevice),
                updatingDevices:         make(map[string]*updateDevice),
                objectRings:             make(map[int]ring.Ring),
                replicateConcurrencySem: make(chan struct{}, concurrency),
                updateConcurrencySem:    make(chan struct{}, updaterConcurrency),
                nurseryConcurrencySem:   make(chan struct{}, nurseryConcurrency),
                rcTimeout:               time.Duration(serverconf.GetInt("object-replicator", "replication_timeout_sec", 0)) * time.Second,
                updateStat:              make(chan statUpdate),
                devices:                 make(map[string]bool),
                partitions:              make(map[string]bool),
                onceDone:                make(chan struct{}),
                client:                  httpClient,
                incomingSem:             make(map[string]chan struct{}),
                stats: map[string]map[string]*DeviceStats{
                        "object-replicator": {},
                        "object-updater":    {},
                        "object-nursery":    {},
                },
        }
        replicator.logLevel = logLevel

        hashPathPrefix, hashPathSuffix, err := cnf.GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, fmt.Errorf("Unable to get hash prefix and suffix: %s", err)
        }</span>
        <span class="cov8" title="1">if replicator.policies, err = cnf.GetPolicies(); err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, err
        }</span>
        <span class="cov8" title="1">for _, policy := range replicator.policies </span><span class="cov8" title="1">{
                if replicator.objectRings[policy.Index], err = cnf.GetRing("object", hashPathPrefix, hashPathSuffix, policy.Index); err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Unable to load ring for Policy %d: %s", policy.Index, err)
                }</span>
        }
        <span class="cov8" title="1">if replicator.containerRing, err = cnf.GetRing("container", hashPathPrefix, hashPathSuffix, 0); err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, fmt.Errorf("Error loading container ring: %v", err)
        }</span>
        <span class="cov8" title="1">if replicator.objEngines, err = buildEngines(serverconf, flags, cnf); err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, err
        }</span>
        <span class="cov8" title="1">if replicator.logger, err = srv.SetupLogger("object-replicator", &amp;logLevel, flags); err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, fmt.Errorf("Error setting up logger: %v", err)
        }</span>
        <span class="cov8" title="1">if serverconf.HasSection("tracing") </span><span class="cov0" title="0">{
                replicator.tracer, replicator.traceCloser, err = tracing.Init("object-replicator", replicator.logger, serverconf.GetSection("tracing"))
                if err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error setting up tracer: %v", err)
                }</span>
                <span class="cov0" title="0">clientTracer, clientTraceCloser, err := tracing.Init("object-replicator", replicator.logger, serverconf.GetSection("tracing"))
                if err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error setting up tracer: %v", err)
                }</span>
                <span class="cov0" title="0">if clientTraceCloser != nil </span><span class="cov0" title="0">{
                        replicator.clientTraceCloser = clientTraceCloser
                }</span>
                <span class="cov0" title="0">enableHTTPTrace := serverconf.GetBool("tracing", "enable_httptrace", true)
                replicator.client, err = client.NewTracingClient(clientTracer, httpClient, enableHTTPTrace)
                if err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error setting up tracing client: %v", err)
                }</span>
        }
        <span class="cov8" title="1">devices_flag := flags.Lookup("devices")
        if devices_flag != nil </span><span class="cov0" title="0">{
                if devices := devices_flag.Value.(flag.Getter).Get().(string); len(devices) &gt; 0 </span><span class="cov0" title="0">{
                        for _, devName := range strings.Split(devices, ",") </span><span class="cov0" title="0">{
                                replicator.devices[strings.TrimSpace(devName)] = true
                        }</span>
                }
        }
        <span class="cov8" title="1">partitions_flag := flags.Lookup("partitions")
        if partitions_flag != nil </span><span class="cov0" title="0">{
                if partitions := partitions_flag.Value.(flag.Getter).Get().(string); len(partitions) &gt; 0 </span><span class="cov0" title="0">{
                        for _, part := range strings.Split(partitions, ",") </span><span class="cov0" title="0">{
                                replicator.partitions[strings.TrimSpace(part)] = true
                        }</span>
                }
        }
        <span class="cov8" title="1">if !replicator.quorumDelete </span><span class="cov8" title="1">{
                quorumFlag := flags.Lookup("q")
                if quorumFlag != nil &amp;&amp; quorumFlag.Value.(flag.Getter).Get() == true </span><span class="cov8" title="1">{
                        replicator.quorumDelete = true
                }</span>
        }
        <span class="cov8" title="1">if serverconf.HasSection("object-auditor") </span><span class="cov8" title="1">{
                replicator.auditor, err = NewAuditorDaemon(serverconf, flags, cnf)
        }</span>
        <span class="cov8" title="1">ipPort = &amp;srv.IpPort{Ip: replicator.bindIp, Port: replicator.port, CertFile: certFile, KeyFile: keyFile}
        return ipPort, replicator, replicator.logger, err</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package objectserver

import (
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "math"
        "net/http"
        "os"
        "strconv"
        "sync"
        "sync/atomic"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/ring"
)

var _ Object = &amp;repObject{}

type repObject struct {
        IndexDBItem
        reserve          int64
        asyncWG          *sync.WaitGroup
        idb              *IndexDB
        ring             ring.Ring
        policy           int
        loaded           bool
        atomicFileWriter fs.AtomicFileWriter
        metadata         map[string]string
        client           *http.Client
        txnId            string
}

func (ro *repObject) Metadata() map[string]string <span class="cov0" title="0">{
        return ro.metadata
}</span>

func (ro *repObject) ContentLength() int64 <span class="cov8" title="1">{
        if contentLength, err := strconv.ParseInt(ro.metadata["Content-Length"], 10, 64); err != nil </span><span class="cov0" title="0">{
                return -1
        }</span> else<span class="cov8" title="1"> {
                return contentLength
        }</span>
}

func (ro *repObject) Quarantine() error <span class="cov0" title="0">{
        return QuarantineItem(ro.idb, &amp;ro.IndexDBItem)
}</span>

func (ro *repObject) Exists() bool <span class="cov0" title="0">{
        if ro.Deletion == true </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return ro.Path != ""</span>
}

func (ro *repObject) Copy(dsts ...io.Writer) (written int64, err error) <span class="cov0" title="0">{
        var f *os.File
        f, err = os.Open(ro.Path)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if len(dsts) == 1 </span><span class="cov0" title="0">{
                written, err = io.Copy(dsts[0], f)
        }</span> else<span class="cov0" title="0"> {
                written, err = common.Copy(f, dsts...)
        }</span>
        <span class="cov0" title="0">if f != nil </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{
                        err = f.Close()
                }</span> else<span class="cov0" title="0"> {
                        f.Close()
                }</span>
        }
        <span class="cov0" title="0">return written, err</span>
}

func (ro *repObject) CopyRange(w io.Writer, start int64, end int64) (int64, error) <span class="cov0" title="0">{
        f, err := os.Open(ro.Path)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if _, err := f.Seek(start, os.SEEK_SET); err != nil </span><span class="cov0" title="0">{
                f.Close()
                return 0, err
        }</span>
        <span class="cov0" title="0">written, err := common.CopyN(f, end-start, w)
        if err == nil </span><span class="cov0" title="0">{
                err = f.Close()
        }</span> else<span class="cov0" title="0"> {
                f.Close()
        }</span>
        <span class="cov0" title="0">return written, err</span>
}

func (ro *repObject) Repr() string <span class="cov0" title="0">{
        return fmt.Sprintf("repObject&lt;%s, %d&gt;", ro.Hash, ro.Timestamp)
}</span>

func (ro *repObject) SetData(size int64) (io.Writer, error) <span class="cov0" title="0">{
        if ro.atomicFileWriter != nil </span><span class="cov0" title="0">{
                ro.atomicFileWriter.Abandon()
        }</span>
        <span class="cov0" title="0">var err error
        ro.atomicFileWriter, err = ro.idb.TempFile(ro.Hash, roShard, math.MaxInt64, size, true)
        return ro.atomicFileWriter, err</span>
}

func (ro *repObject) commit(metadata map[string]string, method string, nursery bool) error <span class="cov0" title="0">{
        var timestamp int64
        timestampStr, ok := metadata["X-Timestamp"]
        if !ok </span><span class="cov0" title="0">{
                return errors.New("no timestamp in metadata")
        }</span>
        <span class="cov0" title="0">timestampTime, err := common.ParseDate(timestampStr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">timestamp = timestampTime.UnixNano()
        err = ro.idb.Commit(ro.atomicFileWriter, ro.Hash, roShard, timestamp, method, metadata, nursery, "")
        ro.atomicFileWriter = nil
        return err</span>
}

func (ro *repObject) Commit(metadata map[string]string) error <span class="cov0" title="0">{
        return ro.commit(metadata, "PUT", true)
}</span>

func (ro *repObject) Delete(metadata map[string]string) error <span class="cov0" title="0">{
        return ro.commit(metadata, "DELETE", true)
}</span>

func (ro *repObject) CommitMetadata(metadata map[string]string) error <span class="cov0" title="0">{
        return ro.commit(metadata, "POST", ro.Nursery)
}</span>

func (ro *repObject) Close() error <span class="cov0" title="0">{
        if ro.atomicFileWriter != nil </span><span class="cov0" title="0">{
                ro.atomicFileWriter.Abandon()
                ro.atomicFileWriter = nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (ro *repObject) isStable(dev *ring.Device) (bool, []*ring.Device, error) <span class="cov8" title="1">{
        if ro.Deletion </span><span class="cov0" title="0">{
                return false, nil, fmt.Errorf("you just send deletions")
        }</span>
        <span class="cov8" title="1">partition, err := ro.ring.PartitionForHash(ro.Hash)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, err
        }</span>
        <span class="cov8" title="1">nodes := ro.ring.GetNodes(partition)
        goodNodes := uint64(0)
        notFoundNodes := []*ring.Device{}
        for _, node := range nodes </span><span class="cov8" title="1">{
                if node.Ip == dev.Ip &amp;&amp; node.Port == dev.Port &amp;&amp; node.Device == dev.Device </span><span class="cov8" title="1">{
                        goodNodes++
                        continue</span>
                }
                <span class="cov8" title="1">url := fmt.Sprintf("%s://%s:%d/%s/%d%s", node.Scheme, node.Ip, node.Port, node.Device, partition, common.Urlencode(ro.metadata["name"]))
                req, err := http.NewRequest("HEAD", url, nil)
                req.Header.Set("X-Backend-Storage-Policy-Index", strconv.FormatInt(int64(ro.policy), 10))
                req.Header.Set("User-Agent", "nursery-stabilizer")
                resp, err := ro.client.Do(req)
                if err == nil &amp;&amp; (resp.StatusCode/100 == 2) &amp;&amp;
                        resp.Header.Get("X-Timestamp") != "" &amp;&amp;
                        resp.Header.Get("X-Timestamp") ==
                                ro.metadata["X-Timestamp"] </span><span class="cov8" title="1">{
                        goodNodes++
                }</span> else<span class="cov8" title="1"> {
                        notFoundNodes = append(notFoundNodes, node)
                }</span>
                <span class="cov8" title="1">if resp != nil </span><span class="cov8" title="1">{
                        resp.Body.Close()
                }</span>
        }
        <span class="cov8" title="1">return goodNodes == ro.ring.ReplicaCount(), notFoundNodes, nil</span>
}

func (ro *repObject) stabilizeDelete(dev *ring.Device) error <span class="cov8" title="1">{
        partition, err := ro.ring.PartitionForHash(ro.Hash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">nodes := ro.ring.GetNodes(partition)
        var successes int64
        wg := sync.WaitGroup{}
        for _, node := range nodes </span><span class="cov8" title="1">{
                if node.Ip == dev.Ip &amp;&amp; node.Port == dev.Port &amp;&amp; node.Device == dev.Device </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">req, err := http.NewRequest("DELETE", fmt.Sprintf("%s://%s:%d/rep-obj/%s/%s", node.Scheme, node.ReplicationIp, node.ReplicationPort, node.Device, ro.Hash), nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">req.Header.Set("X-Timestamp", ro.metadata["X-Timestamp"])
                req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(ro.policy))
                req.Header.Set("X-Trans-Id", ro.txnId)
                wg.Add(1)
                go func(req *http.Request) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        if resp, err := ro.client.Do(req); err == nil </span><span class="cov8" title="1">{
                                io.Copy(ioutil.Discard, resp.Body)
                                resp.Body.Close()
                                if resp.StatusCode/100 == 2 || resp.StatusCode == http.StatusConflict || resp.StatusCode == 404 </span><span class="cov8" title="1">{
                                        atomic.AddInt64(&amp;successes, 1)
                                }</span>
                        }
                }(req)
        }
        <span class="cov8" title="1">wg.Wait()
        if successes+1 != int64(len(nodes)) </span><span class="cov8" title="1">{
                return fmt.Errorf("could not stabilize DELETE to all primaries %d/%d", successes, len(nodes)-1)
        }</span>
        <span class="cov8" title="1">return ro.idb.Remove(ro.Hash, ro.Shard, ro.Timestamp, ro.Nursery)</span>
}

func (ro *repObject) restabilize(dev *ring.Device) error <span class="cov8" title="1">{
        wg := sync.WaitGroup{}
        var successes int64
        partition, err := ro.ring.PartitionForHash(ro.Hash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">nodes := ro.ring.GetNodes(partition)
        for _, node := range nodes </span><span class="cov8" title="1">{
                if node.Ip == dev.Ip &amp;&amp; node.Port == dev.Port &amp;&amp; node.Device == dev.Device </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">req, err := http.NewRequest("POST", fmt.Sprintf("%s://%s:%d/rep-obj/%s/%s", node.Scheme, node.ReplicationIp, node.ReplicationPort, node.Device, ro.Hash), nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">req.Header.Set("X-Timestamp", ro.metadata["X-Timestamp"])
                req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(ro.policy))
                req.Header.Set("X-Trans-Id", ro.txnId)
                for k, v := range ro.metadata </span><span class="cov8" title="1">{
                        req.Header.Set("Meta-"+k, v)
                }</span>
                <span class="cov8" title="1">wg.Add(1)
                go func(req *http.Request) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        if resp, err := ro.client.Do(req); err == nil </span><span class="cov8" title="1">{
                                io.Copy(ioutil.Discard, resp.Body)
                                resp.Body.Close()
                                if resp.StatusCode/100 == 2 || resp.StatusCode == http.StatusConflict </span><span class="cov8" title="1">{
                                        atomic.AddInt64(&amp;successes, 1)
                                }</span>
                        }
                }(req)
        }
        <span class="cov8" title="1">wg.Wait()
        if successes != int64(len(nodes)-1) </span><span class="cov0" title="0">{
                return fmt.Errorf("could not restabilize all primaries %d/%d", successes, len(nodes))
        }</span>
        <span class="cov8" title="1">return ro.idb.SetStabilized(ro.Hash, ro.Shard, ro.Timestamp, false)</span>
}

func (ro *repObject) Stabilize(dev *ring.Device) error <span class="cov8" title="1">{
        partition, err := ro.ring.PartitionForHash(ro.Hash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if ro.Restabilize </span><span class="cov8" title="1">{
                return ro.restabilize(dev)
        }</span>
        <span class="cov8" title="1">if !ro.Nursery </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if ro.Deletion </span><span class="cov8" title="1">{
                return ro.stabilizeDelete(dev)
        }</span>
        <span class="cov8" title="1">isStable, notFoundNodes, err := ro.isStable(dev)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if isStable </span><span class="cov8" title="1">{
                if _, isHandoff := ro.ring.GetJobNodes(partition, dev.Id); isHandoff </span><span class="cov0" title="0">{
                        return ro.idb.Remove(ro.Hash, ro.Shard, ro.Timestamp, ro.Nursery)
                }</span> else<span class="cov8" title="1"> {
                        return ro.idb.SetStabilized(ro.Hash, roShard, ro.Timestamp, true)
                }</span>
        }
        <span class="cov8" title="1">errs := []error{}
        for _, notFoundNode := range notFoundNodes </span><span class="cov8" title="1">{
                // try to replicate, try to Stabilize next time
                if err := ro.Replicate(PriorityRepJob{Partition: partition,
                        FromDevice: dev,
                        ToDevice:   notFoundNode,
                        Policy:     ro.policy}); err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, err)
                }</span>
        }
        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov8" title="1">{
                return errs[0]
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("could not stabilize: fixed %d nodes", len(notFoundNodes))</span>
}

func (ro *repObject) Replicate(prirep PriorityRepJob) error <span class="cov8" title="1">{
        _, isHandoff := ro.ring.GetJobNodes(prirep.Partition, prirep.FromDevice.Id)
        fp, err := os.Open(ro.Path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer fp.Close()
        req, err := http.NewRequest("PUT",
                fmt.Sprintf("%s://%s:%d/rep-obj/%s/%s",
                        prirep.ToDevice.Scheme, prirep.ToDevice.Ip, prirep.ToDevice.Port,
                        prirep.ToDevice.Device, ro.Hash), fp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">req.ContentLength = ro.ContentLength()
        req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(ro.policy))
        req.Header.Set("X-Trans-Id", ro.txnId)
        for k, v := range ro.metadata </span><span class="cov8" title="1">{
                req.Header.Set("Meta-"+k, v)
        }</span>
        <span class="cov8" title="1">resp, err := ro.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error syncing obj %s: %v", ro.Hash, err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        if !(resp.StatusCode/100 == 2 || resp.StatusCode == 409) </span><span class="cov8" title="1">{
                return fmt.Errorf("bad status code %d syncing obj with  %s", resp.StatusCode, ro.Hash)
        }</span>
        <span class="cov0" title="0">if isHandoff </span><span class="cov0" title="0">{
                return ro.idb.Remove(ro.Hash, ro.Shard, ro.Timestamp, ro.Nursery)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package objectserver

import (
        "encoding/json"
        "flag"
        "fmt"
        "io/ioutil"
        "math/bits"
        "net"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "time"

        "golang.org/x/net/http2"

        "go.uber.org/zap"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
)

const (
        roShard = 0
)

func init() <span class="cov8" title="1">{
        RegisterObjectEngine("rep", repEngineConstructor)
}</span>

var _ ObjectEngineConstructor = repEngineConstructor

func repEngineConstructor(config conf.Config, policy *conf.Policy, flags *flag.FlagSet) (ObjectEngine, error) <span class="cov0" title="0">{
        hashPathPrefix, hashPathSuffix, err := conf.GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">driveRoot := config.GetDefault("app:object-server", "devices", "/srv/node")
        rng, err := ring.GetRing("object", hashPathPrefix, hashPathSuffix, policy.Index)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">dbPartPower, err := policy.GetDbPartPower()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">subdirs, err := policy.GetDbSubDirs()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">logLevelString := config.GetDefault("app:object-server", "log_level", "INFO")
        logLevel := zap.NewAtomicLevel()
        logLevel.UnmarshalText([]byte(strings.ToLower(logLevelString)))
        certFile := config.GetDefault("app:object-server", "cert_file", "")
        keyFile := config.GetDefault("app:object-server", "key_file", "")
        transport := &amp;http.Transport{
                MaxIdleConnsPerHost: 256,
                MaxIdleConns:        0,
                IdleConnTimeout:     5 * time.Second,
                DisableCompression:  true,
                Dial: (&amp;net.Dialer{
                        Timeout:   10 * time.Second,
                        KeepAlive: 5 * time.Second,
                }).Dial,
                ExpectContinueTimeout: 10 * time.Minute,
        }
        if certFile != "" &amp;&amp; keyFile != "" </span><span class="cov0" title="0">{
                tlsConf, err := common.NewClientTLSConfig(certFile, keyFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">transport.TLSClientConfig = tlsConf
                if err = http2.ConfigureTransport(transport); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">re := &amp;repEngine{
                driveRoot:      driveRoot,
                hashPathPrefix: hashPathPrefix,
                hashPathSuffix: hashPathSuffix,
                reserve:        config.GetInt("app:object-server", "fallocate_reserve", 0),
                policy:         policy.Index,
                ring:           rng,
                idbs:           map[string]*IndexDB{},
                dbPartPower:    int(dbPartPower),
                numSubDirs:     subdirs,
                client: &amp;http.Client{
                        Timeout:   120 * time.Minute,
                        Transport: transport,
                },
        }
        if re.logger, err = srv.SetupLogger("repobjengine", &amp;logLevel, flags); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Error setting up logger: %v", err)
        }</span>
        <span class="cov0" title="0">return re, nil</span>
}

var _ ObjectEngine = &amp;repEngine{}

type repEngine struct {
        driveRoot      string
        hashPathPrefix string
        hashPathSuffix string
        reserve        int64
        policy         int
        ring           ring.Ring
        logger         srv.LowLevelLogger
        idbs           map[string]*IndexDB
        dblock         sync.Mutex
        dbPartPower    int
        numSubDirs     int
        client         *http.Client
}

func (re *repEngine) getDB(device string) (*IndexDB, error) <span class="cov0" title="0">{
        re.dblock.Lock()
        defer re.dblock.Unlock()
        if idb, ok := re.idbs[device]; ok &amp;&amp; idb != nil </span><span class="cov0" title="0">{
                return idb, nil
        }</span>
        <span class="cov0" title="0">var err error
        dbpath := filepath.Join(re.driveRoot, device, PolicyDir(re.policy), "rep.db")
        path := filepath.Join(re.driveRoot, device, PolicyDir(re.policy), "rep")
        temppath := filepath.Join(re.driveRoot, device, "tmp")
        ringPartPower := bits.Len64(re.ring.PartitionCount() - 1)
        re.idbs[device], err = NewIndexDB(dbpath, path, temppath, ringPartPower, re.dbPartPower, re.numSubDirs, re.reserve, re.logger, repAuditor{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return re.idbs[device], nil</span>
}

func (re *repEngine) New(vars map[string]string, needData bool, asyncWG *sync.WaitGroup) (Object, error) <span class="cov0" title="0">{
        //TODO: not sure if here- but need to show x-backend timestamp on deleted objects
        hash := ObjHash(vars, re.hashPathPrefix, re.hashPathSuffix)
        obj := &amp;repObject{
                IndexDBItem: IndexDBItem{
                        Hash: hash,
                },
                ring:     re.ring,
                policy:   re.policy,
                reserve:  re.reserve,
                metadata: map[string]string{},
                asyncWG:  asyncWG,
                client:   re.client,
                txnId:    vars["txnId"],
        }
        if idb, err := re.getDB(vars["device"]); err == nil </span><span class="cov0" title="0">{
                obj.idb = idb
                if item, err := idb.Lookup(hash, roShard, false); err == nil &amp;&amp; item != nil </span><span class="cov0" title="0">{
                        obj.IndexDBItem = *item
                        if err = json.Unmarshal(item.Metabytes, &amp;obj.metadata); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Error parsing metadata: %v", err)
                        }</span>
                        <span class="cov0" title="0">if !item.Deletion </span><span class="cov0" title="0">{
                                if _, err := os.Stat(item.Path); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        }
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return obj, nil</span>
        } else<span class="cov0" title="0"> {
                return nil, err
        }</span>
}

func (re *repEngine) GetReplicationDevice(oring ring.Ring, dev *ring.Device, r *Replicator) (ReplicationDevice, error) <span class="cov0" title="0">{
        return GetNurseryDevice(oring, dev, re.policy, r, re)
}</span>

func (re *repEngine) GetObjectsToReplicate(prirep PriorityRepJob, c chan ObjectStabilizer, cancel chan struct{}) <span class="cov0" title="0">{
        defer close(c)
        idb, err := re.getDB(prirep.FromDevice.Device)
        if err != nil </span><span class="cov0" title="0">{
                re.logger.Error("error getting local db", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">startHash, stopHash := idb.RingPartRange(int(prirep.Partition))
        items, err := idb.List(startHash, stopHash, "", 0)
        if len(items) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">url := fmt.Sprintf("%s://%s:%d/rep-partition/%s/%d", prirep.ToDevice.Scheme, prirep.ToDevice.Ip, prirep.ToDevice.Port, prirep.ToDevice.Device, prirep.Partition)
        req, err := http.NewRequest("GET", url, nil)
        req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(prirep.Policy))
        req.Header.Set("User-Agent", "nursery-stabilizer")
        resp, err := re.client.Do(req)

        var remoteItems []*IndexDBItem
        if err == nil &amp;&amp; (resp.StatusCode/100 == 2 || resp.StatusCode == 404) </span><span class="cov0" title="0">{
                if data, err := ioutil.ReadAll(resp.Body); err == nil </span><span class="cov0" title="0">{
                        if err = json.Unmarshal(data, &amp;remoteItems); err != nil </span><span class="cov0" title="0">{
                                re.logger.Error("error unmarshaling partition list", zap.Error(err))
                        }</span>
                } else<span class="cov0" title="0"> {
                        re.logger.Error("error reading partition list", zap.Error(err))
                }</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                re.logger.Error("error getting local partition list", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">rii := 0
        for _, item := range items </span><span class="cov0" title="0">{
                if item.Nursery </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">sendItem := true
                for rii &lt; len(remoteItems) </span><span class="cov0" title="0">{
                        if remoteItems[rii].Hash &gt; item.Hash </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">if remoteItems[rii].Hash &lt; item.Hash </span><span class="cov0" title="0">{
                                rii++
                                continue</span>
                        }
                        <span class="cov0" title="0">if remoteItems[rii].Hash == item.Hash &amp;&amp;
                                remoteItems[rii].Timestamp == item.Timestamp &amp;&amp;
                                remoteItems[rii].Nursery == item.Nursery &amp;&amp;
                                remoteItems[rii].Deletion == item.Deletion </span><span class="cov0" title="0">{
                                sendItem = false
                        }</span>
                        <span class="cov0" title="0">rii++
                        break</span>
                }
                <span class="cov0" title="0">obj := &amp;repObject{
                        IndexDBItem: *item,
                        reserve:     re.reserve,
                        ring:        re.ring,
                        policy:      re.policy,
                        idb:         idb,
                        metadata:    map[string]string{},
                        client:      re.client,
                        txnId:       fmt.Sprintf("%s-%s", common.UUID(), prirep.FromDevice.Device),
                }
                if err = json.Unmarshal(item.Metabytes, &amp;obj.metadata); err != nil </span><span class="cov0" title="0">{
                        //TODO: this should prob quarantine- also in ec thing that does this too
                        continue</span>
                }
                <span class="cov0" title="0">if obj.Path, err = idb.WholeObjectPath(item.Hash, item.Shard, item.Timestamp, item.Nursery); err != nil </span><span class="cov0" title="0">{
                        continue</span> // TODO: quarantine here too
                }
                <span class="cov0" title="0">if sendItem </span><span class="cov0" title="0">{
                        select </span>{
                        case c &lt;- obj:</span><span class="cov0" title="0">
                        case &lt;-cancel:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }
}

func (re *repEngine) GetObjectsToStabilize(device string, c chan ObjectStabilizer, cancel chan struct{}) <span class="cov0" title="0">{
        defer close(c)
        idb, err := re.getDB(device)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">items, err := idb.ListObjectsToStabilize()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for _, item := range items </span><span class="cov0" title="0">{
                obj := &amp;repObject{
                        IndexDBItem: *item,
                        reserve:     re.reserve,
                        ring:        re.ring,
                        policy:      re.policy,
                        idb:         idb,
                        metadata:    map[string]string{},
                        client:      re.client,
                        txnId:       fmt.Sprintf("%s-%s", common.UUID(), device),
                }
                if err = json.Unmarshal(item.Metabytes, &amp;obj.metadata); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">select </span>{
                case c &lt;- obj:</span><span class="cov0" title="0">
                case &lt;-cancel:<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (re *repEngine) listPartitionHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        idb, err := re.getDB(vars["device"])
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">part, err := strconv.Atoi(vars["partition"])
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">startHash, stopHash := idb.RingPartRange(part)
        items, err := idb.List(startHash, stopHash, "", 0)
        if err != nil </span><span class="cov0" title="0">{
                re.logger.Error("error listing idb", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">if data, err := json.Marshal(items); err == nil </span><span class="cov0" title="0">{
                writer.WriteHeader(http.StatusOK)
                writer.Write(data)
                return
        }</span> else<span class="cov0" title="0"> {
                re.logger.Error("error marshaling listing idb", zap.Error(err))
        }</span>
        <span class="cov0" title="0">srv.StandardResponse(writer, http.StatusInternalServerError)
        return</span>
}

func (re *repEngine) putStableObject(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        idb, err := re.getDB(vars["device"])
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">rStatus, err := idb.StablePut(vars["hash"], roShard, request)
        if err != nil </span><span class="cov0" title="0">{
                re.logger.Error("error in StablePut", zap.Error(err))
        }</span>
        <span class="cov0" title="0">srv.StandardResponse(writer, rStatus)
        return</span>
}

func (re *repEngine) postStableObject(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        idb, err := re.getDB(vars["device"])
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">rStatus, err := idb.StablePost(vars["hash"], roShard, request)
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("error in StablePost", zap.Error(err))
        }</span>
        <span class="cov0" title="0">srv.StandardResponse(writer, rStatus)
        return</span>
}

func (re *repEngine) deleteStableObject(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        idb, err := re.getDB(vars["device"])
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">reqTimeStamp, err := common.ParseDate(request.Header.Get("X-Timestamp"))
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusBadRequest)
        }</span>
        <span class="cov0" title="0">item, err := idb.Lookup(vars["hash"], roShard, true)
        if err != nil || item == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusNotFound)
                return
        }</span>
        <span class="cov0" title="0">if reqTimeStamp.UnixNano() &lt; item.Timestamp </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusConflict)
                return
        }</span>

        <span class="cov0" title="0">if err := idb.Remove(item.Hash, item.Shard, item.Timestamp, item.Nursery); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusInternalServerError)
        }</span> else<span class="cov0" title="0"> {
                srv.StandardResponse(writer, http.StatusNoContent)
        }</span>
}

func (re *repEngine) RegisterHandlers(addRoute func(method, path string, handler http.HandlerFunc)) <span class="cov0" title="0">{
        addRoute("GET", "/rep-partition/:device/:partition", re.listPartitionHandler)
        addRoute("PUT", "/rep-obj/:device/:hash", re.putStableObject)
        addRoute("POST", "/rep-obj/:device/:hash", re.postStableObject)
        addRoute("DELETE", "/rep-obj/:device/:hash", re.deleteStableObject)
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package objectserver

import (
        "bufio"
        "encoding/hex"
        "encoding/json"
        "io/ioutil"
        "net"
        "net/http"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/justinas/alice"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/pickle"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/middleware"
        "github.com/uber-go/tally"
        promreporter "github.com/uber-go/tally/prometheus"
        "go.uber.org/zap"
)

func (r *Replicator) incomingBegin(device string, timeout time.Duration) bool <span class="cov8" title="1">{
        r.incomingSemLock.Lock()
        devSem, ok := r.incomingSem[device]
        if !ok </span><span class="cov8" title="1">{
                devSem = make(chan struct{}, r.incomingLimitPerDev)
                r.incomingSem[device] = devSem
        }</span>
        <span class="cov8" title="1">r.incomingSemLock.Unlock()
        select </span>{
        case devSem &lt;- struct{}{}:<span class="cov8" title="1">
                return true</span>
        case &lt;-time.After(timeout):<span class="cov0" title="0">
                return false</span>
        }
}

func (r *Replicator) incomingDone(device string) <span class="cov8" title="1">{
        r.incomingSemLock.Lock()
        sem := r.incomingSem[device]
        r.incomingSemLock.Unlock()
        &lt;-sem
}</span>

// ProgressReportHandler handles HTTP requests for current replication progress
func (r *Replicator) ProgressReportHandler(w http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(req)
        data, err := json.Marshal(r.getDeviceProgress(vars["name"]))
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Error Marshaling device progress", zap.Error(err))
                w.WriteHeader(http.StatusInternalServerError)
                w.Write([]byte(err.Error()))
                return
        }</span>
        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        w.Write(data)
        return</span>
}

// priorityRepHandler handles HTTP requests for priority replications jobs.
func (r *Replicator) priorityRepHandler(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        var pri PriorityRepJob
        data, err := ioutil.ReadAll(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(500)
                return
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal(data, &amp;pri); err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(400)
                return
        }</span>
        <span class="cov8" title="1">if r.checkMounts </span><span class="cov0" title="0">{
                if mounted, err := fs.IsMount(filepath.Join(r.deviceRoot, pri.FromDevice.Device)); err != nil || mounted == false </span><span class="cov0" title="0">{
                        w.WriteHeader(507)
                        return
                }</span>
        }
        <span class="cov8" title="1">r.runningDevicesLock.Lock()
        rd, ok := r.runningDevices[deviceKeyId(pri.FromDevice.Device, pri.Policy)]
        r.runningDevicesLock.Unlock()
        if ok </span><span class="cov8" title="1">{
                rd.PriorityReplicate(w, pri)
        }</span> else<span class="cov8" title="1"> {
                w.WriteHeader(404)
        }</span>
}

// priorityRepHandler handles HTTP requests for priority replications jobs.
func (r *Replicator) stabilizeHandler(w http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(req)
        policy, err := strconv.Atoi(req.Header.Get("X-Backend-Storage-Policy-Index"))
        if err != nil </span><span class="cov0" title="0">{
                policy = 0
        }</span>
        <span class="cov0" title="0">engine, ok := r.objEngines[policy]
        if !ok </span><span class="cov0" title="0">{
                r.logger.Error("invalid policy to stabilizeHandler")
                w.WriteHeader(500)
                return
        }</span>
        <span class="cov0" title="0">oring, ok := r.objectRings[policy]
        if !ok </span><span class="cov0" title="0">{
                r.logger.Error("ring not found for policy")
                w.WriteHeader(500)
                return
        }</span>
        <span class="cov0" title="0">ringDevices, err := oring.LocalDevices(r.port)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Error getting local devices from ring", zap.Error(err))
                w.WriteHeader(500)
                return
        }</span>
        <span class="cov0" title="0">var rdev *ring.Device
        for _, dev := range ringDevices </span><span class="cov0" title="0">{
                if dev.Device == vars["device"] </span><span class="cov0" title="0">{
                        rdev = dev
                        break</span>
                }
        }
        <span class="cov0" title="0">if rdev == nil </span><span class="cov0" title="0">{
                r.logger.Error("could not find device in ring", zap.String("device", vars["device"]))
                w.WriteHeader(500)
                return
        }</span>

        <span class="cov0" title="0">o, err := engine.New(vars, false, &amp;r.asyncWG)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("could not build stabilizeHandler Object", zap.Error(err))
                w.WriteHeader(500)
                return
        }</span>
        <span class="cov0" title="0">key := deviceKeyId(vars["device"], policy)
        if rd, ok := r.runningDevices[key]; ok </span><span class="cov0" title="0">{
                if os, ok := o.(ObjectStabilizer); ok </span><span class="cov0" title="0">{
                        if err = os.Stabilize(rdev); err == nil </span><span class="cov0" title="0">{
                                rd.UpdateStat("objectsPeerStabilized", 1)
                        }</span>
                }
                <span class="cov0" title="0">w.WriteHeader(200)
                return</span>
        }
        <span class="cov0" title="0">w.WriteHeader(404)</span>
}

func (r *Replicator) objReplicateHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)

        var recalculate []string
        if len(vars["suffixes"]) &gt; 0 </span><span class="cov8" title="1">{
                recalculate = strings.Split(vars["suffixes"], "-")
        }</span>
        <span class="cov8" title="1">policy, err := strconv.Atoi(request.Header.Get("X-Backend-Storage-Policy-Index"))
        if err != nil </span><span class="cov0" title="0">{
                policy = 0
        }</span>
        <span class="cov8" title="1">hashes, err := GetHashes(r.deviceRoot, vars["device"], vars["partition"], recalculate, r.reclaimAge, policy, srv.GetLogger(request))
        if err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("Unable to get hashes",
                        zap.String("Device", vars["device"]),
                        zap.String("Partition", vars["partition"]), zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">writer.WriteHeader(http.StatusOK)
        writer.Write(pickle.PickleDumps(hashes))</span>
}

func (r *Replicator) objRepConnHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        var conn net.Conn
        var rw *bufio.ReadWriter
        var err error
        var brr BeginReplicationRequest

        vars := srv.GetVars(request)
        startTime := time.Now()

        policy, err := strconv.Atoi(request.Header.Get("X-Backend-Storage-Policy-Index"))
        if err != nil </span><span class="cov0" title="0">{
                policy = 0
        }</span>

        <span class="cov8" title="1">writer.WriteHeader(http.StatusOK)
        if hijacker, ok := writer.(http.Hijacker); !ok </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("[ObjRepConnHandler] Writer not a Hijacker")
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span> else<span class="cov8" title="1"> if conn, rw, err = hijacker.Hijack(); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("[ObjRepConnHandler] Hijack failed", zap.Error(err))
                srv.StandardResponse(writer, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer conn.Close()

        rc := NewIncomingRepConn(rw, conn, r.rcTimeout)
        if err := rc.RecvMessage(&amp;brr); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("[ObjRepConnHandler] Error receiving BeginReplicationRequest", zap.Error(err))
                writer.WriteHeader(http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if request.Header.Get("X-Force-Acquire") != "true" </span><span class="cov8" title="1">{
                if !r.incomingBegin(brr.Device, replicateIncomingTimeout) </span><span class="cov0" title="0">{
                        srv.GetLogger(request).Error("[ObjRepConnHandler] Timed out waiting for concurrency slot")
                        writer.WriteHeader(503)
                        return
                }</span>
                <span class="cov8" title="1">defer r.incomingDone(brr.Device)</span>
        }
        <span class="cov8" title="1">var hashes map[string]string
        if brr.NeedHashes </span><span class="cov8" title="1">{
                hashes, err = GetHashes(r.deviceRoot, brr.Device, brr.Partition, nil, r.reclaimAge, policy, srv.GetLogger(request))
                if err != nil </span><span class="cov0" title="0">{
                        srv.GetLogger(request).Error("[ObjRepConnHandler] Error getting hashes", zap.Error(err))
                        writer.WriteHeader(http.StatusInternalServerError)
                        return
                }</span>
        }
        <span class="cov8" title="1">if err := rc.SendMessage(BeginReplicationResponse{Hashes: hashes}); err != nil </span><span class="cov0" title="0">{
                srv.GetLogger(request).Error("[ObjRepConnHandler] Error sending BeginReplicationResponse", zap.Duration("connectionTime", time.Since(startTime)), zap.Error(err))
                writer.WriteHeader(http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">sfrsProcessed := int64(0)
        startTime = time.Now()
        for </span><span class="cov8" title="1">{
                errType, err := func() (string, error) </span><span class="cov8" title="1">{ // this is a closure so we can use defers inside
                        var sfr SyncFileRequest
                        sfrsProcessed++
                        if err := rc.RecvMessage(&amp;sfr); err != nil </span><span class="cov0" title="0">{
                                return "receiving SyncFileRequest", err
                        }</span>
                        <span class="cov8" title="1">if sfr.Done </span><span class="cov8" title="1">{
                                return "", replicationDone
                        }</span>
                        <span class="cov8" title="1">if sfr.Ping </span><span class="cov0" title="0">{
                                return "ping", rc.SendMessage(SyncFileResponse{Msg: "pong"})
                        }</span>
                        <span class="cov8" title="1">tempDir := TempDirPath(r.deviceRoot, vars["device"])
                        fileName := filepath.Join(r.deviceRoot, sfr.Path)
                        hashDir := filepath.Dir(fileName)

                        if ext := filepath.Ext(fileName); (ext != ".data" &amp;&amp; ext != ".ts" &amp;&amp; ext != ".meta") || len(filepath.Base(filepath.Dir(fileName))) != 32 </span><span class="cov0" title="0">{
                                return "invalid file path", rc.SendMessage(SyncFileResponse{Msg: "bad file path"})
                        }</span>
                        <span class="cov8" title="1">if fs.Exists(fileName) </span><span class="cov8" title="1">{
                                return "file exists", rc.SendMessage(SyncFileResponse{Exists: true, Msg: "exists"})
                        }</span>
                        <span class="cov8" title="1">dataFile, metaFile := ObjectFiles(hashDir)
                        if filepath.Base(fileName) &lt; filepath.Base(dataFile) || filepath.Base(fileName) &lt; filepath.Base(metaFile) </span><span class="cov8" title="1">{
                                return "newer file exists", rc.SendMessage(SyncFileResponse{NewerExists: true, Msg: "newer exists"})
                        }</span>
                        <span class="cov8" title="1">if sfr.Check </span><span class="cov0" title="0">{
                                return "just check", rc.SendMessage(SyncFileResponse{Exists: false, Msg: "doesn't exist"})
                        }</span>
                        <span class="cov8" title="1">tempFile, err := fs.NewAtomicFileWriter(tempDir, hashDir)
                        if err != nil </span><span class="cov0" title="0">{
                                return "creating file writer", err
                        }</span>
                        <span class="cov8" title="1">defer tempFile.Abandon()
                        if err := tempFile.Preallocate(sfr.Size, r.reserve); err != nil </span><span class="cov0" title="0">{
                                return "preallocating space", err
                        }</span>
                        <span class="cov8" title="1">if xattrs, err := hex.DecodeString(sfr.Xattrs); err != nil || len(xattrs) == 0 </span><span class="cov0" title="0">{
                                return "parsing xattrs", rc.SendMessage(SyncFileResponse{Msg: "bad xattrs"})
                        }</span> else<span class="cov8" title="1"> if err := common.SwiftObjectRawWriteMetadata(tempFile.Fd(), xattrs); err != nil </span><span class="cov0" title="0">{
                                return "writing metadata", err
                        }</span>
                        <span class="cov8" title="1">if err := rc.SendMessage(SyncFileResponse{GoAhead: true, Msg: "go ahead"}); err != nil </span><span class="cov0" title="0">{
                                return "sending go ahead", err
                        }</span>
                        <span class="cov8" title="1">if _, err := common.CopyN(rc, sfr.Size, tempFile); err != nil </span><span class="cov0" title="0">{
                                return "copying data", err
                        }</span>
                        <span class="cov8" title="1">if err := tempFile.Save(fileName); err != nil </span><span class="cov0" title="0">{
                                return "saving file", err
                        }</span>
                        <span class="cov8" title="1">if dataFile != "" || metaFile != "" </span><span class="cov0" title="0">{
                                HashCleanupListDir(hashDir, r.reclaimAge)
                        }</span>
                        <span class="cov8" title="1">InvalidateHash(hashDir)
                        err = rc.SendMessage(FileUploadResponse{Success: true, Msg: "YAY"})
                        return "file done", err</span>
                }()
                <span class="cov8" title="1">if err == replicationDone </span><span class="cov8" title="1">{
                        return
                }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                        srv.GetLogger(request).Error("[ObjRepConnHandler] Error replicating",
                                zap.String("errType", errType),
                                zap.Int64("sfrsProcessed", sfrsProcessed),
                                zap.Duration("sfrProcessTime", time.Since(startTime)),
                                zap.Error(err))
                        writer.WriteHeader(http.StatusInternalServerError)
                        return
                }</span>
        }
}

func (r *Replicator) LogRequest(next http.Handler) http.Handler <span class="cov8" title="1">{
        return srv.LogRequest(r.logger, next)
}</span>

func (r *Replicator) GetHandler(config conf.Config, metricsPrefix string) http.Handler <span class="cov8" title="1">{
        r.metricsScope, r.metricsCloser = tally.NewRootScope(tally.ScopeOptions{
                Prefix:         metricsPrefix,
                Tags:           map[string]string{},
                CachedReporter: promreporter.NewReporter(promreporter.Options{}),
                Separator:      promreporter.DefaultSeparator,
        }, time.Second)
        commonHandlers := alice.New(
                middleware.NewDebugResponses(config.GetBool("debug", "debug_x_source_code", false)),
                r.LogRequest,
                middleware.RecoverHandler,
                middleware.ValidateRequest,
        )
        router := srv.NewRouter()
        router.Get("/metrics", prometheus.Handler())
        router.Get("/loglevel", r.logLevel)
        router.Put("/loglevel", r.logLevel)
        router.Get("/healthcheck", commonHandlers.ThenFunc(r.HealthcheckHandler))
        router.Get("/debug/pprof/:parm", http.DefaultServeMux)
        router.Post("/debug/pprof/:parm", http.DefaultServeMux)
        router.Post("/priorityrep", commonHandlers.ThenFunc(r.priorityRepHandler))
        router.Post("/stabilize/:device/:partition/:account/:container/*obj", commonHandlers.ThenFunc(r.stabilizeHandler))
        router.Get("/progress/:name", commonHandlers.ThenFunc(r.ProgressReportHandler))
        for _, policy := range r.policies </span><span class="cov8" title="1">{
                router.HandlePolicy("REPCONN", "/:device/:partition", policy.Index, commonHandlers.ThenFunc(r.objRepConnHandler))
                router.HandlePolicy("REPLICATE", "/:device/:partition/:suffixes", policy.Index, commonHandlers.ThenFunc(r.objReplicateHandler))
                router.HandlePolicy("REPLICATE", "/:device/:partition", policy.Index, commonHandlers.ThenFunc(r.objReplicateHandler))
        }</span>
        <span class="cov8" title="1">router.Get("/debug/*_", http.DefaultServeMux)
        for policy, objEngine := range r.objEngines </span><span class="cov8" title="1">{
                if rhoe, ok := objEngine.(PolicyHandlerRegistrator); ok </span><span class="cov8" title="1">{
                        rhoe.RegisterHandlers(func(method, path string, handler http.HandlerFunc) </span><span class="cov8" title="1">{
                                router.HandlePolicy(method, path, policy, commonHandlers.ThenFunc(handler))
                        }</span>)
                }
        }
        <span class="cov8" title="1">return alice.New(middleware.Metrics(r.metricsScope), middleware.ServerTracer(r.tracer)).Then(router)</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package objectserver

import (
        "bufio"
        "crypto/md5"
        "encoding/hex"
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "math/rand"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/pickle"
        "github.com/troubling/hummingbird/common/srv"
        "go.uber.org/zap"
)

var LockPathError = errors.New("Error locking path")
var PathNotDirError = errors.New("Path is not a directory")

func PolicyDir(policy int) string <span class="cov8" title="1">{
        if policy == 0 </span><span class="cov8" title="1">{
                return "objects"
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("objects-%d", policy)</span>
}

func AsyncDir(policy int) string <span class="cov8" title="1">{
        if policy == 0 </span><span class="cov8" title="1">{
                return "async_pending"
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("async_pending-%d", policy)</span>
}

func UnPolicyDir(dir string) (int, error) <span class="cov8" title="1">{
        if dir == "objects" </span><span class="cov8" title="1">{
                return 0, nil
        }</span>
        <span class="cov8" title="1">var policy int
        if n, err := fmt.Sscanf(dir, "objects-%d", &amp;policy); n == 1 &amp;&amp; err == nil </span><span class="cov8" title="1">{
                return policy, nil
        }</span>
        <span class="cov0" title="0">return 0, fmt.Errorf("Unable to parse policy from dir: %s", dir)</span>
}

func QuarantineHash(hashDir string) error <span class="cov8" title="1">{
        // FYI- this does not invalidate the hash like swift's version. Please
        // do that yourself
        //          objects      partition    suffix       hash
        objsDir := filepath.Dir(filepath.Dir(filepath.Dir(hashDir)))
        driveDir := filepath.Dir(objsDir)
        quarantineDir := filepath.Join(driveDir, "quarantined", filepath.Base(objsDir))
        if err := os.MkdirAll(quarantineDir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">hash := filepath.Base(hashDir)
        destDir := filepath.Join(quarantineDir, hash+"-"+common.UUID())
        if err := os.Rename(hashDir, destDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// InvalidateHash invalidates the hashdir's suffix hash, indicating it needs to be recalculated.
func InvalidateHash(hashDir string) error <span class="cov8" title="1">{
        suffDir := filepath.Dir(hashDir)
        partitionDir := filepath.Dir(suffDir)

        if partitionLock, err := fs.LockPath(partitionDir, 10*time.Second); err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov8" title="1"> {
                defer partitionLock.Close()
        }</span>
        <span class="cov8" title="1">fp, err := os.OpenFile(filepath.Join(partitionDir, "hashes.invalid"), os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0660)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer fp.Close()
        _, err = fmt.Fprintf(fp, "%s\n", filepath.Base(suffDir))
        return err</span>
}

func HashCleanupListDir(hashDir string, reclaimAge int64) ([]string, error) <span class="cov8" title="1">{
        fileList, err := fs.ReadDirNames(hashDir)
        returnList := []string{}
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return returnList, nil
                }</span>
                <span class="cov0" title="0">if fs.IsNotDir(err) </span><span class="cov0" title="0">{
                        return returnList, PathNotDirError
                }</span>
                <span class="cov0" title="0">return returnList, err</span>
        }
        <span class="cov8" title="1">deleteRest := false
        deleteRestMeta := false
        if len(fileList) == 1 </span><span class="cov8" title="1">{
                filename := fileList[0]
                if strings.HasSuffix(filename, ".ts") </span><span class="cov0" title="0">{
                        withoutSuffix := strings.Split(filename, ".")[0]
                        if strings.Contains(withoutSuffix, "_") </span><span class="cov0" title="0">{
                                withoutSuffix = strings.Split(withoutSuffix, "_")[0]
                        }</span>
                        <span class="cov0" title="0">timestamp, _ := strconv.ParseFloat(withoutSuffix, 64)
                        if time.Now().Unix()-int64(timestamp) &gt; reclaimAge </span><span class="cov0" title="0">{
                                os.RemoveAll(hashDir + "/" + filename)
                                return returnList, nil
                        }</span>
                }
                <span class="cov8" title="1">returnList = append(returnList, filename)</span>
        } else<span class="cov8" title="1"> {
                for index := len(fileList) - 1; index &gt;= 0; index-- </span><span class="cov8" title="1">{
                        filename := fileList[index]
                        if deleteRest </span><span class="cov8" title="1">{
                                os.RemoveAll(hashDir + "/" + filename)
                        }</span> else<span class="cov8" title="1"> {
                                if strings.HasSuffix(filename, ".meta") </span><span class="cov8" title="1">{
                                        if deleteRestMeta </span><span class="cov0" title="0">{
                                                os.RemoveAll(hashDir + "/" + filename)
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">deleteRestMeta = true</span>
                                }
                                <span class="cov8" title="1">if strings.HasSuffix(filename, ".ts") || strings.HasSuffix(filename, ".data") </span><span class="cov8" title="1">{
                                        // TODO: check .ts time for expiration
                                        deleteRest = true
                                }</span>
                                <span class="cov8" title="1">returnList = append(returnList, filename)</span>
                        }
                }
        }
        <span class="cov8" title="1">return returnList, nil</span>
}

func RecalculateSuffixHash(suffixDir string, reclaimAge int64) (string, error) <span class="cov8" title="1">{
        // the is hash_suffix in swift
        h := md5.New()

        hashList, err := fs.ReadDirNames(suffixDir)
        if err != nil </span><span class="cov0" title="0">{
                if fs.IsNotDir(err) </span><span class="cov0" title="0">{
                        return "", PathNotDirError
                }</span>
                <span class="cov0" title="0">return "", err</span>
        }
        <span class="cov8" title="1">for _, fullHash := range hashList </span><span class="cov8" title="1">{
                hashPath := suffixDir + "/" + fullHash
                fileList, err := HashCleanupListDir(hashPath, reclaimAge)
                if err != nil </span><span class="cov0" title="0">{
                        if err == PathNotDirError </span><span class="cov0" title="0">{
                                if QuarantineHash(hashPath) == nil </span><span class="cov0" title="0">{
                                        InvalidateHash(hashPath)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov0" title="0">return "", err</span>
                }
                <span class="cov8" title="1">if len(fileList) &gt; 0 </span><span class="cov8" title="1">{
                        for _, fileName := range fileList </span><span class="cov8" title="1">{
                                io.WriteString(h, fileName)
                        }</span>
                } else<span class="cov0" title="0"> {
                        os.Remove(hashPath) // leaves the suffix (swift removes it but who cares)
                }</span>
        }
        <span class="cov8" title="1">return hex.EncodeToString(h.Sum(nil)), nil</span>
}

func GetHashes(driveRoot string, device string, partition string, recalculate []string, reclaimAge int64, policy int, logger srv.LowLevelLogger) (map[string]string, error) <span class="cov8" title="1">{
        partitionDir := filepath.Join(driveRoot, device, PolicyDir(policy), partition)
        pklFile := filepath.Join(partitionDir, "hashes.pkl")
        invalidFile := filepath.Join(partitionDir, "hashes.invalid")

        modified := false
        hashes := make(map[string]string, 4096)
        lsForSuffixes := true
        if data, err := ioutil.ReadFile(pklFile); err == nil </span><span class="cov8" title="1">{
                if v, err := pickle.PickleLoads(data); err == nil </span><span class="cov8" title="1">{
                        if pickledHashes, ok := v.(map[interface{}]interface{}); ok </span><span class="cov8" title="1">{
                                lsForSuffixes = false
                                for suff, hash := range pickledHashes </span><span class="cov8" title="1">{
                                        if hashes[suff.(string)], ok = hash.(string); !ok </span><span class="cov0" title="0">{
                                                hashes[suff.(string)] = ""
                                        }</span>
                                }
                        }
                }
        }
        // check occasionally to see if there are any suffixes not in the hashes.pkl
        <span class="cov8" title="1">if !lsForSuffixes &amp;&amp; len(hashes) &lt; 4096 </span><span class="cov8" title="1">{
                lsForSuffixes = rand.Int31n(10) == 0
        }</span>
        <span class="cov8" title="1">if lsForSuffixes </span><span class="cov8" title="1">{
                // couldn't load hashes pickle, start building new one
                suffs, _ := fs.ReadDirNames(partitionDir)

                for _, suffName := range suffs </span><span class="cov8" title="1">{
                        if len(suffName) == 3 &amp;&amp; hashes[suffName] == "" </span><span class="cov8" title="1">{
                                hashes[suffName] = ""
                        }</span>
                }
        }
        <span class="cov8" title="1">for _, suffix := range recalculate </span><span class="cov8" title="1">{
                if len(suffix) == 3 </span><span class="cov8" title="1">{
                        hashes[suffix] = ""
                }</span>
        }
        <span class="cov8" title="1">mtime := int64(-1)
        if ivf, err := os.OpenFile(invalidFile, os.O_RDWR, 0660); err == nil </span><span class="cov8" title="1">{
                defer ivf.Close()
                if fileInfo, err := ivf.Stat(); err == nil </span><span class="cov8" title="1">{
                        mtime = fileInfo.ModTime().Unix()
                        scanner := bufio.NewScanner(ivf)
                        for scanner.Scan() </span><span class="cov8" title="1">{
                                if suff := scanner.Text(); len(suff) == 3 &amp;&amp; strings.Trim(suff, "0123456789abcdef") == "" </span><span class="cov8" title="1">{
                                        hashes[suff] = ""
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">for suffix, hash := range hashes </span><span class="cov8" title="1">{
                if hash == "" </span><span class="cov8" title="1">{
                        modified = true
                        suffixDir := filepath.Join(partitionDir, suffix)
                        recalc_hash, err := RecalculateSuffixHash(suffixDir, reclaimAge)
                        switch err </span>{
                        case nil:<span class="cov8" title="1">
                                hashes[suffix] = recalc_hash</span>
                        case PathNotDirError:<span class="cov0" title="0">
                                delete(hashes, suffix)</span>
                        default:<span class="cov0" title="0">
                                logger.Error("Error hashing suffix",
                                        zap.String("partitionDir", partitionDir),
                                        zap.String("zapsuffix", suffix),
                                        zap.Error(err))</span>
                        }
                }
        }
        <span class="cov8" title="1">if modified </span><span class="cov8" title="1">{
                partitionLock, err := fs.LockPath(partitionDir, 10*time.Second)
                defer partitionLock.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, LockPathError
                }</span> else<span class="cov8" title="1"> {
                        fileInfo, err := os.Stat(invalidFile)
                        if lsForSuffixes || os.IsNotExist(err) || mtime == fileInfo.ModTime().Unix() </span><span class="cov8" title="1">{
                                tempDir := TempDirPath(driveRoot, device)
                                if tempFile, err := fs.NewAtomicFileWriter(tempDir, partitionDir); err == nil </span><span class="cov8" title="1">{
                                        defer tempFile.Abandon()
                                        tempFile.Write(pickle.PickleDumps(hashes))
                                        tempFile.Save(pklFile)
                                }</span>
                                <span class="cov8" title="1">os.Truncate(invalidFile, 0)
                                return hashes, nil</span>
                        }
                        <span class="cov0" title="0">logger.Debug("Making recursive call to GetHashes.", zap.String("partitionDir", partitionDir))
                        partitionLock.Close()
                        return GetHashes(driveRoot, device, partition, recalculate, reclaimAge, policy, logger)</span>
                }
        }
        <span class="cov8" title="1">return hashes, nil</span>
}

func ObjHash(vars map[string]string, hashPathPrefix string, hashPathSuffix string) string <span class="cov8" title="1">{
        h := md5.New()
        io.WriteString(h, hashPathPrefix+"/"+vars["account"]+"/"+vars["container"]+"/"+vars["obj"]+hashPathSuffix)
        return hex.EncodeToString(h.Sum(nil))
}</span>

func ObjHashDir(vars map[string]string, driveRoot string, hashPathPrefix string, hashPathSuffix string, policy int) string <span class="cov8" title="1">{
        hexHash := ObjHash(vars, hashPathPrefix, hashPathSuffix)
        suffix := hexHash[29:32]
        return filepath.Join(driveRoot, vars["device"], PolicyDir(policy), vars["partition"], suffix, hexHash)
}</span>

func ObjectFiles(directory string) (string, string) <span class="cov8" title="1">{
        fileList, err := fs.ReadDirNames(directory)
        metaFile := ""
        if err != nil </span><span class="cov8" title="1">{
                return "", ""
        }</span>
        <span class="cov8" title="1">for index := len(fileList) - 1; index &gt;= 0; index-- </span><span class="cov8" title="1">{
                filename := fileList[index]
                if strings.HasSuffix(filename, ".meta") </span><span class="cov8" title="1">{
                        metaFile = filename
                }</span>
                <span class="cov8" title="1">if strings.HasSuffix(filename, ".ts") || strings.HasSuffix(filename, ".data") </span><span class="cov8" title="1">{
                        if metaFile != "" </span><span class="cov8" title="1">{
                                return filepath.Join(directory, filename), filepath.Join(directory, metaFile)
                        }</span> else<span class="cov8" title="1"> {
                                return filepath.Join(directory, filename), ""
                        }</span>
                }
        }
        <span class="cov8" title="1">return "", ""</span>
}

func applyMetaFile(metaFile string, datafileMetadata map[string]string) (map[string]string, error) <span class="cov8" title="1">{
        if metadata, err := common.SwiftObjectReadMetadata(metaFile); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span> else<span class="cov8" title="1"> {
                for k, v := range datafileMetadata </span><span class="cov8" title="1">{
                        if k == "Content-Length" || k == "Content-Type" || k == "deleted" || k == "ETag" || k == "X-Backend-Data-Timestamp" || strings.HasPrefix(k, "X-Object-Sysmeta-") </span><span class="cov8" title="1">{
                                metadata[k] = v
                        }</span>
                }
                <span class="cov8" title="1">metadata["X-Backend-Meta-Timestamp"] = metadata["X-Timestamp"]
                return metadata, nil</span>
        }
}

func OpenObjectMetadata(fd uintptr, metaFile string) (map[string]string, error) <span class="cov8" title="1">{
        datafileMetadata, err := common.SwiftObjectReadMetadata(fd)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">datafileMetadata["X-Backend-Data-Timestamp"] = datafileMetadata["X-Timestamp"]
        if metaFile != "" </span><span class="cov8" title="1">{
                return applyMetaFile(metaFile, datafileMetadata)
        }</span>
        <span class="cov8" title="1">return datafileMetadata, nil</span>
}

func ObjectMetadata(dataFile string, metaFile string) (map[string]string, error) <span class="cov8" title="1">{
        datafileMetadata, err := common.SwiftObjectReadMetadata(dataFile)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">datafileMetadata["X-Backend-Data-Timestamp"] = datafileMetadata["X-Timestamp"]
        if metaFile != "" </span><span class="cov8" title="1">{
                return applyMetaFile(metaFile, datafileMetadata)
        }</span>
        <span class="cov8" title="1">return datafileMetadata, nil</span>
}

func TempDirPath(driveRoot string, device string) string <span class="cov8" title="1">{
        return filepath.Join(driveRoot, device, "tmp")
}</span>

func Expired(metadata map[string]string) bool <span class="cov8" title="1">{
        if deleteAt, ok := metadata["X-Delete-At"]; ok </span><span class="cov0" title="0">{
                if deleteTime, err := common.ParseDate(deleteAt); err == nil &amp;&amp; deleteTime.Before(time.Now()) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package objectserver

import (
        "encoding/hex"
        "encoding/json"
        "errors"
        "flag"
        "fmt"
        "io"
        "io/ioutil"
        "math/rand"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "time"

        "go.uber.org/zap"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/pickle"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
)

func getFile(filePath string) (fp *os.File, xattrs []byte, size int64, err error) <span class="cov8" title="1">{
        fp, err = os.Open(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, 0, fmt.Errorf("unable to open file (%v): %s", err, filePath)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        fp.Close()
                }</span>
        }()
        <span class="cov8" title="1">finfo, err := fp.Stat()
        if err != nil || !finfo.Mode().IsRegular() </span><span class="cov8" title="1">{
                return nil, nil, 0, quarantineFileError{"not a regular file"}
        }</span>
        <span class="cov8" title="1">rawxattr, err := common.SwiftObjectRawReadMetadata(fp.Fd())
        if err != nil || len(rawxattr) == 0 </span><span class="cov8" title="1">{
                return nil, nil, 0, quarantineFileError{"error reading xattrs"}
        }</span>

        // Perform a mini-audit, since it's cheap and we can potentially avoid spreading bad data around.
        <span class="cov8" title="1">v, err := pickle.PickleLoads(rawxattr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, 0, quarantineFileError{"error unpickling xattrs"}
        }</span>
        <span class="cov8" title="1">metadata, ok := v.(map[interface{}]interface{})
        if !ok </span><span class="cov8" title="1">{
                return nil, nil, 0, quarantineFileError{"invalid metadata type"}
        }</span>
        <span class="cov8" title="1">for key, value := range metadata </span><span class="cov8" title="1">{
                if _, ok := key.(string); !ok </span><span class="cov8" title="1">{
                        return nil, nil, 0, quarantineFileError{"invalid key in metadata"}
                }</span>
                <span class="cov8" title="1">if _, ok := value.(string); !ok </span><span class="cov8" title="1">{
                        return nil, nil, 0, quarantineFileError{"invalid value in metadata"}
                }</span>
        }
        <span class="cov8" title="1">switch filepath.Ext(filePath) </span>{
        case ".data":<span class="cov8" title="1">
                for _, reqEntry := range []string{"Content-Length", "Content-Type", "name", "ETag", "X-Timestamp"} </span><span class="cov8" title="1">{
                        if _, ok := metadata[reqEntry]; !ok </span><span class="cov8" title="1">{
                                return nil, nil, 0, quarantineFileError{".data missing required metadata"}
                        }</span>
                }
                <span class="cov8" title="1">if contentLength, err := strconv.ParseInt(metadata["Content-Length"].(string), 10, 64); err != nil || contentLength != finfo.Size() </span><span class="cov0" title="0">{
                        return nil, nil, 0, quarantineFileError{"invalid content-length"}
                }</span>
        case ".ts":<span class="cov8" title="1">
                for _, reqEntry := range []string{"name", "X-Timestamp"} </span><span class="cov8" title="1">{
                        if _, ok := metadata[reqEntry]; !ok </span><span class="cov8" title="1">{
                                return nil, nil, 0, quarantineFileError{".ts missing required metadata"}
                        }</span>
                }
        }
        <span class="cov8" title="1">return fp, rawxattr, finfo.Size(), nil</span>
}

type swiftDevice struct {
        // If you have a better way to make struct methods that are overridable for tests, please call my house.
        i interface {
                beginReplication(dev *ring.Device, partition string, hashes bool, rChan chan beginReplicationResponse, headers map[string]string)
                listObjFiles(objChan chan string, cancel chan struct{}, partdir string, needSuffix func(string) bool)
                syncFile(objFile string, dst []*syncFileArg, handoff bool) (syncs int, insync int, err error)
                replicateUsingHashes(rjob replJob, moreNodes ring.MoreNodes) (int64, error)
                replicateAll(rjob replJob, isHandoff bool) (int64, error)
                cleanTemp()
                listPartitions() ([]string, []string, error)
                replicatePartition(partition string)
        }
        r      *Replicator
        dev    *ring.Device
        policy int
        cancel chan struct{}
}

type beginReplicationResponse struct {
        dev    *ring.Device
        conn   RepConn
        hashes map[string]string
        err    error
}

type syncFileArg struct {
        conn RepConn
        dev  *ring.Device
}

type replJob struct {
        partition string
        nodes     []*ring.Device
        headers   map[string]string
}

type quarantineFileError struct {
        msg string
}

func (q quarantineFileError) Error() string <span class="cov0" title="0">{
        return q.msg
}</span>

func (rd *swiftDevice) UpdateStat(stat string, amount int64) <span class="cov8" title="1">{
        rd.r.updateStat &lt;- statUpdate{rd.Type(), rd.Key(), stat, amount}
}</span>

func (rd *swiftDevice) listObjFiles(objChan chan string, cancel chan struct{}, partdir string, needSuffix func(string) bool) <span class="cov8" title="1">{
        defer close(objChan)
        suffixDirs, err := filepath.Glob(filepath.Join(partdir, "[a-f0-9][a-f0-9][a-f0-9]"))
        if err != nil </span><span class="cov0" title="0">{
                rd.r.logger.Error("[listObjFiles]", zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">if len(suffixDirs) == 0 </span><span class="cov8" title="1">{
                os.Remove(filepath.Join(partdir, ".lock"))
                os.Remove(filepath.Join(partdir, "hashes.pkl"))
                os.Remove(filepath.Join(partdir, "hashes.invalid"))
                os.Remove(partdir)
                return
        }</span>
        <span class="cov8" title="1">for i := len(suffixDirs) - 1; i &gt; 0; i-- </span><span class="cov0" title="0">{ // shuffle suffixDirs list
                j := rand.Intn(i + 1)
                suffixDirs[j], suffixDirs[i] = suffixDirs[i], suffixDirs[j]
        }</span>
        <span class="cov8" title="1">for _, suffDir := range suffixDirs </span><span class="cov8" title="1">{
                if !needSuffix(filepath.Base(suffDir)) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">hashDirs, err := filepath.Glob(filepath.Join(suffDir, "????????????????????????????????"))
                if err != nil </span><span class="cov0" title="0">{
                        rd.r.logger.Error("[listObjFiles]", zap.Error(err))
                        return
                }</span>
                <span class="cov8" title="1">if len(hashDirs) == 0 </span><span class="cov8" title="1">{
                        os.Remove(suffDir)
                        continue</span>
                }
                <span class="cov8" title="1">for _, hashDir := range hashDirs </span><span class="cov8" title="1">{
                        fileList, err := filepath.Glob(filepath.Join(hashDir, "*.[tdm]*"))
                        if len(fileList) == 0 </span><span class="cov8" title="1">{
                                os.Remove(hashDir)
                                continue</span>
                        }
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                rd.r.logger.Error("[listObjFiles]", zap.Error(err))
                                return
                        }</span>
                        <span class="cov8" title="1">for _, objFile := range fileList </span><span class="cov8" title="1">{
                                select </span>{
                                case objChan &lt;- objFile:</span><span class="cov8" title="1">
                                case &lt;-cancel:<span class="cov8" title="1">
                                        return</span>
                                }
                        }
                }
        }
}

func (rd *swiftDevice) syncFile(objFile string, dst []*syncFileArg, handoff bool) (syncs int, insync int, err error) <span class="cov8" title="1">{
        // TODO: parallelize the data transfer someday
        var wrs []*syncFileArg
        lst := strings.Split(objFile, string(os.PathSeparator))
        relPath := filepath.Join(lst[len(lst)-5:]...)
        fp, xattrs, fileSize, err := getFile(objFile)
        if _, ok := err.(quarantineFileError); ok </span><span class="cov0" title="0">{
                hashDir := filepath.Dir(objFile)
                rd.r.logger.Error("[syncFile] Failed audit and is being quarantined",
                        zap.String("hashDir", hashDir),
                        zap.Error(err))
                QuarantineHash(hashDir)
                return 0, 0, nil
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                return 0, 0, nil
        }</span>
        <span class="cov8" title="1">defer fp.Close()

        // are we already going to sync to this region?
        syncingRemoteRegion := make(map[int]bool)

        // ask each server if we need to sync the file
        for _, sfa := range dst </span><span class="cov8" title="1">{
                var sfr SyncFileResponse
                thisPath := filepath.Join(sfa.dev.Device, relPath)
                sfa.conn.SendMessage(SyncFileRequest{Path: thisPath, Xattrs: hex.EncodeToString(xattrs), Size: fileSize,
                        // if we're already syncing handoffs to this remote region, just do a check
                        Check: handoff &amp;&amp; syncingRemoteRegion[sfa.dev.Region],
                        // If we're not syncing handoffs, we don't care about the state. Just ping to keep the connection alive.
                        Ping: !handoff &amp;&amp; syncingRemoteRegion[sfa.dev.Region],
                })
                if err := sfa.conn.RecvMessage(&amp;sfr); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov8" title="1"> if sfr.GoAhead </span><span class="cov8" title="1">{
                        wrs = append(wrs, sfa)
                        if sfa.dev.Region != rd.dev.Region </span><span class="cov8" title="1">{
                                syncingRemoteRegion[sfa.dev.Region] = true
                        }</span>
                } else<span class="cov8" title="1"> if sfr.NewerExists </span><span class="cov8" title="1">{
                        insync++
                        if os.Remove(objFile) == nil </span><span class="cov8" title="1">{
                                InvalidateHash(filepath.Dir(objFile))
                        }</span>
                } else<span class="cov8" title="1"> if sfr.Exists </span><span class="cov8" title="1">{
                        insync++
                }</span>
        }
        <span class="cov8" title="1">if len(wrs) == 0 </span><span class="cov8" title="1">{ // nobody needed the file
                return
        }</span>

        // send the file to servers
        <span class="cov8" title="1">scratch := make([]byte, 32768)
        var length int
        var totalRead int64
        for length, err = fp.Read(scratch); err == nil; length, err = fp.Read(scratch) </span><span class="cov8" title="1">{
                totalRead += int64(length)
                for index, sfa := range wrs </span><span class="cov8" title="1">{
                        if sfa == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if _, err := sfa.conn.Write(scratch[0:length]); err != nil </span><span class="cov0" title="0">{
                                rd.r.logger.Error("Failed to write to remoteDevice",
                                        zap.Int("device id", sfa.dev.Id),
                                        zap.Error(err))
                                wrs[index] = nil
                        }</span>
                }
        }
        <span class="cov8" title="1">if totalRead != fileSize </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("Failed to read the full file: %s, %v", objFile, err)
        }</span>

        // get file upload results
        <span class="cov8" title="1">for _, sfa := range wrs </span><span class="cov8" title="1">{
                if sfa == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">var fur FileUploadResponse
                sfa.conn.Flush()
                if sfa.conn.RecvMessage(&amp;fur) == nil </span><span class="cov8" title="1">{
                        if fur.Success </span><span class="cov8" title="1">{
                                syncs++
                                insync++
                                rd.UpdateStat("FilesSent", 1)
                                rd.UpdateStat("BytesSent", fileSize)
                        }</span>
                }
        }
        <span class="cov8" title="1">return syncs, insync, nil</span>
}

func spaceWriter(w http.ResponseWriter, c chan struct{}, d chan struct{}) <span class="cov8" title="1">{
        defer close(d)
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-time.After(time.Minute):<span class="cov0" title="0">
                        w.Write([]byte(" "))</span>
                case &lt;-c:<span class="cov8" title="1">
                        return</span>
                }
        }
}

func (rd *swiftDevice) PriorityReplicate(w http.ResponseWriter, pri PriorityRepJob) <span class="cov8" title="1">{
        if !fs.Exists(filepath.Join(rd.r.deviceRoot, pri.FromDevice.Device, PolicyDir(rd.policy), strconv.FormatUint(pri.Partition, 10))) </span><span class="cov0" title="0">{
                w.WriteHeader(404)
                return
        }</span>
        <span class="cov8" title="1">partition := strconv.FormatUint(pri.Partition, 10)
        _, handoff := rd.r.objectRings[rd.policy].GetJobNodes(pri.Partition, pri.FromDevice.Id)
        jobType := "local"
        if handoff </span><span class="cov8" title="1">{
                jobType = "handoff"
        }</span>
        <span class="cov8" title="1">policy := rd.r.policies[rd.policy]
        if policy == nil </span><span class="cov0" title="0">{
                w.WriteHeader(400)
                return
        }</span>
        <span class="cov8" title="1">rd.r.logger.Info("PriorityReplicationJob",
                zap.Uint64("partition", pri.Partition),
                zap.String("jobType", jobType),
                zap.String("From Device", pri.FromDevice.Device),
                zap.String("To Device", pri.ToDevice.Device))
        rjob := replJob{
                partition: partition, nodes: []*ring.Device{pri.ToDevice},
                headers: map[string]string{"X-Force-Acquire": "true"}}
        var synced int64
        var err error
        w.WriteHeader(200)
        swc := make(chan struct{})
        swd := make(chan struct{})
        go spaceWriter(w, swc, swd)
        if handoff || (policy.Type == "replication-nursery" &amp;&amp;
                !common.LooksTrue(policy.Config["cache_hash_dirs"])) </span><span class="cov8" title="1">{
                synced, err = rd.i.replicateAll(rjob, handoff)
        }</span> else<span class="cov8" title="1"> {
                synced, err = rd.i.replicateUsingHashes(rjob, &amp;NoMoreNodes{})
        }</span>
        <span class="cov8" title="1">rd.UpdateStat("PriorityRepsDone", 1)
        prr := PriorityReplicationResult{ObjectsReplicated: synced, Success: err == nil}
        if err != nil </span><span class="cov0" title="0">{
                prr.ErrorMsg = fmt.Sprintf("%v", err)
        }</span>
        <span class="cov8" title="1">b, err := json.Marshal(prr)
        if err != nil </span><span class="cov0" title="0">{
                rd.r.logger.Error("error prirep jsoning", zap.Error(err))
                b = []byte("There was an internal server error generating JSON.")
        }</span>
        <span class="cov8" title="1">close(swc)
        &lt;-swd
        w.Write(b)
        w.Write([]byte("\n"))</span>
}

func (rd *swiftDevice) beginReplication(dev *ring.Device, partition string, hashes bool, rChan chan beginReplicationResponse, headers map[string]string) <span class="cov8" title="1">{
        var brr BeginReplicationResponse
        if headers == nil </span><span class="cov8" title="1">{
                headers = map[string]string{}
        }</span>
        <span class="cov8" title="1">headers["X-Trans-Id"] = fmt.Sprintf("%s-%d", common.UUID(), dev.Id)

        if rc, err := NewRepConn(dev, partition, rd.policy, headers, rd.r.CertFile, rd.r.KeyFile, rd.r.rcTimeout); err != nil </span><span class="cov8" title="1">{
                rChan &lt;- beginReplicationResponse{dev: dev, err: err}
        }</span> else<span class="cov8" title="1"> if err := rc.SendMessage(BeginReplicationRequest{Device: dev.Device, Partition: partition, NeedHashes: hashes}); err != nil </span><span class="cov0" title="0">{
                rChan &lt;- beginReplicationResponse{dev: dev, err: err}
        }</span> else<span class="cov8" title="1"> if err := rc.RecvMessage(&amp;brr); err != nil </span><span class="cov0" title="0">{
                rChan &lt;- beginReplicationResponse{dev: dev, err: err}
        }</span> else<span class="cov8" title="1"> {
                rChan &lt;- beginReplicationResponse{dev: dev, conn: rc, hashes: brr.Hashes}
        }</span>
}

func (rd *swiftDevice) replicateUsingHashes(rjob replJob, moreNodes ring.MoreNodes) (int64, error) <span class="cov8" title="1">{
        path := filepath.Join(rd.r.deviceRoot, rd.dev.Device, PolicyDir(rd.policy), rjob.partition)
        syncCount := int64(0)
        startGetHashesRemote := time.Now()
        remoteHashes := make(map[int]map[string]string)
        remoteConnections := make(map[int]RepConn)
        rChan := make(chan beginReplicationResponse)
        for _, dev := range rjob.nodes </span><span class="cov8" title="1">{
                go rd.i.beginReplication(dev, rjob.partition, true, rChan, rjob.headers)
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; len(rjob.nodes); i++ </span><span class="cov8" title="1">{
                rData := &lt;-rChan
                if rData.err == nil </span><span class="cov8" title="1">{
                        defer rData.conn.Close()
                        remoteHashes[rData.dev.Id] = rData.hashes
                        remoteConnections[rData.dev.Id] = rData.conn
                }</span> else<span class="cov8" title="1"> if rData.err == RepUnmountedError </span><span class="cov8" title="1">{
                        if nextNode := moreNodes.Next(); nextNode != nil </span><span class="cov8" title="1">{
                                go rd.i.beginReplication(nextNode, rjob.partition, true, rChan, rjob.headers)
                                rjob.nodes = append(rjob.nodes, nextNode)
                        }</span> else<span class="cov0" title="0"> {
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">if len(remoteHashes) == 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("replicateAll could get no remote connections")
        }</span>

        <span class="cov8" title="1">timeGetHashesRemote := float64(time.Now().Sub(startGetHashesRemote)) / float64(time.Second)
        startGetHashesLocal := time.Now()

        recalc := []string{}
        hashes, err := GetHashes(rd.r.deviceRoot, rd.dev.Device, rjob.partition, recalc, rd.r.reclaimAge, rd.policy, rd.r.logger)
        if err != nil </span><span class="cov0" title="0">{
                rd.r.logger.Error("[replicateUsingHashes] error getting local hashes", zap.Error(err))
                return 0, err
        }</span>
        <span class="cov8" title="1">for suffix, localHash := range hashes </span><span class="cov8" title="1">{
                for _, remoteHash := range remoteHashes </span><span class="cov8" title="1">{
                        if remoteHash[suffix] != "" &amp;&amp; localHash != remoteHash[suffix] </span><span class="cov8" title="1">{
                                recalc = append(recalc, suffix)
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">hashes, err = GetHashes(rd.r.deviceRoot, rd.dev.Device, rjob.partition, recalc, rd.r.reclaimAge, rd.policy, rd.r.logger)
        if err != nil </span><span class="cov0" title="0">{
                rd.r.logger.Error("[replicateUsingHashes] error recalculating local hashes", zap.Error(err))
                return 0, err
        }</span>
        <span class="cov8" title="1">timeGetHashesLocal := float64(time.Now().Sub(startGetHashesLocal)) / float64(time.Second)

        objChan := make(chan string, 100)
        cancel := make(chan struct{})
        defer close(cancel)
        go rd.i.listObjFiles(objChan, cancel, path, func(suffix string) bool </span><span class="cov8" title="1">{
                for _, remoteHash := range remoteHashes </span><span class="cov8" title="1">{
                        if hashes[suffix] != remoteHash[suffix] </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        })
        <span class="cov8" title="1">startSyncing := time.Now()
        for objFile := range objChan </span><span class="cov8" title="1">{
                toSync := make([]*syncFileArg, 0)
                suffix := filepath.Base(filepath.Dir(filepath.Dir(objFile)))
                for _, dev := range rjob.nodes </span><span class="cov8" title="1">{
                        if rhashes, ok := remoteHashes[dev.Id]; ok &amp;&amp; hashes[suffix] != rhashes[suffix] </span><span class="cov8" title="1">{
                                if !remoteConnections[dev.Id].Disconnected() </span><span class="cov8" title="1">{
                                        toSync = append(toSync, &amp;syncFileArg{conn: remoteConnections[dev.Id], dev: dev})
                                }</span>
                        }
                }
                <span class="cov8" title="1">if len(toSync) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">if syncs, _, err := rd.i.syncFile(objFile, toSync, false); err == nil </span><span class="cov8" title="1">{
                        syncCount += int64(syncs)
                }</span> else<span class="cov0" title="0"> {
                        rd.r.logger.Error("[syncFile]", zap.Error(err))
                        return syncCount, err
                }</span>
        }
        <span class="cov8" title="1">for _, conn := range remoteConnections </span><span class="cov8" title="1">{
                if !conn.Disconnected() </span><span class="cov8" title="1">{
                        conn.SendMessage(SyncFileRequest{Done: true})
                }</span>
        }
        <span class="cov8" title="1">timeSyncing := float64(time.Now().Sub(startSyncing)) / float64(time.Second)
        if syncCount &gt; 0 </span><span class="cov8" title="1">{
                rd.r.logger.Info("[replicateUsingHashes]",
                        zap.String("Partition", path),
                        zap.Any("Files Synced", syncCount),
                        zap.Float64("timeGetHashesRemote", timeGetHashesRemote),
                        zap.Float64("timeGetHashesLocal", timeGetHashesLocal),
                        zap.Float64("timeSyncing", timeSyncing))
        }</span>
        <span class="cov8" title="1">return syncCount, nil</span>
}

func (rd *swiftDevice) replicateAll(rjob replJob, isHandoff bool) (int64, error) <span class="cov8" title="1">{
        path := filepath.Join(rd.r.deviceRoot, rd.dev.Device, PolicyDir(rd.policy), rjob.partition)
        syncCount := int64(0)
        remoteConnections := make(map[int]RepConn)
        rChan := make(chan beginReplicationResponse)
        for _, dev := range rjob.nodes </span><span class="cov8" title="1">{
                go rd.i.beginReplication(dev, rjob.partition, false, rChan, rjob.headers)
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; len(rjob.nodes); i++ </span><span class="cov8" title="1">{
                rData := &lt;-rChan
                if rData.err == nil </span><span class="cov8" title="1">{
                        defer rData.conn.Close()
                        remoteConnections[rData.dev.Id] = rData.conn
                }</span>
        }
        <span class="cov8" title="1">if len(remoteConnections) == 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("replicateAll could get no remote connections")
        }</span>

        <span class="cov8" title="1">objChan := make(chan string, 100)
        cancel := make(chan struct{})
        defer close(cancel)
        go rd.i.listObjFiles(objChan, cancel, path, func(string) bool </span><span class="cov8" title="1">{ return true }</span>)
        <span class="cov8" title="1">for objFile := range objChan </span><span class="cov8" title="1">{
                toSync := make([]*syncFileArg, 0)
                for _, dev := range rjob.nodes </span><span class="cov8" title="1">{
                        if remoteConnections[dev.Id] != nil &amp;&amp; !remoteConnections[dev.Id].Disconnected() </span><span class="cov8" title="1">{
                                toSync = append(toSync, &amp;syncFileArg{conn: remoteConnections[dev.Id], dev: dev})
                        }</span>
                }
                <span class="cov8" title="1">if len(toSync) == 0 </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("replicateAll could get no remote connections to sync")
                }</span>
                <span class="cov8" title="1">if syncs, insync, err := rd.i.syncFile(objFile, toSync, true); err == nil </span><span class="cov8" title="1">{
                        syncCount += int64(syncs)

                        success := insync == len(rjob.nodes)
                        if rd.r.quorumDelete </span><span class="cov0" title="0">{
                                success = insync &gt;= len(rjob.nodes)/2+1
                        }</span>
                        <span class="cov8" title="1">if success &amp;&amp; isHandoff </span><span class="cov8" title="1">{
                                os.Remove(objFile)
                                os.Remove(filepath.Dir(objFile))
                        }</span>
                } else<span class="cov0" title="0"> {
                        rd.r.logger.Error("[syncFile]", zap.Error(err))
                        return syncCount, err
                }</span>
        }
        <span class="cov8" title="1">for _, conn := range remoteConnections </span><span class="cov8" title="1">{
                if !conn.Disconnected() </span><span class="cov8" title="1">{
                        conn.SendMessage(SyncFileRequest{Done: true})
                }</span>
        }
        <span class="cov8" title="1">if syncCount &gt; 0 </span><span class="cov8" title="1">{
                rd.r.logger.Info("[replicateAll]", zap.String("Partition", path), zap.Any("Files Synced", syncCount))
        }</span>
        <span class="cov8" title="1">return syncCount, nil</span>
}

func (rd *swiftDevice) Key() string <span class="cov8" title="1">{
        return deviceKeyId(rd.dev.Device, rd.policy)
}</span>

func (rd *swiftDevice) Type() string <span class="cov8" title="1">{
        return "object-replicator"
}</span>
func (rd *swiftDevice) cleanTemp() <span class="cov8" title="1">{
        tempDir := TempDirPath(rd.r.deviceRoot, rd.dev.Device)
        if tmpContents, err := ioutil.ReadDir(tempDir); err == nil </span><span class="cov8" title="1">{
                for _, tmpEntry := range tmpContents </span><span class="cov8" title="1">{
                        if time.Since(tmpEntry.ModTime()) &gt; tmpEmptyTime </span><span class="cov8" title="1">{
                                os.RemoveAll(filepath.Join(tempDir, tmpEntry.Name()))
                        }</span>
                }
        }
}

func (rd *swiftDevice) replicatePartition(partition string) <span class="cov8" title="1">{
        rd.r.replicateConcurrencySem &lt;- struct{}{}
        defer func() </span><span class="cov8" title="1">{
                &lt;-rd.r.replicateConcurrencySem
        }</span>()
        <span class="cov8" title="1">partitioni, err := strconv.ParseUint(partition, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">nodes, handoff := rd.r.objectRings[rd.policy].GetJobNodes(partitioni, rd.dev.Id)
        policy := rd.r.policies[rd.policy]
        if policy == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">rjob := replJob{partition: partition, nodes: nodes}
        if handoff || (policy.Type == "replication-nursery" &amp;&amp;
                !common.LooksTrue(policy.Config["cache_hash_dirs"])) </span><span class="cov8" title="1">{
                rd.i.replicateAll(rjob, handoff)
        }</span> else<span class="cov8" title="1"> {
                rd.i.replicateUsingHashes(rjob, rd.r.objectRings[rd.policy].GetMoreNodes(partitioni))
        }</span>
        <span class="cov8" title="1">rd.UpdateStat("PartitionsDone", 1)</span>
}

func (rd *swiftDevice) listPartitions() ([]string, []string, error) <span class="cov8" title="1">{
        // returns a list of all partitions and a subset of that list- just the handoffs
        objPath := filepath.Join(rd.r.deviceRoot, rd.dev.Device, PolicyDir(rd.policy))
        partitions, err := filepath.Glob(filepath.Join(objPath, "[0-9]*"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">partitionList := make([]string, 0, len(partitions))
        handoffList := []string{}
        for _, partition := range partitions </span><span class="cov8" title="1">{
                partition = filepath.Base(partition)
                if len(rd.r.partitions) &gt; 0 &amp;&amp; !rd.r.partitions[partition] </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if _, err := strconv.ParseUint(partition, 10, 64); err == nil </span><span class="cov8" title="1">{
                        partitionList = append(partitionList, partition)
                }</span>
        }
        <span class="cov8" title="1">for i := len(partitionList) - 1; i &gt; 0; i-- </span><span class="cov8" title="1">{ // shuffle partition list
                j := rand.Intn(i + 1)
                partitionList[j], partitionList[i] = partitionList[i], partitionList[j]
        }</span>
        <span class="cov8" title="1">for _, partition := range partitionList </span><span class="cov8" title="1">{
                if pi, err := strconv.ParseUint(partition, 10, 64); err == nil </span><span class="cov8" title="1">{
                        if _, handoff := rd.r.objectRings[rd.policy].GetJobNodes(pi, rd.dev.Id); handoff </span><span class="cov8" title="1">{
                                handoffList = append(handoffList, partition)
                        }</span>
                }
        }
        <span class="cov8" title="1">return partitionList, handoffList, nil</span>
}

func (rd *swiftDevice) Scan() <span class="cov8" title="1">{
        defer srv.LogPanics(rd.r.logger, fmt.Sprintf("PANIC REPLICATING DEVICE: %s", rd.dev.Device))
        rd.UpdateStat("startRun", 1)
        if mounted, err := fs.IsMount(filepath.Join(rd.r.deviceRoot, rd.dev.Device)); rd.r.checkMounts &amp;&amp; (err != nil || mounted != true) </span><span class="cov0" title="0">{
                rd.r.logger.Error("[replicateDevice] Drive not mounted", zap.String("Device", rd.dev.Device), zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">if fs.Exists(filepath.Join(rd.r.deviceRoot, rd.dev.Device, "lock_device")) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">rd.i.cleanTemp()

        allPartitionList, handoffPartitions, err := rd.i.listPartitions()
        if err != nil </span><span class="cov0" title="0">{
                rd.r.logger.Error("[replicateDevice] Error getting partition list",
                        zap.String("Device", rd.dev.Device),
                        zap.Error(err))
                return
        }</span> else<span class="cov8" title="1"> if len(allPartitionList) == 0 </span><span class="cov8" title="1">{
                rd.r.logger.Info("[replicateDevice] No partitions found",
                        zap.String("filepath", filepath.Join(rd.r.deviceRoot, rd.dev.Device, PolicyDir(rd.policy))))
                return
        }</span>
        <span class="cov8" title="1">rd.UpdateStat("PartitionsTotal", int64(len(allPartitionList)))

        lastListing := time.Now()
        handoffsForLog := len(handoffPartitions)
        for i, partition := range allPartitionList </span><span class="cov8" title="1">{
                rd.UpdateStat("checkin", 1)
                select </span>{
                case &lt;-rd.cancel:<span class="cov8" title="1">
                        </span><span class="cov8" title="1">{
                                rd.r.logger.Error("replicateDevice canceled for device", zap.String("Device", rd.dev.Device))
                                return
                        }</span>
                default:</span><span class="cov8" title="1">
                }
                <span class="cov8" title="1">rd.i.replicatePartition(partition)
                if j := common.StringInSliceIndex(partition, handoffPartitions); j &gt;= 0 </span><span class="cov8" title="1">{
                        handoffPartitions = append(handoffPartitions[:j], handoffPartitions[j+1:]...)
                }</span>
                <span class="cov8" title="1">time.Sleep(replicatePartSleepTime)
                if i%handoffToAllMod == 0 &amp;&amp; len(handoffPartitions) &gt; 0 </span><span class="cov8" title="1">{
                        var p string
                        p, handoffPartitions = handoffPartitions[0], handoffPartitions[1:]
                        rd.i.replicatePartition(p)
                }</span>
                <span class="cov8" title="1">if len(handoffPartitions) == 0 </span><span class="cov8" title="1">{
                        if handoffsForLog &gt; 0 </span><span class="cov8" title="1">{
                                rd.r.logger.Info("[replicateDevice] Completed handoff replication pass",
                                        zap.Int("handoffsProcessed", handoffsForLog),
                                        zap.Duration("handoffDuration", time.Since(lastListing)))
                                handoffsForLog = 0
                        }</span>
                        <span class="cov8" title="1">if time.Since(lastListing) &gt; handoffListDirFreq </span><span class="cov0" title="0">{
                                if _, handoffPartitions, err = rd.i.listPartitions(); err != nil </span><span class="cov0" title="0">{
                                        rd.r.logger.Error("[replicateDevice] Error getting handoff partition list",
                                                zap.String("Device", rd.dev.Device),
                                                zap.Error(err))
                                }</span>
                                <span class="cov0" title="0">lastListing = time.Now()
                                handoffsForLog = len(handoffPartitions)</span>
                        }
                }
        }
        <span class="cov8" title="1">rd.UpdateStat("FullReplicateCount", 1)</span>
}

func (rd *swiftDevice) Cancel() <span class="cov0" title="0">{
        rd.UpdateStat("cancel", 1)
        close(rd.cancel)
}</span>

func (rd *swiftDevice) ScanLoop() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-rd.cancel:<span class="cov0" title="0">
                        return</span>
                default:<span class="cov8" title="1">
                        rd.Scan()</span>
                }
                <span class="cov8" title="1">time.Sleep(replicateLoopSleepTime)</span>
        }
}

type NoMoreNodes struct{}

func (n *NoMoreNodes) Next() *ring.Device <span class="cov0" title="0">{
        return nil
}</span>

// SwiftObject implements an Object that is compatible with Swift's object server.
type SwiftObject struct {
        file         *os.File
        afw          fs.AtomicFileWriter
        hashDir      string
        tempDir      string
        dataFile     string
        metaFile     string
        workingClass string
        metadata     map[string]string
        reserve      int64
        reclaimAge   int64
        asyncWG      *sync.WaitGroup // Used to keep track of async goroutines
}

// Metadata returns the object's metadata.
func (o *SwiftObject) Metadata() map[string]string <span class="cov8" title="1">{
        return o.metadata
}</span>

// ContentLength parses and returns the Content-Length for the object.
func (o *SwiftObject) ContentLength() int64 <span class="cov8" title="1">{
        if contentLength, err := strconv.ParseInt(o.metadata["Content-Length"], 10, 64); err != nil </span><span class="cov0" title="0">{
                return -1
        }</span> else<span class="cov8" title="1"> {
                return contentLength
        }</span>
}

// Quarantine removes the object's underlying files to the Quarantined directory on the device.
func (o *SwiftObject) Quarantine() error <span class="cov8" title="1">{
        o.Close()
        if QuarantineHash(o.hashDir) == nil </span><span class="cov8" title="1">{
                return InvalidateHash(o.hashDir)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Exists returns true if the object exists, that is if it has a .data file.
func (o *SwiftObject) Exists() bool <span class="cov8" title="1">{
        return strings.HasSuffix(o.dataFile, ".data")
}</span>

// Copy copies all data from the underlying .data file to the given writers.
func (o *SwiftObject) Copy(dsts ...io.Writer) (written int64, err error) <span class="cov8" title="1">{
        if len(dsts) == 1 </span><span class="cov8" title="1">{
                return io.Copy(dsts[0], o.file)
        }</span> else<span class="cov8" title="1"> {
                return common.Copy(o.file, dsts...)
        }</span>
}

// CopyRange copies data in the range of start to end from the underlying .data file to the writer.
func (o *SwiftObject) CopyRange(w io.Writer, start int64, end int64) (int64, error) <span class="cov8" title="1">{
        if _, err := o.file.Seek(start, os.SEEK_SET); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return common.CopyN(o.file, end-start, w)</span>
}

// Repr returns a string that identifies the object in some useful way, used for logging.
func (o *SwiftObject) Repr() string <span class="cov0" title="0">{
        if o.dataFile != "" &amp;&amp; o.metaFile != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("SwiftObject(%s, %s)", o.dataFile, o.metaFile)
        }</span> else<span class="cov0" title="0"> if o.dataFile != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("SwiftObject(%s)", o.dataFile)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("SwiftObject(%s)", o.hashDir)</span>
}

func (o *SwiftObject) newFile(class string, size int64) (io.Writer, error) <span class="cov8" title="1">{
        var err error
        o.Close()
        if o.afw, err = fs.NewAtomicFileWriter(o.tempDir, o.hashDir); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Error creating temp file: %v", err)
        }</span>
        <span class="cov8" title="1">if err := o.afw.Preallocate(size, o.reserve); err != nil </span><span class="cov0" title="0">{
                o.afw.Abandon()
                return nil, DriveFullError
        }</span>
        <span class="cov8" title="1">o.workingClass = class
        return o.afw, nil</span>
}

// SetData is called to set the object's data.  It takes a size (if available, otherwise set to zero).
func (o *SwiftObject) SetData(size int64) (io.Writer, error) <span class="cov8" title="1">{
        return o.newFile("data", size)
}</span>

// Commit commits an open data file to disk, given the metadata.
func (o *SwiftObject) Commit(metadata map[string]string) error <span class="cov8" title="1">{
        defer o.afw.Abandon()
        timestamp, ok := metadata["X-Timestamp"]
        if !ok </span><span class="cov0" title="0">{
                return errors.New("No timestamp in metadata")
        }</span>
        <span class="cov8" title="1">if err := common.SwiftObjectWriteMetadata(o.afw.Fd(), metadata); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Error writing metadata: %v", err)
        }</span>
        <span class="cov8" title="1">fileName := filepath.Join(o.hashDir, fmt.Sprintf("%s.%s", timestamp, o.workingClass))
        o.afw.Save(fileName)
        o.asyncWG.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer o.asyncWG.Done()
                HashCleanupListDir(o.hashDir, o.reclaimAge)
                if dir, err := os.OpenFile(o.hashDir, os.O_RDONLY, 0666); err == nil </span><span class="cov8" title="1">{
                        dir.Sync()
                        dir.Close()
                }</span>
                <span class="cov8" title="1">InvalidateHash(o.hashDir)</span>
        }()
        <span class="cov8" title="1">return nil</span>
}

func (o *SwiftObject) CommitMetadata(metadata map[string]string) error <span class="cov8" title="1">{
        if _, err := o.newFile("meta", 0); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer o.Close()
        return o.Commit(metadata)</span>
}

// Delete deletes the object.
func (o *SwiftObject) Delete(metadata map[string]string) error <span class="cov8" title="1">{
        if _, err := o.newFile("ts", 0); err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov8" title="1"> {
                defer o.Close()
                return o.Commit(metadata)
        }</span>
}

// Close releases any resources used by the instance of SwiftObject
func (o *SwiftObject) Close() error <span class="cov8" title="1">{
        if o.afw != nil </span><span class="cov8" title="1">{
                defer o.afw.Abandon()
                o.afw = nil
        }</span>
        <span class="cov8" title="1">if o.file != nil </span><span class="cov8" title="1">{
                defer o.file.Close()
                o.file = nil
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type SwiftEngine struct {
        driveRoot      string
        hashPathPrefix string
        hashPathSuffix string
        reserve        int64
        reclaimAge     int64
        policy         int
}

// New returns an instance of SwiftObject with the given parameters. Metadata is read in and if needData is true, the file is opened.  AsyncWG is a waitgroup if the object spawns any async operations
func (f *SwiftEngine) New(vars map[string]string, needData bool, asyncWG *sync.WaitGroup) (Object, error) <span class="cov8" title="1">{
        var err error
        sor := &amp;SwiftObject{reclaimAge: f.reclaimAge, reserve: f.reserve, asyncWG: asyncWG}
        sor.hashDir = ObjHashDir(vars, f.driveRoot, f.hashPathPrefix, f.hashPathSuffix, f.policy)
        sor.tempDir = TempDirPath(f.driveRoot, vars["device"])
        sor.dataFile, sor.metaFile = ObjectFiles(sor.hashDir)
        if sor.Exists() </span><span class="cov8" title="1">{
                var stat os.FileInfo
                if needData </span><span class="cov8" title="1">{
                        if sor.file, err = os.Open(sor.dataFile); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if sor.metadata, err = OpenObjectMetadata(sor.file.Fd(), sor.metaFile); err != nil </span><span class="cov0" title="0">{
                                sor.Quarantine()
                                return nil, fmt.Errorf("Error getting metadata: %v", err)
                        }</span>
                } else<span class="cov8" title="1"> {
                        if sor.metadata, err = ObjectMetadata(sor.dataFile, sor.metaFile); err != nil </span><span class="cov0" title="0">{
                                sor.Quarantine()
                                return nil, fmt.Errorf("Error getting metadata: %v", err)
                        }</span>
                }
                <span class="cov8" title="1">if sor.file != nil </span><span class="cov8" title="1">{
                        if stat, err = sor.file.Stat(); err != nil </span><span class="cov0" title="0">{
                                sor.Close()
                                return nil, fmt.Errorf("Error statting file: %v", err)
                        }</span>
                } else<span class="cov8" title="1"> if stat, err = os.Stat(sor.dataFile); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Error statting file: %v", err)
                }</span>
                <span class="cov8" title="1">if contentLength, err := strconv.ParseInt(sor.metadata["Content-Length"], 10, 64); err != nil </span><span class="cov8" title="1">{
                        sor.Quarantine()
                        return nil, fmt.Errorf("Unable to parse content-length: %s", sor.metadata["Content-Length"])
                }</span> else<span class="cov8" title="1"> if stat.Size() != contentLength </span><span class="cov8" title="1">{
                        sor.Quarantine()
                        return nil, fmt.Errorf("File size doesn't match content-length: %d vs %d", stat.Size(), contentLength)
                }</span>
        } else<span class="cov8" title="1"> {
                sor.metadata, _ = ObjectMetadata(sor.dataFile, sor.metaFile) // ignore errors if deleted
        }</span>
        <span class="cov8" title="1">return sor, nil</span>
}

func (f *SwiftEngine) GetReplicationDevice(oring ring.Ring, dev *ring.Device, r *Replicator) (ReplicationDevice, error) <span class="cov8" title="1">{
        rd := &amp;swiftDevice{
                r:      r,
                dev:    dev,
                policy: f.policy,
                cancel: make(chan struct{}),
        }
        rd.i = rd
        return rd, nil
}</span>

var replicationDone = fmt.Errorf("Replication done")

// SwiftEngineConstructor creates a SwiftEngine given the object server configs.
func SwiftEngineConstructor(config conf.Config, policy *conf.Policy, flags *flag.FlagSet) (ObjectEngine, error) <span class="cov8" title="1">{
        driveRoot := config.GetDefault("app:object-server", "devices", "/srv/node")
        reserve := config.GetInt("app:object-server", "fallocate_reserve", 0)
        hashPathPrefix, hashPathSuffix, err := conf.GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("Unable to load hashpath prefix and suffix")
        }</span>
        <span class="cov8" title="1">reclaimAge := int64(config.GetInt("app:object-server", "reclaim_age", int64(common.ONE_WEEK)))
        return &amp;SwiftEngine{
                driveRoot:      driveRoot,
                hashPathPrefix: hashPathPrefix,
                hashPathSuffix: hashPathSuffix,
                reserve:        reserve,
                reclaimAge:     reclaimAge,
                policy:         policy.Index}, nil</span>
}

func init() <span class="cov8" title="1">{
        RegisterObjectEngine("replication", SwiftEngineConstructor)
}</span>

// make sure these things satisfy interfaces at compile time
var _ ObjectEngineConstructor = SwiftEngineConstructor
var _ Object = &amp;SwiftObject{}
var _ ObjectEngine = &amp;SwiftEngine{}
</pre>
		
		<pre class="file" id="file75" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package objectserver

import (
        "crypto/md5"
        "encoding/hex"
        "fmt"
        "io"
        "math/big"
        "net/http"
        "os"
        "path/filepath"
        "strings"
        "time"

        "context"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/pickle"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/common/tracing"
        "github.com/troubling/hummingbird/middleware"
        "go.uber.org/zap"
)

/*This hash is used to represent a zero byte async file that is
  created for an expiring object*/
const zeroByteHash = "d41d8cd98f00b204e9800998ecf8427e"
const deleteAtAccount = ".expiring_objects"

func splitHeader(header string) []string <span class="cov8" title="1">{
        if header == "" </span><span class="cov8" title="1">{
                return []string{}
        }</span>
        <span class="cov8" title="1">return strings.Split(header, ",")</span>
}

func (server *ObjectServer) hashPath(account, container, obj string) string <span class="cov8" title="1">{
        h := md5.New()
        io.WriteString(h, server.hashPathPrefix+"/"+account+"/"+container+"/"+obj+server.hashPathSuffix)
        return hex.EncodeToString(h.Sum(nil))
}</span>

func (server *ObjectServer) expirerContainer(deleteAt time.Time, account, container, obj string) string <span class="cov8" title="1">{
        i := new(big.Int)
        fmt.Sscanf(server.hashPath(account, container, obj), "%x", i)
        shardInt := i.Mod(i, big.NewInt(100)).Int64()
        timestamp := (deleteAt.Unix()/server.expiringDivisor)*server.expiringDivisor - shardInt
        if timestamp &lt; 0 </span><span class="cov0" title="0">{
                timestamp = 0
        }</span> else<span class="cov8" title="1"> if timestamp &gt; 9999999999 </span><span class="cov0" title="0">{
                timestamp = 9999999999
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%010d", timestamp)</span>
}

func (server *ObjectServer) sendContainerUpdate(ctx context.Context, scheme, host, device, method, partition, account, container, obj string, headers http.Header) bool <span class="cov8" title="1">{
        obj_url := fmt.Sprintf("%s://%s/%s/%s/%s/%s/%s", scheme, host, device, partition,
                common.Urlencode(account), common.Urlencode(container), common.Urlencode(obj))
        if req, err := http.NewRequest(method, obj_url, nil); err == nil </span><span class="cov8" title="1">{
                req = req.WithContext(ctx)
                req.Header = headers
                if resp, err := server.updateClient.Do(req); err == nil </span><span class="cov8" title="1">{
                        resp.Body.Close()
                        if resp.StatusCode/100 == 2 </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

func (server *ObjectServer) saveAsync(method, account, container, obj, localDevice string, headers http.Header, logger srv.LowLevelLogger) <span class="cov8" title="1">{
        hash := server.hashPath(account, container, obj)
        asyncFile := filepath.Join(server.driveRoot, localDevice, "async_pending", hash[29:32], hash+"-"+headers.Get("X-Timestamp"))
        tempDir := TempDirPath(server.driveRoot, localDevice)
        data := map[string]interface{}{
                "op":        method,
                "account":   account,
                "container": container,
                "obj":       obj,
                "headers":   common.Headers2Map(headers),
        }
        var err error
        if err = os.MkdirAll(filepath.Dir(asyncFile), 0755); err == nil </span><span class="cov8" title="1">{
                var writer fs.AtomicFileWriter
                writer, err = fs.NewAtomicFileWriter(tempDir, filepath.Dir(asyncFile))
                if err == nil </span><span class="cov8" title="1">{
                        defer writer.Abandon()
                        writer.Write(pickle.PickleDumps(data))
                        writer.Save(asyncFile)
                        return
                }</span>
        }
        <span class="cov0" title="0">logger.Error("Error saving obj async", zap.String("objPath", fmt.Sprintf("%s/%s/%s", account, container, obj)), zap.Error(err))</span>
}

func (server *ObjectServer) updateContainer(ctx context.Context, metadata map[string]string, request *http.Request, vars map[string]string, logger srv.LowLevelLogger) <span class="cov8" title="1">{
        partition := request.Header.Get("X-Container-Partition")
        hosts := splitHeader(request.Header.Get("X-Container-Host"))
        devices := splitHeader(request.Header.Get("X-Container-Device"))
        schemes := splitHeader(request.Header.Get("X-Container-Scheme"))
        if partition == "" || len(hosts) == 0 || len(devices) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">for len(schemes) &lt; len(hosts) </span><span class="cov0" title="0">{
                schemes = append(schemes, "http")
        }</span>
        <span class="cov8" title="1">requestHeaders := http.Header{
                "X-Backend-Storage-Policy-Index": {common.GetDefault(request.Header, "X-Backend-Storage-Policy-Index", "0")},
                "Referer":                        {common.GetDefault(request.Header, "Referer", "-")},
                "User-Agent":                     {common.GetDefault(request.Header, "User-Agent", "-")},
                "X-Trans-Id":                     {common.GetDefault(request.Header, "X-Trans-Id", "-")},
                "X-Timestamp":                    request.Header["X-Timestamp"],
                "X-Delete-At":                    request.Header["X-Delete-At"],
        }
        if request.Method != "DELETE" </span><span class="cov8" title="1">{
                requestHeaders.Add("X-Content-Type", metadata["Content-Type"])
                requestHeaders.Add("X-Size", metadata["Content-Length"])
                requestHeaders.Add("X-Etag", metadata["ETag"])
        }</span>
        <span class="cov8" title="1">failures := 0
        for index := range hosts </span><span class="cov8" title="1">{
                if !server.sendContainerUpdate(ctx, schemes[index], hosts[index], devices[index], request.Method, partition, vars["account"], vars["container"], vars["obj"], requestHeaders) </span><span class="cov8" title="1">{
                        logger.Error("ERROR container update failed (saving for async update later)",
                                zap.String("Host", hosts[index]),
                                zap.String("Device", devices[index]))
                        failures++
                }</span>
        }
        <span class="cov8" title="1">if failures &gt; 0 </span><span class="cov8" title="1">{
                server.saveAsync(request.Method, vars["account"], vars["container"], vars["obj"], vars["device"], requestHeaders, logger)
        }</span>
}

func (server *ObjectServer) containerUpdates(writer http.ResponseWriter, request *http.Request, metadata map[string]string, deleteAt string, vars map[string]string, logger srv.LowLevelLogger) <span class="cov8" title="1">{
        defer middleware.Recover(writer, request, "PANIC WHILE UPDATING CONTAINER LISTINGS")

        done := make(chan struct{}, 1)
        go func() </span><span class="cov8" title="1">{
                ctx := tracing.CopySpanFromContext(request.Context())
                server.updateContainer(ctx, metadata, request, vars, logger)
                done &lt;- struct{}{}
        }</span>()
        <span class="cov8" title="1">select </span>{
        case &lt;-done:</span><span class="cov8" title="1">
        case &lt;-time.After(server.updateTimeout):</span><span class="cov0" title="0">
        }
}
</pre>
		
		<pre class="file" id="file76" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package objectserver

import (
        "fmt"
        "io/ioutil"
        "math/rand"
        "net/http"
        "os"
        "path/filepath"
        "sync"
        "syscall"
        "time"

        "go.uber.org/zap"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/fs"
        "github.com/troubling/hummingbird/common/pickle"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/middleware"
)

const asyncPendingSleep = 10 * time.Millisecond

type asyncPending struct {
        Headers   map[string]string `pickle:"headers"`
        Object    string            `pickle:"obj"`
        Account   string            `pickle:"account"`
        Container string            `pickle:"container"`
        Method    string            `pickle:"op"`
}

type updateDevice struct {
        r             *Replicator
        dev           *ring.Device
        canchan       chan struct{}
        policy        int
        lastReconDump time.Time
        reconLock     sync.Mutex
        reconRunning  bool
}

func (ud *updateDevice) updateStat(stat string, amount int64) <span class="cov8" title="1">{
        key := deviceKeyId(ud.dev.Device, ud.policy)
        ud.r.updateStat &lt;- statUpdate{"object-updater", key, stat, amount}
}</span>

func (ud *updateDevice) listAsyncs(c chan string, cancel chan struct{}) <span class="cov8" title="1">{
        defer close(c)
        suffixDirs, err := filepath.Glob(filepath.Join(ud.r.deviceRoot, ud.dev.Device, AsyncDir(ud.policy), "[a-f0-9][a-f0-9][a-f0-9]"))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">for i := len(suffixDirs) - 1; i &gt; 0; i-- </span><span class="cov8" title="1">{ // shuffle suffixDirs list
                j := rand.Intn(i + 1)
                suffixDirs[j], suffixDirs[i] = suffixDirs[i], suffixDirs[j]
        }</span>
        <span class="cov8" title="1">for _, suffDir := range suffixDirs </span><span class="cov8" title="1">{
                asyncs, err := fs.ReadDirNames(suffDir)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">for _, async := range asyncs </span><span class="cov8" title="1">{
                        select </span>{
                        case c &lt;- filepath.Join(suffDir, async):</span><span class="cov8" title="1">
                        case &lt;-cancel:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }
}

func (ud *updateDevice) updateContainers(ap *asyncPending) bool <span class="cov8" title="1">{
        successes := uint64(0)
        part := ud.r.containerRing.GetPartition(ap.Account, ap.Container, "")
        header := common.Map2Headers(ap.Headers)
        header.Set("User-Agent", fmt.Sprintf("object-updater %d", os.Getpid()))
        for _, node := range ud.r.containerRing.GetNodes(part) </span><span class="cov8" title="1">{
                objUrl := fmt.Sprintf("%s://%s:%d/%s/%d/%s/%s/%s", node.Scheme, node.Ip, node.Port, node.Device, part,
                        common.Urlencode(ap.Account), common.Urlencode(ap.Container), common.Urlencode(ap.Object))
                req, err := http.NewRequest(ap.Method, objUrl, nil)
                if err != nil </span><span class="cov0" title="0">{
                        ud.r.logger.Error("updateContainers creating new request", zap.Error(err))
                        continue</span>
                }
                <span class="cov8" title="1">req.Header = header
                resp, err := ud.r.client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">resp.Body.Close()
                if resp.StatusCode/100 == 2 </span><span class="cov8" title="1">{
                        successes++
                }</span>
        }
        <span class="cov8" title="1">return successes &gt;= (ud.r.containerRing.ReplicaCount()/2)+1</span>
}

func (ud *updateDevice) processAsync(async string) <span class="cov8" title="1">{
        data, err := ioutil.ReadFile(async)
        if err != nil </span><span class="cov0" title="0">{
                ud.updateStat("Error", 1)
                ud.r.logger.Error("read async_pending fail", zap.String("file", async), zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">var ap asyncPending
        if err := pickle.Unmarshal(data, &amp;ap); err != nil </span><span class="cov0" title="0">{
                ud.updateStat("Error", 1)
                ud.r.logger.Error("unmarshal async_pending fail", zap.String("file", async), zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">if ud.updateContainers(&amp;ap) </span><span class="cov8" title="1">{
                ud.updateStat("Success", 1)
                os.Remove(async)
                os.Remove(filepath.Dir(async))
        }</span> else<span class="cov0" title="0"> {
                ud.updateStat("Failure", 1)
        }</span>
}

func (ud *updateDevice) reconReportAsync() <span class="cov8" title="1">{
        ud.reconLock.Lock()
        if ud.reconRunning </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">ud.reconRunning = true
        ud.reconLock.Unlock()
        defer func() </span><span class="cov8" title="1">{
                ud.reconLock.Lock()
                ud.reconRunning = false
                ud.reconLock.Unlock()
        }</span>()
        <span class="cov8" title="1">cnt := uint64(0)
        suffixDirs, err := filepath.Glob(filepath.Join(ud.r.deviceRoot, ud.dev.Device, AsyncDir(ud.policy), "[a-f0-9][a-f0-9][a-f0-9]"))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">var stat syscall.Stat_t
        for _, suffDir := range suffixDirs </span><span class="cov0" title="0">{
                if err = syscall.Stat(suffDir, &amp;stat); err != nil </span><span class="cov0" title="0">{
                        ud.r.logger.Error("object-updater unable to stat", zap.String("suffDir", suffDir), zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">if stat.Nlink &gt; 1 </span><span class="cov0" title="0">{
                        cnt += stat.Nlink - 1
                }</span>
        }
        <span class="cov8" title="1">if err := middleware.DumpReconCache(ud.r.reconCachePath, "object",
                map[string]interface{}{
                        fmt.Sprintf("async_pending_%s", ud.dev.Device): cnt}); err != nil </span><span class="cov0" title="0">{
                ud.r.logger.Error("object-updater saving recon data", zap.Error(err))
        }</span>
}

func (ud *updateDevice) update() <span class="cov8" title="1">{
        ud.updateStat("startRun", 1)
        if ud.lastReconDump.IsZero() || time.Since(ud.lastReconDump) &gt; time.Hour </span><span class="cov8" title="1">{
                ud.lastReconDump = time.Now()
                go ud.reconReportAsync()
        }</span>
        <span class="cov8" title="1">c := make(chan string, 100)
        cancel := make(chan struct{})
        defer close(cancel)
        go ud.listAsyncs(c, cancel)
        for async := range c </span><span class="cov0" title="0">{
                ud.updateStat("checkin", 1)
                func() </span><span class="cov0" title="0">{
                        ud.r.updateConcurrencySem &lt;- struct{}{}
                        defer func() </span><span class="cov0" title="0">{
                                &lt;-ud.r.updateConcurrencySem
                        }</span>()
                        <span class="cov0" title="0">ud.processAsync(async)</span>
                }()
                <span class="cov0" title="0">select </span>{
                case &lt;-time.After(asyncPendingSleep):</span><span class="cov0" title="0">
                case &lt;-ud.canchan:<span class="cov0" title="0">
                        return</span>
                }
                <span class="cov0" title="0">if time.Since(ud.lastReconDump) &gt; time.Hour </span><span class="cov0" title="0">{
                        ud.lastReconDump = time.Now()
                        go ud.reconReportAsync()
                }</span>
        }
        <span class="cov8" title="1">ud.updateStat("PassComplete", 1)</span>
}

func (ud *updateDevice) updateLoop() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ud.canchan:<span class="cov0" title="0">
                        return</span>
                default:<span class="cov8" title="1">
                        ud.update()</span>
                }
                <span class="cov8" title="1">time.Sleep(replicateLoopSleepTime)
                ud.updateStat("checkin", 1)</span>
        }
}

func (ud *updateDevice) cancel() <span class="cov0" title="0">{
        close(ud.canchan)
}</span>

func newUpdateDevice(dev *ring.Device, policy int, r *Replicator) *updateDevice <span class="cov8" title="1">{
        return &amp;updateDevice{
                policy:  policy,
                dev:     dev,
                r:       r,
                canchan: make(chan struct{}),
        }
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package probe

import (
        "bytes"
        "flag"
        "fmt"
        "io/ioutil"
        "log"
        "net"
        "net/http"
        "net/http/httptest"
        "net/url"
        "os"
        "path/filepath"
        "strconv"
        "sync/atomic"

        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/common/test"
        "github.com/troubling/hummingbird/objectserver"
)

type TestReplicatorWebServer struct {
        *httptest.Server
        host       string
        port       int
        root       string
        replicator *objectserver.Replicator
}

func (t *TestReplicatorWebServer) Close() <span class="cov8" title="1">{
        os.RemoveAll(t.root)
        t.Server.Close()
}</span>

// Environment encapsulates a temporary SAIO-style environment for the object server, replicator, and auditor
// and provides a few utility functions for manipulating it.
type Environment struct {
        driveRoots             []string
        servers                []*httptest.Server
        ports                  []int
        hosts                  []string
        replicatorServers      []*TestReplicatorWebServer
        auditors               []*objectserver.AuditorDaemon
        ring                   ring.Ring
        hashPrefix, hashSuffix string
}

// Close frees any resources associated with the Environment.
func (e *Environment) Close() <span class="cov8" title="1">{
        for _, s := range e.servers </span><span class="cov8" title="1">{
                s.Close()
        }</span>
        <span class="cov8" title="1">for _, s := range e.replicatorServers </span><span class="cov8" title="1">{
                s.Close()
        }</span>
        <span class="cov8" title="1">for _, s := range e.driveRoots </span><span class="cov8" title="1">{
                os.RemoveAll(s)
        }</span>
}

// FileLocations returns a list of file paths for the object's hash directory on all three underlying object servers.
func (e *Environment) FileLocations(account, container, obj string, policy int) (paths []string) <span class="cov8" title="1">{
        partition := e.ring.GetPartition(account, container, obj)
        vars := map[string]string{"account": account, "container": container, "obj": obj, "partition": strconv.Itoa(int(partition)), "device": "sda"}
        for i := 0; i &lt; 4; i++ </span><span class="cov8" title="1">{
                path := objectserver.ObjHashDir(vars, e.driveRoots[i], e.hashPrefix, e.hashSuffix, policy)
                paths = append(paths, path)
        }</span>
        <span class="cov8" title="1">return</span>
}

// PutObject uploads an object "/a/c/o" to the indicated server with X-Timestamp set to timestamp and body set to data.
func (e *Environment) PutObject(server int, timestamp string, data string, policy int) bool <span class="cov8" title="1">{
        body := bytes.NewBuffer([]byte(data))
        req, err := http.NewRequest("PUT", fmt.Sprintf("http://%s:%d/sda/0/a/c/o", e.hosts[server], e.ports[server]), body)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/octet-stream")
        req.Header.Set("Content-Length", strconv.Itoa(len(data)))
        req.Header.Set("X-Timestamp", timestamp)
        req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(policy))
        resp, err := http.DefaultClient.Do(req)
        return err == nil &amp;&amp; resp.StatusCode == 201</span>
}

// DeleteObject deletes the object.
func (e *Environment) DeleteObject(server int, timestamp string, policy int) bool <span class="cov8" title="1">{
        req, err := http.NewRequest("DELETE", fmt.Sprintf("http://%s:%d/sda/0/a/c/o", e.hosts[server], e.ports[server]), nil)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">req.Header.Set("X-Timestamp", timestamp)
        req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(policy))
        resp, err := http.DefaultClient.Do(req)
        return err == nil &amp;&amp; resp.StatusCode == 204</span>
}

// ObjExists returns a boolean indicating that it can fetch the named object and that its X-Timestamp matches the timestamp argument.
func (e *Environment) ObjExists(server int, timestamp string, policy int) bool <span class="cov8" title="1">{
        req, err := http.NewRequest("HEAD", fmt.Sprintf("http://%s:%d/sda/0/a/c/o", e.hosts[server], e.ports[server]), nil)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">req.Header.Set("X-Backend-Storage-Policy-Index", strconv.Itoa(policy))
        resp, err := http.DefaultClient.Do(req)
        if err != nil || resp.StatusCode != 200 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return resp.Header.Get("X-Timestamp") == timestamp</span>
}

var environments uint64 = 0

// NewEnvironment creates a new environment.  Arguments should be a series of key, value pairs that are added to the object server configuration file.
func NewEnvironment(settings ...string) *Environment <span class="cov8" title="1">{
        log.SetFlags(log.LstdFlags | log.Lshortfile)
        testRing := &amp;test.FakeRing{}
        confLoader := srv.NewTestConfigLoader(testRing)
        env := &amp;Environment{ring: testRing}
        env.hashPrefix, env.hashSuffix, _ = confLoader.GetHashPrefixAndSuffix()
        for i := 0; i &lt; 4; i++ </span><span class="cov8" title="1">{
                driveRoot, _ := ioutil.TempDir("", "")
                os.MkdirAll(filepath.Join(driveRoot, "sda", "objects"), 0755)
                ts := httptest.NewServer(nil)
                u, _ := url.Parse(ts.URL)
                host, ports, _ := net.SplitHostPort(u.Host)
                port, _ := strconv.Atoi(ports)

                trs := httptest.NewServer(nil)
                trsURL, _ := url.Parse(trs.URL)
                trsHost, trsPorts, _ := net.SplitHostPort(trsURL.Host)
                trsPort, _ := strconv.Atoi(trsPorts)

                configString := "[DEFAULT]\nmount_check=false\n"
                configString += fmt.Sprintf("devices=%s\n", driveRoot)
                configString += fmt.Sprintf("bind_port=%d\n", port)
                configString += fmt.Sprintf("bind_ip=%s\n", host)
                for i := 0; i &lt; len(settings); i += 2 </span><span class="cov0" title="0">{
                        configString += fmt.Sprintf("%s=%s\n", settings[i], settings[i+1])
                }</span>
                <span class="cov8" title="1">configString += "[app:object-server]\n[object-replicator]\n"
                configString += fmt.Sprintf("bind_port=%d\n", trsPort)
                configString += fmt.Sprintf("bind_ip=%s\n", trsHost)
                configString += "[object-auditor]\n"
                conf, _ := conf.StringConfig(configString)
                _, server, _, err := objectserver.NewServer(conf, &amp;flag.FlagSet{}, confLoader)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov8" title="1">ts.Config.Handler = server.GetHandler(conf, fmt.Sprintf("probe_%d_%d", atomic.AddUint64(&amp;environments, 1), i))

                _, replicator, _, err := objectserver.NewReplicator(conf, &amp;flag.FlagSet{}, confLoader)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov8" title="1">trs.Config.Handler = replicator.(*objectserver.Replicator).GetHandler(conf, fmt.Sprintf("probe_%d_%d", atomic.AddUint64(&amp;environments, 1), i))

                replicatorServer := &amp;TestReplicatorWebServer{Server: trs, host: host, port: port, root: driveRoot, replicator: replicator.(*objectserver.Replicator)}
                auditor, err := objectserver.NewAuditorDaemon(conf, &amp;flag.FlagSet{}, confLoader)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov8" title="1">env.ring.(*test.FakeRing).MockDevices = append(env.ring.(*test.FakeRing).MockDevices, &amp;ring.Device{
                        Id: i, Device: "sda", Scheme: "http", Ip: host, Port: port, Region: 0, ReplicationIp: trsHost, ReplicationPort: trsPort, Weight: 1, Zone: i,
                })

                env.driveRoots = append(env.driveRoots, driveRoot)
                env.servers = append(env.servers, ts)
                env.ports = append(env.ports, port)
                env.hosts = append(env.hosts, host)
                env.replicatorServers = append(env.replicatorServers, replicatorServer)
                env.auditors = append(env.auditors, auditor)</span>
        }
        <span class="cov8" title="1">env.ring.(*test.FakeRing).MockMoreNodes = env.ring.(*test.FakeRing).MockDevices[3]
        return env</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package proxyserver

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/proxyserver/middleware"
)

func (server *ProxyServer) AccountGetHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">options := make(map[string]string)
        if request.ParseForm() == nil </span><span class="cov0" title="0">{
                for k, v := range request.Form </span><span class="cov0" title="0">{
                        if listingQueryParms[k] &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                                options[k] = v[0]
                        }</span>
                }
        }
        <span class="cov0" title="0">resp := ctx.C.GetAccountRaw(request.Context(), vars["account"], options, request.Header)
        if resp.StatusCode == http.StatusNotFound &amp;&amp; server.accountAutoCreate &amp;&amp;
                resp.Header.Get("X-Backend-Delete-Timestamp") == "" </span><span class="cov0" title="0">{
                resp.Body.Close()
                ctx.AutoCreateAccount(request.Context(), vars["account"], request.Header)
                resp = ctx.C.GetAccountRaw(request.Context(), vars["account"], options, request.Header)
        }</span>
        <span class="cov0" title="0">for k := range resp.Header </span><span class="cov0" title="0">{
                if !common.OwnerHeaders[strings.ToLower(k)] || ctx.StorageOwner </span><span class="cov0" title="0">{
                        writer.Header().Set(k, resp.Header.Get(k))
                }</span>
        }
        <span class="cov0" title="0">writer.WriteHeader(resp.StatusCode)
        defer resp.Body.Close()
        common.Copy(resp.Body, writer)</span>
}

func (server *ProxyServer) AccountHeadHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">resp := ctx.C.HeadAccount(request.Context(), vars["account"], request.Header)
        if resp.StatusCode == http.StatusNotFound &amp;&amp; server.accountAutoCreate &amp;&amp;
                resp.Header.Get("X-Backend-Delete-Timestamp") == "" </span><span class="cov0" title="0">{
                resp.Body.Close()
                ctx.AutoCreateAccount(request.Context(), vars["account"], request.Header)
                resp = ctx.C.HeadAccount(request.Context(), vars["account"], request.Header)
        }</span>
        <span class="cov0" title="0">for k := range resp.Header </span><span class="cov0" title="0">{
                if !common.OwnerHeaders[strings.ToLower(k)] || ctx.StorageOwner </span><span class="cov0" title="0">{
                        writer.Header().Set(k, resp.Header.Get(k))
                }</span>
        }
        <span class="cov0" title="0">resp.Body.Close()
        writer.WriteHeader(resp.StatusCode)</span>
}

func (server *ProxyServer) AccountPostHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">if status, str := common.CheckMetadata(request, "Account"); status != http.StatusOK </span><span class="cov0" title="0">{
                writer.Header().Set("Content-Type", "text/html; charset=UTF-8")
                writer.WriteHeader(status)
                writer.Write([]byte(fmt.Sprintf("&lt;html&gt;&lt;h1&gt;%s&lt;/h1&gt;&lt;p&gt;%s&lt;/p&gt;&lt;/html&gt;", http.StatusText(status), str)))
                return
        }</span>
        <span class="cov0" title="0">for k := range request.Header </span><span class="cov0" title="0">{
                if common.OwnerHeaders[strings.ToLower(k)] &amp;&amp; !ctx.StorageOwner </span><span class="cov0" title="0">{
                        request.Header.Del(k)
                }</span>
                <span class="cov0" title="0">if strings.HasPrefix(strings.ToLower(k), "x-remove-account-meta-") </span><span class="cov0" title="0">{
                        request.Header.Del(k)
                        request.Header.Set(strings.Replace(strings.ToLower(k), "-remove", "", 1), "")
                }</span>
        }
        <span class="cov0" title="0">defer ctx.InvalidateAccountInfo(request.Context(), vars["account"])
        resp := ctx.C.PostAccount(request.Context(), vars["account"], request.Header)
        if resp.StatusCode == http.StatusNotFound &amp;&amp; server.accountAutoCreate &amp;&amp;
                resp.Header.Get("X-Backend-Delete-Timestamp") == "" </span><span class="cov0" title="0">{
                resp.Body.Close()
                ctx.AutoCreateAccount(request.Context(), vars["account"], request.Header)
                resp = ctx.C.PostAccount(request.Context(), vars["account"], request.Header)
        }</span>
        <span class="cov0" title="0">resp.Body.Close()
        srv.StandardResponse(writer, resp.StatusCode)</span>
}

func (server *ProxyServer) AccountPutHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">if status, str := common.CheckMetadata(request, "Account"); status != http.StatusOK </span><span class="cov0" title="0">{
                writer.Header().Set("Content-Type", "text/html; charset=UTF-8")
                writer.WriteHeader(status)
                writer.Write([]byte(fmt.Sprintf("&lt;html&gt;&lt;h1&gt;%s&lt;/h1&gt;&lt;p&gt;%s&lt;/p&gt;&lt;/html&gt;", http.StatusText(status), str)))
                return
        }</span>
        <span class="cov0" title="0">for k := range request.Header </span><span class="cov0" title="0">{
                if common.OwnerHeaders[strings.ToLower(k)] &amp;&amp; !ctx.StorageOwner </span><span class="cov0" title="0">{
                        request.Header.Del(k)
                }</span>
                <span class="cov0" title="0">if strings.HasPrefix(strings.ToLower(k), "x-remove-account-meta-") </span><span class="cov0" title="0">{
                        request.Header.Del(k)
                        request.Header.Set(strings.Replace(strings.ToLower(k), "-remove", "", 1), "")
                }</span>
        }
        <span class="cov0" title="0">defer ctx.InvalidateAccountInfo(request.Context(), vars["account"])
        resp := ctx.C.PutAccount(request.Context(), vars["account"], request.Header)
        resp.Body.Close()
        srv.StandardResponse(writer, resp.StatusCode)</span>
}

func (server *ProxyServer) AccountDeleteHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">defer ctx.InvalidateAccountInfo(request.Context(), vars["account"])
        resp := ctx.C.DeleteAccount(request.Context(), vars["account"], request.Header)
        resp.Body.Close()
        srv.StandardResponse(writer, resp.StatusCode)</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package proxyserver

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/proxyserver/middleware"
)

var listingQueryParms = map[string]bool{
        "format":     true,
        "limit":      true,
        "marker":     true,
        "end_marker": true,
        "prefix":     true,
        "delimiter":  true,
        "reverse":    true,
        "path":       true,
}

func (server *ProxyServer) ContainerGetHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">if _, err := ctx.GetAccountInfo(request.Context(), vars["account"]); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 404)
                return
        }</span>
        <span class="cov0" title="0">options := make(map[string]string)
        if request.ParseForm() == nil </span><span class="cov0" title="0">{
                for k, v := range request.Form </span><span class="cov0" title="0">{
                        if listingQueryParms[k] &amp;&amp; len(v) &gt; 0 </span><span class="cov0" title="0">{
                                options[k] = v[0]
                        }</span>
                }
        }
        <span class="cov0" title="0">resp := ctx.C.GetContainerRaw(request.Context(), vars["account"], vars["container"], options, request.Header)
        defer resp.Body.Close()
        ctx.C.SetContainerInfo(request.Context(), vars["account"], vars["container"], resp)
        ctx.ACL = resp.Header.Get("X-Container-Read")
        if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">for k := range resp.Header </span><span class="cov0" title="0">{
                if !common.OwnerHeaders[strings.ToLower(k)] || ctx.StorageOwner </span><span class="cov0" title="0">{
                        writer.Header().Set(k, resp.Header.Get(k))
                }</span>
        }
        <span class="cov0" title="0">writer.WriteHeader(resp.StatusCode)
        common.Copy(resp.Body, writer)</span>
}

func (server *ProxyServer) ContainerHeadHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">if _, err := ctx.GetAccountInfo(request.Context(), vars["account"]); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 404)
                return
        }</span>
        <span class="cov0" title="0">resp := ctx.C.HeadContainer(request.Context(), vars["account"], vars["container"], request.Header)
        resp.Body.Close()
        ctx.C.SetContainerInfo(request.Context(), vars["account"], vars["container"], resp)
        ctx.ACL = resp.Header.Get("X-Container-Read")
        if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">for k := range resp.Header </span><span class="cov0" title="0">{
                if !common.OwnerHeaders[strings.ToLower(k)] || ctx.StorageOwner </span><span class="cov0" title="0">{
                        writer.Header().Set(k, resp.Header.Get(k))
                }</span>
        }
        <span class="cov0" title="0">writer.WriteHeader(resp.StatusCode)</span>
}

func (server *ProxyServer) ContainerPostHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">if _, err := ctx.GetAccountInfo(request.Context(), vars["account"]); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 404)
                return
        }</span>
        <span class="cov0" title="0">if err := cleanACLs(request); err != nil </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(writer, 400, err.Error())
                return
        }</span>
        <span class="cov0" title="0">if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">if status, str := common.CheckContainerPut(request, vars["container"]); status != http.StatusOK </span><span class="cov0" title="0">{
                writer.Header().Set("Content-Type", "text/html; charset=UTF-8")
                writer.WriteHeader(status)
                writer.Write([]byte(fmt.Sprintf("&lt;html&gt;&lt;h1&gt;%s&lt;/h1&gt;&lt;p&gt;%s&lt;/p&gt;&lt;/html&gt;", http.StatusText(status), str)))
                return
        }</span>
        <span class="cov0" title="0">for k := range request.Header </span><span class="cov0" title="0">{
                if common.OwnerHeaders[strings.ToLower(k)] &amp;&amp; !ctx.StorageOwner </span><span class="cov0" title="0">{
                        request.Header.Del(k)
                }</span>
                <span class="cov0" title="0">if strings.HasPrefix(strings.ToLower(k), "x-remove-container-meta-") </span><span class="cov0" title="0">{
                        request.Header.Del(k)
                        request.Header.Set(strings.Replace(strings.ToLower(k), "-remove", "", 1), "")
                }</span>
        }
        <span class="cov0" title="0">resp := ctx.C.PostContainer(request.Context(), vars["account"], vars["container"], request.Header)
        resp.Body.Close()
        srv.StandardResponse(writer, resp.StatusCode)</span>
}

func (server *ProxyServer) ContainerPutHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">if err := cleanACLs(request); err != nil </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(writer, 400, err.Error())
                return
        }</span>
        <span class="cov0" title="0">if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">_, err := ctx.GetAccountInfo(request.Context(), vars["account"])
        if err != nil </span><span class="cov0" title="0">{
                if server.accountAutoCreate </span><span class="cov0" title="0">{
                        ctx.AutoCreateAccount(request.Context(), vars["account"], request.Header)
                        _, err = ctx.GetAccountInfo(request.Context(), vars["account"])
                }</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 404)
                return
        }</span>
        <span class="cov0" title="0">if status, str := common.CheckContainerPut(request, vars["container"]); status != http.StatusOK </span><span class="cov0" title="0">{
                writer.Header().Set("Content-Type", "text/html; charset=UTF-8")
                writer.WriteHeader(status)
                writer.Write([]byte(fmt.Sprintf("&lt;html&gt;&lt;h1&gt;%s&lt;/h1&gt;&lt;p&gt;%s&lt;/p&gt;&lt;/html&gt;", http.StatusText(status), str)))
                return
        }</span>
        <span class="cov0" title="0">for k := range request.Header </span><span class="cov0" title="0">{
                if common.OwnerHeaders[strings.ToLower(k)] &amp;&amp; !ctx.StorageOwner </span><span class="cov0" title="0">{
                        request.Header.Del(k)
                }</span>
                <span class="cov0" title="0">if strings.HasPrefix(strings.ToLower(k), "x-remove-container-meta-") </span><span class="cov0" title="0">{
                        request.Header.Del(k)
                        request.Header.Set(strings.Replace(strings.ToLower(k), "-remove", "", 1), "")
                }</span>
        }
        <span class="cov0" title="0">resp := ctx.C.PutContainer(request.Context(), vars["account"], vars["container"], request.Header)
        resp.Body.Close()
        srv.StandardResponse(writer, resp.StatusCode)</span>
}

func (server *ProxyServer) ContainerDeleteHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">if _, err := ctx.GetAccountInfo(request.Context(), vars["account"]); err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 404)
                return
        }</span>
        <span class="cov0" title="0">if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">resp := ctx.C.DeleteContainer(request.Context(), vars["account"], vars["container"], request.Header)
        resp.Body.Close()
        srv.StandardResponse(writer, resp.StatusCode)</span>
}

func cleanACLs(r *http.Request) error <span class="cov0" title="0">{
        for _, header := range []string{"X-Container-Read", "X-Container-Write"} </span><span class="cov0" title="0">{
                if r.Header.Get(header) != "" </span><span class="cov0" title="0">{
                        cleanedValue, err := middleware.CleanACL(header, r.Header.Get(header))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">r.Header.Set(header, cleanedValue)</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func setVary(writer http.ResponseWriter, h string) <span class="cov8" title="1">{
        if v := writer.Header().Get("Vary"); v != "" </span><span class="cov8" title="1">{
                writer.Header().Set("Vary", fmt.Sprintf("%s, %s", v, h))
        }</span> else<span class="cov8" title="1"> {
                writer.Header().Set("Vary", h)
        }</span>
}

var publicMethods = []string{"HEAD", "GET", "PUT", "POST", "OPTIONS", "DELETE", "COPY"}

func (server *ProxyServer) OptionsHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        origin := request.Header.Get("Origin")
        methodString := strings.Join(publicMethods, ", ")
        if origin == "" || vars["container"] == "" </span><span class="cov8" title="1">{
                writer.Header().Set("Allow", methodString)
                srv.StandardResponse(writer, 200)
                return
        }</span>
        <span class="cov8" title="1">if rqm := request.Header.Get("Access-Control-Request-Method"); rqm == "" </span><span class="cov8" title="1">{
                srv.SimpleErrorResponse(writer, 401, "")
                return
        }</span> else<span class="cov8" title="1"> {
                found := false
                for _, method := range publicMethods </span><span class="cov8" title="1">{
                        if rqm == method </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        srv.SimpleErrorResponse(writer, 401, "")
                        return
                }</span>
        }
        <span class="cov8" title="1">if ci, err := ctx.C.GetContainerInfo(request.Context(), vars["account"], vars["container"]); err == nil </span><span class="cov8" title="1">{
                if common.IsOriginAllowed(ci.Metadata["Access-Control-Allow-Origin"], origin) </span><span class="cov8" title="1">{
                        writer.Header().Set("Allow", methodString)
                        if ci.Metadata["Access-Control-Allow-Origin"] == "*" </span><span class="cov8" title="1">{
                                writer.Header().Set("Access-Control-Allow-Origin", "*")
                        }</span> else<span class="cov8" title="1"> {
                                writer.Header().Set("Access-Control-Allow-Origin", origin)
                                setVary(writer, "Origin")
                        }</span>
                        <span class="cov8" title="1">if ma := ci.Metadata["Access-Control-Max-Age"]; ma != "" </span><span class="cov0" title="0">{
                                writer.Header().Set("Access-Control-Max-Age", ma)
                        }</span>
                        <span class="cov8" title="1">if rh := request.Header.Get("Access-Control-Request-Headers"); rh != "" </span><span class="cov0" title="0">{
                                writer.Header().Set("Access-Control-Allow-Headers", rh)
                                setVary(writer, "Access-Control-Request-Headers")
                        }</span>
                        <span class="cov8" title="1">srv.StandardResponse(writer, 200)
                        return</span>
                }
        }
        <span class="cov8" title="1">srv.SimpleErrorResponse(writer, 401, "")
        return</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package proxyserver

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "strconv"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/proxyserver/middleware"
        "go.uber.org/zap"
)

func (server *ProxyServer) EndpointsObjectGetHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                server.logger.Error("could not get proxy context")
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov8" title="1">vars := srv.GetVars(request)
        ring, resp := ctx.C.ObjectRingFor(request.Context(), vars["account"], vars["container"])
        if resp != nil </span><span class="cov0" title="0">{
                body, _ := ioutil.ReadAll(resp.Body)
                srv.SimpleErrorResponse(writer, 500, string(body))
                return
        }</span>
        <span class="cov8" title="1">partition := ring.GetPartition(vars["account"], vars["container"], vars["obj"])
        endpoints := []string{}
        for _, device := range ring.GetNodes(partition) </span><span class="cov8" title="1">{
                endpoints = append(endpoints, fmt.Sprintf("%s://%s:%d/%s/%d/%s/%s/%s", device.Scheme, device.Ip, device.Port, device.Device, partition, common.Urlencode(vars["account"]), common.Urlencode(vars["container"]), common.Urlencode(vars["obj"])))
        }</span>
        <span class="cov8" title="1">body, err := json.Marshal(endpoints)
        if err != nil </span><span class="cov0" title="0">{
                server.logger.Error("could not marshal endpoints", zap.Any("endpoints", endpoints), zap.Error(err))
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov8" title="1">writer.Header().Set("Content-Type", "application/json; charset=utf-8")
        writer.Header().Set("Content-Length", strconv.Itoa(len(body)))
        writer.WriteHeader(200)
        writer.Write(body)</span>
}

func (server *ProxyServer) EndpointsContainerGetHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                server.logger.Error("could not get proxy context")
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov8" title="1">vars := srv.GetVars(request)
        ring := ctx.C.ContainerRing()
        partition := ring.GetPartition(vars["account"], vars["container"], "")
        endpoints := []string{}
        for _, device := range ring.GetNodes(partition) </span><span class="cov8" title="1">{
                endpoints = append(endpoints, fmt.Sprintf("%s://%s:%d/%s/%d/%s/%s", device.Scheme, device.Ip, device.Port, device.Device, partition, common.Urlencode(vars["account"]), common.Urlencode(vars["container"])))
        }</span>
        <span class="cov8" title="1">body, err := json.Marshal(endpoints)
        if err != nil </span><span class="cov0" title="0">{
                server.logger.Error("could not marshal endpoints", zap.Any("endpoints", endpoints), zap.Error(err))
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov8" title="1">writer.Header().Set("Content-Type", "application/json; charset=utf-8")
        writer.Header().Set("Content-Length", strconv.Itoa(len(body)))
        writer.WriteHeader(200)
        writer.Write(body)</span>
}

func (server *ProxyServer) EndpointsAccountGetHandler(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                server.logger.Error("could not get proxy context")
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov8" title="1">vars := srv.GetVars(request)
        ring := ctx.C.AccountRing()
        partition := ring.GetPartition(vars["account"], "", "")
        endpoints := []string{}
        for _, device := range ring.GetNodes(partition) </span><span class="cov8" title="1">{
                endpoints = append(endpoints, fmt.Sprintf("%s://%s:%d/%s/%d/%s", device.Scheme, device.Ip, device.Port, device.Device, partition, common.Urlencode(vars["account"])))
        }</span>
        <span class="cov8" title="1">body, err := json.Marshal(endpoints)
        if err != nil </span><span class="cov0" title="0">{
                server.logger.Error("could not marshal endpoints", zap.Any("endpoints", endpoints), zap.Error(err))
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov8" title="1">writer.Header().Set("Content-Type", "application/json; charset=utf-8")
        writer.Header().Set("Content-Length", strconv.Itoa(len(body)))
        writer.WriteHeader(200)
        writer.Write(body)</span>
}

func (server *ProxyServer) EndpointsObjectGetHandler2(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                server.logger.Error("could not get proxy context")
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov8" title="1">vars := srv.GetVars(request)
        containerInfo, err := ctx.C.GetContainerInfo(request.Context(), vars["account"], vars["container"])
        if err != nil </span><span class="cov0" title="0">{
                server.logger.Error("could not obtain container info", zap.Error(err))
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov8" title="1">ring, resp := ctx.C.ObjectRingFor(request.Context(), vars["account"], vars["container"])
        if resp != nil </span><span class="cov0" title="0">{
                body, _ := ioutil.ReadAll(resp.Body)
                srv.SimpleErrorResponse(writer, 500, string(body))
                return
        }</span>
        <span class="cov8" title="1">partition := ring.GetPartition(vars["account"], vars["container"], vars["obj"])
        data := struct {
                Endpoints []string          `json:"endpoints"`
                Headers   map[string]string `json:"headers"`
        }{Headers: map[string]string{}}
        data.Headers["X-Backend-Storage-Policy-Index"] = strconv.Itoa(containerInfo.StoragePolicyIndex)
        for _, device := range ring.GetNodes(partition) </span><span class="cov8" title="1">{
                data.Endpoints = append(data.Endpoints, fmt.Sprintf("%s://%s:%d/%s/%d/%s/%s/%s", device.Scheme, device.Ip, device.Port, device.Device, partition, common.Urlencode(vars["account"]), common.Urlencode(vars["container"]), common.Urlencode(vars["obj"])))
        }</span>
        <span class="cov8" title="1">body, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                server.logger.Error("could not marshal data", zap.Any("data", data), zap.Error(err))
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov8" title="1">writer.Header().Set("Content-Type", "application/json; charset=utf-8")
        writer.Header().Set("Content-Length", strconv.Itoa(len(body)))
        writer.WriteHeader(200)
        writer.Write(body)</span>
}

func (server *ProxyServer) EndpointsContainerGetHandler2(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                server.logger.Error("could not get proxy context")
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov8" title="1">vars := srv.GetVars(request)
        containerInfo, err := ctx.C.GetContainerInfo(request.Context(), vars["account"], vars["container"])
        if err != nil </span><span class="cov0" title="0">{
                server.logger.Error("could not obtain container info", zap.Error(err))
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov8" title="1">ring := ctx.C.ContainerRing()
        partition := ring.GetPartition(vars["account"], vars["container"], "")
        data := struct {
                Endpoints []string          `json:"endpoints"`
                Headers   map[string]string `json:"headers"`
        }{Headers: map[string]string{}}
        data.Headers["X-Backend-Storage-Policy-Index"] = strconv.Itoa(containerInfo.StoragePolicyIndex)
        for _, device := range ring.GetNodes(partition) </span><span class="cov8" title="1">{
                data.Endpoints = append(data.Endpoints, fmt.Sprintf("%s://%s:%d/%s/%d/%s/%s", device.Scheme, device.Ip, device.Port, device.Device, partition, common.Urlencode(vars["account"]), common.Urlencode(vars["container"])))
        }</span>
        <span class="cov8" title="1">body, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                server.logger.Error("could not marshal data", zap.Any("data", data), zap.Error(err))
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov8" title="1">writer.Header().Set("Content-Type", "application/json; charset=utf-8")
        writer.Header().Set("Content-Length", strconv.Itoa(len(body)))
        writer.WriteHeader(200)
        writer.Write(body)</span>
}

func (server *ProxyServer) EndpointsAccountGetHandler2(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                server.logger.Error("could not get proxy context")
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov8" title="1">vars := srv.GetVars(request)
        ring := ctx.C.AccountRing()
        partition := ring.GetPartition(vars["account"], "", "")
        data := struct {
                Endpoints []string          `json:"endpoints"`
                Headers   map[string]string `json:"headers"`
        }{Headers: map[string]string{}}
        for _, device := range ring.GetNodes(partition) </span><span class="cov8" title="1">{
                data.Endpoints = append(data.Endpoints, fmt.Sprintf("%s://%s:%d/%s/%d/%s", device.Scheme, device.Ip, device.Port, device.Device, partition, common.Urlencode(vars["account"])))
        }</span>
        <span class="cov8" title="1">body, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                server.logger.Error("could not marshal data", zap.Any("data", data), zap.Error(err))
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov8" title="1">writer.Header().Set("Content-Type", "application/json; charset=utf-8")
        writer.Header().Set("Content-Length", strconv.Itoa(len(body)))
        writer.WriteHeader(200)
        writer.Write(body)</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package proxyserver

import (
        "flag"
        "fmt"
        "io"
        "net/http"
        _ "net/http/pprof"
        "path"
        "strings"
        "time"

        opentracing "github.com/opentracing/opentracing-go"
        "github.com/troubling/hummingbird/client"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/common/tracing"
        globalmiddleware "github.com/troubling/hummingbird/middleware"
        "github.com/troubling/hummingbird/proxyserver/middleware"

        "github.com/justinas/alice"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/uber-go/tally"
        promreporter "github.com/uber-go/tally/prometheus"
        "go.uber.org/zap"
)

type ProxyServer struct {
        logger            srv.LowLevelLogger
        logLevel          zap.AtomicLevel
        mc                ring.MemcacheRing
        accountAutoCreate bool
        proxyClient       client.ProxyClient
        metricsCloser     io.Closer
        traceCloser       io.Closer
        tracer            opentracing.Tracer
}

func (server *ProxyServer) Type() string <span class="cov0" title="0">{
        return "proxy"
}</span>

func (server *ProxyServer) Background(flags *flag.FlagSet) chan struct{} <span class="cov0" title="0">{
        return nil
}</span>

func (server *ProxyServer) Finalize() <span class="cov0" title="0">{
        if server.metricsCloser != nil </span><span class="cov0" title="0">{
                server.metricsCloser.Close()
        }</span>
        <span class="cov0" title="0">if server.traceCloser != nil </span><span class="cov0" title="0">{
                server.traceCloser.Close()
        }</span>
        <span class="cov0" title="0">server.proxyClient.Close()</span>
}

func (server *ProxyServer) GetHandler(config conf.Config, metricsPrefix string) http.Handler <span class="cov0" title="0">{
        obfuscatedPrefix, _ := config.Get("proxy-server", "obfuscated_prefix")
        var metricsScope tally.Scope
        metricsScope, server.metricsCloser = tally.NewRootScope(tally.ScopeOptions{
                Prefix:         metricsPrefix,
                Tags:           map[string]string{},
                CachedReporter: promreporter.NewReporter(promreporter.Options{}),
                Separator:      promreporter.DefaultSeparator,
        }, time.Second)
        router := srv.NewRouter()
        if obfuscatedPrefix != "" </span><span class="cov0" title="0">{
                op := obfuscatedPrefix
                if op == "-" </span><span class="cov0" title="0">{
                        op = ""
                }</span>
                <span class="cov0" title="0">router.Get(path.Join("/", op, "metrics"), prometheus.Handler())
                router.Get(path.Join("/", op, "loglevel"), server.logLevel)
                router.Put(path.Join("/", op, "loglevel"), server.logLevel)
                router.Get(path.Join("/", op, "debug/pprof/:parm"), http.DefaultServeMux)
                router.Post(path.Join("/", op, "debug/pprof/:parm"), http.DefaultServeMux)
                router.Get(path.Join("/", op, "endpoints/v1/:account/:container/*obj"), http.HandlerFunc(server.EndpointsObjectGetHandler))
                router.Get(path.Join("/", op, "endpoints/v1/:account/:container"), http.HandlerFunc(server.EndpointsContainerGetHandler))
                router.Get(path.Join("/", op, "endpoints/v1/:account"), http.HandlerFunc(server.EndpointsAccountGetHandler))
                router.Get(path.Join("/", op, "endpoints/v2/:account/:container/*obj"), http.HandlerFunc(server.EndpointsObjectGetHandler2))
                router.Get(path.Join("/", op, "endpoints/v2/:account/:container"), http.HandlerFunc(server.EndpointsContainerGetHandler2))
                router.Get(path.Join("/", op, "endpoints/v2/:account"), http.HandlerFunc(server.EndpointsAccountGetHandler2))
                router.Get(path.Join("/", op, "endpoints/:account/:container/*obj"), http.HandlerFunc(server.EndpointsObjectGetHandler))
                router.Get(path.Join("/", op, "endpoints/:account/:container"), http.HandlerFunc(server.EndpointsContainerGetHandler))
                router.Get(path.Join("/", op, "endpoints/:account"), http.HandlerFunc(server.EndpointsAccountGetHandler))</span>
        }
        <span class="cov0" title="0">router.Get("/v1/:account/:container/*obj", http.HandlerFunc(server.ObjectGetHandler))
        router.Head("/v1/:account/:container/*obj", http.HandlerFunc(server.ObjectHeadHandler))
        router.Put("/v1/:account/:container/*obj", http.HandlerFunc(server.ObjectPutHandler))
        router.Delete("/v1/:account/:container/*obj", http.HandlerFunc(server.ObjectDeleteHandler))
        router.Post("/v1/:account/:container/*obj", http.HandlerFunc(server.ObjectPostHandler))
        router.Options("/v1/:account/:container/*obj", http.HandlerFunc(server.OptionsHandler))

        router.Get("/v1/:account/:container", http.HandlerFunc(server.ContainerGetHandler))
        router.Get("/v1/:account/:container/", http.HandlerFunc(server.ContainerGetHandler))
        router.Head("/v1/:account/:container", http.HandlerFunc(server.ContainerHeadHandler))
        router.Head("/v1/:account/:container/", http.HandlerFunc(server.ContainerHeadHandler))
        router.Put("/v1/:account/:container", http.HandlerFunc(server.ContainerPutHandler))
        router.Put("/v1/:account/:container/", http.HandlerFunc(server.ContainerPutHandler))
        router.Delete("/v1/:account/:container", http.HandlerFunc(server.ContainerDeleteHandler))
        router.Delete("/v1/:account/:container/", http.HandlerFunc(server.ContainerDeleteHandler))
        router.Post("/v1/:account/:container", http.HandlerFunc(server.ContainerPostHandler))
        router.Post("/v1/:account/:container/", http.HandlerFunc(server.ContainerPostHandler))
        router.Options("/v1/:account/:container", http.HandlerFunc(server.OptionsHandler))
        router.Options("/v1/:account/:container/", http.HandlerFunc(server.OptionsHandler))

        router.Get("/v1/:account", http.HandlerFunc(server.AccountGetHandler))
        router.Get("/v1/:account/", http.HandlerFunc(server.AccountGetHandler))
        router.Head("/v1/:account", http.HandlerFunc(server.AccountHeadHandler))
        router.Head("/v1/:account/", http.HandlerFunc(server.AccountHeadHandler))
        router.Put("/v1/:account", http.HandlerFunc(server.AccountPutHandler))
        router.Put("/v1/:account/", http.HandlerFunc(server.AccountPutHandler))
        router.Delete("/v1/:account", http.HandlerFunc(server.AccountDeleteHandler))
        router.Delete("/v1/:account/", http.HandlerFunc(server.AccountDeleteHandler))
        router.Post("/v1/:account", http.HandlerFunc(server.AccountPostHandler))
        router.Post("/v1/:account/", http.HandlerFunc(server.AccountPostHandler))
        router.Options("/v1/:account", http.HandlerFunc(server.OptionsHandler))
        router.Options("/v1/:account/", http.HandlerFunc(server.OptionsHandler))

        tempAuth := config.GetBool("proxy-server", "tempauth_enabled", true)
        var middlewares []struct {
                construct func(conf.Section, tally.Scope) (func(http.Handler) http.Handler, error)
                section   string
        }
        // TODO: make this all dynamical and stuff
        if tempAuth </span><span class="cov0" title="0">{
                middlewares = []struct {
                        construct func(conf.Section, tally.Scope) (func(http.Handler) http.Handler, error)
                        section   string
                }{
                        {middleware.NewCatchError, "filter:catch_errors"},
                        {middleware.NewHealthcheck, "filter:healthcheck"},
                        {middleware.NewRequestLogger, "filter:proxy-logging"},
                        {middleware.NewS3Auth, "filter:s3api"},
                        {middleware.NewCrossDomain, "filter:crossdomain"},
                        {middleware.NewCors, "filter:cors"}, // TODO: i dont want to have to have a seciton for this
                        {middleware.NewFormPost, "filter:formpost"},
                        {middleware.NewTempURL, "filter:tempurl"},
                        {middleware.NewTempAuth, "filter:tempauth"},
                        {middleware.NewS3Api, "filter:s3api"},
                        {middleware.NewBulk, "filter:bulk"},
                        {middleware.NewMultirange, "filter:multirange"},
                        {middleware.NewRatelimiter, "filter:ratelimit"},
                        {middleware.NewStaticWeb, "filter:staticweb"},
                        {middleware.NewCopyMiddleware, "filter:copy"},
                        {middleware.NewAccountQuota, "filter:account-quotas"},
                        {middleware.NewContainerQuota, "filter:container-quotas"},
                        {middleware.NewVersionedWrites, "filter:versioned_writes"},
                        {middleware.NewXlo, "filter:slo"},
                }
        }</span> else<span class="cov0" title="0"> {
                middlewares = []struct {
                        construct func(conf.Section, tally.Scope) (func(http.Handler) http.Handler, error)
                        section   string
                }{
                        {middleware.NewCatchError, "filter:catch_errors"},
                        {middleware.NewHealthcheck, "filter:healthcheck"},
                        {middleware.NewRequestLogger, "filter:proxy-logging"},
                        {middleware.NewS3Auth, "filter:s3api"},
                        {middleware.NewCrossDomain, "filter:crossdomain"},
                        {middleware.NewCors, "filter:cors"},
                        {middleware.NewFormPost, "filter:formpost"},
                        {middleware.NewTempURL, "filter:tempurl"},
                        {middleware.NewAuthToken, "filter:authtoken"},
                        {middleware.NewS3Api, "filter:s3api"},
                        {middleware.NewKeystoneAuth, "filter:keystoneauth"},
                        {middleware.NewBulk, "filter:bulk"},
                        {middleware.NewMultirange, "filter:multirange"},
                        {middleware.NewRatelimiter, "filter:ratelimit"},
                        {middleware.NewStaticWeb, "filter:staticweb"},
                        {middleware.NewCopyMiddleware, "filter:copy"},
                        {middleware.NewAccountQuota, "filter:account-quotas"},
                        {middleware.NewContainerQuota, "filter:container-quotas"},
                        {middleware.NewVersionedWrites, "filter:versioned_writes"},
                        {middleware.NewXlo, "filter:slo"},
                }
        }</span>
        <span class="cov0" title="0">pipeline := alice.New(globalmiddleware.ServerTracer(server.tracer), middleware.NewContext(config.GetBool("debug", "debug_x_source_code", false),
                server.mc, server.logger, server.proxyClient))
        for _, m := range middlewares </span><span class="cov0" title="0">{
                mid, err := m.construct(config.GetSection(m.section), metricsScope)
                if err != nil </span><span class="cov0" title="0">{
                        // TODO: propagate error upwards instead of panicking
                        panic("Unable to construct middleware")</span>
                }
                <span class="cov0" title="0">pipeline = pipeline.Append(mid)</span>
        }
        <span class="cov0" title="0">return pipeline.Then(router)</span>
}

func NewServer(serverconf conf.Config, flags *flag.FlagSet, cnf srv.ConfigLoader) (*srv.IpPort, srv.Server, srv.LowLevelLogger, error) <span class="cov0" title="0">{
        var err error
        var ipPort *srv.IpPort
        server := &amp;ProxyServer{}
        server.mc, err = ring.NewMemcacheRingFromConfig(serverconf)
        if err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, err
        }</span>

        <span class="cov0" title="0">bindIP := serverconf.GetDefault("DEFAULT", "bind_ip", "0.0.0.0")
        bindPort := int(serverconf.GetInt("DEFAULT", "bind_port", common.DefaultProxyServerPort))
        certFile := serverconf.GetDefault("DEFAULT", "cert_file", "")
        keyFile := serverconf.GetDefault("DEFAULT", "key_file", "")

        readAff := serverconf.GetDefault("app:proxy-server", "read_affinity", "")
        writeAff := serverconf.GetDefault("app:proxy-server", "write_affinity", "")
        writeAffCount := serverconf.GetDefault("app:proxy-server", "write_affinity_node_count", "")
        logLevelString := serverconf.GetDefault("app:proxy-server", "log_level", "INFO")
        server.logLevel = zap.NewAtomicLevel()
        server.logLevel.UnmarshalText([]byte(strings.ToLower(logLevelString)))
        server.accountAutoCreate = serverconf.GetBool("app:proxy-server", "account_autocreate", false)
        if server.logger, err = srv.SetupLogger("proxy-server", &amp;server.logLevel, flags); err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, fmt.Errorf("Error setting up logger: %v", err)
        }</span>
        <span class="cov0" title="0">if serverconf.HasSection("tracing") </span><span class="cov0" title="0">{
                server.tracer, server.traceCloser, err = tracing.Init("proxyserver", server.logger, serverconf.GetSection("tracing"))
                if err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error setting up tracer: %v", err)
                }</span>
                <span class="cov0" title="0">server.mc = ring.NewTracingMemcacheRing(server.mc, server.tracer)</span>
        }
        <span class="cov0" title="0">policies, err := cnf.GetPolicies()
        if err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, err
        }</span>
        <span class="cov0" title="0">server.proxyClient, err = client.NewProxyClient(
                policies, cnf, server.logger, certFile, keyFile, readAff, writeAff, writeAffCount, serverconf)
        if err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, fmt.Errorf("Error setting up proxyClient: %v", err)
        }</span>
        <span class="cov0" title="0">info := map[string]interface{}{
                "version":                  common.Version,
                "strict_cors_mode":         true,
                "policies":                 policies.GetPolicyInfo(),
                "account_autocreate":       server.accountAutoCreate,
                "allow_account_management": true,
        }
        for k, v := range common.DEFAULT_CONSTRAINTS </span><span class="cov0" title="0">{
                info[k] = v
        }</span>
        <span class="cov0" title="0">middleware.RegisterInfo("swift", info)
        ipPort = &amp;srv.IpPort{Ip: bindIP, Port: int(bindPort), CertFile: certFile, KeyFile: keyFile}
        return ipPort, server, server.logger, nil</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "net/http"
        "strconv"

        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"

        "github.com/uber-go/tally"
)

func accountQuota(metric tally.Counter) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                        if !(request.Method == "PUT" || request.Method == "POST") </span><span class="cov0" title="0">{
                                next.ServeHTTP(writer, request)
                                return
                        }</span>

                        <span class="cov8" title="1">ctx := GetProxyContext(request)
                        _, account, container, obj := getPathParts(request)

                        if container == "" </span><span class="cov8" title="1">{
                                var quotaSet bool
                                if _, ok := request.Header["X-Account-Meta-Quota-Bytes"]; ok </span><span class="cov8" title="1">{
                                        quotaSet = true
                                }</span>
                                <span class="cov8" title="1">removeQuota := request.Header.Get("X-Remove-Account-Meta-Quota-Bytes")
                                if quotaSet || removeQuota != "" </span><span class="cov8" title="1">{
                                        if ctx.Authorize != nil </span><span class="cov0" title="0">{
                                                if ok, st := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                                                        srv.StandardResponse(writer, st)
                                                        return
                                                }</span>
                                        }
                                        <span class="cov8" title="1">if !ctx.ResellerRequest </span><span class="cov0" title="0">{
                                                srv.StandardResponse(writer, http.StatusForbidden)
                                                return
                                        }</span>
                                }
                                <span class="cov8" title="1">quota := request.Header.Get("X-Account-Meta-Quota-Bytes")
                                if quota != "" </span><span class="cov8" title="1">{
                                        if _, err := strconv.ParseInt(quota, 10, 64); err != nil </span><span class="cov8" title="1">{
                                                srv.SimpleErrorResponse(writer, http.StatusBadRequest, "Invalid bytes quota.")
                                                return
                                        }</span>
                                }
                                <span class="cov0" title="0">next.ServeHTTP(writer, request)
                                return</span>
                        }

                        <span class="cov8" title="1">if request.Method == "POST" || obj == "" </span><span class="cov0" title="0">{
                                next.ServeHTTP(writer, request)
                                return
                        }</span>

                        <span class="cov8" title="1">ai, err := ctx.GetAccountInfo(request.Context(), account)
                        if err != nil </span><span class="cov0" title="0">{
                                next.ServeHTTP(writer, request)
                                return
                        }</span>

                        <span class="cov8" title="1">qBytes := ai.Metadata["Quota-Bytes"]
                        if qBytes != "" </span><span class="cov8" title="1">{
                                if quota, err := strconv.ParseInt(qBytes, 10, 64); err == nil </span><span class="cov8" title="1">{
                                        newSize := ai.ObjectBytes + request.ContentLength
                                        if quota &lt; newSize </span><span class="cov8" title="1">{
                                                srv.SimpleErrorResponse(writer, http.StatusRequestEntityTooLarge, "Upload exceeds quota.")
                                                return
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">next.ServeHTTP(writer, request)</span>
                })
        }
}

func NewAccountQuota(config conf.Section, metricsScope tally.Scope) (func(http.Handler) http.Handler, error) <span class="cov8" title="1">{
        RegisterInfo("account_quotas", map[string]interface{}{})
        return accountQuota(metricsScope.Counter("account_quotas")), nil
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "errors"
        "fmt"
        "net/http"
        "net/url"
        "strings"

        "github.com/troubling/hummingbird/common"
)

// Returns a cleaned ACL header value, validating that it meets the formatting
// requirements for standard Hummingbird ACL strings.
func CleanACL(name string, value string) (string, error) <span class="cov8" title="1">{
        name = strings.ToLower(name)
        var values []string
        for _, rawValue := range strings.Split(value, ",") </span><span class="cov8" title="1">{
                rawValue = strings.TrimSpace(rawValue)
                if rawValue == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if !strings.Contains(rawValue, ":") </span><span class="cov8" title="1">{
                        values = append(values, rawValue)
                        continue</span>
                }
                <span class="cov8" title="1">v := strings.SplitN(rawValue, ":", 2)
                v[0] = strings.TrimSpace(v[0])
                v[1] = strings.TrimSpace(v[1])
                if v[0] == "" || !strings.HasPrefix(v[0], ".") </span><span class="cov8" title="1">{
                        values = append(values, rawValue)
                }</span> else<span class="cov8" title="1"> if common.StringInSlice(v[0], []string{".r", ".ref", ".referer", ".referrer"}) </span><span class="cov8" title="1">{
                        if strings.Contains(name, "write") </span><span class="cov8" title="1">{
                                return "", fmt.Errorf("Referrers not allowed in write ACL: %s", rawValue)
                        }</span>
                        <span class="cov8" title="1">negate := false
                        if v[1] != "" &amp;&amp; strings.HasPrefix(v[1], "-") </span><span class="cov8" title="1">{
                                negate = true
                                v[1] = strings.TrimSpace(v[1][1:])
                        }</span>
                        <span class="cov8" title="1">if v[1] != "" &amp;&amp; v[1] != "*" &amp;&amp; strings.HasPrefix(v[1], "*") </span><span class="cov8" title="1">{
                                v[1] = strings.TrimSpace(v[1][1:])
                        }</span>
                        <span class="cov8" title="1">if v[1] == "" || v[1] == "." </span><span class="cov8" title="1">{
                                return "", fmt.Errorf("No host/domain value after referrer designation in ACL: %s", rawValue)
                        }</span>
                        <span class="cov8" title="1">if negate </span><span class="cov8" title="1">{
                                values = append(values, fmt.Sprintf(".r:-%s", v[1]))
                        }</span> else<span class="cov8" title="1"> {
                                values = append(values, fmt.Sprintf(".r:%s", v[1]))
                        }</span>
                } else<span class="cov8" title="1"> {
                        return "", fmt.Errorf("Unknown designator %s in ACL: %s", v[0], rawValue)
                }</span>
        }
        <span class="cov8" title="1">return strings.Join(values, ","), nil</span>

}

// Parses a standard Hummingbird ACL string into a referrers list and groups list.
func ParseACL(acl string) ([]string, []string) <span class="cov8" title="1">{
        referrers := []string{}
        groups := []string{}
        if acl != "" </span><span class="cov8" title="1">{
                for _, value := range strings.Split(acl, ",") </span><span class="cov8" title="1">{
                        if strings.HasPrefix(value, ".r:") </span><span class="cov8" title="1">{
                                referrers = append(referrers, value[len(".r:"):])
                        }</span> else<span class="cov8" title="1"> {
                                groups = append(groups, value)
                        }</span>
                }
        }
        <span class="cov8" title="1">return referrers, groups</span>
}

//Returns True if the referrer should be allowed based on the referrerACL list
func ReferrerAllowed(referrer string, referrerACL []string) bool <span class="cov8" title="1">{
        allow := false
        if len(referrerACL) &gt; 0 </span><span class="cov8" title="1">{
                rHost := "unknown"
                if u, err := url.Parse(referrer); err == nil </span><span class="cov8" title="1">{
                        rHost = u.Hostname()
                }</span>
                <span class="cov8" title="1">for _, mHost := range referrerACL </span><span class="cov8" title="1">{
                        if strings.HasPrefix(mHost, "-") </span><span class="cov8" title="1">{
                                mHost = mHost[1:]
                                if mHost == rHost || (strings.HasPrefix(mHost, ".") &amp;&amp; strings.HasSuffix(rHost, mHost)) </span><span class="cov8" title="1">{
                                        allow = false
                                }</span>
                        } else<span class="cov8" title="1"> if mHost == "*" || mHost == rHost || (strings.HasPrefix(mHost, ".") &amp;&amp; strings.HasSuffix(rHost, mHost)) </span><span class="cov8" title="1">{
                                allow = true
                        }</span>
                }
        }
        <span class="cov8" title="1">return allow</span>
}

func AuthorizeUnconfirmedIdentity(r *http.Request, obj string, referrers []string, roles []string) (bool, error) <span class="cov8" title="1">{
        if ReferrerAllowed(r.Referer(), referrers) </span><span class="cov8" title="1">{
                if obj != "" || common.StringInSlice(".rlistings", roles) </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
                <span class="cov8" title="1">return false, nil</span>
        }
        <span class="cov8" title="1">return false, errors.New("unable to confirm identity")</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "bytes"
        "context"
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strings"
        "sync"
        "time"

        "github.com/troubling/hummingbird/client"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/common/tracing"
        "github.com/uber-go/tally"
        "go.uber.org/zap"
)

type identity struct {
        client          common.HTTPClient
        authURL         string
        authPlugin      string
        projectDomainID string
        userDomainID    string
        projectName     string
        userName        string
        password        string
        userAgent       string
}

type authToken struct {
        *identity
        next           http.Handler
        cacheDur       time.Duration
        preValidateDur time.Duration
        preValidations map[string]bool
        lock           sync.Mutex
}

var authHeaders = []string{"X-Identity-Status",
        "X-Service-Identity-Status",
        "X-Domain-Id",
        "X-Domain-Name",
        "X-Project-Id",
        "X-Project-Name",
        "X-Project-Domain-Id",
        "X-Project-Domain-Name",
        "X-User-Id",
        "X-User-Name",
        "X-User-Domain-Id",
        "X-User-Domain-Name",
        "X-Roles",
        "X-Service-Domain-Id",
        "X-Service-Domain-Name",
        "X-Service-Project-Id",
        "X-Service-Project-Name",
        "X-Service-Project-Domain-Id",
        "X-Service-Project-Domain-Name",
        "X-Service-User-Id",
        "X-Service-User-Name",
        "X-Service-User-Domain-Id",
        "X-Service-User-Domain-Name",
        "X-Service-Roles",
        "X-Service-Catalog",
        "X-Is-Admin-Project",
        //Deprecated Headers
        "X-Role",
        "X-User",
        "X-Tenant-Id",
        "X-Tenant-Name",
        "X-Tenant",
}

type domain struct {
        ID      string `json:"id"`
        Name    string `json:"name,omitempty"`
        Enabled bool   `json:"enabled,omitempty"`
}

type project struct {
        ID      string  `json:"id,omitempty"`
        Name    string  `json:"name,omitempty"`
        Enabled bool    `json:"enabled,omitempty"`
        Domain  *domain `json:"domain"`
}

type token struct {
        ExpiresAt     time.Time `json:"expires_at"`
        MemcacheTtlAt time.Time
        IssuedAt      time.Time `json:"issued_at"`
        Methods       []string
        User          struct {
                ID      string
                Name    string
                Email   string
                Enabled bool
                Domain  struct {
                        ID   string
                        Name string
                }
        }
        Project *project
        Domain  *domain
        Roles   *[]struct {
                ID   string
                Name string
        }
        S3Creds *s3Blob
}

type s3Token struct {
        Access    string `json:"access"`
        Token     string `json:"token"`
        Signature string `json:"signature"`
}

type s3Creds struct {
        Credentials s3Token `json:"credentials"`
}

func (t token) Valid() bool <span class="cov8" title="1">{
        now := time.Now().Unix()
        return now &lt; t.ExpiresAt.Unix()
}</span>

func (t token) populateReqHeader(r *http.Request, headerPrefix string) <span class="cov8" title="1">{
        r.Header.Set(fmt.Sprintf("X%s-User-Id", headerPrefix), t.User.ID)
        r.Header.Set(fmt.Sprintf("X%s-User-Name", headerPrefix), t.User.Name)
        r.Header.Set(fmt.Sprintf("X%s-User-Domain-Id", headerPrefix), t.User.Domain.ID)
        r.Header.Set(fmt.Sprintf("X%s-User-Domain-Name", headerPrefix), t.User.Domain.Name)

        if project := t.Project; project != nil </span><span class="cov8" title="1">{
                r.Header.Set(fmt.Sprintf("X%s-Project-Name", headerPrefix), project.Name)
                r.Header.Set(fmt.Sprintf("X%s-Project-Id", headerPrefix), project.ID)
                r.Header.Set(fmt.Sprintf("X%s-Project-Domain-Name", headerPrefix), project.Domain.Name)
                r.Header.Set(fmt.Sprintf("X%s-Project-Domain-Id", headerPrefix), project.Domain.ID)
        }</span>

        <span class="cov8" title="1">if domain := t.Domain; domain != nil </span><span class="cov8" title="1">{
                r.Header.Set(fmt.Sprintf("X%s-Domain-Id", headerPrefix), domain.ID)
                r.Header.Set(fmt.Sprintf("X%s-Domain-Name", headerPrefix), domain.Name)
        }</span>

        <span class="cov8" title="1">if roles := t.Roles; roles != nil </span><span class="cov8" title="1">{
                roleNames := []string{}
                for _, role := range *t.Roles </span><span class="cov8" title="1">{
                        roleNames = append(roleNames, role.Name)
                }</span>
                <span class="cov8" title="1">r.Header.Set(fmt.Sprintf("X%s-Roles", headerPrefix), strings.Join(roleNames, ","))</span>
        }
}

type identityReq struct {
        Auth struct {
                Identity struct {
                        Methods  []string `json:"methods"`
                        Password struct {
                                User struct {
                                        Domain struct {
                                                ID string `json:"id"`
                                        } `json:"domain"`
                                        Name     string `json:"name"`
                                        Password string `json:"password"`
                                } `json:"user"`
                        } `json:"password"`
                } `json:"identity"`

                Scope struct {
                        Project *project `json:"project"`
                } `json:"scope"`
        } `json:"auth"`
}

type identityResponse struct {
        Error *struct {
                Code    int
                Message string
                Title   string
        }
        Token *token
}

type credential struct {
        UserId    string `json:"user_id"`
        ProjectId string `json:"project_id"`
        Blob      string `json:"blob"`
        Id        string `json:"id"`
}

type s3Blob struct {
        Access string `json:"access"`
        Secret string `json:"secret"`
}

type credentialsResponse struct {
        Credentials []credential `json:"credentials"`
}

func (at *authToken) preValidate(ctx context.Context, proxyCtx *ProxyContext, authToken string) <span class="cov8" title="1">{
        at.lock.Lock()
        defer at.lock.Unlock()
        _, ok := at.preValidations[authToken]
        if ok </span><span class="cov0" title="0">{
                return
        }</span> else<span class="cov8" title="1"> {
                at.preValidations[authToken] = true
        }</span>
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                ctx = tracing.CopySpanFromContext(ctx)
                at.validate(ctx, proxyCtx, authToken)
                at.lock.Lock()
                defer at.lock.Unlock()
                delete(at.preValidations, authToken)
        }</span>()
}

func (at *authToken) fetchAndValidateToken(ctx context.Context, proxyCtx *ProxyContext, authToken string) (*token, bool, error) <span class="cov8" title="1">{
        if proxyCtx == nil </span><span class="cov0" title="0">{
                return nil, false, errors.New("no proxyCtx")
        }</span>
        <span class="cov8" title="1">cachedToken := at.loadTokenFromCache(ctx, proxyCtx, authToken)
        if cachedToken != nil </span><span class="cov8" title="1">{
                return cachedToken, true, nil
        }</span>
        <span class="cov8" title="1">return at.validate(ctx, proxyCtx, authToken)</span>
}

func (at *authToken) loadTokenFromCache(ctx context.Context, proxyCtx *ProxyContext, key string) *token <span class="cov8" title="1">{
        var cachedToken token
        if err := proxyCtx.Cache.GetStructured(ctx, key, &amp;cachedToken); err == nil </span><span class="cov8" title="1">{
                if at.preValidateDur &gt; 0 &amp;&amp; !cachedToken.MemcacheTtlAt.IsZero() </span><span class="cov8" title="1">{
                        invalidateEarlyTime := time.Now().Add(at.preValidateDur)
                        if cachedToken.MemcacheTtlAt.Before(invalidateEarlyTime) </span><span class="cov8" title="1">{
                                at.preValidate(ctx, proxyCtx, key)
                        }</span>
                }
                <span class="cov8" title="1">proxyCtx.Logger.Debug("Found cache token",
                        zap.String("token", key))
                return &amp;cachedToken</span>
        } else<span class="cov8" title="1"> {
                return nil
        }</span>
}

func (at *authToken) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        proxyCtx := GetProxyContext(r)
        if proxyCtx.Authorize != nil </span><span class="cov0" title="0">{
                at.next.ServeHTTP(w, r)
                return
        }</span>
        <span class="cov8" title="1">removeAuthHeaders(r)
        r.Header.Set("X-Identity-Status", "Invalid")
        serviceAuthToken := r.Header.Get("X-Service-Token")
        if serviceAuthToken != "" </span><span class="cov0" title="0">{
                serviceToken, serviceTokenValid, err := at.fetchAndValidateToken(r.Context(), proxyCtx, serviceAuthToken)
                if err != nil </span><span class="cov0" title="0">{
                        srv.SimpleErrorResponse(w, http.StatusInternalServerError, "")
                        return
                }</span>
                <span class="cov0" title="0">if serviceToken != nil &amp;&amp; serviceTokenValid </span><span class="cov0" title="0">{
                        r.Header.Set("X-Service-Identity-Status", "Confirmed")
                        serviceToken.populateReqHeader(r, "-Service")
                }</span> else<span class="cov0" title="0"> {
                        r.Header.Set("X-Service-Identity-Status", "Invalid")
                }</span>
        }
        <span class="cov8" title="1">if proxyCtx.S3Auth != nil </span><span class="cov0" title="0">{
                // Handle S3 auth validation first
                userToken, userTokenValid := at.validateS3Signature(r.Context(), proxyCtx)
                if userToken != nil &amp;&amp; userTokenValid </span><span class="cov0" title="0">{
                        r.Header.Set("X-Identity-Status", "Confirmed")
                        userToken.populateReqHeader(r, "")
                }</span> else<span class="cov0" title="0"> {
                        proxyCtx.Authorize = func(r *http.Request) (bool, int) </span><span class="cov0" title="0">{
                                return false, http.StatusForbidden
                        }</span>
                }
        }

        <span class="cov8" title="1">userAuthToken := r.Header.Get("X-Auth-Token")
        if userAuthToken == "" </span><span class="cov8" title="1">{
                userAuthToken = r.Header.Get("X-Storage-Token")
        }</span>
        <span class="cov8" title="1">if userAuthToken != "" </span><span class="cov8" title="1">{
                userToken, userTokenValid, err := at.fetchAndValidateToken(r.Context(), proxyCtx, userAuthToken)
                if err != nil </span><span class="cov0" title="0">{
                        srv.SimpleErrorResponse(w, http.StatusInternalServerError, "")
                        return
                }</span>
                <span class="cov8" title="1">if userToken != nil &amp;&amp; userTokenValid </span><span class="cov8" title="1">{
                        r.Header.Set("X-Identity-Status", "Confirmed")
                        userToken.populateReqHeader(r, "")
                }</span>
        }
        <span class="cov8" title="1">at.next.ServeHTTP(w, r)</span>
}

func (at *authToken) validateS3Signature(ctx context.Context, proxyCtx *ProxyContext) (*token, bool) <span class="cov0" title="0">{
        // Check for a cached token
        cachedToken := at.loadTokenFromCache(ctx, proxyCtx, "S3:"+proxyCtx.S3Auth.Key)
        if cachedToken != nil </span><span class="cov0" title="0">{
                proxyCtx.S3Auth.Account = cachedToken.Project.ID
                return cachedToken, proxyCtx.S3Auth.validateSignature([]byte(cachedToken.S3Creds.Secret))
        }</span>
        <span class="cov0" title="0">tok, err := at.doValidateS3(ctx, proxyCtx, proxyCtx.S3Auth.StringToSign, proxyCtx.S3Auth.Key, proxyCtx.S3Auth.Signature)
        if err != nil </span><span class="cov0" title="0">{
                proxyCtx.Logger.Debug("Failed to validate s3 signature", zap.Error(err))
                return nil, false
        }</span>

        <span class="cov0" title="0">if tok != nil </span><span class="cov0" title="0">{
                proxyCtx.S3Auth.Account = tok.Project.ID
                // TODO: We need to get and cache the secret to sign our own requests
                at.cacheToken(ctx, proxyCtx, "S3:"+proxyCtx.S3Auth.Key, tok)
                return tok, true
        }</span>

        <span class="cov0" title="0">return nil, false</span>
}

func (at *authToken) validate(ctx context.Context, proxyCtx *ProxyContext, authToken string) (*token, bool, error) <span class="cov8" title="1">{
        tok, err := at.doValidate(ctx, proxyCtx, authToken)
        if err != nil </span><span class="cov0" title="0">{
                proxyCtx.Logger.Debug("Failed to validate token", zap.Error(err))
                return nil, false, err
        }</span>

        <span class="cov8" title="1">if tok != nil </span><span class="cov8" title="1">{
                at.cacheToken(ctx, proxyCtx, authToken, tok)
                return tok, true, nil
        }</span>

        <span class="cov8" title="1">return nil, false, nil</span>
}

func (at *authToken) cacheToken(ctx context.Context, proxyCtx *ProxyContext, key string, tok *token) <span class="cov8" title="1">{
        ttl := at.cacheDur
        if expiresIn := tok.ExpiresAt.Sub(time.Now()); expiresIn &lt; ttl &amp;&amp; expiresIn &gt; 0 </span><span class="cov0" title="0">{
                ttl = expiresIn
        }</span>
        <span class="cov8" title="1">tok.MemcacheTtlAt = time.Now().Add(ttl)
        proxyCtx.Cache.Set(ctx, key, *tok, int(ttl/time.Second))</span>
}

// doValidateS3 returns an error for any problems attempting the validation
// (i.e. the end user did nothing wrong); it will return nil, nil if the user's
// credentials could not be validated; or it will return the token, nil on
// successful validation.
func (at *authToken) doValidateS3(ctx context.Context, proxyCtx *ProxyContext, stringToSign, key, signature string) (*token, error) <span class="cov0" title="0">{
        creds := &amp;s3Creds{}
        creds.Credentials.Access = key
        creds.Credentials.Signature = signature
        creds.Credentials.Token = base64.URLEncoding.EncodeToString([]byte(stringToSign))
        credsReqBody, err := json.Marshal(creds)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req, err := http.NewRequest("POST", at.authURL+"v3/s3tokens", bytes.NewBuffer(credsReqBody))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        r, err := at.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer r.Body.Close()

        if r.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                return nil, errors.New(r.Status)
        }</span>

        <span class="cov0" title="0">token, err := at.parseAuthResponse(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if token == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Now we need to get the creds so that we can do the signing next time
        <span class="cov0" title="0">for tries := 0; tries &lt; 2; tries++ </span><span class="cov0" title="0">{ // second try will use fresh serverAuthToken
                var req2 *http.Request
                req2, err = http.NewRequest("GET", at.authURL+"v3/credentials?type=ec2&amp;user_id="+token.User.ID, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">var serverAuthToken string
                serverAuthToken, err = at.serverAuth(ctx, proxyCtx, tries &gt; 0)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req2.Header.Set("X-Auth-Token", serverAuthToken)
                req2.Header.Set("Content-Type", "application/json")
                var r2 *http.Response
                r2, err = at.client.Do(req2)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">defer r2.Body.Close() // yes, defer in loop, but loop is just 2 iterations at most
                if r2.StatusCode == 401 </span><span class="cov0" title="0">{
                        err = errors.New("serverAuth was invalid, 401")
                        continue</span>
                }
                <span class="cov0" title="0">var s3creds *s3Blob
                s3creds, err = at.parseCredentialsResponse(r2, key)
                token.S3Creds = s3creds
                break</span>
        }

        <span class="cov0" title="0">return token, err</span>
}

// doValidate returns an error for any problems attempting the validation (i.e.
// the end user did nothing wrong); it will return nil, nil if the user's
// credentials could not be validated; or it will return the token, nil on
// successful validation.
func (at *authToken) doValidate(ctx context.Context, proxyCtx *ProxyContext, tken string) (*token, error) <span class="cov8" title="1">{
        if !strings.HasSuffix(at.authURL, "/") </span><span class="cov8" title="1">{
                at.authURL += "/"
        }</span>
        <span class="cov8" title="1">var tok *token
        var err error
        for tries := 0; tries &lt; 2; tries++ </span><span class="cov8" title="1">{ // second try will use fresh serverAuthToken
                var req *http.Request
                req, err = http.NewRequest("GET", at.authURL+"v3/auth/tokens?nocatalog", nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">var serverAuthToken string
                serverAuthToken, err = at.serverAuth(ctx, proxyCtx, tries &gt; 0)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">req.Header.Set("X-Auth-Token", serverAuthToken)
                req.Header.Set("X-Subject-Token", tken)
                req.Header.Set("User-Agent", at.userAgent)
                req = req.WithContext(ctx)
                var resp *http.Response
                resp, err = at.client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">defer resp.Body.Close() // yes, defer in loop, but loop is just 2 iterations at most
                if resp.StatusCode == 401 || resp.StatusCode == 403 </span><span class="cov0" title="0">{
                        err = fmt.Errorf("serverAuth was invalid, %d", resp.StatusCode)
                        continue</span>
                }
                <span class="cov8" title="1">if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">tok, err = at.parseAuthResponse(resp)
                break</span>
        }
        <span class="cov8" title="1">return tok, err</span>
}

// parseAuthResponse returns an error for any problems attempting the
// validation (i.e. the end user did nothing wrong); it will return nil, nil if
// the user's credentials could not be validated; or it will return the token,
// nil on successful validation.
func (at *authToken) parseAuthResponse(r *http.Response) (*token, error) <span class="cov8" title="1">{
        var resp identityResponse
        if err := json.NewDecoder(r.Body).Decode(&amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if e := resp.Error; e != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s : %s", r.Status, e.Message)
        }</span>
        <span class="cov8" title="1">if r.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s", r.Status)
        }</span>
        <span class="cov8" title="1">if resp.Token == nil </span><span class="cov0" title="0">{
                return nil, errors.New("Response didn't contain token context")
        }</span>
        <span class="cov8" title="1">if !resp.Token.Valid() </span><span class="cov8" title="1">{
                return nil, nil

        }</span>
        <span class="cov8" title="1">return resp.Token, nil</span>
}

func (at *authToken) parseCredentialsResponse(r *http.Response, key string) (*s3Blob, error) <span class="cov0" title="0">{
        var resp credentialsResponse
        if err := json.NewDecoder(r.Body).Decode(&amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Credentials) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("Response didn't contain credentials")
        }</span>
        <span class="cov0" title="0">var blob s3Blob
        for _, c := range resp.Credentials </span><span class="cov0" title="0">{
                if err := json.Unmarshal([]byte(c.Blob), &amp;blob); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if blob.Access == key </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return &amp;blob, nil</span>
}

// serverAuth return the X-Auth-Token to use or an error.
func (at *authToken) serverAuth(ctx context.Context, proxyCtx *ProxyContext, fresh bool) (string, error) <span class="cov8" title="1">{
        cacheKey := "Keystone:ServerAuth"
        var cachedServerAuth struct{ XSubjectToken string }
        if !fresh </span><span class="cov8" title="1">{
                if err := proxyCtx.Cache.GetStructured(ctx, cacheKey, &amp;cachedServerAuth); err == nil </span><span class="cov0" title="0">{
                        if cachedServerAuth.XSubjectToken != "" </span><span class="cov0" title="0">{
                                return cachedServerAuth.XSubjectToken, nil
                        }</span>
                }
        }
        <span class="cov8" title="1">authReq := &amp;identityReq{}
        authReq.Auth.Identity.Methods = []string{at.authPlugin}
        authReq.Auth.Identity.Password.User.Domain.ID = at.userDomainID
        authReq.Auth.Identity.Password.User.Name = at.userName
        authReq.Auth.Identity.Password.User.Password = at.password
        authReq.Auth.Scope.Project = &amp;project{Domain: &amp;domain{ID: at.projectDomainID}, Name: at.projectName}
        authReqBody, err := json.Marshal(authReq)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest("POST", at.authURL+"v3/auth/tokens", bytes.NewBuffer(authReqBody))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req = req.WithContext(ctx)
        resp, err := at.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        if resp.StatusCode != 201 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("server auth token request gave status %d", resp.StatusCode)
        }</span>
        <span class="cov8" title="1">cachedServerAuth.XSubjectToken = resp.Header.Get("X-Subject-Token")
        proxyCtx.Cache.Set(ctx, cacheKey, cachedServerAuth, int(at.cacheDur/time.Second))
        return cachedServerAuth.XSubjectToken, nil</span>
}

func removeAuthHeaders(r *http.Request) <span class="cov8" title="1">{
        for _, header := range authHeaders </span><span class="cov8" title="1">{
                r.Header.Del(header)
        }</span>
}

func NewAuthToken(section conf.Section, metricsScope tally.Scope) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                tokenCacheDur := time.Duration(int(section.GetInt("token_cache_time", 300))) * time.Second
                c := &amp;http.Client{
                        Timeout: 5 * time.Second,
                }
                authTokenMiddleware := &amp;authToken{
                        next:           next,
                        cacheDur:       tokenCacheDur,
                        preValidateDur: (tokenCacheDur / 10),
                        preValidations: make(map[string]bool),
                        identity: &amp;identity{authURL: section.GetDefault("auth_uri", "http://127.0.0.1:5000/"),
                                authPlugin:      section.GetDefault("auth_plugin", "password"),
                                projectDomainID: section.GetDefault("project_domain_id", "default"),
                                userDomainID:    section.GetDefault("user_domain_id", "default"),
                                projectName:     section.GetDefault("project_name", "service"),
                                userName:        section.GetDefault("username", "swift"),
                                password:        section.GetDefault("password", "password"),
                                userAgent:       section.GetDefault("user_agent", "hummingbird-keystone-middleware/1.0"),
                                client:          c},
                }
                if section.GetConfig().HasSection("tracing") </span><span class="cov0" title="0">{
                        clientTracer, _, err := tracing.Init("proxy-keystone-client", zap.NewNop(), section.GetConfig().GetSection("tracing"))
                        if err == nil </span><span class="cov0" title="0">{
                                enableHTTPTrace := section.GetConfig().GetBool("tracing", "enable_httptrace", true)
                                authTokenMiddleware.client, err = client.NewTracingClient(clientTracer, c, enableHTTPTrace)
                                if err != nil </span><span class="cov0" title="0">{ // In case of error revert to normal http client
                                        authTokenMiddleware.client = c
                                }</span>
                        }
                }
                <span class="cov0" title="0">return authTokenMiddleware</span>
        }, nil
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package middleware

import (
        "archive/tar"
        "bufio"
        "bytes"
        "compress/bzip2"
        "compress/gzip"
        "encoding/json"
        "encoding/xml"
        "fmt"
        "io"
        "net/http"
        "net/http/httptest"
        "net/url"
        "path"
        "strconv"
        "strings"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/uber-go/tally"
        "go.uber.org/zap"
)

func NewBulk(config conf.Section, metricsScope tally.Scope) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        yieldFrequency := time.Duration(time.Duration(config.GetInt("yield_frequency", 10)) * time.Second) // for yielding prepending whitespace to keep a client response alive
        maxContainersPerExtraction := int(config.GetInt("max_containers_per_extraction", 10000))
        maxFailedExtractions := int(config.GetInt("max_failed_extractions", 1000))
        maxDeletesPerRequest := int(config.GetInt("max_deletes_per_request", 10000))
        maxFailedDeletes := int(config.GetInt("max_failed_deletes", 1000))
        // TODO: We may implement these later:
        // delete_concurrency
        // delete_container_retry_count
        RegisterInfo("bulk_upload", map[string]interface{}{
                "max_containers_per_extraction": maxContainersPerExtraction,
                "max_failed_extractions":        maxFailedExtractions,
        })
        RegisterInfo("bulk_delete", map[string]interface{}{
                "max_deletes_per_request": maxDeletesPerRequest,
                "max_failed_deletes":      maxFailedDeletes,
        })
        return bulk(metricsScope, yieldFrequency, maxContainersPerExtraction, maxFailedExtractions, maxDeletesPerRequest, maxFailedDeletes), nil
}</span>

func bulk(metricsScope tally.Scope, yieldFrequency time.Duration, maxContainersPerExtraction, maxFailedExtractions, maxDeletesPerRequest, maxFailedDeletes int) func(next http.Handler) http.Handler <span class="cov0" title="0">{
        putRequestsMetric := metricsScope.Counter("bulk_put_requests")
        deleteRequestsMetric := metricsScope.Counter("bulk_delete_requests")
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                        switch request.Method </span>{
                        case "PUT":<span class="cov0" title="0">
                                var f func(r io.Reader, f func(name string, header http.Header, reader io.Reader)) error
                                switch request.URL.Query().Get("extract-archive") </span>{
                                case "tar":<span class="cov0" title="0">
                                        f = processBulkTar</span>
                                case "tar.gz":<span class="cov0" title="0">
                                        f = processBulkTarGz</span>
                                case "tar.bz2":<span class="cov0" title="0">
                                        f = processBulkTarBz2</span>
                                }
                                <span class="cov0" title="0">if f != nil </span><span class="cov0" title="0">{
                                        (&amp;bulkPut{
                                                next:                       next,
                                                requestsMetric:             putRequestsMetric,
                                                yieldFrequency:             yieldFrequency,
                                                maxContainersPerExtraction: maxContainersPerExtraction,
                                                maxFailedExtractions:       maxFailedExtractions,
                                                processBodyFunc:            f,
                                        }).ServeHTTP(writer, request)
                                        return
                                }</span>
                        case "DELETE", "POST":<span class="cov0" title="0">
                                if _, ok := request.URL.Query()["bulk-delete"]; ok </span><span class="cov0" title="0">{
                                        (&amp;bulkDelete{
                                                next:                 next,
                                                requestsMetric:       deleteRequestsMetric,
                                                yieldFrequency:       yieldFrequency,
                                                maxDeletesPerRequest: maxDeletesPerRequest,
                                                maxFailedDeletes:     maxFailedDeletes,
                                        }).ServeHTTP(writer, request)
                                        return
                                }</span>
                        default:</span><span class="cov0" title="0">
                        }
                        <span class="cov0" title="0">next.ServeHTTP(writer, request)</span>
                })
        }
}

type bulkPut struct {
        next                       http.Handler
        requestsMetric             tally.Counter
        yieldFrequency             time.Duration
        maxContainersPerExtraction int
        maxFailedExtractions       int
        processBodyFunc            func(r io.Reader, f func(name string, header http.Header, reader io.Reader)) error
}

func (b *bulkPut) ServeHTTP(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        contentType := request.Header.Get("Content-Type")
        if ok, _ := strconv.ParseBool(request.Header.Get("X-Detect-Content-Type")); ok </span><span class="cov0" title="0">{
                contentType = ""
        }</span>
        <span class="cov0" title="0">accept := request.Header.Get("Accept")
        outputType := "text"
        if strings.Contains(accept, "/json") </span><span class="cov0" title="0">{
                writer.Header().Set("Content-Type", "application/json; charset=utf-8")
                outputType = "json"
        }</span> else<span class="cov0" title="0"> if strings.Contains(accept, "/xml") </span><span class="cov0" title="0">{
                writer.Header().Set("Content-Type", "application/xml; charset=utf-8")
                outputType = "xml"
        }</span> else<span class="cov0" title="0"> {
                writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
        }</span>
        <span class="cov0" title="0">writer.Header().Set("Transfer-Encoding", "chunked")
        writer.WriteHeader(http.StatusOK)
        if outputType == "xml" </span><span class="cov0" title="0">{
                writer.Write([]byte(xml.Header))
        }</span>
        <span class="cov0" title="0">stopTheSpaces := make(chan struct{})
        hasEmittedSpaces := make(chan bool)
        go func() </span><span class="cov0" title="0">{
                spacesWereEmitted := false
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-time.After(b.yieldFrequency):<span class="cov0" title="0">
                                writer.Write([]byte("  "))
                                spacesWereEmitted = true</span>
                        case &lt;-stopTheSpaces:<span class="cov0" title="0">
                                hasEmittedSpaces &lt;- spacesWereEmitted
                                close(hasEmittedSpaces)
                                return</span>
                        }
                }
        }()
        <span class="cov0" title="0">ctx := GetProxyContext(request)
        numberFilesCreated := 0
        failures := [][]string{}
        failureResponseType := http.StatusBadRequest
        failureResponseBody := ""
        containerPuts := map[string]bool{}
        processItemFunc := func(name string, header http.Header, reader io.Reader) </span><span class="cov0" title="0">{
                if len(failures) &gt;= b.maxFailedExtractions || len(containerPuts) &gt; b.maxContainersPerExtraction </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">subpath := path.Join(request.URL.Path, name)
                apiRequest, account, container, object := getPathSegments(subpath)
                if object == "" </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">containerPath := "/" + path.Join(apiRequest, account, container)
                if !containerPuts[containerPath] </span><span class="cov0" title="0">{
                        containerPuts[containerPath] = true
                        if len(containerPuts) &gt; b.maxContainersPerExtraction </span><span class="cov0" title="0">{
                                failures = append(failures, []string{subpath, httpStatusString(http.StatusBadRequest)})
                                failureResponseType = http.StatusBadRequest
                                failureResponseBody = fmt.Sprintf("More than %d containers to create from tar.", b.maxContainersPerExtraction)
                                return
                        }</span>
                        // We continue no matter what because the future object PUT can
                        // still succeed, such as when the container PUTs aren't authorized
                        // but the container already exists.
                        <span class="cov0" title="0">subreq, err := ctx.newSubrequest("PUT", containerPath, reader, request, "bulkput")
                        if err != nil </span><span class="cov0" title="0">{
                                failures = append(failures, []string{containerPath, httpStatusString(http.StatusInternalServerError)})
                        }</span> else<span class="cov0" title="0"> {
                                subrec := httptest.NewRecorder()
                                ctx.serveHTTPSubrequest(subrec, subreq)
                                subresp := subrec.Result()
                                subresp.Body.Close()
                                if subresp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                                        failures = append(failures, []string{containerPath, httpStatusString(subresp.StatusCode)})
                                }</span>
                        }
                }
                <span class="cov0" title="0">subreq, err := ctx.newSubrequest("PUT", subpath, reader, request, "bulkput")
                if err != nil </span><span class="cov0" title="0">{
                        failures = append(failures, []string{subpath, httpStatusString(http.StatusInternalServerError)})
                        return
                }</span>
                <span class="cov0" title="0">if contentType != "" </span><span class="cov0" title="0">{
                        subreq.Header.Set("Content-Type", contentType)
                }</span>
                // We just do Set as none of hummingbird supports multi-value headers.
                <span class="cov0" title="0">for k := range header </span><span class="cov0" title="0">{
                        subreq.Header.Set(k, header.Get(k))
                }</span>
                <span class="cov0" title="0">subrec := httptest.NewRecorder()
                ctx.serveHTTPSubrequest(subrec, subreq)
                subresp := subrec.Result()
                subresp.Body.Close()
                if subresp.StatusCode/100 == 5 </span><span class="cov0" title="0">{
                        failures = append(failures, []string{subpath, httpStatusString(subresp.StatusCode)})
                        failureResponseType = http.StatusBadGateway
                        return
                }</span> else<span class="cov0" title="0"> if subresp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                        failures = append(failures, []string{subpath, httpStatusString(subresp.StatusCode)})
                        return
                }</span>
                <span class="cov0" title="0">numberFilesCreated++</span>
        }
        <span class="cov0" title="0">responseStatus := http.StatusCreated
        responseBody := ""
        if err := b.processBodyFunc(request.Body, processItemFunc); err != nil </span><span class="cov0" title="0">{
                responseStatus = http.StatusBadGateway
                responseBody = fmt.Sprintf("Invalid Tar File: %s", err)
        }</span> else<span class="cov0" title="0"> if len(failures) &gt; 0 </span><span class="cov0" title="0">{
                responseStatus = failureResponseType
                responseBody = failureResponseBody
        }</span> else<span class="cov0" title="0"> if numberFilesCreated &lt; 1 </span><span class="cov0" title="0">{
                responseStatus = http.StatusBadRequest
                responseBody = "Invalid Tar File: No Valid Files"
        }</span>
        <span class="cov0" title="0">close(stopTheSpaces)
        if &lt;-hasEmittedSpaces </span><span class="cov0" title="0">{
                // Not sure why, but the Swift code uses \r\n here and \n everywhere else.
                writer.Write([]byte("\r\n\r\n"))
        }</span>
        <span class="cov0" title="0">switch outputType </span>{
        case "json":<span class="cov0" title="0">
                type js struct {
                        ResponseStatus     string `json:"Response Status"`
                        ResponseBody       string `json:"Response Body"`
                        NumberFilesCreated int    `json:"Number Files Created"`
                        Errors             [][]string
                }
                j := &amp;js{
                        ResponseStatus:     fmt.Sprintf("%d %s", responseStatus, http.StatusText(responseStatus)),
                        ResponseBody:       responseBody,
                        NumberFilesCreated: numberFilesCreated,
                        Errors:             [][]string{},
                }
                j.Errors = failures
                b, err := json.Marshal(j)
                if err != nil </span><span class="cov0" title="0">{
                        ctx.Logger.Error("JSON encoding error: %s\n%#v\n", zap.Any("j", j), zap.Error(err))
                        b = []byte("There was an internal server error generating JSON.")
                }</span>
                <span class="cov0" title="0">writer.Write(b)
                writer.Write([]byte("\n"))</span>
        case "xml":<span class="cov0" title="0">
                type errorObject struct {
                        Name   string `xml:"name"`
                        Status string `xml:"status"`
                }
                type replaceNameWithDeleteLowercase struct {
                        ResponseStatus     string `xml:"response_status"`
                        ResponseBody       string `xml:"response_body"`
                        NumberFilesCreated int    `xml:"number_files_created"`
                        Error              struct {
                                Object []*errorObject `xml:"object"`
                        } `xml:"errors"`
                }
                x := &amp;replaceNameWithDeleteLowercase{}
                x.ResponseStatus = fmt.Sprintf("%d %s", responseStatus, http.StatusText(responseStatus))
                x.ResponseBody = responseBody
                x.NumberFilesCreated = numberFilesCreated
                for _, failure := range failures </span><span class="cov0" title="0">{
                        x.Error.Object = append(x.Error.Object, &amp;errorObject{failure[0], failure[1]})
                }</span>
                <span class="cov0" title="0">b, err := xml.Marshal(x)
                if err != nil </span><span class="cov0" title="0">{
                        ctx.Logger.Error("XML encoding error: %s\n%#v\n", zap.Any("x", x), zap.Error(err))
                        b = []byte("There was an internal server error generating XML.")
                }</span>
                // Yes, even the PUTs are labeled &lt;delete&gt; in the XML from Swift's code.
                <span class="cov0" title="0">b = bytes.Replace(b, []byte("replaceNameWithDeleteLowercase"), []byte("delete"), -1)
                writer.Write(b)
                writer.Write([]byte("\n"))</span>
        default:<span class="cov0" title="0">
                writer.Write([]byte(fmt.Sprintf("Response Status: %d %s\n", responseStatus, http.StatusText(responseStatus))))
                writer.Write([]byte(fmt.Sprintf("Response Body: %s\n", responseBody)))
                writer.Write([]byte(fmt.Sprintf("Number Files Created: %d\n", numberFilesCreated)))
                writer.Write([]byte("Errors:\n"))
                for _, failure := range failures </span><span class="cov0" title="0">{
                        writer.Write([]byte(fmt.Sprintf("%s, %s\n", failure[0], failure[1])))
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

type bulkDelete struct {
        next                 http.Handler
        requestsMetric       tally.Counter
        yieldFrequency       time.Duration
        maxDeletesPerRequest int
        maxFailedDeletes     int
}

func (b *bulkDelete) ServeHTTP(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        accept := request.Header.Get("Accept")
        outputType := "text"
        if strings.Contains(accept, "/json") </span><span class="cov0" title="0">{
                writer.Header().Set("Content-Type", "application/json; charset=utf-8")
                outputType = "json"
        }</span> else<span class="cov0" title="0"> if strings.Contains(accept, "/xml") </span><span class="cov0" title="0">{
                writer.Header().Set("Content-Type", "application/xml; charset=utf-8")
                outputType = "xml"
        }</span> else<span class="cov0" title="0"> {
                writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
        }</span>
        <span class="cov0" title="0">writer.Header().Set("Transfer-Encoding", "chunked")
        writer.WriteHeader(http.StatusOK)
        if outputType == "xml" </span><span class="cov0" title="0">{
                writer.Write([]byte(xml.Header))
        }</span>
        <span class="cov0" title="0">stopTheSpaces := make(chan struct{})
        hasEmittedSpaces := make(chan bool)
        go func() </span><span class="cov0" title="0">{
                spacesWereEmitted := false
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-time.After(b.yieldFrequency):<span class="cov0" title="0">
                                writer.Write([]byte("  "))
                                spacesWereEmitted = true</span>
                        case &lt;-stopTheSpaces:<span class="cov0" title="0">
                                hasEmittedSpaces &lt;- spacesWereEmitted
                                close(hasEmittedSpaces)
                                return</span>
                        }
                }
        }()
        <span class="cov0" title="0">ctx := GetProxyContext(request)
        apiReq, account, _, _ := getPathSegments(request.URL.Path)
        numberDeleted := 0
        numberNotFound := 0
        failures := [][]string{}
        failureResponseType := http.StatusBadRequest
        failureResponseBody := ""
        containersToDelete := []string{}
        scanner := bufio.NewScanner(request.Body)
        // "/c/o\n" *3 because everything could be url-encoded excepting the newline
        maxLineLength := (common.MAX_CONTAINER_NAME_LENGTH+common.MAX_OBJECT_NAME_LENGTH+2)*3 + 1
        scanner.Buffer(make([]byte, maxLineLength), maxLineLength)
        for scanner.Scan() </span><span class="cov0" title="0">{
                if numberDeleted+numberNotFound+len(failures) &gt; b.maxDeletesPerRequest </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if len(failures) &gt; b.maxFailedDeletes </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">subpath := scanner.Text()
                u, err := url.Parse(subpath)
                if err != nil </span><span class="cov0" title="0">{
                        failures = append(failures, []string{subpath, httpStatusString(http.StatusBadRequest)})
                        continue</span>
                }
                <span class="cov0" title="0">subpath = u.Path
                subpath = strings.TrimPrefix(subpath, "/")
                parts := strings.SplitN(subpath, "/", 2)
                switch len(parts) </span>{
                case 0:<span class="cov0" title="0">
                        failures = append(failures, []string{subpath, httpStatusString(http.StatusBadRequest)})
                        continue</span>
                case 1:<span class="cov0" title="0">
                        containersToDelete = append(containersToDelete, parts[0])
                        continue</span>
                }
                <span class="cov0" title="0">subreq, err := ctx.newSubrequest("DELETE", "/"+path.Join(apiReq, account, subpath), nil, request, "bulkdelete")
                if err != nil </span><span class="cov0" title="0">{
                        failures = append(failures, []string{subpath, httpStatusString(http.StatusInternalServerError)})
                        return
                }</span>
                <span class="cov0" title="0">subrec := httptest.NewRecorder()
                ctx.serveHTTPSubrequest(subrec, subreq)
                subresp := subrec.Result()
                subresp.Body.Close()
                if subresp.StatusCode/100 == 5 </span><span class="cov0" title="0">{
                        failures = append(failures, []string{subpath, httpStatusString(subresp.StatusCode)})
                        failureResponseType = http.StatusBadGateway
                }</span> else<span class="cov0" title="0"> if subresp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                        numberNotFound++
                }</span> else<span class="cov0" title="0"> if subresp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                        failures = append(failures, []string{subpath, httpStatusString(subresp.StatusCode)})
                }</span> else<span class="cov0" title="0"> {
                        numberDeleted++
                }</span>
        }
        <span class="cov0" title="0">for _, container := range containersToDelete </span><span class="cov0" title="0">{
                if numberDeleted+numberNotFound+len(failures) &gt; b.maxDeletesPerRequest </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if len(failures) &gt; b.maxFailedDeletes </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">subpath := "/" + container
                subreq, err := ctx.newSubrequest("DELETE", "/"+path.Join(apiReq, account, subpath), nil, request, "bulkdelete")
                if err != nil </span><span class="cov0" title="0">{
                        failures = append(failures, []string{subpath, httpStatusString(http.StatusInternalServerError)})
                        return
                }</span>
                <span class="cov0" title="0">subrec := httptest.NewRecorder()
                ctx.serveHTTPSubrequest(subrec, subreq)
                subresp := subrec.Result()
                subresp.Body.Close()
                if subresp.StatusCode/100 == 5 </span><span class="cov0" title="0">{
                        failures = append(failures, []string{subpath, httpStatusString(subresp.StatusCode)})
                        failureResponseType = http.StatusBadGateway
                }</span> else<span class="cov0" title="0"> if subresp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                        numberNotFound++
                }</span> else<span class="cov0" title="0"> if subresp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                        failures = append(failures, []string{subpath, httpStatusString(subresp.StatusCode)})
                }</span> else<span class="cov0" title="0"> {
                        numberDeleted++
                }</span>
        }
        <span class="cov0" title="0">responseStatus := http.StatusOK
        responseBody := ""
        if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                responseStatus = http.StatusBadGateway
                responseBody = fmt.Sprintf("Invalid bulk delete: %s", err)
        }</span> else<span class="cov0" title="0"> if len(failures) &gt; 0 </span><span class="cov0" title="0">{
                responseStatus = failureResponseType
                responseBody = failureResponseBody
        }</span> else<span class="cov0" title="0"> if numberDeleted &lt; 1 &amp;&amp; numberNotFound &lt; 1 </span><span class="cov0" title="0">{
                responseStatus = http.StatusBadRequest
                responseBody = "Invalid bulk delete."
        }</span> else<span class="cov0" title="0"> if numberDeleted+numberNotFound+len(failures) &gt; b.maxDeletesPerRequest </span><span class="cov0" title="0">{
                responseStatus = http.StatusRequestEntityTooLarge
                responseBody = fmt.Sprintf("Maximum Bulk Deletes: %d per request", b.maxDeletesPerRequest)
        }</span>
        <span class="cov0" title="0">close(stopTheSpaces)
        if &lt;-hasEmittedSpaces </span><span class="cov0" title="0">{
                // Not sure why, but the Swift code uses \r\n here and \n everywhere else.
                writer.Write([]byte("\r\n\r\n"))
        }</span>
        <span class="cov0" title="0">switch outputType </span>{
        case "json":<span class="cov0" title="0">
                type js struct {
                        ResponseStatus string `json:"Response Status"`
                        ResponseBody   string `json:"Response Body"`
                        NumberDeleted  int    `json:"Number Deleted"`
                        NumberNotFound int    `json:"Number Not Found"`
                        Errors         [][]string
                }
                j := &amp;js{
                        ResponseStatus: fmt.Sprintf("%d %s", responseStatus, http.StatusText(responseStatus)),
                        ResponseBody:   responseBody,
                        NumberDeleted:  numberDeleted,
                        NumberNotFound: numberNotFound,
                        Errors:         [][]string{},
                }
                j.Errors = failures
                b, err := json.Marshal(j)
                if err != nil </span><span class="cov0" title="0">{
                        writer.Write([]byte(fmt.Sprintf("JSON encoding error: %s\n%#v\n", err, j)))
                }</span>
                <span class="cov0" title="0">writer.Write(b)
                writer.Write([]byte("\n"))</span>
        case "xml":<span class="cov0" title="0">
                type errorObject struct {
                        Name   string `xml:"name"`
                        Status string `xml:"status"`
                }
                type replaceNameWithDeleteLowercase struct {
                        ResponseStatus string `xml:"response_status"`
                        ResponseBody   string `xml:"response_body"`
                        NumberDeleted  int    `xml:"number_deleted"`
                        NumberNotFound int    `xml:"number_not_found"`
                        Error          struct {
                                Object []*errorObject `xml:"object"`
                        } `xml:"errors"`
                }
                x := &amp;replaceNameWithDeleteLowercase{}
                x.ResponseStatus = fmt.Sprintf("%d %s", responseStatus, http.StatusText(responseStatus))
                x.ResponseBody = responseBody
                x.NumberDeleted = numberDeleted
                x.NumberNotFound = numberNotFound
                for _, failure := range failures </span><span class="cov0" title="0">{
                        x.Error.Object = append(x.Error.Object, &amp;errorObject{failure[0], failure[1]})
                }</span>
                <span class="cov0" title="0">b, err := xml.Marshal(x)
                if err != nil </span><span class="cov0" title="0">{
                        writer.Write([]byte(fmt.Sprintf("XML encoding error: %s\n%#v\n", err, x)))
                }</span>
                <span class="cov0" title="0">b = bytes.Replace(b, []byte("replaceNameWithDeleteLowercase"), []byte("delete"), -1)
                writer.Write(b)
                writer.Write([]byte("\n"))</span>
        default:<span class="cov0" title="0">
                writer.Write([]byte(fmt.Sprintf("Response Status: %d %s\n", responseStatus, http.StatusText(responseStatus))))
                writer.Write([]byte(fmt.Sprintf("Response Body: %s\n", responseBody)))
                writer.Write([]byte(fmt.Sprintf("Number Deleted: %d\n", numberDeleted)))
                writer.Write([]byte(fmt.Sprintf("Number Not Found: %d\n", numberNotFound)))
                writer.Write([]byte("Errors:\n"))
                for _, failure := range failures </span><span class="cov0" title="0">{
                        writer.Write([]byte(fmt.Sprintf("%s, %s\n", failure[0], failure[1])))
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func processBulkTar(r io.Reader, f func(name string, header http.Header, reader io.Reader)) error <span class="cov8" title="1">{
        t := tar.NewReader(r)
        for </span><span class="cov8" title="1">{
                h, err := t.Next()
                if err == io.EOF </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if h.Typeflag != tar.TypeReg &amp;&amp; h.Typeflag != tar.TypeRegA </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if len(h.Name) == 0 || h.Name[len(h.Name)-1] == '/' </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">header := http.Header{}
                for k, v := range h.Xattrs </span><span class="cov8" title="1">{
                        if k == "user.mime_type" </span><span class="cov8" title="1">{
                                header.Set("Content-Type", v)
                        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(k, "user.meta.") </span><span class="cov8" title="1">{
                                header.Set("X-Object-Meta-"+strings.Title(strings.Replace(k[len("user.meta."):], ".", "-", -1)), v)
                        }</span>
                }
                <span class="cov8" title="1">header.Set("Content-Length", strconv.FormatInt(h.Size, 10))
                n := h.Name
                if strings.HasPrefix(n, "./") </span><span class="cov8" title="1">{
                        n = n[len("./"):]
                }</span>
                <span class="cov8" title="1">f(n, header, t)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func processBulkTarGz(r io.Reader, f func(name string, header http.Header, reader io.Reader)) error <span class="cov8" title="1">{
        g, err := gzip.NewReader(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return processBulkTar(g, f)</span>
}

func processBulkTarBz2(r io.Reader, f func(name string, header http.Header, reader io.Reader)) error <span class="cov8" title="1">{
        return processBulkTar(bzip2.NewReader(r), f)
}</span>

func httpStatusString(status int) string <span class="cov0" title="0">{
        return fmt.Sprintf("%d %s", status, http.StatusText(status))
}</span>
</pre>
		
		<pre class="file" id="file86" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "net/http"

        "go.uber.org/zap"

        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/uber-go/tally"
)

func Recover(w http.ResponseWriter, r *http.Request, msg string, recoversMetric tally.Counter) <span class="cov0" title="0">{
        if err := recover(); err != nil </span><span class="cov0" title="0">{
                transactionId := r.Header.Get("X-Trans-Id")
                if ctx := GetProxyContext(r); ctx != nil </span><span class="cov0" title="0">{
                        ctx.Logger.Error(msg, zap.Any("err", err), zap.String("txn", transactionId))
                        recoversMetric.Inc(1)
                        // if we haven't set a status code yet, we can send a 500 response.
                        if started, _ := ctx.Response(); started.IsZero() </span><span class="cov0" title="0">{
                                srv.StandardResponse(w, http.StatusInternalServerError)
                        }</span>
                }
        }
}

func NewCatchError(config conf.Section, metricsScope tally.Scope) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        recoversMetric := metricsScope.Counter("recovers")
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(
                        func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                                defer Recover(w, r, "PANIC", recoversMetric)
                                next.ServeHTTP(w, r)
                        }</span>,
                )
        }, nil
}
</pre>
		
		<pre class="file" id="file87" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "net/http"
        "strconv"

        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"

        "github.com/uber-go/tally"
)

func containerQuota(metric tally.Counter) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                        ctx := GetProxyContext(request)
                        _, account, container, obj := getPathParts(request)
                        if container == "" </span><span class="cov0" title="0">{
                                next.ServeHTTP(writer, request)
                                return
                        }</span>

                        <span class="cov8" title="1">if obj == "" &amp;&amp; (request.Method == "PUT" || request.Method == "POST") </span><span class="cov8" title="1">{
                                qBytes := request.Header.Get("X-Container-Meta-Quota-Bytes")
                                if qBytes != "" </span><span class="cov8" title="1">{
                                        if _, err := strconv.ParseInt(qBytes, 10, 64); err != nil </span><span class="cov8" title="1">{
                                                srv.SimpleErrorResponse(writer, http.StatusBadRequest, "Invalid bytes quota.")
                                                return
                                        }</span>
                                }
                                <span class="cov8" title="1">qCount := request.Header.Get("X-Container-Meta-Quota-Count")
                                if qCount != "" </span><span class="cov8" title="1">{
                                        if _, err := strconv.ParseInt(qCount, 10, 64); err != nil </span><span class="cov8" title="1">{
                                                srv.SimpleErrorResponse(writer, http.StatusBadRequest, "Invalid count quota.")
                                                return
                                        }</span>
                                }
                        } else<span class="cov8" title="1"> if obj != "" &amp;&amp; request.Method == "PUT" </span><span class="cov8" title="1">{
                                ci, err := ctx.C.GetContainerInfo(request.Context(), account, container)
                                if err != nil </span><span class="cov0" title="0">{
                                        next.ServeHTTP(writer, request)
                                        return
                                }</span>
                                <span class="cov8" title="1">qBytes := ci.Metadata["Quota-Bytes"]
                                if qBytes != "" </span><span class="cov8" title="1">{
                                        if quota, err := strconv.ParseInt(qBytes, 10, 64); err == nil </span><span class="cov8" title="1">{
                                                newSize := ci.ObjectBytes + request.ContentLength
                                                if quota &lt; newSize </span><span class="cov8" title="1">{
                                                        srv.SimpleErrorResponse(writer, http.StatusRequestEntityTooLarge, "Upload exceeds quota.")
                                                        return
                                                }</span>
                                        }
                                }
                                <span class="cov8" title="1">qCount := ci.Metadata["Quota-Count"]
                                if qCount != "" </span><span class="cov8" title="1">{
                                        if quota, err := strconv.ParseInt(qCount, 10, 64); err == nil </span><span class="cov8" title="1">{
                                                newCount := ci.ObjectCount + 1
                                                if quota &lt; newCount </span><span class="cov8" title="1">{
                                                        srv.SimpleErrorResponse(writer, http.StatusRequestEntityTooLarge, "Upload exceeds quota.")
                                                        return
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">next.ServeHTTP(writer, request)</span>
                })
        }
}

func NewContainerQuota(config conf.Section, metricsScope tally.Scope) (func(http.Handler) http.Handler, error) <span class="cov8" title="1">{
        RegisterInfo("container_quotas", map[string]interface{}{})
        return containerQuota(metricsScope.Counter("container_quotas")), nil
}</span>
</pre>
		
		<pre class="file" id="file88" style="display: none">//  Copyright (c) 2015-2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "runtime/debug"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/troubling/hummingbird/client"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
        "go.uber.org/zap"
)

var (
        serverInfo     = make(map[string]interface{})
        sil            sync.Mutex
        excludeHeaders = []string{
                "X-Account-Sysmeta-",
                "X-Container-Sysmeta-",
                "X-Object-Sysmeta-",
                "X-Object-Transient-Sysmeta-",
                "X-Backend-",
        }
)

func RegisterInfo(name string, data interface{}) <span class="cov8" title="1">{
        sil.Lock()
        defer sil.Unlock()
        serverInfo[name] = data
}</span>

func serverInfoDump() ([]byte, error) <span class="cov0" title="0">{
        sil.Lock()
        defer sil.Unlock()
        data, err := json.Marshal(serverInfo)
        return data, err
}</span>

// Used to capture response from a subrequest
type captureWriter struct {
        status int
        body   []byte
        header http.Header
}

func (x *captureWriter) Header() http.Header    <span class="cov8" title="1">{ return x.header }</span>
func (x *captureWriter) WriteHeader(status int) <span class="cov8" title="1">{ x.status = status }</span>
func (x *captureWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        x.body = append(x.body, b...)
        return len(b), nil
}</span>

func NewCaptureWriter() *captureWriter <span class="cov8" title="1">{
        return &amp;captureWriter{header: make(http.Header)}
}</span>

type AccountInfo struct {
        ContainerCount int64
        ObjectCount    int64
        ObjectBytes    int64
        Metadata       map[string]string
        SysMetadata    map[string]string
        StatusCode     int `json:"status"`
}

type AuthorizeFunc func(r *http.Request) (bool, int)
type subrequestCopy func(dst, src *http.Request)

type ProxyContextMiddleware struct {
        next               http.Handler
        log                srv.LowLevelLogger
        Cache              ring.MemcacheRing
        proxyClientFactory client.ProxyClient
        debugResponses     bool
}

type ProxyContext struct {
        *ProxyContextMiddleware
        C                client.RequestClient
        Authorize        AuthorizeFunc
        RemoteUsers      []string
        StorageOwner     bool
        ResellerRequest  bool
        ACL              string
        subrequestCopy   subrequestCopy
        Logger           *zap.Logger
        TxId             string
        responseSent     time.Time
        status           int
        accountInfoCache map[string]*AccountInfo
        depth            int
        Source           string
        S3Auth           *S3AuthInfo
}

func GetProxyContext(r *http.Request) *ProxyContext <span class="cov8" title="1">{
        if rv := r.Context().Value("proxycontext"); rv != nil </span><span class="cov8" title="1">{
                return rv.(*ProxyContext)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (ctx *ProxyContext) Response() (time.Time, int) <span class="cov0" title="0">{
        return ctx.responseSent, ctx.status
}</span>

func (ctx *ProxyContext) addSubrequestCopy(f subrequestCopy) <span class="cov0" title="0">{
        if ctx.subrequestCopy == nil </span><span class="cov0" title="0">{
                ctx.subrequestCopy = f
                return
        }</span>
        <span class="cov0" title="0">ca := ctx.subrequestCopy
        ctx.subrequestCopy = func(dst, src *http.Request) </span><span class="cov0" title="0">{
                ca(dst, src)
                f(dst, src)
        }</span>
}

func getPathParts(request *http.Request) (bool, string, string, string) <span class="cov8" title="1">{
        apiRequest, account, container, object := getPathSegments(request.URL.Path)
        return apiRequest == "v1", account, container, object
}</span>

func getPathSegments(requestPath string) (string, string, string, string) <span class="cov8" title="1">{
        parts := strings.SplitN(requestPath, "/", 5)
        switch len(parts) </span>{
        case 5:<span class="cov8" title="1">
                return parts[1], parts[2], parts[3], parts[4]</span>
        case 4:<span class="cov8" title="1">
                return parts[1], parts[2], parts[3], ""</span>
        case 3:<span class="cov8" title="1">
                return parts[1], parts[2], "", ""</span>
        case 2:<span class="cov0" title="0">
                return parts[1], "", "", ""</span>
        default:<span class="cov0" title="0">
                return "", "", "", ""</span>
        }
}

func (pc *ProxyContext) GetAccountInfo(ctx context.Context, account string) (*AccountInfo, error) <span class="cov8" title="1">{
        key := fmt.Sprintf("account/%s", account)
        ai := pc.accountInfoCache[key]
        if ai == nil </span><span class="cov0" title="0">{
                if err := pc.Cache.GetStructured(ctx, key, &amp;ai); err != nil </span><span class="cov0" title="0">{
                        ai = nil
                }</span>
        }
        <span class="cov8" title="1">if ai != nil &amp;&amp; ai.StatusCode != 0 &amp;&amp; ai.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%d error retrieving info for account %s", ai.StatusCode, account)
        }</span>
        <span class="cov8" title="1">if ai == nil </span><span class="cov0" title="0">{
                resp := pc.C.HeadAccount(ctx, account, nil)
                resp.Body.Close()
                if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                        pc.Cache.Set(ctx, key, &amp;AccountInfo{StatusCode: resp.StatusCode}, 30)
                        return nil, fmt.Errorf("%d error retrieving info for account %s", resp.StatusCode, account)
                }</span>
                <span class="cov0" title="0">ai = &amp;AccountInfo{
                        Metadata:    make(map[string]string),
                        SysMetadata: make(map[string]string),
                        StatusCode:  resp.StatusCode,
                }
                var err error
                if ai.ContainerCount, err = strconv.ParseInt(resp.Header.Get("X-Account-Container-Count"), 10, 64); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Error retrieving info for account %s : %s", account, err)
                }</span>
                <span class="cov0" title="0">if ai.ObjectCount, err = strconv.ParseInt(resp.Header.Get("X-Account-Object-Count"), 10, 64); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Error retrieving info for account %s : %s", account, err)
                }</span>
                <span class="cov0" title="0">if ai.ObjectBytes, err = strconv.ParseInt(resp.Header.Get("X-Account-Bytes-Used"), 10, 64); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Error retrieving info for account %s : %s", account, err)
                }</span>
                <span class="cov0" title="0">for k := range resp.Header </span><span class="cov0" title="0">{
                        if strings.HasPrefix(k, "X-Account-Meta-") </span><span class="cov0" title="0">{
                                ai.Metadata[k[15:]] = resp.Header.Get(k)
                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(k, "X-Account-Sysmeta-") </span><span class="cov0" title="0">{
                                ai.SysMetadata[k[18:]] = resp.Header.Get(k)
                        }</span>
                }
                <span class="cov0" title="0">pc.Cache.Set(ctx, key, ai, 30)</span>
        }
        <span class="cov8" title="1">return ai, nil</span>
}

func (pc *ProxyContext) InvalidateAccountInfo(ctx context.Context, account string) <span class="cov0" title="0">{
        key := fmt.Sprintf("account/%s", account)
        delete(pc.accountInfoCache, key)
        pc.Cache.Delete(ctx, key)
}</span>

func (pc *ProxyContext) AutoCreateAccount(ctx context.Context, account string, headers http.Header) <span class="cov0" title="0">{
        h := http.Header{"X-Timestamp": []string{common.GetTimestamp()},
                "X-Trans-Id": []string{pc.TxId}}
        for key := range headers </span><span class="cov0" title="0">{
                if strings.HasPrefix(key, "X-Account-Sysmeta-") </span><span class="cov0" title="0">{
                        h[key] = []string{headers.Get(key)}
                }</span>
        }
        <span class="cov0" title="0">resp := pc.C.PutAccount(ctx, account, h)
        if resp.StatusCode/100 == 2 </span><span class="cov0" title="0">{
                pc.InvalidateAccountInfo(ctx, account)
        }</span>
}

func (pc *ProxyContext) newSubrequest(method, urlStr string, body io.Reader, req *http.Request, source string) (*http.Request, error) <span class="cov8" title="1">{
        if source == "" </span><span class="cov0" title="0">{
                panic("Programmer error: You must supply the source with newSubrequest. If you want the subrequest to be treated a user request (billing, quotas, etc.) you can set the source to \"-\"")</span>
        }
        <span class="cov8" title="1">if source == "-" </span><span class="cov0" title="0">{
                source = ""
        }</span>
        <span class="cov8" title="1">subreq, err := http.NewRequest(method, urlStr, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">subctx := &amp;ProxyContext{
                ProxyContextMiddleware: pc.ProxyContextMiddleware,
                Authorize:              pc.Authorize,
                RemoteUsers:            pc.RemoteUsers,
                subrequestCopy:         pc.subrequestCopy,
                Logger:                 pc.Logger.With(zap.String("src", source)),
                C:                      pc.C,
                TxId:                   pc.TxId,
                accountInfoCache:       pc.accountInfoCache,
                status:                 500,
                depth:                  pc.depth + 1,
                Source:                 source,
                S3Auth:                 pc.S3Auth,
        }
        subreq = subreq.WithContext(context.WithValue(req.Context(), "proxycontext", subctx))
        if subctx.subrequestCopy != nil </span><span class="cov0" title="0">{
                subctx.subrequestCopy(subreq, req)
        }</span>
        <span class="cov8" title="1">if v := req.Header.Get("Referer"); v != "" </span><span class="cov0" title="0">{
                subreq.Header.Set("Referer", v)
        }</span>
        <span class="cov8" title="1">subreq.Header.Set("X-Trans-Id", subctx.TxId)
        subreq.Header.Set("X-Timestamp", common.GetTimestamp())
        return subreq, nil</span>
}

func (pc *ProxyContext) serveHTTPSubrequest(writer http.ResponseWriter, subreq *http.Request) <span class="cov8" title="1">{
        subctx := GetProxyContext(subreq)
        // TODO: check subctx.depth
        subwriter := srv.NewCustomWriter(writer, func(w http.ResponseWriter, status int) int </span><span class="cov8" title="1">{
                subctx.responseSent = time.Now()
                subctx.status = status
                return status
        }</span>)
        <span class="cov8" title="1">subwriter.Header().Set("X-Trans-Id", subctx.TxId)
        pc.next.ServeHTTP(subwriter, subreq)</span>
}

func (m *ProxyContextMiddleware) ServeHTTP(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        if !srv.ValidateRequest(writer, request) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if request.URL.Path == "/info" </span><span class="cov0" title="0">{
                if request.URL.Query().Get("swiftinfo_sig") != "" || request.URL.Query().Get("swiftinfo_expires") != "" </span><span class="cov0" title="0">{
                        writer.WriteHeader(403)
                        return
                }</span>
                <span class="cov0" title="0">if request.Method == "GET" </span><span class="cov0" title="0">{
                        if data, err := serverInfoDump(); err != nil </span><span class="cov0" title="0">{
                                srv.StandardResponse(writer, 500)
                        }</span> else<span class="cov0" title="0"> {
                                writer.Header().Set("Content-Type", "application/json; charset=UTF-8")
                                writer.WriteHeader(200)
                                writer.Write(data)
                        }</span>
                        <span class="cov0" title="0">return</span>
                } else<span class="cov0" title="0"> if request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        writer.Header().Set("Allow", "HEAD, GET, OPTIONS")
                        writer.WriteHeader(200)
                        return
                }</span> else<span class="cov0" title="0"> if request.Method == "HEAD" </span><span class="cov0" title="0">{
                        if _, err := serverInfoDump(); err != nil </span><span class="cov0" title="0">{
                                srv.StandardResponse(writer, 500)
                        }</span> else<span class="cov0" title="0"> {
                                writer.WriteHeader(200)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
        }

        <span class="cov0" title="0">for k := range request.Header </span><span class="cov0" title="0">{
                for _, ex := range excludeHeaders </span><span class="cov0" title="0">{
                        if strings.HasPrefix(k, ex) || k == "X-Timestamp" </span><span class="cov0" title="0">{
                                delete(request.Header, k)
                        }</span>
                }
        }

        <span class="cov0" title="0">transId := common.GetTransactionId()
        request.Header.Set("X-Trans-Id", transId)
        writer.Header().Set("X-Trans-Id", transId)
        writer.Header().Set("X-Openstack-Request-Id", transId)
        request.Header.Set("X-Timestamp", common.GetTimestamp())
        logr := m.log.With(zap.String("txn", transId))
        pc := &amp;ProxyContext{
                ProxyContextMiddleware: m,
                Authorize:              nil,
                Logger:                 logr,
                TxId:                   transId,
                status:                 500,
                accountInfoCache:       make(map[string]*AccountInfo),
                C:                      m.proxyClientFactory.NewRequestClient(m.Cache, make(map[string]*client.ContainerInfo), logr),
        }
        // we'll almost certainly need the AccountInfo and ContainerInfo for the current path, so pre-fetch them in parallel.
        apiRequest, account, container, _ := getPathParts(request)
        if apiRequest &amp;&amp; account != "" </span><span class="cov0" title="0">{
                wg := &amp;sync.WaitGroup{}
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        pc.GetAccountInfo(request.Context(), account)
                }</span>()
                <span class="cov0" title="0">if container != "" </span><span class="cov0" title="0">{
                        wg.Add(1)
                        go func() </span><span class="cov0" title="0">{
                                defer wg.Done()
                                pc.C.GetContainerInfo(request.Context(), account, container)
                        }</span>()
                }
                <span class="cov0" title="0">wg.Wait()</span>
        }
        <span class="cov0" title="0">newWriter := srv.NewCustomWriter(writer, func(w http.ResponseWriter, status int) int </span><span class="cov0" title="0">{
                // strip out any bad headers before calling real WriteHeader
                for k := range w.Header() </span><span class="cov0" title="0">{
                        if k == "X-Account-Sysmeta-Project-Domain-Id" </span><span class="cov0" title="0">{
                                w.Header().Set("X-Account-Project-Domain-Id", w.Header().Get(k))
                        }</span>
                        <span class="cov0" title="0">for _, ex := range excludeHeaders </span><span class="cov0" title="0">{
                                if strings.HasPrefix(k, ex) </span><span class="cov0" title="0">{
                                        delete(w.Header(), k)
                                }</span>
                        }
                }
                <span class="cov0" title="0">if status == http.StatusUnauthorized &amp;&amp; w.Header().Get("Www-Authenticate") == "" </span><span class="cov0" title="0">{
                        if account != "" </span><span class="cov0" title="0">{
                                w.Header().Set("Www-Authenticate", fmt.Sprintf("Swift realm=\"%s\"", common.Urlencode(account)))
                        }</span> else<span class="cov0" title="0"> {
                                w.Header().Set("Www-Authenticate", "Swift realm=\"unknown\"")
                        }</span>
                }

                <span class="cov0" title="0">if m.debugResponses &amp;&amp; status/100 != 2 </span><span class="cov0" title="0">{
                        buf := debug.Stack()
                        w.Header().Set("X-Source-Code", string(buf))
                }</span>

                <span class="cov0" title="0">pc.responseSent = time.Now()
                pc.status = status
                return status</span>
        })
        <span class="cov0" title="0">request = request.WithContext(context.WithValue(request.Context(), "proxycontext", pc))
        m.next.ServeHTTP(newWriter, request)</span>
}

func NewContext(debugResponses bool, mc ring.MemcacheRing, log srv.LowLevelLogger, proxyClientFactory client.ProxyClient) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return &amp;ProxyContextMiddleware{
                        Cache:              mc,
                        log:                log,
                        next:               next,
                        proxyClientFactory: proxyClientFactory,
                        debugResponses:     debugResponses,
                }
        }</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "fmt"
        "io"
        "net/http"
        "net/http/httptest"
        "net/url"
        "strings"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/uber-go/tally"
)

type CopyWriter struct {
        http.ResponseWriter
        Logger        srv.LowLevelLogger
        accountName   string
        containerName string
        objectName    string
        origReqMethod string
        postAsCopy    bool
}

func (cw *CopyWriter) WriteHeader(status int) <span class="cov8" title="1">{
        if cw.postAsCopy &amp;&amp; status == http.StatusCreated </span><span class="cov8" title="1">{
                cw.ResponseWriter.WriteHeader(http.StatusAccepted)
        }</span> else<span class="cov8" title="1"> {
                cw.ResponseWriter.WriteHeader(status)
        }</span>
}

type copyMiddleware struct {
        next http.Handler
}

func (cw *CopyWriter) getSrcAccountName(request *http.Request) string <span class="cov8" title="1">{
        copyFromAccount := request.Header.Get("X-Copy-From-Account")
        name, err := common.CheckNameFormat(request, copyFromAccount, "Account")
        if err == nil </span><span class="cov8" title="1">{
                return name
        }</span>
        <span class="cov8" title="1">return cw.accountName</span>
}

func (cw *CopyWriter) getDestAccountName(request *http.Request) string <span class="cov8" title="1">{
        destAccount := request.Header.Get("Destination-Account")
        name, err := common.CheckNameFormat(request, destAccount, "Account")
        if err == nil </span><span class="cov8" title="1">{
                request.Header.Set("X-Copy-From-Account", cw.accountName)
                cw.accountName = name
                request.Header.Del("Destination-Account")
        }</span>
        <span class="cov8" title="1">return cw.accountName</span>
}

func getHeaderContainerObjectName(request *http.Request, header string) (string, string, error) <span class="cov8" title="1">{
        path, err := url.QueryUnescape(request.Header.Get(header))
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("Invalid %s: %s", header, err)
        }</span>
        <span class="cov8" title="1">if !strings.HasPrefix(path, "/") </span><span class="cov8" title="1">{
                path = "/" + path
        }</span>

        <span class="cov8" title="1">parts := strings.SplitN(path, "/", 3)
        if len(parts) != 3 </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("Invalid %s", header)
        }</span>
        <span class="cov8" title="1">name, name_err := common.CheckNameFormat(request, parts[1], "Account")
        if name_err != nil </span><span class="cov8" title="1">{
                return "", "", fmt.Errorf("Invalid %s: %s", header, name_err)
        }</span>
        <span class="cov8" title="1">return name, parts[2], nil</span>
}

func (c *copyMiddleware) handlePostAsCopy(writer *CopyWriter, request *http.Request) <span class="cov8" title="1">{
        request.Method = "PUT"
        writer.postAsCopy = true

        request.URL.Path = fmt.Sprintf("/v1/%s/%s/%s", writer.accountName, writer.containerName, writer.objectName)
        request.ContentLength = 0
        request.Header.Del("Range")
        objectPath := fmt.Sprintf("/%s/%s", writer.containerName, writer.objectName)
        request.Header.Set("X-Copy-From", common.Urlencode(objectPath))

        values, err := url.ParseQuery(request.URL.RawQuery)
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 400)
                return
        }</span>
        <span class="cov8" title="1">values.Set("multipart-manifest", "get")
        values.Set("format", "raw")
        request.URL.RawQuery = values.Encode()

        c.handlePut(writer, request)</span>
}

func (c *copyMiddleware) handleCopy(writer *CopyWriter, request *http.Request) <span class="cov8" title="1">{
        if request.Header.Get("Destination") == "" </span><span class="cov8" title="1">{
                // FIXME.
                // swift has: body='Destination header required'
                srv.StandardResponse(writer, 412)
                return
        }</span>
        <span class="cov8" title="1">destAccount := writer.getDestAccountName(request)
        destContainer, destObject, err := getHeaderContainerObjectName(request, "Destination")
        if err != nil </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, 412)
                return
        }</span>
        <span class="cov8" title="1">source := fmt.Sprintf("%s/%s", writer.containerName, writer.objectName)
        writer.containerName = destContainer
        writer.objectName = destObject

        request.Method = "PUT"
        request.URL.Path = fmt.Sprintf("/v1/%s/%s/%s", destAccount, destContainer, destObject)
        request.ContentLength = 0
        request.Header.Set("X-Copy-From", common.Urlencode(source))
        request.Header.Del("Destination")
        request.TransferEncoding = []string{"chunked"}

        c.handlePut(writer, request)</span>
}

func RemoveItemsWithPrefix(header http.Header, prefix string) <span class="cov8" title="1">{
        for k := range header </span><span class="cov8" title="1">{
                if strings.HasPrefix(k, prefix) </span><span class="cov0" title="0">{
                        header.Del(k)
                }</span>
        }
}

func copyItemsWithPrefix(dest, src http.Header, prefix string) <span class="cov8" title="1">{
        for k, v := range src </span><span class="cov8" title="1">{
                if strings.HasPrefix(k, prefix) </span><span class="cov8" title="1">{
                        dest.Del(k)
                        for _, v1 := range v </span><span class="cov8" title="1">{
                                dest.Add(k, v1)
                        }</span>
                }
        }
}

// TODO: This seems like it might copy headers it shouldn't.
// Also, shouldn't it be called copyHeaders instead?
func CopyItems(dest, src http.Header) <span class="cov8" title="1">{
        for k, v := range src </span><span class="cov8" title="1">{
                dest.Del(k)
                for _, v1 := range v </span><span class="cov8" title="1">{
                        dest.Add(k, v1)
                }</span>
        }
}

func copyMetaItems(dest, src http.Header) <span class="cov8" title="1">{
        copyItemsWithPrefix(dest, src, "X-Object-Meta-")
        copyItemsWithPrefix(dest, src, "X-Object-Sysmeta-")
        copyItemsWithPrefix(dest, src, "X-Object-Transient-Sysmeta-")
        dest.Set("X-Delete-At", src.Get("X-Delete-At"))
}</span>

func excludeContains(exclude []string, k string) bool <span class="cov8" title="1">{
        for _, ex := range exclude </span><span class="cov8" title="1">{
                if k == ex </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func CopyItemsExclude(dest, src http.Header, exclude []string) <span class="cov8" title="1">{
        for k, v := range src </span><span class="cov8" title="1">{
                if !excludeContains(exclude, k) </span><span class="cov8" title="1">{
                        dest.Del(k)
                        for _, v1 := range v </span><span class="cov8" title="1">{
                                dest.Add(k, v1)
                        }</span>
                }
        }
}

func (c *copyMiddleware) handlePut(writer *CopyWriter, request *http.Request) <span class="cov8" title="1">{
        if request.ContentLength != 0 </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 400)
                return
        }</span>

        <span class="cov8" title="1">srcAccountName := writer.getSrcAccountName(request)
        srcContainer, srcObject, err := getHeaderContainerObjectName(request, "X-Copy-From")
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 412)
                return
        }</span>

        <span class="cov8" title="1">srcPath := fmt.Sprintf("/v1/%s/%s/%s", srcAccountName, srcContainer, srcObject)

        post := writer.origReqMethod == "POST"
        var auth AuthorizeFunc
        if !post </span><span class="cov8" title="1">{
                writer.Logger.Info(fmt.Sprintf("Copying object from %s to %s", srcPath, request.URL.Path))
        }</span> else<span class="cov8" title="1"> {
                // POST doesn't need to auth the internal GET; if they issued a POST
                // and it was authorized and we happen to need to do a GET+PUT for our
                // own reasons, that's fine.
                auth = func(r *http.Request) (bool, int) </span><span class="cov0" title="0">{ return true, http.StatusOK }</span>
        }

        <span class="cov8" title="1">srcBody, srcHeader, srcStatus := PipedGet(common.Urlencode(srcPath), request, "copy", auth)
        if srcBody != nil </span><span class="cov8" title="1">{
                defer srcBody.Close()
        }</span>
        <span class="cov8" title="1">if srcStatus &gt;= 300 </span><span class="cov0" title="0">{
                // Return the result of the GET
                for k := range srcHeader </span><span class="cov0" title="0">{
                        writer.Header().Set(k, srcHeader.Get(k))
                }</span>
                <span class="cov0" title="0">writer.WriteHeader(srcStatus)
                if srcBody != nil </span><span class="cov0" title="0">{
                        common.Copy(srcBody, writer)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">origHeader := make(map[string][]string)
        CopyItems(origHeader, request.Header)
        if post </span><span class="cov8" title="1">{
                // Post-as-copy: ignore new sysmeta, copy existing sysmeta
                RemoveItemsWithPrefix(request.Header, "X-Object-Sysmeta-")
                copyItemsWithPrefix(request.Header, srcHeader, "X-Object-Sysmeta-")
        }</span> else<span class="cov8" title="1"> if common.LooksTrue(request.Header.Get("X-Fresh-Metadata")) </span><span class="cov0" title="0">{
                // # x-fresh-metadata only applies to copy, not post-as-copy: ignore
                // existing user metadata, update existing sysmeta with new
                copyItemsWithPrefix(request.Header, srcHeader, "X-Object-Sysmeta-")
                copyItemsWithPrefix(request.Header, origHeader, "X-Object-Sysmeta-")
        }</span> else<span class="cov8" title="1"> {
                // First copy existing sysmeta, user meta and other headers from the
                // source to the request, apart from headers that are conditionally
                // copied below and timestamps.
                exclude := []string{"X-Static-Large-Object", "X-Object-Manifest",
                        "Etag", "Content-Type", "X-Timestamp", "X-Backend-Timestamp"}
                CopyItemsExclude(request.Header, srcHeader, exclude)
                // now update with original req headers
                CopyItems(request.Header, origHeader)
        }</span>

        <span class="cov8" title="1">values, err := url.ParseQuery(request.URL.RawQuery)
        if err != nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 400)
                return
        }</span>
        <span class="cov8" title="1">if values.Get("multipart-manifest") == "get" </span><span class="cov8" title="1">{
                if srcHeader.Get("X-Static-Large-Object") != "" </span><span class="cov0" title="0">{
                        values.Set("multipart-manifest", "put")
                }</span>
                <span class="cov8" title="1">if srcHeader.Get("X-Object-Manifest") != "" </span><span class="cov0" title="0">{
                        values.Del("multipart-manifest")
                        request.Header.Set("X-Object-Manifest", srcHeader.Get("X-Object-Manifest"))
                }</span>
        }

        <span class="cov8" title="1">request.URL.RawQuery = values.Encode()
        request.ContentLength = 0
        request.Body = srcBody

        if srcStatus == http.StatusOK &amp;&amp;
                srcHeader.Get("X-Static-Large-Object") == "" &amp;&amp;
                (srcHeader.Get("X-Object-Manifest") == "" || request.URL.Query().Get("multipart-manifest") == "get") </span><span class="cov8" title="1">{
                // copy source etag so that copied content is verified, unless:
                //  - not a 200 OK response: source etag may not match the actual
                //    content, for example with a 206 Partial Content response to a
                //    ranged request
                //  - SLO manifest: etag cannot be specified in manifest PUT; SLO
                //    generates its own etag value which may differ from source
                //  - SLO: etag in SLO response is not hash of actual content
                //  - DLO: etag in DLO response is not hash of actual content
                request.Header.Set("Etag", srcHeader.Get("Etag"))
        }</span> else<span class="cov0" title="0"> {
                // since we're not copying the source etag, make sure that any
                // container update override values are not copied.
                RemoveItemsWithPrefix(request.Header, "X-Object-Sysmeta-Container-Update-Override-")
        }</span>

        <span class="cov8" title="1">request.Header.Del("X-Copy-From")
        request.Header.Del("X-Copy-From-Account")

        // If the copy request does not explicitly override content-type,
        // use the one present in the source object.
        if request.Header.Get("Content-Type") == "" </span><span class="cov8" title="1">{
                request.Header.Set("Content-Type", srcHeader.Get("Content-Type"))
        }</span>

        <span class="cov8" title="1">var respHeader http.Header = make(map[string][]string)

        respHeader.Set("X-Copied-From-Account", common.Urlencode(srcAccountName))
        copiedFrom := fmt.Sprintf("%s/%s", srcContainer, srcObject)
        respHeader.Set("X-Copied-From", common.Urlencode(copiedFrom))
        if srcHeader.Get("Last-Modified") != "" </span><span class="cov0" title="0">{
                respHeader.Set("X-Copied-From-Last-Modified", srcHeader.Get("Last-Modified"))
        }</span>

        <span class="cov8" title="1">copyMetaItems(respHeader, request.Header)

        for k, v := range respHeader </span><span class="cov8" title="1">{
                for _, v1 := range v </span><span class="cov8" title="1">{
                        writer.Header().Add(k, v1)
                }</span>
        }

        <span class="cov8" title="1">c.next.ServeHTTP(writer, request)</span>
}

func (c *copyMiddleware) ServeHTTP(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        apiReq, account, container, object := getPathParts(request)
        if !apiReq || account == "" || container == "" || object == "" </span><span class="cov0" title="0">{
                c.next.ServeHTTP(writer, request)
                return
        }</span>
        <span class="cov8" title="1">ctx := GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>

        <span class="cov8" title="1">cw := &amp;CopyWriter{
                ResponseWriter: writer,
                Logger:         ctx.Logger,
                accountName:    account,
                containerName:  container,
                objectName:     object,
        }

        if request.Method == "PUT" &amp;&amp; request.Header.Get("X-Copy-From") != "" </span><span class="cov8" title="1">{
                c.handlePut(cw, request)
                return
        }</span> else<span class="cov8" title="1"> if request.Method == "COPY" </span><span class="cov8" title="1">{
                cw.origReqMethod = "COPY"
                c.handleCopy(cw, request)
                return
        }</span> else<span class="cov8" title="1"> if request.Method == "POST" </span><span class="cov8" title="1">{
                // TODO: Replace with PipeResponse stuff from #154
                subrec := httptest.NewRecorder()
                c.next.ServeHTTP(subrec, request)
                subresp := subrec.Result()
                defer subresp.Body.Close()
                if subresp.StatusCode == http.StatusConflict </span><span class="cov8" title="1">{
                        cw.origReqMethod = "POST"
                        c.handlePostAsCopy(cw, request)
                }</span> else<span class="cov0" title="0"> {
                        // Copy headers that weren't previously set.
                        for k, vs := range subresp.Header </span><span class="cov0" title="0">{
                                if _, ok := writer.Header()[k]; !ok </span><span class="cov0" title="0">{
                                        for _, v := range vs </span><span class="cov0" title="0">{
                                                writer.Header().Add(k, v)
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">writer.WriteHeader(subresp.StatusCode)
                        io.Copy(writer, subresp.Body)</span>
                }
                <span class="cov8" title="1">return</span>
        }
        <span class="cov8" title="1">c.next.ServeHTTP(writer, request)</span>
}

func NewCopyMiddleware(config conf.Section, metricsScope tally.Scope) (func(http.Handler) http.Handler, error) <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{ return &amp;copyMiddleware{next: next} }</span>, nil
}
</pre>
		
		<pre class="file" id="file90" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "net/http"
        "strings"

        "github.com/troubling/hummingbird/client"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/uber-go/tally"
)

type corsMiddleware struct {
        next http.Handler
}

type cors struct {
        origin string
        ci     *client.ContainerInfo
}

func (c *cors) HandleCors(writer http.ResponseWriter, status int) int <span class="cov8" title="1">{
        if c.origin == "" || !common.IsOriginAllowed(c.ci.Metadata["Access-Control-Allow-Origin"], c.origin) </span><span class="cov8" title="1">{
                return status
        }</span>
        <span class="cov8" title="1">if writer.Header().Get("Access-Control-Expose-Headers") == "" </span><span class="cov8" title="1">{
                corsExposeHeaders := []string{"Cache-Control", "Content-Language",
                        "Content-Type", "Expires", "Last-Modified", "Pragma", "Etag",
                        "X-Timestamp", "X-Trans-Id", "X-Openstack-Request-Id"}
                for k := range writer.Header() </span><span class="cov0" title="0">{
                        if strings.HasPrefix(
                                k, "X-Container-Meta") || strings.HasPrefix(
                                k, "X-Object-Meta") </span><span class="cov0" title="0">{
                                corsExposeHeaders = append(corsExposeHeaders, k)
                        }</span>
                }
                <span class="cov8" title="1">if c.ci.Metadata["Access-Control-Expose-Headers"] != "" </span><span class="cov8" title="1">{
                        for _, h := range strings.Split(
                                c.ci.Metadata["Access-Control-Expose-Headers"], " ") </span><span class="cov8" title="1">{
                                corsExposeHeaders = append(corsExposeHeaders, h)
                        }</span>
                }
                <span class="cov8" title="1">writer.Header().Set(
                        "Access-Control-Expose-Headers", strings.ToLower(strings.Join(corsExposeHeaders, ", ")))</span>
        }
        <span class="cov8" title="1">if writer.Header().Get("Access-Control-Allow-Origin") == "" </span><span class="cov8" title="1">{
                if c.ci.Metadata["Access-Control-Allow-Origin"] == "*" </span><span class="cov8" title="1">{
                        writer.Header().Set("Access-Control-Allow-Origin", "*")
                }</span> else<span class="cov8" title="1"> {
                        writer.Header().Set("Access-Control-Allow-Origin", c.origin)
                }</span>
        }
        <span class="cov8" title="1">return status</span>
}

func (cm *corsMiddleware) ServeHTTP(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        origin := request.Header.Get("Origin")
        ctx := GetProxyContext(request)
        if ctx == nil || origin == "" </span><span class="cov0" title="0">{
                cm.next.ServeHTTP(writer, request)
                return
        }</span>
        <span class="cov0" title="0">pathParts, err := common.ParseProxyPath(request.URL.Path)
        if err != nil || pathParts["container"] == "" </span><span class="cov0" title="0">{
                cm.next.ServeHTTP(writer, request)
                return
        }</span>
        <span class="cov0" title="0">if ci, err := ctx.C.GetContainerInfo(request.Context(), pathParts["account"], pathParts["container"]); err == nil </span><span class="cov0" title="0">{
                cHandler := &amp;cors{origin: origin, ci: ci}
                w := srv.NewCustomWriter(writer, cHandler.HandleCors)
                cm.next.ServeHTTP(w, request)
                return
        }</span>
        <span class="cov0" title="0">cm.next.ServeHTTP(writer, request)</span>
}

func NewCors(config conf.Section, metricsScope tally.Scope) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return &amp;corsMiddleware{
                        next: next,
                }
        }</span>, nil
}
</pre>
		
		<pre class="file" id="file91" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "fmt"
        "net/http"

        "github.com/troubling/hummingbird/common/conf"
        "github.com/uber-go/tally"
)

func crossdomain(policy string, requestsMetric tally.Counter) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                        if request.URL.Path == "/crossdomain.xml" &amp;&amp; request.Method == "GET" </span><span class="cov8" title="1">{
                                writer.Header().Set("Content-Type", "application/xml; charset=utf-8")
                                writer.WriteHeader(http.StatusOK)
                                writer.Write([]byte(policy))
                                return
                        }</span>
                        <span class="cov8" title="1">next.ServeHTTP(writer, request)</span>
                })
        }
}

func NewCrossDomain(config conf.Section, metricsScope tally.Scope) (func(http.Handler) http.Handler, error) <span class="cov8" title="1">{
        RegisterInfo("crossdomain", map[string]interface{}{})
        defaultPolicy := `&lt;allow-access-from domain="*" secure="false" /&gt;`
        crossDomainPolicy := config.GetDefault("cross_domain_policy", defaultPolicy)
        policy := fmt.Sprintf("&lt;?xml version=\"1.0\"?&gt;\n"+
                "&lt;!DOCTYPE cross-domain-policy SYSTEM "+
                "\"http://www.adobe.com/xml/dtds/cross-domain-policy.dtd\" &gt;\n"+
                "&lt;cross-domain-policy&gt;\n"+
                "%s\n"+
                "&lt;/cross-domain-policy&gt;", crossDomainPolicy)

        return crossdomain(policy, metricsScope.Counter("crossdomain_requests")), nil
}</span>
</pre>
		
		<pre class="file" id="file92" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "context"
        "crypto/hmac"
        "crypto/sha1"
        "encoding/hex"
        "errors"
        "fmt"
        "html"
        "io"
        "io/ioutil"
        "mime"
        "mime/multipart"
        "net/http"
        "net/http/httptest"
        "strconv"
        "strings"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/uber-go/tally"
)

const (
        FP_INVALID = iota
        FP_ERROR
        FP_EXPIRED
        FP_SCOPE_ACCOUNT
        FP_SCOPE_CONTAINER
)

type fpLimitReader struct {
        io.Reader
        l int64
        r int64
}

func (o *fpLimitReader) overRead() bool <span class="cov8" title="1">{
        return o.r &gt; o.l
}</span>

func (o *fpLimitReader) Read(p []byte) (int, error) <span class="cov8" title="1">{
        i, err := o.Reader.Read(p)
        o.r += int64(i)
        if o.r &gt; o.l </span><span class="cov8" title="1">{
                return 0, errors.New("Read over limit")
        }</span>
        <span class="cov8" title="1">return i, err</span>
}

func authenticateFormpost(ctx context.Context, proxyCtx *ProxyContext, account, container, path string, attrs map[string]string) int <span class="cov8" title="1">{
        if expires, err := common.ParseDate(attrs["expires"]); err != nil </span><span class="cov8" title="1">{
                return FP_ERROR
        }</span> else<span class="cov8" title="1"> if time.Now().After(expires) </span><span class="cov8" title="1">{
                return FP_EXPIRED
        }</span>

        <span class="cov8" title="1">sigb, err := hex.DecodeString(attrs["signature"])
        if err != nil || len(sigb) == 0 </span><span class="cov8" title="1">{
                return FP_ERROR
        }</span>

        <span class="cov8" title="1">checkhmac := func(key []byte) bool </span><span class="cov8" title="1">{
                mac := hmac.New(sha1.New, key)
                fmt.Fprintf(mac, "%s\n%s\n%s\n%s\n%s", path, attrs["redirect"],
                        attrs["max_file_size"], attrs["max_file_count"], attrs["expires"])
                return hmac.Equal(sigb, mac.Sum(nil))
        }</span>

        <span class="cov8" title="1">if ai, err := proxyCtx.GetAccountInfo(ctx, account); err == nil </span><span class="cov8" title="1">{
                if key, ok := ai.Metadata["Temp-Url-Key"]; ok &amp;&amp; checkhmac([]byte(key)) </span><span class="cov8" title="1">{
                        return FP_SCOPE_ACCOUNT
                }</span> else<span class="cov8" title="1"> if key, ok := ai.Metadata["Temp-Url-Key-2"]; ok &amp;&amp; checkhmac([]byte(key)) </span><span class="cov8" title="1">{
                        return FP_SCOPE_ACCOUNT
                }</span> else<span class="cov8" title="1"> if ci, err := proxyCtx.C.GetContainerInfo(ctx, account, container); err == nil </span><span class="cov8" title="1">{
                        if key, ok := ci.Metadata["Temp-Url-Key"]; ok &amp;&amp; checkhmac([]byte(key)) </span><span class="cov8" title="1">{
                                return FP_SCOPE_CONTAINER
                        }</span> else<span class="cov8" title="1"> if key, ok := ci.Metadata["Temp-Url-Key-2"]; ok &amp;&amp; checkhmac([]byte(key)) </span><span class="cov8" title="1">{
                                return FP_SCOPE_CONTAINER
                        }</span>
                }
        }
        <span class="cov8" title="1">return FP_INVALID</span>
}

func formpostRespond(writer http.ResponseWriter, status int, message, redirect string) <span class="cov8" title="1">{
        if redirect == "" </span><span class="cov8" title="1">{
                body := fmt.Sprintf("&lt;h1&gt;%d %s&lt;/h1&gt;FormPost: %s", status, http.StatusText(status), message)
                writer.Header().Set("Content-Type", "text/html")
                writer.Header().Set("Content-Length", strconv.FormatInt(int64(len(body)), 10))
                writer.WriteHeader(status)
                writer.Write([]byte(body))
        }</span> else<span class="cov8" title="1"> {
                glue := "?"
                if strings.Contains(redirect, "?") </span><span class="cov0" title="0">{
                        glue = "&amp;"
                }</span>
                <span class="cov8" title="1">redir := fmt.Sprintf("%s%sstatus=%d&amp;message=%s", redirect, glue, status, common.Urlencode(message))
                body := fmt.Sprintf("&lt;html&gt;&lt;body&gt;&lt;p&gt;&lt;a href=\"%s\"&gt;Click to continue...&lt;/a&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;",
                        html.EscapeString(redir))
                writer.Header().Set("Location", redir)
                writer.Header().Set("Content-Length", strconv.Itoa(len(body)))
                writer.WriteHeader(303)
                io.WriteString(writer, body)</span>
        }
}

func formpostAuthorizer(scope int, account, container string) func(r *http.Request) (bool, int) <span class="cov8" title="1">{
        return func(r *http.Request) (bool, int) </span><span class="cov8" title="1">{
                ar, a, c, _ := getPathParts(r)
                if scope == FP_SCOPE_ACCOUNT </span><span class="cov8" title="1">{
                        if ar &amp;&amp; a == account </span><span class="cov8" title="1">{
                                return true, http.StatusOK
                        }</span>
                } else<span class="cov8" title="1"> if scope == FP_SCOPE_CONTAINER </span><span class="cov8" title="1">{
                        if ar &amp;&amp; a == account &amp;&amp; c == container </span><span class="cov8" title="1">{
                                return true, http.StatusOK
                        }</span>
                }
                <span class="cov8" title="1">return false, http.StatusForbidden</span>
        }
}

func formpost(formpostRequestsMetric tally.Counter) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                        if request.Method != "POST" </span><span class="cov0" title="0">{
                                next.ServeHTTP(writer, request)
                                return
                        }</span>

                        <span class="cov8" title="1">contentType, params, err := mime.ParseMediaType(request.Header.Get("Content-Type"))
                        if err != nil || contentType != "multipart/form-data" || params["boundary"] == "" </span><span class="cov0" title="0">{
                                next.ServeHTTP(writer, request)
                                return
                        }</span>

                        <span class="cov8" title="1">apiReq, account, container, _ := getPathParts(request)
                        if !apiReq || account == "" || container == "" </span><span class="cov0" title="0">{
                                srv.StandardResponse(writer, 401)
                                return
                        }</span>

                        <span class="cov8" title="1">ctx := GetProxyContext(request)
                        if ctx.Authorize != nil </span><span class="cov0" title="0">{
                                next.ServeHTTP(writer, request)
                                return
                        }</span>

                        <span class="cov8" title="1">validated := false
                        attrs := map[string]string{
                                "redirect":       "",
                                "max_file_size":  "0",
                                "max_file_count": "0",
                                "expires":        "0",
                        }
                        mr := multipart.NewReader(request.Body, params["boundary"])
                        var maxFileCount, fileCount, maxFileSize int64
                        for </span><span class="cov8" title="1">{
                                p, err := mr.NextPart()
                                if err == io.EOF </span><span class="cov8" title="1">{
                                        break</span>
                                } else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                                        formpostRespond(writer, 400, "invalid request", attrs["redirect"])
                                        return
                                }</span>
                                <span class="cov8" title="1">if fn := p.FileName(); fn == "" </span><span class="cov8" title="1">{
                                        data, err := ioutil.ReadAll(&amp;io.LimitedReader{R: p, N: 8192})
                                        if err != nil </span><span class="cov0" title="0">{
                                                formpostRespond(writer, 400, "error reading form value", attrs["redirect"])
                                                return
                                        }</span>
                                        <span class="cov8" title="1">if len(attrs) &gt; 64 </span><span class="cov0" title="0">{
                                                formpostRespond(writer, 400, "too many form post values", attrs["redirect"])
                                                return
                                        }</span>
                                        <span class="cov8" title="1">attrs[p.FormName()] = string(data)</span>
                                } else<span class="cov8" title="1"> {
                                        if !validated </span><span class="cov8" title="1">{
                                                if maxFileCount, err = strconv.ParseInt(attrs["max_file_count"], 10, 64); err != nil || maxFileCount &lt;= 0 </span><span class="cov0" title="0">{
                                                        formpostRespond(writer, 400, "max_file_count not valid", attrs["redirect"])
                                                        return
                                                }</span>
                                                <span class="cov8" title="1">if maxFileSize, err = strconv.ParseInt(attrs["max_file_size"], 10, 64); err != nil || maxFileSize &lt; 0 </span><span class="cov0" title="0">{
                                                        formpostRespond(writer, 400, "max_file_size not valid", attrs["redirect"])
                                                        return
                                                }</span>
                                                <span class="cov8" title="1">scope := authenticateFormpost(request.Context(), ctx, account, container, request.URL.Path, attrs)
                                                switch scope </span>{
                                                case FP_EXPIRED:<span class="cov8" title="1">
                                                        formpostRespond(writer, 401, "Form Expired", attrs["redirect"])
                                                        return</span>
                                                case FP_INVALID:<span class="cov0" title="0">
                                                        formpostRespond(writer, 401, "Invalid Signature", attrs["redirect"])
                                                        return</span>
                                                case FP_ERROR:<span class="cov0" title="0">
                                                        formpostRespond(writer, 400, "invalid request", attrs["redirect"])
                                                        return</span>
                                                default:<span class="cov8" title="1">
                                                        ctx.RemoteUsers = []string{".formpost"}
                                                        ctx.Authorize = formpostAuthorizer(scope, account, container)
                                                        validated = true</span>
                                                }
                                        }

                                        <span class="cov8" title="1">fileCount++
                                        if fileCount &gt; maxFileCount </span><span class="cov0" title="0">{
                                                formpostRespond(writer, 400, "max file count exceeded", attrs["redirect"])
                                                return
                                        }</span>

                                        <span class="cov8" title="1">path := request.URL.Path
                                        if !strings.HasSuffix(path, "/") &amp;&amp; strings.Count(path, "/") &lt; 4 </span><span class="cov8" title="1">{
                                                path += "/"
                                        }</span>
                                        <span class="cov8" title="1">path += fn
                                        neww := httptest.NewRecorder()
                                        flr := &amp;fpLimitReader{Reader: p, l: maxFileSize}
                                        newreq, err := ctx.newSubrequest("PUT", path, flr, request, "formpost")
                                        if err != nil </span><span class="cov0" title="0">{
                                                formpostRespond(writer, 500, "internal server error", attrs["redirect"])
                                                return
                                        }</span>
                                        <span class="cov8" title="1">newreq.Header.Set("X-Delete-At", attrs["x_delete_at"])
                                        newreq.Header.Set("X-Delete-After", attrs["x_delete_after"])
                                        newreq.TransferEncoding = []string{"chunked"}
                                        if attrs["content-type"] != "" </span><span class="cov0" title="0">{
                                                newreq.Header.Set("Content-Type", attrs["content-type"])
                                        }</span> else<span class="cov8" title="1"> {
                                                newreq.Header.Set("Content-Type", "application/octet-stream")
                                        }</span>
                                        <span class="cov8" title="1">ctx.serveHTTPSubrequest(neww, newreq)
                                        if flr.overRead() </span><span class="cov0" title="0">{
                                                formpostRespond(writer, 400, "max_file_size exceeded", attrs["redirect"])
                                                return
                                        }</span>
                                        <span class="cov8" title="1">if neww.Code/100 != 2 </span><span class="cov0" title="0">{
                                                formpostRespond(writer, neww.Code, "upload error", attrs["redirect"])
                                                return
                                        }</span>
                                }
                                <span class="cov8" title="1">p.Close()</span>
                        }
                        <span class="cov8" title="1">formpostRespond(writer, 201, "Success.", attrs["redirect"])</span>
                })
        }
}

func NewFormPost(config conf.Section, metricsScope tally.Scope) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        RegisterInfo("formpost", map[string]interface{}{})
        return formpost(metricsScope.Counter("formpost_requests")), nil
}</span>
</pre>
		
		<pre class="file" id="file93" style="display: none">//  Copyright (c) 2015-2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "net/http"

        "github.com/troubling/hummingbird/common/conf"
        "github.com/uber-go/tally"
)

func NewHealthcheck(config conf.Section, metricsScope tally.Scope) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(
                        func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                                if request.URL.Path == "/healthcheck" &amp;&amp; request.Method == "GET" </span><span class="cov0" title="0">{
                                        writer.Header().Set("Content-Length", "2")
                                        writer.WriteHeader(http.StatusOK)
                                        writer.Write([]byte("OK"))
                                        return
                                }</span>
                                <span class="cov0" title="0">next.ServeHTTP(writer, request)</span>
                        },
                )
        }, nil
}
</pre>
		
		<pre class="file" id="file94" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/uber-go/tally"
        "go.uber.org/zap"
)

type keystoneAuth struct {
        resellerPrefixes  []string
        accountRules      map[string]map[string][]string
        resellerAdminRole string
        defaultDomainID   string
        next              http.Handler
}

func (ka *keystoneAuth) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        defer ka.next.ServeHTTP(w, r)
        ctx := GetProxyContext(r)
        if ctx.Authorize != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">pathParts, err := common.ParseProxyPath(r.URL.Path)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if _, ok := ka.getAccountPrefix(pathParts["account"]); !ok </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">identityMap := extractIdentity(r)
        if len(identityMap) == 0 </span><span class="cov0" title="0">{
                ctx.Authorize = ka.authorizeAnonymous
                return
        }</span>
        <span class="cov0" title="0">ctx.RemoteUsers = []string{identityMap["tenantName"]}
        ctx.Authorize = ka.authorize
        ctx.addSubrequestCopy(keystoneSubrequestCopy)</span>
}

func (ka *keystoneAuth) accountMatchesTenant(account string, tenantID string) bool <span class="cov0" title="0">{
        for _, prefix := range ka.resellerPrefixes </span><span class="cov0" title="0">{
                if fmt.Sprintf("%s%s", prefix, tenantID) == account </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (ka *keystoneAuth) getProjectDomainID(r *http.Request, account string) string <span class="cov0" title="0">{
        ctx := GetProxyContext(r)
        ai, err := ctx.GetAccountInfo(r.Context(), account)
        if err != nil </span><span class="cov0" title="0">{
                return "" // TODO: I assume this is what we want here
        }</span>
        <span class="cov0" title="0">return ai.SysMetadata["Project-Domain-Id"]</span>
}

func (ka *keystoneAuth) setProjectDomainID(r *http.Request, pathParts map[string]string, identityMap map[string]string) <span class="cov0" title="0">{
        for k := range r.Header </span><span class="cov0" title="0">{
                if k == "X-Account-Sysmeta-Project-Domain-Id" </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">if pathParts["object"] != "" || (pathParts["container"] != "" &amp;&amp; r.Method != "PUT") ||
                !common.StringInSlice(r.Method, []string{"PUT", "POST"}) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">tenantID := identityMap["tenantID"]
        sysmetaID := ka.getProjectDomainID(r, pathParts["account"])
        reqID, newID := "", ""
        if ka.accountMatchesTenant(pathParts["account"], tenantID) </span><span class="cov0" title="0">{
                reqID = identityMap["projectDomainID"]
                newID = reqID
        }</span>
        <span class="cov0" title="0">if sysmetaID == "" &amp;&amp; reqID == ka.defaultDomainID </span><span class="cov0" title="0">{
                newID = reqID
        }</span>
        <span class="cov0" title="0">if newID != "" </span><span class="cov0" title="0">{
                r.Header.Set("X-Account-Sysmeta-Project-Domain-Id", newID)
        }</span>
}

func (ka *keystoneAuth) isNameAllowedinACL(r *http.Request, account string, identityMap map[string]string) bool <span class="cov0" title="0">{
        userDomainID := identityMap["userDomainID"]
        if userDomainID != "" &amp;&amp; userDomainID != ka.defaultDomainID </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">projectDomainID := identityMap["projectDomainID"]
        if projectDomainID != "" &amp;&amp; projectDomainID != ka.defaultDomainID </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">tenantID := identityMap["tenantID"]
        allow := false
        if ka.accountMatchesTenant(account, tenantID) </span><span class="cov0" title="0">{
                allow = true
        }</span> else<span class="cov0" title="0"> if common.StringInSlice(ka.getProjectDomainID(r, account), []string{ka.defaultDomainID, ""}) </span><span class="cov0" title="0">{
                allow = true
        }</span>
        <span class="cov0" title="0">return allow</span>
}

func (ka *keystoneAuth) authorizeCrossTenant(userID string, userName string,
        tenantID string, tenantName string, roles []string, allowNames bool) string <span class="cov0" title="0">{
        tenantMatch := []string{tenantID, "*"}
        userMatch := []string{userID, "*"}
        if allowNames </span><span class="cov0" title="0">{
                tenantMatch = append(tenantMatch, tenantName)
                userMatch = append(userMatch, userName)
        }</span>
        <span class="cov0" title="0">for _, tenant := range tenantMatch </span><span class="cov0" title="0">{
                for _, user := range userMatch </span><span class="cov0" title="0">{
                        s := fmt.Sprintf("%s:%s", tenant, user)
                        if common.StringInSlice(s, roles) </span><span class="cov0" title="0">{
                                return s
                        }</span>
                }
        }
        <span class="cov0" title="0">return ""</span>
}

func (ka *keystoneAuth) authorize(r *http.Request) (bool, int) <span class="cov0" title="0">{
        identityMap := extractIdentity(r)
        ctx := GetProxyContext(r)
        if ctx == nil </span><span class="cov0" title="0">{
                return false, http.StatusUnauthorized
        }</span>
        <span class="cov0" title="0">s := http.StatusUnauthorized
        if len(ctx.RemoteUsers) != 0 </span><span class="cov0" title="0">{
                s = http.StatusForbidden
        }</span>
        <span class="cov0" title="0">tenantID := identityMap["tenantID"]
        tenantName := identityMap["tenantName"]
        userID := identityMap["userID"]
        userName := identityMap["userName"]

        referrers, roles := ParseACL(ctx.ACL)

        // allow OPTIONS requests to proceed as normal
        if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                return true, http.StatusOK
        }</span>
        <span class="cov0" title="0">pathParts, err := common.ParseProxyPath(r.URL.Path)
        if err != nil </span><span class="cov0" title="0">{
                ctx.Logger.Error("Unable to parse URL", zap.Error(err))
                return false, s
        }</span>

        <span class="cov0" title="0">ka.setProjectDomainID(r, pathParts, identityMap)
        userRoles := []string{}
        for _, userRole := range common.SliceFromCSV(identityMap["roles"]) </span><span class="cov0" title="0">{
                userRoles = append(userRoles, strings.ToLower(userRole))
        }</span>
        <span class="cov0" title="0">userServiceRoles := []string{}
        for _, userServiceRole := range common.SliceFromCSV(identityMap["serviceRoles"]) </span><span class="cov0" title="0">{
                userServiceRoles = append(userServiceRoles, strings.ToLower(userServiceRole))
        }</span>
        <span class="cov0" title="0">if common.StringInSlice(ka.resellerAdminRole, userRoles) </span><span class="cov0" title="0">{
                ctx.Logger.Debug("User has reseller admin authorization", zap.String("userid", tenantID))
                ctx.StorageOwner = true
                ctx.ResellerRequest = true
                return true, http.StatusOK
        }</span>

        <span class="cov0" title="0">if pathParts["container"] == "" &amp;&amp; pathParts["object"] == "" &amp;&amp;
                r.Method == "DELETE" </span><span class="cov0" title="0">{
                ctx.Logger.Debug("User is not allowed to delete its own account",
                        zap.String("tenantName", tenantName),
                        zap.String("userName", userName))
                return false, s
        }</span>
        <span class="cov0" title="0">matchedACL := ""
        if len(roles) &gt; 0 </span><span class="cov0" title="0">{
                allowNames := ka.isNameAllowedinACL(r, pathParts["account"], identityMap)
                matchedACL = ka.authorizeCrossTenant(userID, userName, tenantID, tenantName, roles, allowNames)
        }</span>
        <span class="cov0" title="0">if matchedACL != "" </span><span class="cov0" title="0">{
                ctx.Logger.Debug("user allowed in ACL authorizing", zap.String("user", matchedACL))
                return true, http.StatusOK
        }</span>

        <span class="cov0" title="0">isAuthorized, authErr := AuthorizeUnconfirmedIdentity(r, pathParts["object"], referrers, roles)
        if !ka.accountMatchesTenant(pathParts["account"], tenantID) </span><span class="cov0" title="0">{
                if isAuthorized </span><span class="cov0" title="0">{
                        // Passed the unconfirmed check, with mismatching tenant, don't go through to the storage owner matrix
                        return true, http.StatusOK
                }</span>
                <span class="cov0" title="0">return false, s</span>
        }
        <span class="cov0" title="0">accountPrefix, _ := ka.getAccountPrefix(pathParts["account"])
        operatorRoles := ka.accountRules[accountPrefix]["operator_roles"]
        haveOperatorRole := false
        for _, or := range operatorRoles </span><span class="cov0" title="0">{
                if common.StringInSlice(or, userRoles) </span><span class="cov0" title="0">{
                        haveOperatorRole = true
                        break</span>
                }
        }
        <span class="cov0" title="0">serviceRoles := ka.accountRules[accountPrefix]["service_roles"]
        haveServiceRole := false
        for _, or := range serviceRoles </span><span class="cov0" title="0">{
                if common.StringInSlice(or, userServiceRoles) </span><span class="cov0" title="0">{
                        haveServiceRole = true
                        break</span>
                }
        }
        /* Copying this truth table from swift.
           # Compare roles from tokens against the configuration options:
           #
           # X-Auth-Token role  Has specified  X-Service-Token role  Grant
           # in operator_roles? service_roles? in service_roles?     swift_owner?
           # ------------------ -------------- --------------------  ------------
           # yes                yes            yes                   yes
           # yes                yes            no                    no
           # yes                no             don't care            yes
           # no                 don't care     don't care            no
           # ------------------ -------------- --------------------  ------------
        */
        <span class="cov0" title="0">allowed := false
        if haveOperatorRole &amp;&amp; (len(serviceRoles) &gt; 0 &amp;&amp; haveServiceRole) </span><span class="cov0" title="0">{
                allowed = true
        }</span> else<span class="cov0" title="0"> if haveOperatorRole &amp;&amp; len(serviceRoles) == 0 </span><span class="cov0" title="0">{
                allowed = true
        }</span>
        <span class="cov0" title="0">if allowed </span><span class="cov0" title="0">{
                ctx.StorageOwner = true
                return true, http.StatusOK
        }</span>
        <span class="cov0" title="0">if !isAuthorized &amp;&amp; authErr == nil </span><span class="cov0" title="0">{
                return false, s
        }</span>
        <span class="cov0" title="0">for _, role := range roles </span><span class="cov0" title="0">{
                if common.StringInSlice(role, userRoles) </span><span class="cov0" title="0">{
                        return true, http.StatusOK
                }</span>

        }
        <span class="cov0" title="0">if isAuthorized </span><span class="cov0" title="0">{
                return true, http.StatusOK
        }</span>
        <span class="cov0" title="0">return false, s</span>
}

func (ka *keystoneAuth) getAccountPrefix(account string) (string, bool) <span class="cov0" title="0">{
        // Empty prefix matches everything, so try to match others first
        for _, prefix := range ka.resellerPrefixes </span><span class="cov0" title="0">{
                if prefix != "" &amp;&amp; strings.HasPrefix(account, prefix) </span><span class="cov0" title="0">{
                        return prefix, true
                }</span>
        }
        <span class="cov0" title="0">for _, prefix := range ka.resellerPrefixes </span><span class="cov0" title="0">{
                if prefix == "" </span><span class="cov0" title="0">{
                        return "", true
                }</span>
        }
        <span class="cov0" title="0">return "", false</span>
}

func (ka *keystoneAuth) authorizeAnonymous(r *http.Request) (bool, int) <span class="cov0" title="0">{
        ctx := GetProxyContext(r)
        pathParts, err := common.ParseProxyPath(r.URL.Path)
        s := http.StatusUnauthorized
        if len(ctx.RemoteUsers) != 0 </span><span class="cov0" title="0">{
                s = http.StatusForbidden
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ctx.Logger.Error("Unable to parse URL", zap.Error(err))
                return false, s
        }</span>
        // allow OPTIONS requests to proceed as normal
        <span class="cov0" title="0">if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                return true, http.StatusOK
        }</span>
        <span class="cov0" title="0">isAuthorized := false
        if pathParts["account"] != "" </span><span class="cov0" title="0">{
                if prefix, ok := ka.getAccountPrefix(pathParts["account"]); ok </span><span class="cov0" title="0">{
                        if common.StringInSlice(prefix, ka.resellerPrefixes) </span><span class="cov0" title="0">{
                                isAuthorized = true
                        }</span>
                }
        }
        <span class="cov0" title="0">if !isAuthorized </span><span class="cov0" title="0">{
                return false, s
        }</span>

        <span class="cov0" title="0">referrers, roles := ParseACL(ctx.ACL)
        isAuthorized, _ = AuthorizeUnconfirmedIdentity(r, pathParts["object"], referrers, roles)

        if !isAuthorized </span><span class="cov0" title="0">{
                return false, s
        }</span>
        <span class="cov0" title="0">return true, http.StatusOK</span>
}

func keystoneSubrequestCopy(dst, src *http.Request) <span class="cov0" title="0">{
        for _, h := range []string{"X-Identity-Status", "X-Service-Identity-Status", "X-User-Id", "X-User-Name", "X-Project-Id", "X-Project-Name", "X-Roles", "X-Service-Roles", "X-User-Domain-Id", "X-User-Domain-Name", "X-Project-Domain-Id", "X-Project-Domain-Name"} </span><span class="cov0" title="0">{
                if v := src.Header.Get(h); v != "" </span><span class="cov0" title="0">{
                        dst.Header.Set(h, v)
                }</span> else<span class="cov0" title="0"> {
                        delete(dst.Header, h)
                }</span>
        }
}

func extractIdentity(r *http.Request) map[string]string <span class="cov0" title="0">{
        identity := make(map[string]string)
        if r.Header.Get("X-Identity-Status") != "Confirmed" ||
                !common.StringInSlice(r.Header.Get("X-Service-Identity-Status"), []string{"Confirmed", ""}) </span><span class="cov0" title="0">{
                return identity
        }</span>

        <span class="cov0" title="0">identity["userID"] = r.Header.Get("X-User-Id")
        identity["userName"] = r.Header.Get("X-User-Name")
        identity["tenantID"] = r.Header.Get("X-Project-Id")
        identity["tenantName"] = r.Header.Get("X-Project-Name")
        identity["roles"] = r.Header.Get("X-Roles")
        identity["serviceRoles"] = r.Header.Get("X-Service-Roles")
        identity["userDomainID"] = r.Header.Get("X-User-Domain-Id")
        identity["userDomainName"] = r.Header.Get("X-User-Domain-Name")
        identity["projectDomainID"] = r.Header.Get("X-Project-Domain-Id")
        identity["projectDomainName"] = r.Header.Get("X-Project-Domain-Name")

        return identity</span>
}

func NewKeystoneAuth(config conf.Section, metricsScope tally.Scope) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        defaultRules := map[string][]string{"operator_roles": {"admin", "swiftoperator"},
                "service_roles": {}}
        resellerPrefixes, accountRules := conf.ReadResellerOptions(config, defaultRules)
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return &amp;keystoneAuth{
                        next:              next,
                        resellerPrefixes:  resellerPrefixes,
                        accountRules:      accountRules,
                        resellerAdminRole: strings.ToLower(config.GetDefault("reseller_admin_role", "ResellerAdmin")),
                        defaultDomainID:   config.GetDefault("default_domain_id", "default"),
                }
        }</span>, nil
}
</pre>
		
		<pre class="file" id="file95" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "bytes"
        "crypto/md5"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "mime"
        "net/http"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"

        "go.uber.org/zap"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/uber-go/tally"
)

var maxManifestSize = 1024 * 1024 * 2 // TODO add a check for this
var maxManifestLen = 1000

type segItem struct {
        Hash         string `json:"hash"`
        LastModified string `json:"last_modified"`
        Bytes        int64  `json:"bytes"`
        Name         string `json:"name"`
        ContentType  string `json:"content_type"`
        Range        string `json:"range,omitempty"`
        SubSlo       bool   `json:"sub_slo,omitempty"`
}

func (si segItem) segLenHash() (int64, string) <span class="cov8" title="1">{
        if si.Range != "" </span><span class="cov8" title="1">{
                segRange := si.makeRange()
                return segRange.End - segRange.Start, fmt.Sprintf(
                        "%s:%s;", si.Hash, si.Range)
        }</span>
        <span class="cov8" title="1">return int64(si.Bytes), si.Hash</span>
}

// will return the segment range specified, or a range for the whole body
func (si segItem) makeRange() common.HttpRange <span class="cov8" title="1">{
        if si.Range != "" </span><span class="cov8" title="1">{
                ranges, err := common.ParseRange(fmt.Sprintf("bytes=%s", si.Range), int64(si.Bytes))
                if err == nil &amp;&amp; len(ranges) == 1 </span><span class="cov8" title="1">{
                        return ranges[0]
                }</span>
        }
        <span class="cov8" title="1">return common.HttpRange{Start: 0, End: int64(si.Bytes)}</span>
}

type sloPutManifest struct {
        Path      string `json:"path"`
        Etag      string `json:"etag"`
        SizeBytes int64  `json:"size_bytes"`
        Range     string `json:"range,omitempty"`
}

func splitSegPath(thePath string) (string, string, error) <span class="cov8" title="1">{
        segPathParts := strings.SplitN(strings.TrimLeft(thePath, "/"), "/", 2)
        if len(segPathParts) != 2 || segPathParts[0] == "" || segPathParts[1] == "" </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("invalid segment path: %s", thePath)
        }</span>
        <span class="cov8" title="1">return segPathParts[0], segPathParts[1], nil</span>
}

type etagQuoteWriter struct {
        http.ResponseWriter
}

func (w *etagQuoteWriter) WriteHeader(status int) <span class="cov8" title="1">{
        etag := w.Header().Get("ETag")
        w.Header().Set("ETag", fmt.Sprintf("\"%s\"", strings.Trim(etag, "\"")))
        w.ResponseWriter.WriteHeader(status)
}</span>

type xloIdentifyWriter struct {
        http.ResponseWriter
        funcName string
        status   int
        isSlo    bool
        isDlo    bool
        body     *bytes.Buffer
}

func (sw *xloIdentifyWriter) WriteHeader(status int) <span class="cov8" title="1">{
        sw.status = status
        if theDlo := sw.Header().Get("X-Object-Manifest"); theDlo != "" &amp;&amp; sw.funcName != "get" </span><span class="cov8" title="1">{
                sw.isDlo = true
        }</span>
        <span class="cov8" title="1">if isSlo := sw.Header().Get("X-Static-Large-Object"); isSlo == "True" </span><span class="cov8" title="1">{
                sw.isSlo = true
        }</span>
        <span class="cov8" title="1">if !sw.isSlo &amp;&amp; !sw.isDlo </span><span class="cov8" title="1">{
                sw.ResponseWriter.WriteHeader(status)
                return
        }</span>
        <span class="cov8" title="1">sw.body = bytes.NewBuffer(make([]byte, 0))</span>
}

func (sw *xloIdentifyWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        if sw.isDlo </span><span class="cov8" title="1">{
                return len(b), nil
        }</span> else<span class="cov8" title="1"> if sw.isSlo </span><span class="cov8" title="1">{
                return sw.body.Write(b)
        }</span> else<span class="cov8" title="1"> {
                return sw.ResponseWriter.Write(b)
        }</span>
}

type xloForwardBodyWriter struct {
        http.ResponseWriter
        // If constructed with status != 0 xloForwardBodyWriter will call x.ResponseWriter.WriteHeader.
        status int
        header http.Header
}

func (x *xloForwardBodyWriter) Header() http.Header <span class="cov8" title="1">{
        return x.header
}</span>

func (x *xloForwardBodyWriter) WriteHeader(status int) <span class="cov8" title="1">{
        if x.status != 0 </span><span class="cov8" title="1">{
                if status/100 != 2 </span><span class="cov0" title="0">{
                        x.ResponseWriter.WriteHeader(http.StatusConflict)
                }</span> else<span class="cov8" title="1"> {
                        x.ResponseWriter.WriteHeader(x.status)
                }</span>
        }
        <span class="cov8" title="1">x.status = status</span>
}

func (x *xloForwardBodyWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        return x.ResponseWriter.Write(b)
}</span>

func needToRefetchManifest(sw *xloIdentifyWriter, request *http.Request) bool <span class="cov8" title="1">{
        if request.Method == "HEAD" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if request.Header.Get("Range") != "" &amp;&amp; (sw.status == 416) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if request.Header.Get("Range") != "" &amp;&amp; (sw.status == 200 || sw.status == 206) </span><span class="cov8" title="1">{
                re := regexp.MustCompile(`bytes (\d+)-(\d+)/(\d+)$`)
                res := re.FindStringSubmatch(sw.Header().Get("Content-Range"))
                if res == nil || len(res) != 4 </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov0" title="0">end, _ := strconv.ParseInt(res[2], 10, 64)
                length, _ := strconv.ParseInt(res[3], 10, 64)
                got_everything := (res[1] == "0" &amp;&amp; end == length-1)
                return !got_everything</span>
        }
        <span class="cov8" title="1">return false</span>
}

type xloMiddleware struct {
        next                    http.Handler
        dloGetRequestsMetric    tally.Counter
        sloGetRequestsMetric    tally.Counter
        sloPutRequestsMetric    tally.Counter
        sloDeleteRequestsMetric tally.Counter
}

func (xlo *xloMiddleware) feedOutSegments(sw *xloIdentifyWriter, request *http.Request, manifest []segItem, reqRange common.HttpRange, status int) <span class="cov8" title="1">{
        ctx := GetProxyContext(request)
        pathMap, err := common.ParseProxyPath(request.URL.Path)
        if err != nil || pathMap["account"] == "" </span><span class="cov0" title="0">{
                sw.ResponseWriter.WriteHeader(http.StatusBadRequest)
                ctx.Logger.Error("invalid origReq path", zap.String("path", request.URL.Path), zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">writeHeader := true
        for _, si := range manifest </span><span class="cov8" title="1">{
                segLen, _ := si.segLenHash()
                if reqRange.Start &gt;= segLen </span><span class="cov8" title="1">{
                        reqRange.Start -= segLen
                        reqRange.End -= segLen
                        if reqRange.End &lt; 0 </span><span class="cov0" title="0">{
                                if writeHeader </span><span class="cov0" title="0">{
                                        sw.ResponseWriter.WriteHeader(status)
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">if reqRange.End &lt; 0 </span><span class="cov0" title="0">{
                        if writeHeader </span><span class="cov0" title="0">{
                                sw.ResponseWriter.WriteHeader(status)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov8" title="1">segmentRange := si.makeRange()
                subReqStart := segmentRange.Start
                if reqRange.Start &gt; 0 </span><span class="cov8" title="1">{
                        subReqStart += reqRange.Start
                }</span>
                <span class="cov8" title="1">subReqEnd := segmentRange.End
                if subReqEnd &gt; segmentRange.Start+reqRange.End </span><span class="cov8" title="1">{
                        subReqEnd = segmentRange.Start + reqRange.End
                }</span>
                <span class="cov8" title="1">if subReqEnd &lt;= 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">container, object, err := splitSegPath(si.Name)
                if err != nil </span><span class="cov0" title="0">{
                        if writeHeader </span><span class="cov0" title="0">{
                                sw.ResponseWriter.WriteHeader(http.StatusConflict)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov8" title="1">newPath := fmt.Sprintf("/v1/%s/%s/%s", pathMap["account"], container, object)
                newReq, err := ctx.newSubrequest("GET", newPath, http.NoBody, request, "slo")
                if err != nil </span><span class="cov0" title="0">{
                        ctx.Logger.Error("error building subrequest", zap.Error(err))
                        if writeHeader </span><span class="cov0" title="0">{
                                sw.ResponseWriter.WriteHeader(http.StatusConflict)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov8" title="1">newReq.Header.Set("Range", fmt.Sprintf("bytes=%d-%d", subReqStart, subReqEnd-1))
                sw2 := &amp;xloForwardBodyWriter{ResponseWriter: sw.ResponseWriter, header: make(http.Header)}
                if writeHeader </span><span class="cov8" title="1">{
                        sw2.status = status
                        writeHeader = false
                }</span>
                <span class="cov8" title="1">ctx.serveHTTPSubrequest(sw2, newReq)
                if sw2.status/100 != 2 </span><span class="cov0" title="0">{
                        ctx.Logger.Debug("segment not found", zap.String("path", newPath),
                                zap.String("Segment404", "404"), zap.Int("sw2.status", sw2.status))
                        break</span>
                }
                <span class="cov8" title="1">reqRange.Start -= segLen
                reqRange.End -= segLen</span>
        }
        <span class="cov8" title="1">if writeHeader </span><span class="cov0" title="0">{
                sw.ResponseWriter.WriteHeader(status)
        }</span>
}

func (xlo *xloMiddleware) buildSloManifest(request *http.Request, manPath string) (manifest []segItem, status int, err error) <span class="cov8" title="1">{
        ctx := GetProxyContext(request)
        newReq, err := ctx.newSubrequest("GET", fmt.Sprintf("%s?multipart-manifest=get", manPath), http.NoBody, request, "slo")
        if err != nil </span><span class="cov0" title="0">{
                return manifest, http.StatusInternalServerError, err
        }</span>
        <span class="cov8" title="1">swRefetch := NewCaptureWriter()
        ctx.serveHTTPSubrequest(swRefetch, newReq)
        if swRefetch.status != 200 &amp;&amp; swRefetch.body == nil </span><span class="cov0" title="0">{
                return nil, swRefetch.status, errors.New("Error fetching manifest")
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(swRefetch.body, &amp;manifest)
        return manifest, http.StatusOK, err</span>
}

func (xlo *xloMiddleware) buildDloManifest(sw *xloIdentifyWriter, request *http.Request, account string, container string, prefix string) (manifest []segItem, status int, err error) <span class="cov8" title="1">{
        ctx := GetProxyContext(request)
        newReq, err := ctx.newSubrequest("GET", fmt.Sprintf("/v1/%s/%s?format=json&amp;prefix=%s", account, container, prefix), http.NoBody, request, "slo")
        if err != nil </span><span class="cov0" title="0">{
                return manifest, 500, err
        }</span>
        <span class="cov8" title="1">swRefetch := NewCaptureWriter()
        ctx.serveHTTPSubrequest(swRefetch, newReq)
        if swRefetch.status != 200 || swRefetch.body == nil </span><span class="cov0" title="0">{
                return nil, swRefetch.status, fmt.Errorf("Error %d fetching manifest", swRefetch.status)
        }</span>
        <span class="cov8" title="1">if err = json.Unmarshal(swRefetch.body, &amp;manifest); err != nil </span><span class="cov0" title="0">{
                return manifest, 500, err
        }</span>
        <span class="cov8" title="1">for i := range manifest </span><span class="cov8" title="1">{
                manifest[i].Name = fmt.Sprintf("%s/%s", container, manifest[i].Name)
        }</span>
        <span class="cov8" title="1">return manifest, 200, nil</span>
}

func convertManifest(manifestBytes []byte) ([]byte, error) <span class="cov8" title="1">{
        var savedManifest []segItem
        var putManifest []sloPutManifest
        err := json.Unmarshal(manifestBytes, &amp;savedManifest)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}, err
        }</span>
        <span class="cov8" title="1">for _, si := range savedManifest </span><span class="cov8" title="1">{
                putManifest = append(putManifest, sloPutManifest{
                        Path: si.Name, Etag: si.Hash, SizeBytes: si.Bytes, Range: si.Range})
        }</span>
        <span class="cov8" title="1">newBody, err := json.Marshal(putManifest)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}, err
        }</span>
        <span class="cov8" title="1">return []byte(newBody), nil</span>
}

func (xlo *xloMiddleware) byteFeeder(sw *xloIdentifyWriter, request *http.Request, xloEtag string, xloContentLengthStr string, manifest []segItem) <span class="cov8" title="1">{
        xloContentLength := int64(0)
        if xloContentLengthStr != "" </span><span class="cov0" title="0">{
                if cl, err := strconv.ParseInt(xloContentLengthStr, 10, 64); err == nil </span><span class="cov0" title="0">{
                        xloContentLength = cl
                }</span> else<span class="cov0" title="0"> {
                        xloContentLengthStr = ""
                }</span>
        }
        <span class="cov8" title="1">if xloEtag == "" || xloContentLengthStr == "" </span><span class="cov8" title="1">{
                xloEtagGen := md5.New()
                xloContentLengthGen := int64(0)
                for _, si := range manifest </span><span class="cov8" title="1">{
                        segLen, segHash := si.segLenHash()
                        xloContentLengthGen += segLen
                        io.WriteString(xloEtagGen, segHash)
                }</span>
                <span class="cov8" title="1">xloEtag = fmt.Sprintf("%x", xloEtagGen.Sum(nil))
                xloContentLength = xloContentLengthGen</span>
        }
        <span class="cov8" title="1">if request.Header.Get("If-Match") != "" </span><span class="cov0" title="0">{
                ifMatches := common.ParseIfMatch(request.Header.Get("If-Match"))
                if !ifMatches[strings.Trim(xloEtag, "\"")] </span><span class="cov0" title="0">{
                        srv.SimpleErrorResponse(sw.ResponseWriter, 412, "")
                        return
                }</span>
        }
        <span class="cov8" title="1">if request.Header.Get("If-None-Match") != "" </span><span class="cov0" title="0">{
                ifNoneMatches := common.ParseIfMatch(request.Header.Get("If-None-Match"))
                if ifNoneMatches[strings.Trim(xloEtag, "\"")] </span><span class="cov0" title="0">{
                        srv.SimpleErrorResponse(sw.ResponseWriter, 304, "")
                        return
                }</span>
        }
        <span class="cov8" title="1">if (request.Header.Get("If-Unmodified-Since") != "" &amp;&amp; sw.status == 412) ||
                (request.Header.Get("If-Modified-Since") != "" &amp;&amp; sw.status == 304) </span><span class="cov0" title="0">{
                sw.Header().Set("Etag", fmt.Sprintf("\"%s\"", xloEtag))
                sw.ResponseWriter.WriteHeader(sw.status)
                return
        }</span>
        <span class="cov8" title="1">reqRangeStr := request.Header.Get("Range")
        reqRange := common.HttpRange{Start: 0, End: xloContentLength}
        status := http.StatusOK
        if reqRangeStr != "" </span><span class="cov8" title="1">{
                if ranges, err := common.ParseRange(reqRangeStr, xloContentLength); err == nil </span><span class="cov8" title="1">{
                        xloContentLength = 0
                        if len(ranges) &gt; 1 </span><span class="cov0" title="0">{
                                sw.ResponseWriter.Header().Set("Content-Range", fmt.Sprintf("bytes */%d", xloContentLength))
                                srv.SimpleErrorResponse(sw.ResponseWriter, http.StatusRequestedRangeNotSatisfiable, "invalid multi range")
                                return
                        }</span> else<span class="cov8" title="1"> if len(ranges) == 1 </span><span class="cov8" title="1">{
                                reqRange = ranges[0]
                                sw.Header().Set("Content-Range", fmt.Sprintf("%d-%d/%s", reqRange.Start, reqRange.End, xloContentLengthStr))
                                status = http.StatusPartialContent
                        }</span>
                } else<span class="cov0" title="0"> {
                        sw.ResponseWriter.Header().Set("Content-Range", fmt.Sprintf("bytes */%d", xloContentLength))
                        srv.SimpleErrorResponse(sw.ResponseWriter, http.StatusRequestedRangeNotSatisfiable, "invalid range")
                        return
                }</span>
        }
        <span class="cov8" title="1">sw.Header().Set("Content-Length", strconv.FormatInt(reqRange.End-reqRange.Start, 10))
        sw.Header().Set("Content-Type", sw.Header().Get("Content-Type"))
        sw.Header().Set("Etag", fmt.Sprintf("\"%s\"", xloEtag))
        xlo.feedOutSegments(sw, request, manifest, reqRange, status)</span>
}

func (xlo *xloMiddleware) handleDloGet(sw *xloIdentifyWriter, request *http.Request) <span class="cov8" title="1">{
        xlo.dloGetRequestsMetric.Inc(1)
        pathMap, err := common.ParseProxyPath(request.URL.Path)
        if err != nil || pathMap["object"] == "" </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(sw.ResponseWriter, 400, fmt.Sprintf(
                        "invalid must multipath PUT to an object path: %s", request.URL.Path))
                return
        }</span>
        <span class="cov8" title="1">container, prefix, err := splitSegPath(sw.Header().Get("X-Object-Manifest"))
        if err != nil </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(sw.ResponseWriter, 400, "invalid dlo manifest path")
                return
        }</span>
        <span class="cov8" title="1">manifest, status, err := xlo.buildDloManifest(sw, request, pathMap["account"], container, prefix)
        if err != nil </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(sw.ResponseWriter, status,
                        fmt.Sprintf("can not build dlo manifest at: %s?%s", container, prefix))
                return
        }</span>
        <span class="cov8" title="1">xlo.byteFeeder(sw, request, "", "", manifest)</span>
}

func (xlo *xloMiddleware) handleSloGet(sw *xloIdentifyWriter, request *http.Request) <span class="cov8" title="1">{
        xlo.sloGetRequestsMetric.Inc(1)
        // next has already been called and this is an SLO
        //TODO: what does comment at slo.py#624 mean?
        contentType, _, _ := common.ParseContentTypeForSlo(sw.Header().Get("Content-Type"), 0)
        sw.Header().Set("Content-Type", contentType)

        if sw.funcName == "get" </span><span class="cov8" title="1">{
                manifestBytes := sw.body.Bytes()
                var err error
                if request.URL.Query().Get("format") == "raw" </span><span class="cov8" title="1">{
                        manifestBytes, err = convertManifest(manifestBytes)
                        if err != nil </span><span class="cov0" title="0">{
                                srv.SimpleErrorResponse(sw.ResponseWriter, 400, "invalid slo manifest")
                                return
                        }</span>
                } else<span class="cov8" title="1"> {
                        sw.Header().Set("Content-Type", "application/json; charset=utf-8")
                }</span>
                <span class="cov8" title="1">sw.Header().Set("Content-Length", strconv.Itoa(len(manifestBytes)))
                sw.Header().Set("Etag", strings.Trim(sw.Header().Get("Etag"), "\""))
                sw.ResponseWriter.WriteHeader(http.StatusOK)
                sw.ResponseWriter.Write(manifestBytes)
                return</span>
        }
        <span class="cov8" title="1">sloEtag := sw.Header().Get("X-Object-Sysmeta-Slo-Etag")
        savedContentLength := sw.Header().Get("X-Object-Sysmeta-Slo-Size")

        if (request.Method == "HEAD" ||
                sw.status == 304 || sw.status == 412) &amp;&amp; (sloEtag != "" || savedContentLength != "") </span><span class="cov0" title="0">{
                if request.Method == "HEAD" </span><span class="cov0" title="0">{
                        sw.Header().Set("Content-Length", savedContentLength)
                }</span>
                <span class="cov0" title="0">sw.Header().Set("Etag", fmt.Sprintf("\"%s\"", sloEtag))
                sw.ResponseWriter.WriteHeader(sw.status)
                return</span>
        }
        <span class="cov8" title="1">var manifest []segItem
        var status int
        var err error
        manifestBytes := sw.body.Bytes()
        if needToRefetchManifest(sw, request) </span><span class="cov8" title="1">{
                manifest, status, err = xlo.buildSloManifest(request, request.URL.Path)
        }</span> else<span class="cov8" title="1"> {
                err = json.Unmarshal(manifestBytes, &amp;manifest)
                status = http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(sw.ResponseWriter, status, "invalid slo manifest")
                return
        }</span>
        <span class="cov8" title="1">xlo.byteFeeder(sw, request, sloEtag, savedContentLength, manifest)</span>
}

func parsePutSloManifest(body io.ReadCloser) (manifest []sloPutManifest, errs []string) <span class="cov8" title="1">{
        dec := json.NewDecoder(body)
        if d, err := dec.Token(); err != nil </span><span class="cov0" title="0">{
                return manifest, []string{"Invalid manifest json- not a list."}
        }</span> else<span class="cov8" title="1"> if r, ok := d.(json.Delim); !ok || r != '[' </span><span class="cov0" title="0">{
                return manifest, []string{"Invalid manifest json- not a list."}
        }</span>
        <span class="cov8" title="1">for i := 0; dec.More(); i++ </span><span class="cov8" title="1">{
                if i &gt; maxManifestLen </span><span class="cov0" title="0">{
                        errs = append(errs, "Invalid manifest json- too many segments")
                        break</span>
                }
                <span class="cov8" title="1">var manItem sloPutManifest
                if err := dec.Decode(&amp;manItem); err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, "Invalid manifest json- invalid format.")
                        break</span>
                }
                <span class="cov8" title="1">if strings.Index(strings.TrimLeft(manItem.Path, "/"), "/") == -1 </span><span class="cov0" title="0">{
                        errs = append(errs,
                                fmt.Sprintf("Index %d: path does not refer to an object. Path must be of the form /container/object.", i))
                        continue</span>
                }
                // cant really check this here because you can send size_bytes as None now
                <span class="cov8" title="1">if manItem.SizeBytes &lt; 0 </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Sprintf("Index %d: too small; each segment must be at least 1 byte.", i))
                        continue</span>
                }
                <span class="cov8" title="1">if manItem.Range != "" </span><span class="cov0" title="0">{
                        if strings.Count(manItem.Range, "-") != 1 </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Sprintf("Index %d: invalid or multiple ranges (only one allowed)", i))
                                continue</span>
                        }
                }
                <span class="cov8" title="1">manifest = append(manifest, manItem)</span>
        }
        <span class="cov8" title="1">return manifest, errs</span>
}

func (xlo *xloMiddleware) handleSloPut(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        xlo.sloPutRequestsMetric.Inc(1)
        pathMap, err := common.ParseProxyPath(request.URL.Path)
        if err != nil || pathMap["object"] == "" </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(writer, 400, fmt.Sprintf(
                        "invalid must multipath PUT to an object path: %s", request.URL.Path))
                return
        }</span>
        <span class="cov8" title="1">contentLength := request.Header.Get("Content-Length")
        if contentLength == "" &amp;&amp; request.Header.Get("Transfer-Encoding") != "chunked" </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 411)
                return
        }</span>
        <span class="cov8" title="1">if request.Header.Get("X-Copy-From") != "" </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(writer, 405, "Multipart Manifest PUTs cannot be COPY requests")
                return
        }</span>
        <span class="cov8" title="1">manifest, errs := parsePutSloManifest(request.Body)
        if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(writer, 400, strings.Join(errs, "\n"))
                return
        }</span>
        <span class="cov8" title="1">var toPutManifest []segItem
        i := 0
        totalSize := int64(0)
        sloEtag := md5.New()
        ctx := GetProxyContext(request)
        for _, spm := range manifest </span><span class="cov8" title="1">{
                spmContainer, spmObject, err := splitSegPath(spm.Path)
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Sprintf("invalid manifest path: %s", spm.Path))
                        break</span>
                }
                <span class="cov8" title="1">if spmContainer == pathMap["container"] &amp;&amp; spmObject == pathMap["object"] </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Sprintf("manifest cannot reference itself: %s", spm.Path))
                        break</span>
                }

                <span class="cov8" title="1">newPath := fmt.Sprintf("/v1/%s/%s/%s", pathMap["account"], spmContainer, spmObject)
                newReq, err := ctx.newSubrequest("HEAD", newPath, http.NoBody, request, "slo")
                if err != nil </span><span class="cov0" title="0">{
                        ctx.Logger.Error("Couldn't create http.Request", zap.Error(err))
                        return
                }</span>
                <span class="cov8" title="1">pw := NewCaptureWriter()
                ctx.serveHTTPSubrequest(pw, newReq)
                if pw.status != 200 </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Sprintf("%d %s response on segment: %s", pw.status, http.StatusText(pw.status), newPath))
                        continue</span>
                }
                <span class="cov8" title="1">contentLength, err := strconv.ParseInt(pw.Header().Get("Content-Length"), 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Sprintf("bad content-length on segment: %s", newPath))
                        continue</span>
                }
                <span class="cov8" title="1">segEtag := strings.Trim(pw.Header().Get("Etag"), "\"")
                isSlo := false
                if xslo := pw.Header().Get("X-Static-Large-Object"); xslo == "True" </span><span class="cov0" title="0">{
                        isSlo = true
                }</span>
                <span class="cov8" title="1">if spm.SizeBytes &gt; 0 &amp;&amp; contentLength != spm.SizeBytes </span><span class="cov0" title="0">{
                        errs = append(errs,
                                fmt.Sprintf("Unmatching ContentLength (manifest %d) != (segment actual %d) response on segment: %s", spm.SizeBytes, contentLength, newPath))
                        continue</span>
                }
                <span class="cov8" title="1">segmentSize := contentLength
                parsedRange := spm.Range
                if spm.Range != "" </span><span class="cov0" title="0">{
                        ranges, err := common.ParseRange(fmt.Sprintf("bytes=%s", spm.Range), contentLength)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs,
                                        fmt.Sprintf("Index %d: invalid range", i))
                                continue</span>
                        }
                        <span class="cov0" title="0">if len(ranges) != 1 </span><span class="cov0" title="0">{
                                errs = append(errs,
                                        fmt.Sprintf("Index %d:  multiple ranges (only one allowed)", i))
                                continue</span>
                        }
                        <span class="cov0" title="0">segmentSize = int64(ranges[0].End - ranges[0].Start)
                        parsedRange = fmt.Sprintf("%d-%d", ranges[0].Start, ranges[0].End-1)</span> // why -1? because...
                }
                <span class="cov8" title="1">totalSize += segmentSize
                if spm.Etag != "" &amp;&amp; spm.Etag != segEtag </span><span class="cov0" title="0">{
                        errs = append(errs,
                                fmt.Sprintf("Etag Mismatch on %s: %s != %s", spm.Path, spm.Etag, segEtag))
                        continue</span>
                }
                <span class="cov8" title="1">lastModDate, _ := common.ParseDate(pw.Header().Get("Last-Modified"))

                contentType, _, _ := common.ParseContentTypeForSlo(pw.Header().Get("Content-Type"), 0)
                newSi := segItem{Name: spm.Path, Bytes: contentLength,
                        Hash: segEtag, Range: parsedRange, SubSlo: isSlo,
                        ContentType:  contentType,
                        LastModified: lastModDate.Format("2006-01-02T15:04:05.00000")}
                _, newSiHash := newSi.segLenHash()
                io.WriteString(sloEtag, newSiHash)
                toPutManifest = append(toPutManifest, newSi)</span>
        }
        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(writer, 400, strings.Join(errs, "\n"))
                return
        }</span>
        <span class="cov8" title="1">xloEtagGen := fmt.Sprintf("%x", sloEtag.Sum(nil))
        if reqEtag := request.Header.Get("Etag"); reqEtag != "" </span><span class="cov0" title="0">{
                if strings.Trim(reqEtag, "\"") != xloEtagGen </span><span class="cov0" title="0">{
                        srv.SimpleErrorResponse(writer, 422, "Invalid Etag")
                        return
                }</span>
        }
        <span class="cov8" title="1">contentType := request.Header.Get("Content-Type")
        if contentType == "" </span><span class="cov0" title="0">{
                pathMap, _ := common.ParseProxyPath(request.URL.Path)
                contentType = mime.TypeByExtension(filepath.Ext(pathMap["object"]))
                if contentType == "" </span><span class="cov0" title="0">{
                        contentType = "application/octet-stream"
                }</span>
        }
        <span class="cov8" title="1">newBody, err := json.Marshal(toPutManifest)
        request.Body = ioutil.NopCloser(bytes.NewReader(newBody))
        request.Header.Set("Content-Type", fmt.Sprintf("%s;swift_bytes=%d", contentType, totalSize))
        request.Header.Set("X-Static-Large-Object", "True")
        request.Header.Set("X-Object-Sysmeta-Slo-Etag", xloEtagGen)
        request.Header.Set("X-Object-Sysmeta-Slo-Size", fmt.Sprintf("%d", totalSize))
        request.Header.Set("Etag", fmt.Sprintf("%x", md5.Sum(newBody)))
        request.Header.Set("Content-Length", strconv.Itoa(len(newBody)))

        etagWriter := &amp;etagQuoteWriter{ResponseWriter: writer}
        xlo.next.ServeHTTP(etagWriter, request)
        return</span>
}

func segmentIsSlo(request *http.Request, path string) bool <span class="cov8" title="1">{
        ctx := GetProxyContext(request)
        newReq, err := ctx.newSubrequest("HEAD", path, http.NoBody, request, "slo")
        if err != nil </span><span class="cov0" title="0">{
                ctx.Logger.Error("error building subrequest", zap.Error(err))
                return false
        }</span>
        <span class="cov8" title="1">writer := NewCaptureWriter()
        ctx.serveHTTPSubrequest(writer, newReq)
        if writer.Header().Get("X-Static-Large-Object") == "True" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (xlo *xloMiddleware) deleteAllSegments(w http.ResponseWriter, request *http.Request, manifest []segItem) error <span class="cov8" title="1">{
        pathMap, err := common.ParseProxyPath(request.URL.Path)
        if err != nil || pathMap["account"] == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid path to slo delete: %s: %s", request.URL.Path, err)
        }</span>
        <span class="cov8" title="1">ctx := GetProxyContext(request)
        for _, si := range manifest </span><span class="cov8" title="1">{
                container, object, err := splitSegPath(si.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid slo item: %s: %s", si.Name, err)
                }</span>
                <span class="cov8" title="1">newPath := fmt.Sprintf("/v1/%s/%s/%s", pathMap["account"], container, object)
                if segmentIsSlo(request, newPath) </span><span class="cov0" title="0">{
                        newPath += "?multipart-manifest=delete"
                }</span>
                <span class="cov8" title="1">newReq, err := ctx.newSubrequest("DELETE", newPath, http.NoBody, request, "slo")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error building subrequest: %s", err)
                }</span>
                <span class="cov8" title="1">sw := NewCaptureWriter()
                ctx.serveHTTPSubrequest(sw, newReq)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (xlo *xloMiddleware) handleSloDelete(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        xlo.sloDeleteRequestsMetric.Inc(1)
        pathMap, err := common.ParseProxyPath(request.URL.Path)
        if err != nil || pathMap["object"] == "" </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(writer, 400, fmt.Sprintf(
                        "invalid must multipath DELETE to an object path: %s", request.URL.Path))
                return
        }</span>
        <span class="cov8" title="1">manifest, status, err := xlo.buildSloManifest(request, request.URL.Path)
        if err != nil </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(writer, status, fmt.Sprintf("invalid manifest json: %d %s", status, err))
                return
        }</span>
        <span class="cov8" title="1">if err = xlo.deleteAllSegments(writer, request, manifest); err != nil </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(writer, 400, fmt.Sprintf("error deleting slo: %s", err))
                return
        }</span>
        <span class="cov8" title="1">xlo.next.ServeHTTP(writer, request)
        return</span>
}

func updateEtagIsAt(request *http.Request, etagLoc string) <span class="cov8" title="1">{
        curHeader := request.Header.Get("X-Backend-Etag-Is-At")
        if curHeader == "" </span><span class="cov8" title="1">{
                curHeader = etagLoc
        }</span> else<span class="cov0" title="0"> {
                curHeader = fmt.Sprintf("%s,%s", curHeader, etagLoc)
        }</span>
        <span class="cov8" title="1">request.Header.Set("X-Backend-Etag-Is-At", curHeader)</span>
}

func isValidDloHeader(manifest string) bool <span class="cov0" title="0">{
        if !strings.HasPrefix(manifest, "/") &amp;&amp;
                strings.Index(manifest, "?") == -1 &amp;&amp;
                strings.Index(manifest, "&amp;") == -1 </span><span class="cov0" title="0">{
                m := strings.SplitN(manifest, "/", 2)
                if len(m) == 2 &amp;&amp; m[0] != "" &amp;&amp; m[1] != "" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (xlo *xloMiddleware) ServeHTTP(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        if ctx := GetProxyContext(request); ctx != nil &amp;&amp; ctx.Source == "VW" </span><span class="cov0" title="0">{
                xlo.next.ServeHTTP(writer, request)
                return
        }</span>
        <span class="cov8" title="1">xloFuncName := request.URL.Query().Get("multipart-manifest")
        if request.Method == "PUT" &amp;&amp; request.Header.Get("X-Object-Manifest") != "" </span><span class="cov0" title="0">{
                if !isValidDloHeader(request.Header.Get("X-Object-Manifest")) </span><span class="cov0" title="0">{
                        srv.SimpleErrorResponse(writer, 400, fmt.Sprintf(
                                "X-Object-Manifest must be in the format container/prefix"))
                        return
                }</span>
                <span class="cov0" title="0">if xloFuncName == "put" </span><span class="cov0" title="0">{
                        srv.SimpleErrorResponse(writer, 400, fmt.Sprintf("Cannot be both SLO and DLO"))
                        return
                }</span>
        }
        <span class="cov8" title="1">if request.Method == "PUT" &amp;&amp; xloFuncName == "put" </span><span class="cov8" title="1">{
                xlo.handleSloPut(writer, request)
                return
        }</span>
        <span class="cov8" title="1">if request.Method == "DELETE" &amp;&amp; xloFuncName == "delete" </span><span class="cov8" title="1">{
                xlo.handleSloDelete(writer, request)
                return
        }</span>
        <span class="cov8" title="1">if request.Method == "GET" || request.Method == "HEAD" </span><span class="cov8" title="1">{
                if xloFuncName != "get" </span><span class="cov8" title="1">{
                        updateEtagIsAt(request, "X-Object-Sysmeta-Slo-Etag")
                }</span>
                <span class="cov8" title="1">sw := &amp;xloIdentifyWriter{ResponseWriter: writer, funcName: xloFuncName}
                xlo.next.ServeHTTP(sw, request)
                if sw.isSlo </span><span class="cov8" title="1">{
                        xlo.handleSloGet(sw, request)
                }</span> else<span class="cov8" title="1"> if sw.isDlo </span><span class="cov8" title="1">{
                        xlo.handleDloGet(sw, request)
                }</span>
                <span class="cov8" title="1">return</span>
        }
        <span class="cov0" title="0">xlo.next.ServeHTTP(writer, request)</span>
}

func NewXlo(config conf.Section, metricsScope tally.Scope) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        RegisterInfo("slo", map[string]interface{}{"max_manifest_segments": 1000, "max_manifest_size": 2097152, "min_segment_size": 1048576})
        RegisterInfo("dlo", map[string]interface{}{"max_segments": 10000})
        dloGetRequestsMetric := metricsScope.Counter("dlo_GET_requests")
        sloGetRequestsMetric := metricsScope.Counter("slo_GET_requests")
        sloPutRequestsMetric := metricsScope.Counter("slo_PUT_requests")
        sloDeleteRequestsMetric := metricsScope.Counter("slo_DELETE_requests")
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return &amp;xloMiddleware{
                        next:                    next,
                        dloGetRequestsMetric:    dloGetRequestsMetric,
                        sloGetRequestsMetric:    sloGetRequestsMetric,
                        sloPutRequestsMetric:    sloPutRequestsMetric,
                        sloDeleteRequestsMetric: sloDeleteRequestsMetric,
                }
        }</span>, nil
}
</pre>
		
		<pre class="file" id="file96" style="display: none">//  Copyright (c) 2015-2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "fmt"
        "net/http"
        "time"

        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/uber-go/tally"
)

func NewRequestLogger(config conf.Section, metricsScope tally.Scope) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        requestsMetric := metricsScope.Counter("requests")
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                        start := time.Now()
                        newWriter := &amp;srv.WebWriter{ResponseWriter: writer, Status: 500}
                        newReader := &amp;srv.CountingReadCloser{ReadCloser: request.Body}
                        request.Body = newReader
                        next.ServeHTTP(newWriter, request)
                        ctx := GetProxyContext(request)
                        srv.LogRequestLine(ctx.Logger, request, start, newWriter, newReader)
                        if ctx.Source == "" </span><span class="cov0" title="0">{
                                requestsMetric.Inc(1)
                                metricsScope.Counter(request.Method + "_requests").Inc(1)
                                metricsScope.Counter(fmt.Sprintf("%d_responses", newWriter.Status)).Inc(1)
                        }</span>
                })
        }, nil
}
</pre>
		
		<pre class="file" id="file97" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "fmt"
        "io"
        "io/ioutil"
        "net/http"
        "strconv"
        "strings"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/uber-go/tally"
)

type mrw struct {
        io.Writer
        header http.Header
        err    error
}

func (w *mrw) WriteHeader(int)     {<span class="cov8" title="1">}</span>
func (w *mrw) Header() http.Header <span class="cov8" title="1">{ return w.header }</span>

func firstRange(rangeHeader string) string <span class="cov8" title="1">{
        rangeHeader = strings.Replace(strings.ToLower(rangeHeader), " ", "", -1)
        if !strings.HasPrefix(rangeHeader, "bytes=") </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">rangeHeader = rangeHeader[6:]
        return "bytes=" + strings.Split(rangeHeader, ",")[0]</span>
}

func multirange(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                rangeHeader := request.Header.Get("Range")
                if request.Method != "GET" || rangeHeader == "" || !strings.Contains(rangeHeader, ",") </span><span class="cov8" title="1">{
                        next.ServeHTTP(writer, request)
                        return
                }</span>
                <span class="cov8" title="1">if apiReq, _, _, object := getPathParts(request); !apiReq || object == "" </span><span class="cov0" title="0">{
                        next.ServeHTTP(writer, request)
                        return
                }</span>
                <span class="cov8" title="1">var ranges []common.HttpRange

                ctx := GetProxyContext(request)
                var contentLength int64
                var contentType string
                var mw *common.MultiWriter

                subreq, err := ctx.newSubrequest("GET", request.URL.Path, nil, request, "multirange")
                if err != nil </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, 500)
                        return
                }</span>
                <span class="cov8" title="1">subreq.Header.Set("Range", firstRange(rangeHeader))

                uw := &amp;mrw{Writer: ioutil.Discard, header: make(http.Header)}
                subw := srv.NewCustomWriter(uw, func(w http.ResponseWriter, status int) int </span><span class="cov8" title="1">{
                        if status != http.StatusPartialContent </span><span class="cov8" title="1">{
                                uw.err = fmt.Errorf("Bad status code %d", status)
                                uw.Writer = writer
                                for k := range uw.header </span><span class="cov8" title="1">{
                                        writer.Header().Set(k, uw.header.Get(k))
                                }</span>
                                <span class="cov8" title="1">writer.WriteHeader(status)
                                return status</span>
                        }
                        <span class="cov8" title="1">contentType = uw.header.Get("Content-Type")
                        rspRange := uw.header.Get("Content-Range")
                        rrp := strings.Split(rspRange, "/")
                        if contentLength, err = strconv.ParseInt(rrp[len(rrp)-1], 10, 64); err != nil </span><span class="cov0" title="0">{
                                uw.err = fmt.Errorf("Error parsing content-length from response: %q", uw.header.Get("Content-Range"))
                                writer.Header().Set("Content-Range", uw.header.Get("Content-Range"))
                                srv.StandardResponse(writer, http.StatusInternalServerError)
                                return http.StatusInternalServerError
                        }</span>
                        <span class="cov8" title="1">if ranges, err = common.ParseRange(rangeHeader, contentLength); err != nil </span><span class="cov0" title="0">{
                                uw.err = fmt.Errorf("Error parsing multiple ranges from request: %q", rangeHeader)
                                writer.Header().Set("Content-Range", fmt.Sprintf("bytes */%d", contentLength))
                                srv.StandardResponse(writer, http.StatusRequestedRangeNotSatisfiable)
                                return http.StatusRequestedRangeNotSatisfiable
                        }</span>
                        <span class="cov8" title="1">mw = common.NewMultiWriter(writer, contentType, contentLength)
                        for _, rng := range ranges </span><span class="cov8" title="1">{
                                mw.Expect(rng.Start, rng.End)
                        }</span>
                        <span class="cov8" title="1">writer.Header().Set("Content-Length", strconv.FormatInt(mw.ContentLength(), 10))
                        writer.Header().Set("Content-Type", "multipart/byteranges;boundary="+mw.Boundary())
                        writer.WriteHeader(http.StatusPartialContent)

                        part, err := mw.CreatePart(ranges[0].Start, ranges[0].End)
                        if err != nil </span><span class="cov0" title="0">{
                                uw.err = err
                        }</span> else<span class="cov8" title="1"> {
                                uw.Writer = part
                        }</span>
                        <span class="cov8" title="1">return status</span>
                })
                <span class="cov8" title="1">if ctx.serveHTTPSubrequest(subw, subreq); uw.err != nil </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">for _, rng := range ranges[1:] </span><span class="cov8" title="1">{
                        if subreq, err = ctx.newSubrequest("GET", request.URL.Path, nil, request, "multirange"); err != nil </span><span class="cov0" title="0">{
                                srv.StandardResponse(writer, 500)
                                return
                        }</span>
                        <span class="cov8" title="1">subreq.Header.Set("Range", fmt.Sprintf("bytes=%d-%d", rng.Start, rng.End-1))
                        if err != nil </span><span class="cov0" title="0">{
                                return // we just can't complete this request
                        }</span>
                        <span class="cov8" title="1">uw := &amp;mrw{Writer: ioutil.Discard, header: make(http.Header)}
                        subw := srv.NewCustomWriter(uw, func(w http.ResponseWriter, status int) int </span><span class="cov8" title="1">{
                                part, err := mw.CreatePart(rng.Start, rng.End)
                                if err != nil </span><span class="cov0" title="0">{
                                        uw.err = err
                                }</span> else<span class="cov8" title="1"> if status != http.StatusPartialContent </span><span class="cov0" title="0">{
                                        uw.err = fmt.Errorf("Bad status code %d", status)
                                }</span> else<span class="cov8" title="1"> {
                                        uw.Writer = part
                                }</span>
                                <span class="cov8" title="1">return status</span>
                        })
                        <span class="cov8" title="1">if ctx.serveHTTPSubrequest(subw, subreq); uw.err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
                <span class="cov8" title="1">mw.Close()</span>
        })
}

// NewMultirange returns an instance of the multirange middleware with the given config.
//
// This middleware intercepts object GET requests with multiple ranges in the Range header and
// turns them into separate single-range requests on the backend, combining them into a multipart
// response.  This should simplify the implementation of things like xLO and the object server.
func NewMultirange(config conf.Section, metricsScope tally.Scope) (func(http.Handler) http.Handler, error) <span class="cov8" title="1">{
        return multirange, nil
}</span>
</pre>
		
		<pre class="file" id="file98" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "io"
        "net/http"
        "strings"

        "github.com/troubling/hummingbird/common/srv"
        "go.uber.org/zap"
)

type PipeResponseWriter struct {
        w      *io.PipeWriter
        status int
        header http.Header
        ready  chan struct{}
        Logger srv.LowLevelLogger
}

func (w *PipeResponseWriter) Write(stuff []byte) (int, error) <span class="cov8" title="1">{
        written, err := w.w.Write(stuff)
        if err != nil </span><span class="cov0" title="0">{
                if !strings.Contains(err.Error(), "closed pipe") </span><span class="cov0" title="0">{
                        w.Logger.Error("PipeResponseWriter Write() error", zap.Error(err))
                }</span>
        }
        <span class="cov8" title="1">return written, err</span>
}

func (w *PipeResponseWriter) Header() http.Header <span class="cov8" title="1">{
        return w.header
}</span>

func (w *PipeResponseWriter) WriteHeader(status int) <span class="cov8" title="1">{
        w.status = status
        close(w.ready)
}</span>

func (w *PipeResponseWriter) Close() <span class="cov8" title="1">{
        w.w.Close()
}</span>

func NewPipeResponseWriter(writer *io.PipeWriter, ready chan struct{}, logger srv.LowLevelLogger) *PipeResponseWriter <span class="cov8" title="1">{
        header := make(map[string][]string)
        return &amp;PipeResponseWriter{
                w:      writer,
                header: header,
                ready:  ready,
                Logger: logger,
        }
}</span>

func PipedGet(urlStr string, request *http.Request, source string, auth AuthorizeFunc) (io.ReadCloser, http.Header, int) <span class="cov8" title="1">{
        ctx := GetProxyContext(request)
        subRequest, err := ctx.newSubrequest("GET", urlStr, nil, request, source)
        if err != nil </span><span class="cov0" title="0">{
                ctx.Logger.Error("getSourceObject GET error", zap.Error(err))
                return nil, nil, 400
        }</span>
        <span class="cov8" title="1">if request.URL.Query().Get("multipart-manifest") == "get" </span><span class="cov8" title="1">{
                subRequest.URL.RawQuery = "multipart-manifest=get&amp;format=raw"
        }</span>
        <span class="cov8" title="1">CopyItems(subRequest.Header, request.Header)
        // FIXME. Are we going to do X-Newest?
        subRequest.Header.Set("X-Newest", "true")
        subRequest.Header.Del("X-Backend-Storage-Policy-Index")

        if auth != nil </span><span class="cov8" title="1">{
                GetProxyContext(subRequest).Authorize = auth
        }</span>

        <span class="cov8" title="1">pipeReader, pipeWriter := io.Pipe()
        ready := make(chan struct{})
        writer := NewPipeResponseWriter(pipeWriter, ready, ctx.Logger)
        go func() </span><span class="cov8" title="1">{
                defer writer.Close()
                ctx.serveHTTPSubrequest(writer, subRequest)
        }</span>()
        <span class="cov8" title="1">&lt;-ready

        return pipeReader, writer.Header(), writer.status</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "context"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/uber-go/tally"
        "go.uber.org/zap"
)

const rateBuffer = int64(5 * time.Second)
const maxSleep = int64(60 * time.Second)
const nsPerSecond = int64(1000000000)

var writeMethods = map[string]bool{"PUT": true, "DELETE": true, "POST": true}

// will sleep on write requests if the client starts to exceed the
// specified rate. The maximum rate allowed per sec is only as
// accurate as the clocks in the proxy layer- meaning if your clocks
// are accurate to 1/100 of a second then the max reliable rate/sec
// you can set is 100/sec.

type ratelimiter struct {
        accountLimit   int64
        containerLimit int64
        next           http.Handler
}

var sleep = func(s time.Duration) <span class="cov0" title="0">{
        time.Sleep(s)
}</span>

var nowNano = func() int64 <span class="cov0" title="0">{
        return time.Now().UnixNano()
}</span>

// returns int64 of ns to sleep before serving request
func (r *ratelimiter) getSleepTime(ctx context.Context, mc ring.MemcacheRing, key string, ratePs int64) (int64, error) <span class="cov8" title="1">{
        nsPerRequest := nsPerSecond / ratePs
        runningTime, err := mc.Incr(ctx, key, nsPerRequest, 3600)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">sleepTime := int64(0)
        now := nowNano()
        if int64(now-runningTime) &gt; rateBuffer </span><span class="cov8" title="1">{
                // nothing has happened in a while, set new clocktime
                mc.Set(ctx, key, now+nsPerRequest, 3600)
        }</span> else<span class="cov8" title="1"> {
                sleepTime = runningTime - now - nsPerRequest
                if sleepTime &lt; 0 </span><span class="cov0" title="0">{
                        sleepTime = 0
                }</span>
        }
        <span class="cov8" title="1">return sleepTime, nil</span>
}

func (r *ratelimiter) ServeHTTP(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        isWrite := writeMethods[request.Method]
        pathParts, err := common.ParseProxyPath(request.URL.Path)
        if !isWrite || err != nil || pathParts["container"] == "" </span><span class="cov0" title="0">{
                r.next.ServeHTTP(writer, request)
                return
        }</span>
        <span class="cov0" title="0">ctx := GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                ctx.Logger.Error("Error ratelimiter getting ctx")
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">limit := int64(0)
        var ratekey string
        if pathParts["object"] == "" </span><span class="cov0" title="0">{
                ratekey = fmt.Sprintf(
                        "ratelimit/%s", pathParts["account"])
                limit = r.accountLimit
        }</span> else<span class="cov0" title="0"> {
                ratekey = fmt.Sprintf(
                        "ratelimit/%s/%s", pathParts["account"], pathParts["container"])
                limit = r.containerLimit
        }</span>
        <span class="cov0" title="0">ai, err := ctx.GetAccountInfo(request.Context(), pathParts["account"])
        if err != nil </span><span class="cov0" title="0">{
                ctx.Logger.Debug("Error ratelimiter getting account info", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                if rl, ok := ai.SysMetadata["Global-Write-Ratelimit"]; ok </span><span class="cov0" title="0">{
                        if rl == "BLACKLIST" </span><span class="cov0" title="0">{
                                sleep(time.Second)
                                srv.StandardResponse(writer, 497)
                                return
                        }</span>
                        <span class="cov0" title="0">if rl == "WHITELIST" </span><span class="cov0" title="0">{
                                r.next.ServeHTTP(writer, request)
                                return
                        }</span>
                        <span class="cov0" title="0">if rli, err := strconv.ParseInt(rl, 10, 64); err == nil &amp;&amp; rli &gt; 0 </span><span class="cov0" title="0">{
                                ratekey = fmt.Sprintf(
                                        "ratelimit/global/%s", pathParts["account"])
                                limit = rli
                        }</span>
                }
        }
        <span class="cov0" title="0">if limit &gt; 0 </span><span class="cov0" title="0">{
                sleepTime, err := r.getSleepTime(request.Context(), ctx.Cache, ratekey, limit)
                if err == nil </span><span class="cov0" title="0">{
                        if sleepTime &gt; maxSleep </span><span class="cov0" title="0">{
                                sleep(time.Second)
                                srv.StandardResponse(writer, 498)
                                return
                        }</span>
                        <span class="cov0" title="0">sleep(time.Duration(sleepTime))</span>
                } else<span class="cov0" title="0"> {
                        ctx.Logger.Debug("Ratelimiter errored while getting sleep time", zap.Error(err))
                }</span>
        }
        <span class="cov0" title="0">r.next.ServeHTTP(writer, request)</span>
}

func NewRatelimiter(config conf.Section, metricsScope tally.Scope) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{

        accLimit := int64(config.GetInt("account_db_max_writes_per_sec", 0))
        contLimit := int64(config.GetInt("container_db_max_writes_per_sec", 0))
        RegisterInfo("ratelimit", map[string]interface{}{"account_ratelimit": accLimit, "container_ratelimits": [][]int64{{contLimit}}, "max_sleep_time_seconds": float64(60.0)})
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return &amp;ratelimiter{
                        accountLimit:   accLimit,
                        containerLimit: contLimit,
                        next:           next,
                }
        }</span>, nil
}
</pre>
		
		<pre class="file" id="file100" style="display: none">//  Copyright (c) 2018 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

// To use with keystone, create s3 style credentials
//   `openstack ec2 credentials create`
//
// To enable, add the following to `/etc/hummingbird/proxy-server.conf`
//
//   [filter:s3api]
//   enabled = true
//
// Example using boto2 and haio with tempauth:
//
//  from boto.s3.connection import S3Connection
//  connection = S3Connection(
//    aws_access_key_id="test:tester",
//    aws_secret_access_key="testing",
//    port=8080,
//    host='127.0.0.1',
//    is_secure=False,
//    calling_format=boto.s3.connection.OrdinaryCallingFormat()
//  )
//  connection.get_all_buckets()
//
//  If you are using keystone auth, substitue the key and access key returned from keystone

package middleware

import (
        "encoding/base64"
        "encoding/json"
        "encoding/xml"
        "fmt"
        "net/http"
        "strconv"
        "strings"

        "github.com/troubling/hummingbird/accountserver"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/containerserver"
        "github.com/uber-go/tally"
)

const (
        s3Xmlns = "http://s3.amazonaws.com/doc/2006-03-01"
)

type s3Response struct {
        Code    string
        Message string
}

var s3Responses = map[int]s3Response{
        // NOTE: These are meant to be generic responses
        403: {"AccessDenied", "Access Denied"},
        404: {"NotFound", "Not Found"}, // TODO: S3 responds with differetn 404 messages
        405: {"MethodNotAllowed", "The specified method is not allowed against this resource."},
        411: {"MissingContentLength", "You must provide the Content-Length HTTP header."},
        500: {"InternalError", "We encountered an internal error. Please try again."},
        501: {"NotImplemented", "A header you provided implies functionality that is not implemented."},
        503: {"ServiceUnavailable", "Reduce your request rate."},
}

type s3Owner struct {
        ID          string `xml:"ID"`
        DisplayName string `xml:"DisplayName"`
}

type s3BucketInfo struct {
        Name         string `xml:"Name"`
        CreationDate string `xml:"CreationDate"`
}

type s3BucketList struct {
        XMLName xml.Name       `xml:"ListAllMyBucketsResult"`
        Xmlns   string         `xml:"xmlns,attr"`
        Owner   s3Owner        `xml:"Owner"`
        Buckets []s3BucketInfo `xml:"Buckets&gt;Bucket"`
}

func NewS3BucketList() *s3BucketList <span class="cov0" title="0">{
        return &amp;s3BucketList{Xmlns: s3Xmlns}
}</span>

type s3ObjectInfo struct {
        Name         string   `xml:"Key"`
        LastModified string   `xml:"LastModified"`
        ETag         string   `xml:"ETag"`
        Size         int64    `xml:"Size"`
        StorageClass string   `xml:"StorageClass"`
        Owner        *s3Owner `xml:"Owner,omitempty"`
}

type s3ObjectList struct {
        XMLName               xml.Name       `xml:"ListBucketResult"`
        Xmlns                 string         `xml:"xmlns,attr"`
        Name                  string         `xml:"Name"`
        Prefix                string         `xml:"Prefix"`
        Marker                string         `xml:"Marker"`
        NextMarker            string         `xml:"NextMarker"`
        MaxKeys               int            `xml:"MaxKeys"`
        IsTruncated           bool           `xml:"IsTruncated"`
        ContinuationToken     string         `xml:"ContinuationToken,omitempty"`
        NextContinuationToken string         `xml:"NextContinationToken,omitempty"`
        StartAfter            string         `xml:"StartAfter,omitempty"`
        KeyCount              string         `xml:"KeyCount,omitempty"`
        Objects               []s3ObjectInfo `xml:"Contents"`
}

func NewS3ObjectList() *s3ObjectList <span class="cov0" title="0">{
        return &amp;s3ObjectList{Xmlns: s3Xmlns}
}</span>

type s3CopyObject struct {
        XMLName      xml.Name `xml:"CopyObjectResult"`
        LastModified string   `xml:"LastModified"`
        ETag         string   `xml:"ETag"`
}

type s3Error struct {
        XMLName   xml.Name `xml:"Error"`
        Code      string   `xml:"Code"`
        Message   string   `xml:"Message"`
        Resource  string   `xml:"Resource"`
        RequestId string   `xml:"RequestId"`
}

func NewS3Error() *s3Error <span class="cov0" title="0">{
        return &amp;s3Error{}
}</span>

// This will wrap http.ResponseWriter to support s3 style xml responses on errors
// TODO: This may still need some work for more specific error responses
type s3ResponseWriterWrapper struct {
        writer    http.ResponseWriter
        hijack    bool
        resource  string
        requestId string
        msg       []byte
}

func newS3ResponseWriterWrapper(w http.ResponseWriter, r *http.Request) *s3ResponseWriterWrapper <span class="cov0" title="0">{
        ctx := GetProxyContext(r)
        return &amp;s3ResponseWriterWrapper{
                writer:    w,
                hijack:    false,
                resource:  r.URL.Path,
                requestId: ctx.TxId,
        }
}</span>

func (w *s3ResponseWriterWrapper) Header() http.Header <span class="cov0" title="0">{
        return w.writer.Header()
}</span>

func (w *s3ResponseWriterWrapper) WriteHeader(statusCode int) <span class="cov0" title="0">{
        if statusCode/100 != 2 </span><span class="cov0" title="0">{
                // We are going to hijack to return an S3 style result
                w.hijack = true
                if statusCode == 401 </span><span class="cov0" title="0">{
                        statusCode = 403 // S3 returns 403 instead of 401
                }</span>
                <span class="cov0" title="0">msg := NewS3Error()
                msg.Code = s3Responses[statusCode].Code
                msg.Message = s3Responses[statusCode].Message
                msg.Resource = w.resource
                msg.RequestId = w.requestId
                output, err := xml.MarshalIndent(msg, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        w.hijack = false
                        w.WriteHeader(500)
                }</span>
                <span class="cov0" title="0">output = []byte(xml.Header + string(output))
                headers := w.writer.Header()
                headers.Set("Content-Type", "application/xml; charset=utf-8")
                headers.Set("Content-Length", strconv.Itoa(len(output)))
                w.msg = output</span>
        }
        <span class="cov0" title="0">w.writer.WriteHeader(statusCode)</span>
}

func (w *s3ResponseWriterWrapper) Write(buf []byte) (int, error) <span class="cov0" title="0">{
        if !w.hijack </span><span class="cov0" title="0">{
                return w.writer.Write(buf)
        }</span> else<span class="cov0" title="0"> {
                n, err := w.writer.Write(w.msg)
                return n, err
        }</span>
}

type s3ApiHandler struct {
        next           http.Handler
        ctx            *ProxyContext
        account        string
        container      string
        object         string
        path           string
        signature      string
        requestsMetric tally.Counter
}

func s3PathSplit(path string) (string, string) <span class="cov0" title="0">{
        if len(path) &gt; 0 &amp;&amp; !strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                path = "/" + path
        }</span>
        <span class="cov0" title="0">parts := strings.SplitN(path, "/", 3)
        switch len(parts) </span>{
        case 3:<span class="cov0" title="0">
                return parts[1], parts[2]</span>
        case 2:<span class="cov0" title="0">
                return parts[1], ""</span>
        default:<span class="cov0" title="0">
                return "", ""</span>
        }
}

func (s *s3ApiHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        ctx := GetProxyContext(request)
        // Check if this is an S3 request
        if ctx.S3Auth == nil || strings.HasPrefix(strings.ToLower(request.URL.Path), "/v1/") </span><span class="cov0" title="0">{
                // Not an S3 request
                s.next.ServeHTTP(writer, request)
                return
        }</span>

        <span class="cov0" title="0">s.container, s.object = s3PathSplit(request.URL.Path)
        s.account = ctx.S3Auth.Account

        // TODO: Validate the container
        // Generate the hbird api path
        if s.object != "" </span><span class="cov0" title="0">{
                s.path = fmt.Sprintf("/v1/AUTH_%s/%s/%s", s.account, s.container, s.object)
        }</span> else<span class="cov0" title="0"> if s.container != "" </span><span class="cov0" title="0">{
                s.path = fmt.Sprintf("/v1/AUTH_%s/%s", s.account, s.container)
        }</span> else<span class="cov0" title="0"> {
                s.path = fmt.Sprintf("/v1/AUTH_%s", s.account)
        }</span>
        // TODO: Handle metadata?

        <span class="cov0" title="0">if s.object != "" </span><span class="cov0" title="0">{
                s.handleObjectRequest(writer, request)
                return
        }</span> else<span class="cov0" title="0"> if s.container != "" </span><span class="cov0" title="0">{
                s.handleContainerRequest(writer, request)
                return
        }</span> else<span class="cov0" title="0"> {
                s.handleAccountRequest(writer, request)
                return
        }</span>
}

func (s *s3ApiHandler) handleObjectRequest(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        ctx := GetProxyContext(request)

        if request.Method == "GET" || request.Method == "HEAD" </span><span class="cov0" title="0">{
                newReq, err := ctx.newSubrequest(request.Method, s.path, http.NoBody, request, "s3api")
                if err != nil </span><span class="cov0" title="0">{
                        srv.SimpleErrorResponse(writer, http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">newReq.Header.Set("Range", request.Header.Get("Range"))
                newReq.Header.Set("If-Match", request.Header.Get("If-Match"))
                newReq.Header.Set("If-None-Match", request.Header.Get("If-None-Match"))
                newReq.Header.Set("If-Modified-Since", request.Header.Get("If-Modified-Since"))
                newReq.Header.Set("If-UnModified-Since", request.Header.Get("If-UnModified-Since"))
                ctx.serveHTTPSubrequest(writer, newReq)
                return</span>
        }

        <span class="cov0" title="0">if request.Method == "DELETE" </span><span class="cov0" title="0">{
                newReq, err := ctx.newSubrequest("DELETE", s.path, http.NoBody, request, "s3api")
                if err != nil </span><span class="cov0" title="0">{
                        srv.SimpleErrorResponse(writer, http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">cap := NewCaptureWriter()
                ctx.serveHTTPSubrequest(cap, newReq)
                if cap.status/100 != 2 </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, cap.status)
                        return
                }</span> else<span class="cov0" title="0"> {
                        writer.WriteHeader(204)
                        return
                }</span>
        }

        <span class="cov0" title="0">if request.Method == "PUT" </span><span class="cov0" title="0">{
                method := "PUT"
                dest := ""
                // Check to see if this is a copy request
                copySource := request.Header.Get("X-Amz-Copy-Source")
                if copySource != "" </span><span class="cov0" title="0">{
                        method = "COPY"
                        dest = s.path
                        c, o := s3PathSplit(copySource)
                        s.path = fmt.Sprintf("/v1/AUTH_%s/%s/%s", s.account, c, o)
                }</span>
                <span class="cov0" title="0">newReq, err := ctx.newSubrequest(method, s.path, request.Body, request, "s3api")
                if err != nil </span><span class="cov0" title="0">{
                        srv.SimpleErrorResponse(writer, http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">if copySource != "" </span><span class="cov0" title="0">{
                        pathMap, err := common.ParseProxyPath(dest)
                        if err != nil </span><span class="cov0" title="0">{
                                srv.SimpleErrorResponse(writer, http.StatusInternalServerError, err.Error())
                        }</span>
                        <span class="cov0" title="0">newReq.Header.Set("Destination", fmt.Sprintf("/%s/%s", pathMap["container"], pathMap["object"]))</span>
                }
                <span class="cov0" title="0">newReq.Header.Set("Content-Length", request.Header.Get("Content-Length"))
                newReq.Header.Set("Content-Type", request.Header.Get("Content-Type"))
                cap := NewCaptureWriter()
                ctx.serveHTTPSubrequest(cap, newReq)
                if cap.status/100 != 2 </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, cap.status)
                        return
                }</span> else<span class="cov0" title="0"> {
                        if copySource != "" </span><span class="cov0" title="0">{
                                copyResult := &amp;s3CopyObject{}
                                copyResult.ETag = "\"" + cap.Header().Get("ETag") + "\""
                                copyResult.LastModified = cap.Header().Get("Last-Modified")
                                output, err := xml.MarshalIndent(copyResult, "", "  ")
                                if err != nil </span><span class="cov0" title="0">{
                                        srv.SimpleErrorResponse(writer, http.StatusInternalServerError, err.Error())
                                        return
                                }</span>
                                <span class="cov0" title="0">output = []byte(xml.Header + string(output))
                                writer.WriteHeader(200)
                                writer.Write(output)</span>
                        } else<span class="cov0" title="0"> {
                                writer.Header().Set("ETag", "\""+cap.Header().Get("ETag")+"\"")
                                writer.Header().Set("Content-Length", cap.Header().Get("Content-Length"))
                                writer.WriteHeader(200)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
        }

        <span class="cov0" title="0">if request.Method == "POST" </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, http.StatusNotImplemented)
                return
        }</span>

        // If we didn't get to anything, then return method not allowed
        <span class="cov0" title="0">srv.StandardResponse(writer, http.StatusMethodNotAllowed)</span>
}

func (s *s3ApiHandler) handleContainerRequest(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        ctx := GetProxyContext(request)

        if request.Method == "HEAD" </span><span class="cov0" title="0">{
                newReq, err := ctx.newSubrequest("HEAD", s.path, http.NoBody, request, "s3api")
                if err != nil </span><span class="cov0" title="0">{
                        srv.SimpleErrorResponse(writer, http.StatusInternalServerError, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">cap := NewCaptureWriter()
                ctx.serveHTTPSubrequest(cap, newReq)
                if cap.status/100 != 2 </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, cap.status)
                        return
                }</span> else<span class="cov0" title="0"> {
                        writer.WriteHeader(200)
                        return
                }</span>
        }

        <span class="cov0" title="0">if request.Method == "DELETE" </span><span class="cov0" title="0">{
                newReq, err := ctx.newSubrequest("DELETE", s.path, http.NoBody, request, "s3api")
                if err != nil </span><span class="cov0" title="0">{
                        srv.SimpleErrorResponse(writer, http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">cap := NewCaptureWriter()
                ctx.serveHTTPSubrequest(cap, newReq)
                if cap.status/100 != 2 </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, cap.status)
                        return
                }</span> else<span class="cov0" title="0"> {
                        writer.WriteHeader(204)
                        return
                }</span>
        }

        <span class="cov0" title="0">if request.Method == "PUT" </span><span class="cov0" title="0">{
                newReq, err := ctx.newSubrequest("PUT", s.path, http.NoBody, request, "s3api")
                if err != nil </span><span class="cov0" title="0">{
                        srv.SimpleErrorResponse(writer, http.StatusInternalServerError, err.Error())
                }</span>
                <span class="cov0" title="0">cap := NewCaptureWriter()
                ctx.serveHTTPSubrequest(cap, newReq)
                if cap.status/100 != 2 </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, cap.status)
                        return
                }</span> else<span class="cov0" title="0"> {
                        writer.WriteHeader(200)
                        return
                }</span>
        }

        <span class="cov0" title="0">if request.Method == "GET" </span><span class="cov0" title="0">{
                q := request.URL.Query()
                maxKeys, err := strconv.Atoi(q.Get("max-keys"))
                if err != nil </span><span class="cov0" title="0">{
                        maxKeys = 1000
                }</span>
                <span class="cov0" title="0">newReq, err := ctx.newSubrequest("GET", s.path, http.NoBody, request, "s3api")
                if err != nil </span><span class="cov0" title="0">{
                        srv.SimpleErrorResponse(writer, http.StatusInternalServerError, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">newReq.Header.Set("Accept", "application/json")
                nq := newReq.URL.Query()
                nq.Set("limit", strconv.Itoa(maxKeys+1))
                ver := q.Get("list-type")
                marker := q.Get("marker")
                prefix := q.Get("prefix")
                delimeter := q.Get("delimeter")
                fetchOwner := false
                if ver == "2" </span><span class="cov0" title="0">{
                        marker = q.Get("start-after")
                        cont := q.Get("continuation-token")
                        if cont != "" </span><span class="cov0" title="0">{
                                if b, err := base64.StdEncoding.DecodeString(cont); err == nil </span><span class="cov0" title="0">{
                                        marker = string(b)
                                }</span>
                        }
                        <span class="cov0" title="0">fetchOwner, err = strconv.ParseBool(q.Get("fetch-owner"))
                        if err != nil </span><span class="cov0" title="0">{
                                fetchOwner = false
                        }</span>
                }
                <span class="cov0" title="0">if marker != "" </span><span class="cov0" title="0">{
                        nq.Set("marker", marker)
                }</span>
                <span class="cov0" title="0">if prefix != "" </span><span class="cov0" title="0">{
                        nq.Set("prefix", prefix)
                }</span>
                <span class="cov0" title="0">if delimeter != "" </span><span class="cov0" title="0">{
                        nq.Set("delimiter", delimeter)
                }</span>
                <span class="cov0" title="0">cap := NewCaptureWriter()
                newReq.URL.RawQuery = nq.Encode()
                ctx.serveHTTPSubrequest(cap, newReq)
                if cap.status/100 != 2 </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, cap.status)
                        return
                }</span>
                <span class="cov0" title="0">objectListing := []containerserver.ObjectListingRecord{}
                err = json.Unmarshal(cap.body, &amp;objectListing)
                if err != nil </span><span class="cov0" title="0">{
                        srv.SimpleErrorResponse(writer, http.StatusInternalServerError, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">truncated := maxKeys &gt; 0 &amp;&amp; len(objectListing) &gt; maxKeys
                if len(objectListing) &gt; maxKeys </span><span class="cov0" title="0">{
                        objectListing = objectListing[:maxKeys]
                }</span>
                <span class="cov0" title="0">objectList := NewS3ObjectList()
                objectList.Name = s.container
                objectList.MaxKeys = maxKeys
                objectList.IsTruncated = truncated
                objectList.Marker = marker
                objectList.Prefix = prefix
                if ver == "2" </span><span class="cov0" title="0">{
                        if truncated </span><span class="cov0" title="0">{
                                objectList.NextContinuationToken = base64.StdEncoding.EncodeToString([]byte(objectListing[len(objectListing)].Name))
                        }</span>
                        <span class="cov0" title="0">objectList.ContinuationToken = q.Get("continuation-token")
                        objectList.StartAfter = q.Get("start-after")
                        objectList.KeyCount = strconv.Itoa(len(objectListing))</span>
                } else<span class="cov0" title="0"> {
                        if truncated &amp;&amp; delimeter != "" </span><span class="cov0" title="0">{
                                objectList.NextMarker = objectListing[len(objectListing)].Name
                        }</span>
                }
                <span class="cov0" title="0">for _, o := range objectListing </span><span class="cov0" title="0">{
                        obj := s3ObjectInfo{
                                Name:         o.Name,
                                LastModified: o.LastModified + "Z",
                                ETag:         "\"" + o.ETag + "\"",
                                Size:         o.Size,
                                StorageClass: "STANDARD",
                        }
                        if fetchOwner || ver != "2" </span><span class="cov0" title="0">{
                                obj.Owner = &amp;s3Owner{
                                        ID:          ctx.S3Auth.Account,
                                        DisplayName: ctx.S3Auth.Account,
                                }
                        }</span>
                        <span class="cov0" title="0">objectList.Objects = append(objectList.Objects, obj)</span>
                }
                <span class="cov0" title="0">output, err := xml.MarshalIndent(objectList, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        srv.SimpleErrorResponse(writer, http.StatusInternalServerError, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">output = []byte(xml.Header + string(output))
                headers := writer.Header()
                headers.Set("Content-Type", "application/xml; charset=utf-8")
                headers.Set("Content-Length", strconv.Itoa(len(output)))
                writer.WriteHeader(200)
                writer.Write(output)
                return</span>

        }
        // If we didn't get to anything, then return method not allowed
        <span class="cov0" title="0">srv.StandardResponse(writer, http.StatusMethodNotAllowed)</span>
}

func (s *s3ApiHandler) handleAccountRequest(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        ctx := GetProxyContext(request)
        if request.Method == "GET" </span><span class="cov0" title="0">{
                newReq, err := ctx.newSubrequest("GET", s.path, http.NoBody, request, "s3api")
                if err != nil </span><span class="cov0" title="0">{
                        srv.SimpleErrorResponse(writer, http.StatusInternalServerError, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">newReq.Header.Set("Accept", "application/json")
                cap := NewCaptureWriter()
                ctx.serveHTTPSubrequest(cap, newReq)
                if cap.status/100 != 2 </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, cap.status)
                        return
                }</span>
                <span class="cov0" title="0">containerListing := []accountserver.ContainerListingRecord{}
                err = json.Unmarshal(cap.body, &amp;containerListing)
                if err != nil </span><span class="cov0" title="0">{
                        srv.SimpleErrorResponse(writer, http.StatusInternalServerError, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">bucketList := NewS3BucketList()
                bucketList.Owner.ID = ctx.S3Auth.Account
                bucketList.Owner.DisplayName = ctx.S3Auth.Account
                // NOTE: The container list api doesn't have a creation date for the container, so we use an "arbitrary" date.
                for _, c := range containerListing </span><span class="cov0" title="0">{
                        bucketList.Buckets = append(bucketList.Buckets, s3BucketInfo{
                                Name:         c.Name,
                                CreationDate: "2009-02-03T16:45:09.000Z",
                        })
                }</span>
                <span class="cov0" title="0">output, err := xml.MarshalIndent(bucketList, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        srv.SimpleErrorResponse(writer, http.StatusInternalServerError, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">output = []byte(xml.Header + string(output))
                headers := writer.Header()
                headers.Set("Content-Type", "application/xml; charset=utf-8")
                headers.Set("Content-Length", strconv.Itoa(len(output)))
                writer.WriteHeader(200)
                writer.Write(output)
                return</span>

        }

        // If we didn't get to anything, then return method not allowed
        <span class="cov0" title="0">srv.StandardResponse(writer, http.StatusMethodNotAllowed)</span>
}

func NewS3Api(config conf.Section, metricsScope tally.Scope) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        enabled, ok := config.Section["enabled"]
        if !ok || strings.Compare(strings.ToLower(enabled), "false") == 0 </span><span class="cov0" title="0">{
                // s3api is disabled, so pass the request on
                return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                        return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                                next.ServeHTTP(writer, request)
                        }</span>)
                }, nil
        }
        <span class="cov0" title="0">RegisterInfo("s3Api", map[string]interface{}{})
        return s3Api(metricsScope.Counter("s3Api_requests")), nil</span>
}

func s3Api(requestsMetric tally.Counter) func(next http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                        (&amp;s3ApiHandler{next: next, requestsMetric: requestsMetric}).ServeHTTP(writer, request)
                }</span>)
        }
}
</pre>
		
		<pre class="file" id="file101" style="display: none">//  Copyright (c) 2018 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "bytes"
        "crypto/hmac"
        "crypto/sha1"
        "encoding/base64"
        "fmt"
        "net/http"
        "sort"
        "strings"

        "github.com/troubling/hummingbird/common/conf"
        "github.com/uber-go/tally"
)

type S3AuthInfo struct {
        Key          string
        Signature    string
        StringToSign string
        Account      string
}

func (s *S3AuthInfo) validateSignature(secret []byte) bool <span class="cov0" title="0">{
        // S3 Auth signature V2 Validation
        mac := hmac.New(sha1.New, secret)
        mac.Write([]byte(s.StringToSign))
        sig1 := mac.Sum(nil)
        sig2, err := base64.StdEncoding.DecodeString(s.Signature)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        // TODO: Add support for constat time compare
        <span class="cov0" title="0">return hmac.Equal(sig1, sig2)</span>
}

type s3AuthHandler struct {
        next           http.Handler
        ctx            *ProxyContext
        requestsMetric tally.Counter
}

func (s *s3AuthHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        ctx := GetProxyContext(request)
        // Check if this is an S3 request
        var key, signature string
        authStr := request.Header.Get("Authorization")
        if authStr == "" </span><span class="cov0" title="0">{
                authStr = request.Form.Get("AWSAccessKeyId")
        }</span>
        <span class="cov0" title="0">if authStr != "" </span><span class="cov0" title="0">{
                authStr = strings.TrimPrefix(authStr, "AWS ")
                i := strings.LastIndex(authStr, ":")
                if i &lt; 0 </span><span class="cov0" title="0">{
                        ctx.Authorize = func(r *http.Request) (bool, int) </span><span class="cov0" title="0">{
                                return false, http.StatusForbidden
                        }</span>
                        <span class="cov0" title="0">s.next.ServeHTTP(writer, request)
                        return</span>
                }
                <span class="cov0" title="0">key = authStr[0:i]
                signature = authStr[i+1:]</span>
        }
        <span class="cov0" title="0">if authStr == "" </span><span class="cov0" title="0">{
                // Check params for auth info
                key = request.FormValue("AWSAccessKeyId")
                signature = request.FormValue("Signature")
        }</span>
        <span class="cov0" title="0">if key == "" || signature == "" || ctx.S3Auth != nil </span><span class="cov0" title="0">{
                // Not an S3 request or already processed
                s.next.ServeHTTP(writer, request)
                return
        }</span>

        // Wrap the writer so that we can capture errors and send correct S3 style responses
        <span class="cov0" title="0">writer = newS3ResponseWriterWrapper(writer, request)

        // TODO: Handle parameter style auth
        // TODO: Handle V2 signature validation
        // Setup the string to be signed
        var buf bytes.Buffer
        buf.WriteString(request.Method)
        buf.WriteString("\n")
        buf.WriteString(request.Header.Get("Content-MD5"))
        buf.WriteString("\n")
        buf.WriteString(request.Header.Get("Content-Type"))
        buf.WriteString("\n")
        if request.Header.Get("x-amz-date") != "" </span><span class="cov0" title="0">{
                buf.WriteString("\n")
        }</span> else<span class="cov0" title="0"> {
                buf.WriteString(request.Header.Get("Date"))
                buf.WriteString("\n")
        }</span>
        <span class="cov0" title="0">akeys := make([]string, 0)
        for k := range request.Header </span><span class="cov0" title="0">{
                if strings.HasPrefix(strings.ToLower(k), "x-amz-") </span><span class="cov0" title="0">{
                        akeys = append(akeys, k)
                }</span>
        }
        // the headers need to be in sorted order before signing
        <span class="cov0" title="0">sort.Strings(akeys)
        for _, k := range akeys </span><span class="cov0" title="0">{
                for _, v := range request.Header[k] </span><span class="cov0" title="0">{
                        buf.WriteString(fmt.Sprintf("%s:%s", strings.ToLower(k), v))
                        buf.WriteString("\n")
                }</span>
        }
        // NOTE: The following is for V2 Auth

        <span class="cov0" title="0">buf.WriteString(request.URL.Path)
        ctx.S3Auth = &amp;S3AuthInfo{
                StringToSign: buf.String(),
                Key:          key,
                Signature:    signature,
        }

        // TODO: Handle V4 signature validation

        s.next.ServeHTTP(writer, request)</span>
}

func NewS3Auth(config conf.Section, metricsScope tally.Scope) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        enabled, ok := config.Section["enabled"]
        if !ok || strings.Compare(strings.ToLower(enabled), "false") == 0 </span><span class="cov0" title="0">{
                // s3api is disabled, so pass the request on
                return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                        return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                                next.ServeHTTP(writer, request)
                        }</span>)
                }, nil
        }
        <span class="cov0" title="0">RegisterInfo("s3Auth", map[string]interface{}{})
        return s3Auth(metricsScope.Counter("s3Auth_requests")), nil</span>
}

func s3Auth(requestsMetric tally.Counter) func(next http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                        (&amp;s3AuthHandler{next: next, requestsMetric: requestsMetric}).ServeHTTP(writer, request)
                }</span>)
        }
}
</pre>
		
		<pre class="file" id="file102" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "bytes"
        "encoding/json"
        "fmt"
        "html"
        "io"
        "math"
        "net/http"
        "net/http/httptest"
        "net/url"
        "strings"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/uber-go/tally"
)

func NewStaticWeb(config conf.Section, metricsScope tally.Scope) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        RegisterInfo("staticweb", map[string]interface{}{})
        return staticWeb(metricsScope), nil
}</span>

func staticWeb(metricsScope tally.Scope) func(next http.Handler) http.Handler <span class="cov0" title="0">{
        requestsMetric := metricsScope.Counter("staticweb_requests")
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                        (&amp;staticWebHandler{next: next, requestsMetric: requestsMetric}).ServeHTTP(writer, request)
                }</span>)
        }
}

type staticWebHandler struct {
        next             http.Handler
        ctx              *ProxyContext
        account          string
        container        string
        object           string
        webIndex         string
        webError         string
        webListings      bool
        webListingsLabel string
        webListingsCSS   string
        webDirType       string
        requestsMetric   tally.Counter
}

func (s *staticWebHandler) ServeHTTP(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        if request.Method != "GET" &amp;&amp; request.Method != "HEAD" </span><span class="cov0" title="0">{
                s.next.ServeHTTP(writer, request)
                return
        }</span>
        <span class="cov8" title="1">s.ctx = GetProxyContext(request)
        if s.ctx.Source == "staticweb" </span><span class="cov8" title="1">{
                s.next.ServeHTTP(writer, request)
                return
        }</span>
        <span class="cov8" title="1">if len(s.ctx.RemoteUsers) != 0 &amp;&amp; !common.LooksTrue(request.Header.Get("X-Web-Mode")) </span><span class="cov0" title="0">{
                s.next.ServeHTTP(writer, request)
                return
        }</span>
        <span class="cov8" title="1">var apiReq bool
        apiReq, s.account, s.container, s.object = getPathParts(request)
        if !apiReq || s.account == "" || s.container == "" </span><span class="cov0" title="0">{
                s.next.ServeHTTP(writer, request)
                return
        }</span>
        <span class="cov8" title="1">ci, err := s.ctx.C.GetContainerInfo(request.Context(), s.account, s.container)
        if err != nil </span><span class="cov8" title="1">{
                s.next.ServeHTTP(writer, request)
                return
        }</span>
        // If no staticweb-related metadata exists, treat as a plain public container.
        <span class="cov8" title="1">anythingSet := false
        for _, h := range []string{"Web-Index", "Web-Error", "Web-Listings", "Web-Listings-Label", "Web-Listings-Css", "Web-Directory-Type"} </span><span class="cov8" title="1">{
                if _, ok := ci.Metadata[h]; ok </span><span class="cov8" title="1">{
                        anythingSet = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !anythingSet </span><span class="cov0" title="0">{
                s.next.ServeHTTP(writer, request)
                return
        }</span>
        <span class="cov8" title="1">s.webIndex = strings.TrimSpace(ci.Metadata["Web-Index"])
        s.webError = strings.TrimSpace(ci.Metadata["Web-Error"])
        s.webListings = common.LooksTrue(strings.TrimSpace(ci.Metadata["Web-Listings"]))
        s.webListingsLabel = strings.TrimSpace(ci.Metadata["Web-Listings-Label"])
        s.webListingsCSS = strings.TrimSpace(ci.Metadata["Web-Listings-Css"])
        s.webDirType = strings.TrimSpace(ci.Metadata["Web-Directory-Type"])
        if s.webDirType == "" </span><span class="cov8" title="1">{
                s.webDirType = "application/directory"
        }</span>
        <span class="cov8" title="1">s.ctx.ACL = ci.ReadACL
        if s.ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, st := s.ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, st)
                        return
                }</span>
        }
        <span class="cov8" title="1">s.requestsMetric.Inc(1)
        if s.object != "" </span><span class="cov8" title="1">{
                s.handleObject(writer, request)
                return
        }</span>
        <span class="cov8" title="1">s.handleDirectory(writer, request)</span>
}

func (s *staticWebHandler) handleObject(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        subreq, err := s.ctx.newSubrequest("HEAD", request.URL.Path, nil, request, "staticweb")
        if err != nil </span><span class="cov0" title="0">{
                s.handleError(writer, request, http.StatusInternalServerError, err)
                return
        }</span>
        <span class="cov8" title="1">subrec := httptest.NewRecorder()
        s.ctx.serveHTTPSubrequest(subrec, subreq)
        subresp := subrec.Result()
        if subresp.StatusCode &gt;= 200 &amp;&amp; subresp.StatusCode &lt;= 399 </span><span class="cov8" title="1">{
                if subresp.Header.Get("Content-Type") == s.webDirType &amp;&amp; subresp.ContentLength &lt;= 1 </span><span class="cov0" title="0">{
                        s.handleDirectory(writer, request)
                        return
                }</span>
                <span class="cov8" title="1">s.next.ServeHTTP(writer, request)
                return</span>
        }
        <span class="cov8" title="1">if subresp.StatusCode != http.StatusNotFound </span><span class="cov8" title="1">{
                s.handleError(writer, request, subresp.StatusCode, nil)
                return
        }</span>
        <span class="cov8" title="1">s.handleDirectory(writer, request)</span>
}

func (s *staticWebHandler) handleDirectory(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        if s.webIndex == "" &amp;&amp; !s.webListings </span><span class="cov8" title="1">{
                s.handleError(writer, request, http.StatusNotFound, nil)
                return
        }</span>
        <span class="cov8" title="1">if !strings.HasSuffix(request.URL.Path, "/") </span><span class="cov8" title="1">{
                if s.webIndex != "" </span><span class="cov8" title="1">{
                        subreq, err := s.ctx.newSubrequest("HEAD", request.URL.Path+"/"+s.webIndex, nil, request, "staticweb")
                        if err != nil </span><span class="cov0" title="0">{
                                s.handleError(writer, request, http.StatusInternalServerError, err)
                                return
                        }</span>
                        <span class="cov8" title="1">subrec := httptest.NewRecorder()
                        s.ctx.serveHTTPSubrequest(subrec, subreq)
                        subresp := subrec.Result()
                        if subresp.StatusCode &gt;= 200 &amp;&amp; subresp.StatusCode &lt;= 399 </span><span class="cov8" title="1">{
                                writer.Header().Set("Location", request.URL.Path+"/")
                                srv.StandardResponse(writer, http.StatusMovedPermanently)
                                return
                        }</span>
                }
                <span class="cov8" title="1">if s.webListings </span><span class="cov8" title="1">{
                        if s.object == "" </span><span class="cov8" title="1">{
                                writer.Header().Set("Location", request.URL.Path+"/")
                                srv.StandardResponse(writer, http.StatusMovedPermanently)
                                return
                        }</span>
                        <span class="cov8" title="1">subreq, err := s.ctx.newSubrequest("GET", fmt.Sprintf("/v1/%s/%s?limit=1&amp;format=json&amp;delimiter=/&amp;prefix=%s/", url.PathEscape(s.account), url.PathEscape(s.container), url.QueryEscape(s.object)), nil, request, "staticweb")
                        if err != nil </span><span class="cov0" title="0">{
                                s.handleError(writer, request, http.StatusInternalServerError, err)
                                return
                        }</span>
                        <span class="cov8" title="1">subrec := httptest.NewRecorder()
                        s.ctx.serveHTTPSubrequest(subrec, subreq)
                        subresp := subrec.Result()
                        if subresp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                                s.handleError(writer, request, subresp.StatusCode, nil)
                                return
                        }</span>
                        <span class="cov8" title="1">listing := make([]struct{}, 0)
                        if err = json.NewDecoder(subresp.Body).Decode(&amp;listing); err != nil </span><span class="cov0" title="0">{
                                if err == io.EOF </span><span class="cov0" title="0">{
                                        s.handleError(writer, request, http.StatusNotFound, err)
                                }</span> else<span class="cov0" title="0"> {
                                        s.handleError(writer, request, http.StatusInternalServerError, err)
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                        <span class="cov8" title="1">if len(listing) == 0 </span><span class="cov8" title="1">{
                                s.handleError(writer, request, http.StatusNotFound, nil)
                                return
                        }</span>
                        <span class="cov8" title="1">writer.Header().Set("Location", request.URL.Path+"/")
                        srv.StandardResponse(writer, http.StatusMovedPermanently)
                        return</span>
                }
                <span class="cov0" title="0">s.handleError(writer, request, http.StatusNotFound, nil)
                return</span>
        }
        <span class="cov8" title="1">if s.webIndex != "" </span><span class="cov8" title="1">{
                subreq, err := s.ctx.newSubrequest("HEAD", request.URL.Path+s.webIndex, nil, request, "staticweb")
                if err != nil </span><span class="cov0" title="0">{
                        s.handleError(writer, request, http.StatusInternalServerError, err)
                        return
                }</span>
                <span class="cov8" title="1">subrec := httptest.NewRecorder()
                s.ctx.serveHTTPSubrequest(subrec, subreq)
                subresp := subrec.Result()
                if subresp.StatusCode/100 == 2 </span><span class="cov8" title="1">{
                        subreq, err := s.ctx.newSubrequest(request.Method, request.URL.Path+s.webIndex, request.Body, request, "staticweb")
                        if err != nil </span><span class="cov0" title="0">{
                                s.handleError(writer, request, http.StatusInternalServerError, err)
                                return
                        }</span>
                        <span class="cov8" title="1">for k, v := range request.Header </span><span class="cov0" title="0">{
                                subreq.Header[k] = v
                        }</span>
                        <span class="cov8" title="1">s.ctx.serveHTTPSubrequest(writer, subreq)
                        return</span>
                } else<span class="cov8" title="1"> if subresp.StatusCode != http.StatusNotFound </span><span class="cov0" title="0">{
                        s.handleError(writer, request, subresp.StatusCode, nil)
                        return
                }</span>
        }
        <span class="cov8" title="1">label := request.URL.Path
        if s.webListingsLabel != "" </span><span class="cov0" title="0">{
                label = s.webListingsLabel + "/" + s.object
        }</span>
        <span class="cov8" title="1">css := defaultCSS
        if s.webListingsCSS != "" </span><span class="cov8" title="1">{
                path := s.webListingsCSS
                if !strings.HasPrefix(s.webListingsCSS, "/") &amp;&amp; !strings.HasPrefix(s.webListingsCSS, "http://") &amp;&amp; !strings.HasPrefix(s.webListingsCSS, "https://") </span><span class="cov8" title="1">{
                        path = ""
                        for i := strings.Count(s.webListingsCSS, "/"); i &gt; 0; i-- </span><span class="cov0" title="0">{
                                path += "../"
                        }</span>
                        <span class="cov8" title="1">path += s.webListingsCSS</span>
                }
                <span class="cov8" title="1">css = fmt.Sprintf(`&lt;link rel="stylesheet" type="text/css" href="%s" /&gt;`, path)</span>
        }
        <span class="cov8" title="1">if !s.webListings </span><span class="cov8" title="1">{
                webIndexNote := ""
                if s.webIndex != "" </span><span class="cov8" title="1">{
                        webIndexNote = fmt.Sprintf(webIndexNoteHTML, html.EscapeString(s.webIndex))
                }</span>
                <span class="cov8" title="1">body := fmt.Sprintf(disabledListingHTML, html.EscapeString(label), css, webIndexNote)
                writer.Header().Set("Content-Type", "text/html")
                writer.Header().Set("Content-Length", fmt.Sprintf("%d", len(body)))
                writer.WriteHeader(http.StatusNotFound)
                writer.Write([]byte(body))
                return</span>
        }
        <span class="cov8" title="1">listingPath := fmt.Sprintf("/v1/%s/%s?format=json&amp;delimiter=/", url.PathEscape(s.account), url.PathEscape(s.container))
        if s.object != "" </span><span class="cov8" title="1">{
                listingPath += fmt.Sprintf("&amp;prefix=%s", url.QueryEscape(s.object))
        }</span>
        <span class="cov8" title="1">subreq, err := s.ctx.newSubrequest("GET", listingPath, nil, request, "staticweb")
        if err != nil </span><span class="cov0" title="0">{
                s.handleError(writer, request, http.StatusInternalServerError, err)
                return
        }</span>
        <span class="cov8" title="1">subrec := httptest.NewRecorder()
        s.ctx.serveHTTPSubrequest(subrec, subreq)
        subresp := subrec.Result()
        if subresp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                s.handleError(writer, request, subresp.StatusCode, nil)
                return
        }</span>
        <span class="cov8" title="1">type entry struct {
                Name         string `json:"name"`
                ContentType  string `json:"content_type"`
                Bytes        int    `json:"bytes"`
                LastModified string `json:"last_modified"`
                Subdir       string `json:"subdir"`
        }
        listing := make([]*entry, 0)
        if err = json.NewDecoder(subresp.Body).Decode(&amp;listing); err != nil </span><span class="cov0" title="0">{
                if err == io.EOF </span><span class="cov0" title="0">{
                        s.handleError(writer, request, http.StatusNotFound, err)
                }</span> else<span class="cov0" title="0"> {
                        s.handleError(writer, request, http.StatusInternalServerError, err)
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov8" title="1">if len(listing) == 0 </span><span class="cov0" title="0">{
                s.handleError(writer, request, http.StatusNotFound, nil)
                return
        }</span>
        <span class="cov8" title="1">var body bytes.Buffer
        fmt.Fprintf(&amp;body, preambleListingHTML, html.EscapeString(label), css, html.EscapeString(label))
        if s.object != "" </span><span class="cov8" title="1">{
                body.WriteString(`&lt;tr id="parent" class="item"&gt;&lt;td class="colname"&gt;&lt;a href="../"&gt;../&lt;/a&gt;&lt;/td&gt;&lt;td class="colsize"&gt;&amp;nbsp;&lt;/td&gt;&lt;td class="coldate"&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;`)
        }</span>
        <span class="cov8" title="1">for _, e := range listing </span><span class="cov8" title="1">{
                if e.Subdir == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">p := strings.TrimPrefix(e.Subdir, s.object)
                fmt.Fprintf(&amp;body, `&lt;tr class="item subdir"&gt;&lt;td class="colname"&gt;&lt;a href="%s"&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td class="colsize"&gt;&amp;nbsp;&lt;/td&gt;&lt;td class="coldate"&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;`, html.EscapeString(p), html.EscapeString(p))</span>
        }
        <span class="cov8" title="1">for _, e := range listing </span><span class="cov8" title="1">{
                if e.Subdir != "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">var c []string
                for _, s := range strings.Split(strings.ToLower(e.ContentType), "/") </span><span class="cov8" title="1">{
                        c = append(c, "type-"+s)
                }</span>
                <span class="cov8" title="1">p := strings.TrimPrefix(e.Name, s.object)
                m := strings.Replace(strings.Split(e.LastModified, ".")[0], "T", " ", 1)
                fmt.Fprintf(&amp;body, `&lt;tr class="item %s"&gt;&lt;td class="colname"&gt;&lt;a href="%s"&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td class="colsize"&gt;%s&lt;/td&gt;&lt;td class="coldate"&gt;%s&lt;/td&gt;&lt;/tr&gt;`, html.EscapeString(strings.Join(c, " ")), html.EscapeString(p), html.EscapeString(p), humanReadable(e.Bytes), html.EscapeString(m))</span>
        }
        <span class="cov8" title="1">body.WriteString(`&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;`)
        writer.Header().Set("Content-Type", "text/html")
        writer.Header().Set("Content-Length", fmt.Sprintf("%d", body.Len()))
        writer.WriteHeader(http.StatusOK)
        writer.Write(body.Bytes())</span>
}

const defaultCSS string = `
&lt;style type="text/css"&gt;
    h1 {font-size: 1em; font-weight: bold;}
    th {text-align: left; padding: 0px 1em 0px 1em;}
    td {padding: 0px 1em 0px 1em;}
    p {font-size: 2}
    a {text-decoration: none;}
&lt;/style&gt;
`

const disabledListingHTML string = `&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Listing of %s&lt;/title&gt;
        %s
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Web Listing Disabled&lt;/h1&gt;
        &lt;p&gt;The owner of this web site has disabled web listing.&lt;/p&gt;
        &lt;p&gt;If you are the owner of this web site, you can enableweb listing by setting X-Container-Meta-Web-Listings.&lt;/p&gt;
        %s
    &lt;/body&gt;
&lt;/html&gt;
`

const webIndexNoteHTML string = `
&lt;h1&gt;Index File Not Found&lt;/h1&gt;
&lt;p&gt;The owner of this web site has set &lt;b&gt;X-Container-Meta-Web-Index: %s&lt;/b&gt;. However, this file was not found.&lt;/p&gt;
`

const preambleListingHTML string = `&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Listing of %s&lt;/title&gt;
        %s
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1 id="title"&gt;Listing of %s&lt;/h1&gt;
        &lt;table id="listing"&gt;
            &lt;tr id="heading"&gt;
                &lt;th class="colname"&gt;Name&lt;/th&gt;
                &lt;th class="colsize"&gt;Size&lt;/th&gt;
                &lt;th class="coldate"&gt;Date&lt;/th&gt;
            &lt;/tr&gt;
`

func humanReadable(value int) string <span class="cov8" title="1">{
        v := float64(value)
        i := -1
        suffixes := "KMGTPEZY"
        for v &gt;= 1024 &amp;&amp; i+1 &lt; len(suffixes) </span><span class="cov0" title="0">{
                i += 1
                v = math.Floor(v/1024 + .5)
        }</span>
        <span class="cov8" title="1">if i == -1 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%d", int(v))
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%d%ci", int(v), suffixes[i])</span>
}

func (s *staticWebHandler) handleError(writer http.ResponseWriter, request *http.Request, status int, err error) <span class="cov8" title="1">{
        if s.webError == "" </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, status)
                return
        }</span>
        <span class="cov8" title="1">subBody, subHeader, subStatus := PipedGet(fmt.Sprintf("/v1/%s/%s/%d%s", url.PathEscape(s.account), url.PathEscape(s.container), status, s.webError), request, "staticweb", nil)
        if subBody != nil </span><span class="cov8" title="1">{
                defer subBody.Close()
        }</span>
        <span class="cov8" title="1">if subStatus/100 != 2 </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, status)
                return
        }</span>
        <span class="cov8" title="1">writer.Header().Set("Content-Type", subHeader.Get("Content-Type"))
        writer.Header().Set("Content-Length", subHeader.Get("Content-Length"))
        writer.WriteHeader(status)
        io.Copy(writer, subBody)</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">//  Copyright (c) 2015-2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "context"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/uber-go/tally"
        "go.uber.org/zap"
)

type testUser struct {
        Account   string
        Username  string
        Password  string
        Roles     []string
        Url       string
        AccountID string
}

type tempAuth struct {
        testUsers    []testUser
        resellers    []string
        reseller     string
        accountRules map[string]map[string][]string
        next         http.Handler
}

func (ta *tempAuth) getUser(account, user, key string) *testUser <span class="cov8" title="1">{
        for _, tu := range ta.testUsers </span><span class="cov8" title="1">{
                if tu.Account == account &amp;&amp; tu.Username == user &amp;&amp; tu.Password == key </span><span class="cov8" title="1">{
                        return &amp;tu
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (ta *tempAuth) getUserPassword(account, user string) string <span class="cov0" title="0">{
        for _, tu := range ta.testUsers </span><span class="cov0" title="0">{
                if tu.Account == account &amp;&amp; tu.Username == user </span><span class="cov0" title="0">{
                        return tu.Password
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

type cachedAuth struct {
        Groups  []string
        Expires int64
}

func (ta *tempAuth) getUserGroups(tu *testUser) []string <span class="cov8" title="1">{
        groups := []string{tu.Account, fmt.Sprintf("%s:%s", tu.Account, tu.Username)}
        isAdmin := false
        for _, r := range tu.Roles </span><span class="cov8" title="1">{
                if r == ".admin" </span><span class="cov8" title="1">{
                        isAdmin = true
                }</span> else<span class="cov0" title="0"> {
                        groups = append(groups, r)
                }</span>
        }
        <span class="cov8" title="1">if isAdmin </span><span class="cov8" title="1">{
                for _, r := range ta.resellers </span><span class="cov8" title="1">{
                        groups = append(groups, r+tu.Account)
                }</span>
                <span class="cov8" title="1">if tu.AccountID != "" &amp;&amp; !common.StringInSlice(tu.AccountID, groups) </span><span class="cov8" title="1">{
                        groups = append(groups, tu.AccountID)
                }</span>
        }
        <span class="cov8" title="1">return groups</span>
}

func (ta *tempAuth) getToken(ctx context.Context, proxyCtx *ProxyContext, user, account, password string) (*testUser, string) <span class="cov8" title="1">{
        var prevToken string
        var token string
        tUser := ta.getUser(account, user, password)
        if tUser == nil </span><span class="cov8" title="1">{
                return nil, ""
        }</span>
        <span class="cov8" title="1">userGroups := ta.getUserGroups(tUser)
        if err := proxyCtx.Cache.GetStructured(ctx, "authuser:"+user, &amp;prevToken); err == nil </span><span class="cov8" title="1">{
                var ca cachedAuth
                if err = proxyCtx.Cache.GetStructured(ctx, "auth:"+prevToken, &amp;ca); err == nil </span><span class="cov8" title="1">{
                        if ca.Expires &gt; time.Now().Unix() &amp;&amp; len(userGroups) == len(ca.Groups) </span><span class="cov0" title="0">{
                                eq := true
                                for i, r := range userGroups </span><span class="cov0" title="0">{
                                        if r != ca.Groups[i] </span><span class="cov0" title="0">{
                                                eq = false
                                        }</span>
                                }
                                <span class="cov0" title="0">if eq </span><span class="cov0" title="0">{
                                        token = prevToken
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">if token == "" </span><span class="cov8" title="1">{
                token = ta.reseller + common.UUID()
                now := time.Now().Unix()
                proxyCtx.Cache.Set(ctx, "auth:"+token, &amp;cachedAuth{Expires: now + 86400, Groups: userGroups}, 86400)
                if err := proxyCtx.Cache.Set(ctx, "authuser:"+user, &amp;token, 86400); err != nil </span><span class="cov0" title="0">{
                        proxyCtx.Logger.Debug("Error setting tempauth token", zap.Error(err))
                        return tUser, ""
                }</span>
        }
        <span class="cov8" title="1">return tUser, token</span>
}

func (ta *tempAuth) handleGetToken(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        if request.Method != "GET" </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 400)
                return
        }</span>
        <span class="cov8" title="1">user := request.Header.Get("X-Auth-User")
        if user == "" </span><span class="cov0" title="0">{
                user = request.Header.Get("X-Storage-User")
        }</span>
        <span class="cov8" title="1">parts := strings.Split(user, ":")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 401)
                return
        }</span>
        <span class="cov8" title="1">account := parts[0]
        user = parts[1]
        password := request.Header.Get("X-Auth-Key")
        if password == "" </span><span class="cov0" title="0">{
                password = request.Header.Get("X-Storage-Pass")
        }</span>
        <span class="cov8" title="1">ctx := GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov8" title="1">tUser, token := ta.getToken(request.Context(), ctx, user, account, password)
        if tUser == nil </span><span class="cov8" title="1">{
                srv.StandardResponse(writer, 401)
                return
        }</span> else<span class="cov8" title="1"> if token == "" </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(writer, 500, "Error setting token")
                return
        }</span>
        <span class="cov8" title="1">ctx.RemoteUsers = []string{user}
        writer.Header().Set("X-Storage-Token", token)
        writer.Header().Set("X-Auth-Token", token)
        if tUser.Url != "" </span><span class="cov0" title="0">{
                writer.Header().Set("X-Storage-URL", tUser.Url)
        }</span> else<span class="cov8" title="1"> {
                writer.Header().Set("X-Storage-URL", fmt.Sprintf("http://%s/v1/%s%s", request.Host, ta.reseller, account))
        }</span>
        <span class="cov8" title="1">srv.StandardResponse(writer, 200)</span>

}

func (ta *tempAuth) getReseller(account string) (string, bool) <span class="cov8" title="1">{
        // dosn't handle empty resellers yet
        if strings.HasPrefix(account, ta.reseller) </span><span class="cov8" title="1">{
                return ta.reseller, true
        }</span>
        <span class="cov8" title="1">for _, r := range ta.resellers </span><span class="cov8" title="1">{
                if strings.HasPrefix(account, r) </span><span class="cov8" title="1">{
                        return r, true
                }</span>
        }
        <span class="cov8" title="1">return "", false</span>
}

func (ta *tempAuth) ServeHTTP(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        ctx := GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                ta.next.ServeHTTP(writer, request)
                return
        }</span>
        <span class="cov8" title="1">if ctx.S3Auth != nil &amp;&amp; ctx.Authorize == nil </span><span class="cov0" title="0">{
                // handle S3 auth validation
                key := ctx.S3Auth.Key
                parts := strings.Split(key, ":")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        ctx.Authorize = func(r *http.Request) (bool, int) </span><span class="cov0" title="0">{
                                return false, http.StatusForbidden
                        }</span>
                } else<span class="cov0" title="0"> {
                        account := parts[0]
                        user := parts[1]
                        secret := ta.getUserPassword(account, user)
                        isValid := ctx.S3Auth.validateSignature([]byte(secret))
                        if !isValid </span><span class="cov0" title="0">{
                                ctx.Authorize = func(r *http.Request) (bool, int) </span><span class="cov0" title="0">{
                                        return false, http.StatusForbidden
                                }</span>
                        } else<span class="cov0" title="0"> {
                                ctx.S3Auth.Account = account
                                // Get a token for this user to be used with the rest of the request
                                request.Header.Set("X-Auth-User", key)
                                request.Header.Set("X-Auth-Key", secret)
                                _, token := ta.getToken(request.Context(), ctx, user, account, secret)
                                request.Header.Set("X-Auth-Token", token)
                        }</span>
                }
        }
        <span class="cov8" title="1">if request.URL.Path == "/auth/v1.0" </span><span class="cov0" title="0">{
                ta.handleGetToken(writer, request)
                return
        }</span> else<span class="cov8" title="1"> if ctx.S3Auth != nil || strings.HasPrefix(request.URL.Path, "/v1") || strings.HasPrefix(request.URL.Path, "/V1") </span><span class="cov8" title="1">{
                token := request.Header.Get("X-Auth-Token")
                if token == "" </span><span class="cov0" title="0">{
                        token = request.Header.Get("X-Storage-Token")
                }</span>
                <span class="cov8" title="1">if ctx.Authorize == nil </span><span class="cov8" title="1">{
                        account := ""
                        if ctx.S3Auth != nil </span><span class="cov0" title="0">{
                                account = ctx.S3Auth.Account
                        }</span> else<span class="cov8" title="1"> {
                                pathParts, err := common.ParseProxyPath(request.URL.Path)
                                if err != nil </span><span class="cov0" title="0">{
                                        ta.next.ServeHTTP(writer, request)
                                        return
                                }</span>
                                <span class="cov8" title="1">account = pathParts["account"]</span>
                        }
                        <span class="cov8" title="1">if token != "" &amp;&amp; strings.HasPrefix(token, ta.reseller) </span><span class="cov8" title="1">{
                                if curReseller, ok := ta.getReseller(account); ok &amp;&amp; curReseller == ta.reseller </span><span class="cov8" title="1">{
                                        var ca cachedAuth
                                        if err := ctx.Cache.GetStructured(request.Context(), "auth:"+token, &amp;ca); err != nil </span><span class="cov0" title="0">{
                                                s := http.StatusServiceUnavailable
                                                if err == ring.CacheMiss </span><span class="cov0" title="0">{
                                                        s = http.StatusUnauthorized
                                                }</span>
                                                <span class="cov0" title="0">ctx.Authorize = func(r *http.Request) (bool, int) </span><span class="cov0" title="0">{
                                                        return false, s
                                                }</span>
                                        } else<span class="cov8" title="1"> {
                                                if st := request.Header.Get("X-Service-Token"); st != "" </span><span class="cov0" title="0">{
                                                        var caSt cachedAuth
                                                        if err := ctx.Cache.GetStructured(request.Context(), "auth:"+st, &amp;caSt); err == nil </span><span class="cov0" title="0">{
                                                                for _, g := range caSt.Groups </span><span class="cov0" title="0">{
                                                                        ca.Groups = append(ca.Groups, g)
                                                                }</span>
                                                        }
                                                }
                                                <span class="cov8" title="1">ctx.RemoteUsers = ca.Groups
                                                ctx.Authorize = ta.authorize</span>
                                        }
                                } else<span class="cov0" title="0"> if ok </span><span class="cov0" title="0">{
                                        ctx.Authorize = ta.authorize
                                }</span>
                        } else<span class="cov8" title="1"> {
                                if _, ok := ta.getReseller(account); ok </span><span class="cov8" title="1">{
                                        // i do handle the req's reseller auth. allow anonymous authorize
                                        ctx.Authorize = ta.authorize
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">ta.next.ServeHTTP(writer, request)</span>
}

func (ta *tempAuth) authorize(r *http.Request) (bool, int) <span class="cov8" title="1">{
        pathParts, err := common.ParseProxyPath(r.URL.Path)
        if err != nil </span><span class="cov0" title="0">{
                return false, http.StatusNotFound
        }</span>
        <span class="cov8" title="1">if r.Method == "OPTIONS" </span><span class="cov8" title="1">{
                return true, http.StatusOK
        }</span>
        <span class="cov8" title="1">reseller, ok := ta.getReseller(pathParts["account"])
        if !ok </span><span class="cov8" title="1">{
                return false, http.StatusUnauthorized
        }</span>
        <span class="cov8" title="1">ctx := GetProxyContext(r)
        if ctx == nil </span><span class="cov0" title="0">{
                return false, http.StatusUnauthorized
        }</span>
        <span class="cov8" title="1">s := http.StatusUnauthorized
        if len(ctx.RemoteUsers) != 0 </span><span class="cov8" title="1">{
                s = http.StatusForbidden
        }</span>
        <span class="cov8" title="1">if common.StringInSlice(".reseller_admin", ctx.RemoteUsers) &amp;&amp;
                !common.StringInSlice(pathParts["account"], ta.resellers) &amp;&amp;
                !strings.HasPrefix(pathParts["account"], ".") </span><span class="cov8" title="1">{
                ctx.StorageOwner = true
                return true, http.StatusOK
        }</span>
        <span class="cov8" title="1">if common.StringInSlice(pathParts["account"], ctx.RemoteUsers) &amp;&amp;
                (pathParts["container"] != "" || !common.StringInSlice(r.Method, []string{"PUT", "DELETE"})) </span><span class="cov8" title="1">{
                // The user is admin for the account and is not trying to do an account DELETE or PUT
                var requireGroups []string
                if rule, ok := ta.accountRules[reseller]; ok </span><span class="cov8" title="1">{
                        requireGroups = rule["require_group"]
                }</span>
                <span class="cov8" title="1">if len(requireGroups) == 0 </span><span class="cov8" title="1">{
                        ctx.StorageOwner = true
                        return true, http.StatusOK
                }</span> else<span class="cov8" title="1"> {
                        for _, rg := range requireGroups </span><span class="cov8" title="1">{
                                if common.StringInSlice(rg, ctx.RemoteUsers) </span><span class="cov8" title="1">{
                                        ctx.StorageOwner = true
                                        return true, http.StatusOK
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">referrers, roles := ParseACL(ctx.ACL)
        if auth, _ := AuthorizeUnconfirmedIdentity(r, pathParts["object"], referrers, roles); auth </span><span class="cov8" title="1">{
                return true, http.StatusOK
        }</span>
        <span class="cov8" title="1">for _, ru := range ctx.RemoteUsers </span><span class="cov8" title="1">{
                if common.StringInSlice(ru, roles) </span><span class="cov8" title="1">{
                        return true, http.StatusOK
                }</span>
        }
        <span class="cov8" title="1">return false, s</span>
}

func NewTempAuth(config conf.Section, metricsScope tally.Scope) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        users := []testUser{}
        defaultRules := map[string][]string{"require_group": {}}
        resellerPrefixes, accountRules := conf.ReadResellerOptions(config, defaultRules)
        reseller := resellerPrefixes[0]
        for key, val := range config.Section </span><span class="cov0" title="0">{
                keyparts := strings.Split(key, "_")
                valparts := strings.Fields(val)
                if len(keyparts) != 3 || keyparts[0] != "user" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">account, user := keyparts[1], keyparts[2]
                vallen := len(valparts)
                if vallen &lt; 1 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">url := ""
                accountID := reseller + account
                groups := []string{}
                if vallen &gt; 1 </span><span class="cov0" title="0">{
                        urlSpot := 0
                        s := valparts[vallen-1]
                        if strings.HasPrefix(s, "http://") || strings.HasPrefix(s, "https://") </span><span class="cov0" title="0">{
                                urlSpot = 1
                                url = s
                                urlParts := strings.Split(url, "/")
                                accountID = urlParts[len(urlParts)-1]
                        }</span>
                        <span class="cov0" title="0">for _, group := range valparts[1 : vallen-urlSpot] </span><span class="cov0" title="0">{
                                groups = append(groups, group)
                        }</span>
                }

                <span class="cov0" title="0">users = append(users, testUser{account, user, valparts[0], groups, url, accountID})</span>
        }
        <span class="cov0" title="0">RegisterInfo("tempauth", map[string]interface{}{"account_acls": false})
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return &amp;tempAuth{
                        next:         next,
                        testUsers:    users,
                        resellers:    resellerPrefixes,
                        reseller:     reseller,
                        accountRules: accountRules,
                }
        }</span>, nil
}
</pre>
		
		<pre class="file" id="file104" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "crypto/hmac"
        "crypto/sha1"
        "encoding/hex"
        "fmt"
        "net/http"
        "path/filepath"
        "strings"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/uber-go/tally"
)

const (
        SCOPE_INVALID = iota
        SCOPE_ACCOUNT
        SCOPE_CONTAINER
)

type tuWriter struct {
        http.ResponseWriter
        method   string
        filename string
        obj      string
        expires  string
        inline   bool
}

func dispositionFormat(dtype string, filename string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s; filename=\"%s\"; filename*=UTF-8''%s",
                dtype, common.Urlencode(filename), common.Urlencode(filename))
}</span>

func (w *tuWriter) WriteHeader(status int) <span class="cov8" title="1">{
        if (w.method == "GET" || w.method == "HEAD") &amp;&amp; status/100 == 2 </span><span class="cov8" title="1">{
                for k := range w.Header() </span><span class="cov8" title="1">{
                        if strings.HasPrefix(k, "X-Object-Meta") &amp;&amp; !strings.HasPrefix(k, "X-Object-Meta-Public-") </span><span class="cov8" title="1">{
                                w.Header().Del(k)
                        }</span>
                }
                <span class="cov8" title="1">if w.inline </span><span class="cov8" title="1">{
                        if w.filename == "" </span><span class="cov8" title="1">{
                                w.Header().Set("Content-Disposition", "inline")
                        }</span> else<span class="cov8" title="1"> {
                                w.Header().Set("Content-Disposition", dispositionFormat("inline", w.filename))
                        }</span>
                } else<span class="cov8" title="1"> if w.filename != "" </span><span class="cov8" title="1">{
                        w.Header().Set("Content-Disposition", dispositionFormat("attachment", w.filename))
                }</span> else<span class="cov8" title="1"> if w.Header().Get("Content-Disposition") == "" </span><span class="cov8" title="1">{
                        w.Header().Set("Content-Disposition", dispositionFormat("attachment", filepath.Base(w.obj)))
                }</span>
                <span class="cov8" title="1">w.Header().Set("Expires", w.expires)</span>
        }
        <span class="cov8" title="1">w.ResponseWriter.WriteHeader(status)</span>
}

func checkhmac(key, sig []byte, method, path string, expires time.Time) bool <span class="cov8" title="1">{
        if method == "HEAD" </span><span class="cov8" title="1">{
                for _, meth := range []string{"HEAD", "GET", "POST", "PUT"} </span><span class="cov8" title="1">{
                        mac := hmac.New(sha1.New, key)
                        fmt.Fprintf(mac, "%s\n%d\n%s", meth, expires.Unix(), path)
                        if hmac.Equal(sig, mac.Sum(nil)) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">return false</span>
        } else<span class="cov8" title="1"> {
                mac := hmac.New(sha1.New, key)
                fmt.Fprintf(mac, "%s\n%d\n%s", method, expires.Unix(), path)
                return hmac.Equal(sig, mac.Sum(nil))
        }</span>
}

func tempurl(requestsMetric tally.Counter) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                        if request.Method == "OPTIONS" </span><span class="cov8" title="1">{
                                next.ServeHTTP(writer, request)
                                return
                        }</span>
                        <span class="cov8" title="1">ctx := GetProxyContext(request)
                        if ctx.Authorize != nil </span><span class="cov8" title="1">{
                                next.ServeHTTP(writer, request)
                                return
                        }</span>
                        <span class="cov8" title="1">q := request.URL.Query()
                        sig := q.Get("temp_url_sig")
                        exps := q.Get("temp_url_expires")
                        _, inline := q["inline"]

                        if sig == "" &amp;&amp; exps == "" </span><span class="cov8" title="1">{
                                next.ServeHTTP(writer, request)
                                return
                        }</span> else<span class="cov8" title="1"> if sig == "" || exps == "" </span><span class="cov8" title="1">{
                                srv.StandardResponse(writer, 401)
                                return
                        }</span>

                        <span class="cov8" title="1">requestsMetric.Inc(1)

                        expires, err := common.ParseDate(exps)
                        if err != nil || time.Now().After(expires) </span><span class="cov8" title="1">{
                                srv.StandardResponse(writer, 401)
                                return
                        }</span>

                        <span class="cov8" title="1">sigb, err := hex.DecodeString(sig)
                        if err != nil </span><span class="cov8" title="1">{
                                srv.StandardResponse(writer, 401)
                                return
                        }</span>

                        <span class="cov8" title="1">apiReq, account, container, obj := getPathParts(request)
                        if !apiReq || account == "" || container == "" </span><span class="cov8" title="1">{
                                srv.StandardResponse(writer, 401)
                                return
                        }</span>

                        <span class="cov8" title="1">if bh := request.Header.Get("X-Object-Manifest"); bh != "" &amp;&amp; (request.Method == "PUT" || request.Method == "POST") </span><span class="cov8" title="1">{
                                srv.StandardResponse(writer, 400)
                                return
                        }</span>

                        <span class="cov8" title="1">path := ""
                        if _, hasPrefix := q["temp_url_prefix"]; hasPrefix </span><span class="cov8" title="1">{
                                prefix := q.Get("temp_url_prefix")
                                if !strings.HasPrefix(obj, prefix) </span><span class="cov0" title="0">{
                                        srv.StandardResponse(writer, 401)
                                        return
                                }</span>
                                <span class="cov8" title="1">path = fmt.Sprintf("prefix:/v1/%s/%s/%s", account, container, prefix)</span>
                        } else<span class="cov8" title="1"> {
                                path = fmt.Sprintf("/v1/%s/%s/%s", account, container, obj)
                        }</span>

                        <span class="cov8" title="1">scope := SCOPE_INVALID
                        if ai, err := ctx.GetAccountInfo(request.Context(), account); err == nil </span><span class="cov8" title="1">{
                                if key, ok := ai.Metadata["Temp-Url-Key"]; ok &amp;&amp; checkhmac([]byte(key), sigb, request.Method, path, expires) </span><span class="cov8" title="1">{
                                        scope = SCOPE_ACCOUNT
                                }</span> else<span class="cov8" title="1"> if key, ok := ai.Metadata["Temp-Url-Key-2"]; ok &amp;&amp; checkhmac([]byte(key), sigb, request.Method, path, expires) </span><span class="cov0" title="0">{
                                        scope = SCOPE_ACCOUNT
                                }</span> else<span class="cov8" title="1"> if ci, err := ctx.C.GetContainerInfo(request.Context(), account, container); err == nil </span><span class="cov8" title="1">{
                                        if key, ok := ci.Metadata["Temp-Url-Key"]; ok &amp;&amp; checkhmac([]byte(key), sigb, request.Method, path, expires) </span><span class="cov8" title="1">{
                                                scope = SCOPE_CONTAINER
                                        }</span> else<span class="cov8" title="1"> if key, ok := ci.Metadata["Temp-Url-Key-2"]; ok &amp;&amp; checkhmac([]byte(key), sigb, request.Method, path, expires) </span><span class="cov0" title="0">{
                                                scope = SCOPE_CONTAINER
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">if scope == SCOPE_INVALID </span><span class="cov8" title="1">{
                                srv.StandardResponse(writer, 401)
                                return
                        }</span>
                        <span class="cov8" title="1">ctx.RemoteUsers = []string{".tempurl"}
                        ctx.Authorize = func(r *http.Request) (bool, int) </span><span class="cov8" title="1">{
                                ar, a, c, _ := getPathParts(r)
                                if ar &amp;&amp; ((scope == SCOPE_ACCOUNT &amp;&amp; a == account) || (scope == SCOPE_CONTAINER &amp;&amp; c == container)) </span><span class="cov8" title="1">{
                                        return true, http.StatusOK
                                }</span>
                                <span class="cov8" title="1">return false, http.StatusUnauthorized</span>
                        }

                        <span class="cov8" title="1">next.ServeHTTP(
                                &amp;tuWriter{
                                        ResponseWriter: writer,
                                        method:         request.Method,
                                        obj:            obj,
                                        filename:       q.Get("filename"),
                                        expires:        expires.Format(time.RFC1123),
                                        inline:         inline,
                                },
                                request,
                        )</span>
                })
        }
}

func NewTempURL(config conf.Section, metricsScope tally.Scope) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        RegisterInfo("tempurl", map[string]interface{}{
                "methods":                 []string{"GET", "HEAD", "PUT", "POST", "DELETE"},
                "incoming_remove_headers": []string{"x-timestamp"},
                "incoming_allow_headers":  []string{},
                "outgoing_remove_headers": []string{"x-object-meta-*"}, "outgoing_allow_headers": []string{"x-object-meta-public-*"},
        })
        requestsMetric := metricsScope.Counter("tempurl_requests")
        return tempurl(requestsMetric), nil
}</span>
</pre>
		
		<pre class="file" id="file105" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package middleware

import (
        "bytes"
        "encoding/json"
        //"errors"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strings"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/uber-go/tally"
        "go.uber.org/zap"
)

const (
        DELETE_MARKER_CONTENT_TYPE = "application/x-deleted;swift_versions_deleted=1"
        CLIENT_VERSIONS_LOC        = "X-Versions-Location"
        CLIENT_HISTORY_LOC         = "X-History-Location"
        SYSMETA_VERSIONS_LOC       = "X-Container-Sysmeta-Versions-Location"
        SYSMETA_VERSIONS_MODE      = "X-Container-Sysmeta-Versions-Mode"
)

type versionedWrites struct {
        next    http.Handler
        enabled bool
}

type listingWriter struct {
        http.ResponseWriter
        buffer  *bytes.Buffer
        success bool
}

func (l *listingWriter) WriteHeader(status int) <span class="cov8" title="1">{
        if status/100 == 2 </span><span class="cov8" title="1">{
                l.success = true
                l.buffer = bytes.NewBuffer(make([]byte, 0))
        }</span>
}

func (l *listingWriter) Write(stuff []byte) (int, error) <span class="cov8" title="1">{
        if l.success </span><span class="cov8" title="1">{
                l.buffer.Write(stuff)
        }</span>
        <span class="cov8" title="1">return len(stuff), nil</span>
}

type VersionedObjectWriter struct {
        header http.Header
        status int
}

func (vow *VersionedObjectWriter) Write(stuff []byte) (int, error) <span class="cov0" title="0">{
        return len(stuff), nil
}</span>

func (vow *VersionedObjectWriter) Header() http.Header <span class="cov8" title="1">{
        return vow.header
}</span>

func (vow *VersionedObjectWriter) WriteHeader(status int) <span class="cov8" title="1">{
        vow.status = status
}</span>

func NewVersionedObjectWriter() *VersionedObjectWriter <span class="cov8" title="1">{
        header := make(map[string][]string)
        return &amp;VersionedObjectWriter{
                status: 500,
                header: header,
        }
}</span>

type VersionedContainerWriter struct {
        http.ResponseWriter
}

func (vcw *VersionedContainerWriter) WriteHeader(status int) <span class="cov8" title="1">{
        mode := ""
        location := ""
        if vcw.ResponseWriter.Header().Get(SYSMETA_VERSIONS_LOC) != "" </span><span class="cov8" title="1">{
                location = vcw.ResponseWriter.Header().Get(SYSMETA_VERSIONS_LOC)
        }</span>
        <span class="cov8" title="1">if vcw.ResponseWriter.Header().Get(SYSMETA_VERSIONS_MODE) != "" </span><span class="cov8" title="1">{
                mode = vcw.ResponseWriter.Header().Get(SYSMETA_VERSIONS_MODE)
        }</span>

        <span class="cov8" title="1">if location != "" </span><span class="cov8" title="1">{
                if mode == "history" </span><span class="cov0" title="0">{
                        vcw.ResponseWriter.Header().Set(CLIENT_HISTORY_LOC, location)
                }</span> else<span class="cov8" title="1"> {
                        vcw.ResponseWriter.Header().Set(CLIENT_VERSIONS_LOC, location)
                }</span>
        }

        <span class="cov8" title="1">vcw.ResponseWriter.WriteHeader(status)</span>
}

func (v *versionedWrites) handleContainer(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        versionsLocs, v_ok := request.Header[CLIENT_VERSIONS_LOC]
        historyLocs, h_ok := request.Header[CLIENT_HISTORY_LOC]

        if v_ok &amp;&amp; h_ok </span><span class="cov8" title="1">{
                srv.SimpleErrorResponse(writer, 400, fmt.Sprintf("Only one of %s or %s may be specified", CLIENT_VERSIONS_LOC, CLIENT_HISTORY_LOC))
                return
        }</span>

        <span class="cov8" title="1">if v_ok || h_ok </span><span class="cov8" title="1">{
                val := ""
                var mode string
                if v_ok </span><span class="cov8" title="1">{
                        val = versionsLocs[0]
                        mode = "stack"
                }</span> else<span class="cov0" title="0"> {
                        val = historyLocs[0]
                        mode = "history"
                }</span>
                <span class="cov8" title="1">if val != "" </span><span class="cov8" title="1">{
                        request.Header.Set(SYSMETA_VERSIONS_LOC, val)
                        request.Header.Set(SYSMETA_VERSIONS_MODE, mode)

                        request.Header.Del(CLIENT_VERSIONS_LOC)
                        request.Header.Del(CLIENT_HISTORY_LOC)
                        // Adding a location trumps removing them.
                        request.Header.Del("X-Remove-Versions-Location")
                        request.Header.Del("X-Remove-History-Location")
                }</span> else<span class="cov0" title="0"> {
                        request.Header.Set("X-Remove-Versions-Location", "x")
                }</span>
        }

        <span class="cov8" title="1">if request.Header.Get("X-Remove-Versions-Location") != "" || request.Header.Get("X-Remove-History-Location") != "" </span><span class="cov8" title="1">{
                request.Header.Set(CLIENT_VERSIONS_LOC, "")
                request.Header.Set(SYSMETA_VERSIONS_LOC, "")
                request.Header.Set(SYSMETA_VERSIONS_MODE, "")
                request.Header.Del("X-Remove-Versions-Location")
                request.Header.Del("X-Remove-History-Location")
        }</span>

        <span class="cov8" title="1">vcw := &amp;VersionedContainerWriter{
                ResponseWriter: writer,
        }

        v.next.ServeHTTP(vcw, request)</span>
}

func (v *versionedWrites) versionedObjectPrefix(object string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%03x%s/", len(object), object)
}</span>

func (v *versionedWrites) versionedObjectName(object string, ts string) string <span class="cov8" title="1">{
        return v.versionedObjectPrefix(object) + ts
}</span>

func (v *versionedWrites) containerListing(writer http.ResponseWriter, req *http.Request, urlStr string) (listing []segItem, err error) <span class="cov8" title="1">{
        ctx := GetProxyContext(req)
        request, err := ctx.newSubrequest("GET", urlStr, http.NoBody, req, "VW")
        if err != nil </span><span class="cov0" title="0">{
                return listing, err
        }</span>
        <span class="cov8" title="1">lw := &amp;listingWriter{ResponseWriter: writer}
        GetProxyContext(request).Authorize = okAuthFunc
        ctx.serveHTTPSubrequest(lw, request)
        if lw.success </span><span class="cov8" title="1">{
                if err = json.Unmarshal(lw.buffer.Bytes(), &amp;listing); err != nil </span><span class="cov0" title="0">{
                        return listing, err
                }</span>
        }
        <span class="cov8" title="1">return listing, nil</span>
}

func (v *versionedWrites) putDeletedMarker(writer http.ResponseWriter, req *http.Request, path string) (http.Header, int) <span class="cov8" title="1">{
        ctx := GetProxyContext(req)
        request, err := ctx.newSubrequest("PUT", common.Urlencode(path), http.NoBody, req, "VW")
        if err != nil </span><span class="cov0" title="0">{
                ctx.Logger.Error("putDeletedMarker PUT error", zap.Error(err))
                return nil, 500
        }</span>
        <span class="cov8" title="1">request.Header.Set("Content-Type", DELETE_MARKER_CONTENT_TYPE)
        request.Header.Set("Content-Length", "0")
        // request.ContentLength = 0

        vow := NewVersionedObjectWriter()
        GetProxyContext(request).Authorize = okAuthFunc
        ctx.serveHTTPSubrequest(vow, request)
        return vow.Header(), vow.status</span>
}

func (v *versionedWrites) putVersionedObj(writer http.ResponseWriter, req *http.Request, path string, body io.ReadCloser, header http.Header) (http.Header, int) <span class="cov8" title="1">{
        ctx := GetProxyContext(req)
        request, err := ctx.newSubrequest("PUT", common.Urlencode(path), body, req, "VW")
        if err != nil </span><span class="cov0" title="0">{
                ctx.Logger.Error("putVersionedObj PUT error", zap.Error(err))
                return nil, 400
        }</span>

        <span class="cov8" title="1">CopyItemsExclude(request.Header, header, []string{"X-Timestamp"})
        vow := NewVersionedObjectWriter()
        GetProxyContext(request).Authorize = okAuthFunc
        ctx.serveHTTPSubrequest(vow, request)
        return vow.Header(), vow.status</span>
}

func okAuthFunc(r *http.Request) (bool, int) <span class="cov0" title="0">{ return true, http.StatusOK }</span>

func (v *versionedWrites) copyObject(writer http.ResponseWriter, request *http.Request, dest string, src string) bool <span class="cov8" title="1">{
        ctx := GetProxyContext(request)
        srcBody, srcHeader, srcStatus := PipedGet(common.Urlencode(src), request, "VW", okAuthFunc)
        if srcBody != nil </span><span class="cov8" title="1">{
                defer srcBody.Close()
        }</span>
        <span class="cov8" title="1">if srcStatus == http.StatusNotFound </span><span class="cov0" title="0">{
                ctx.Logger.Info("copyObject not found", zap.String("path", src))
                return false
        }</span>
        <span class="cov8" title="1">if srcStatus/100 != 2 </span><span class="cov0" title="0">{
                ctx.Logger.Info("copyObject srcStatus", zap.Int("status", srcStatus))
                return false
        }</span>
        <span class="cov8" title="1">_, destStatus := v.putVersionedObj(writer, request, dest, srcBody, srcHeader)
        if destStatus/100 != 2 </span><span class="cov0" title="0">{
                ctx.Logger.Info("copyObject destStatus", zap.Int("status", destStatus))
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

func (v *versionedWrites) copyCurrent(writer http.ResponseWriter, request *http.Request, account, container, versionContainer, object string) (bool, int) <span class="cov8" title="1">{
        ctx := GetProxyContext(request)
        if ci, err := ctx.C.GetContainerInfo(request.Context(), account, container); err != nil </span><span class="cov0" title="0">{
                // No container info?
                return false, 400
        }</span> else<span class="cov8" title="1"> {
                ctx.ACL = ci.WriteACL
                if ctx.Authorize != nil </span><span class="cov0" title="0">{
                        if ok, st := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                                return false, st
                        }</span>
                }
        }

        <span class="cov8" title="1">srcBody, srcHeader, srcStatus := PipedGet(common.Urlencode(request.URL.Path), request, "VW", okAuthFunc)
        if srcBody != nil </span><span class="cov8" title="1">{
                defer srcBody.Close()
        }</span>
        <span class="cov8" title="1">if srcStatus == http.StatusNotFound </span><span class="cov0" title="0">{
                return true, 200
        }</span>
        <span class="cov8" title="1">if srcStatus/100 != 2 </span><span class="cov0" title="0">{
                ctx.Logger.Info("Bad status in copyCurrent GET", zap.Int("srcStatus", srcStatus))
                return false, srcStatus
        }</span>

        <span class="cov8" title="1">ts, err := common.StandardizeTimestamp(srcHeader.Get("X-Timestamp"))
        if err != nil </span><span class="cov0" title="0">{
                ctx.Logger.Info("Bad X-Timestamp", zap.String("X-Timestamp", srcHeader.Get("X-Timestamp")))
                return false, 500
        }</span>
        <span class="cov8" title="1">if ts == "" </span><span class="cov0" title="0">{
                if lm, err := common.ParseDate(srcHeader.Get("Last-Modified")); err == nil </span><span class="cov0" title="0">{
                        ts = common.CanonicalTimestampFromTime(lm)
                }</span> else<span class="cov0" title="0"> {
                        ctx.Logger.Info("Bad Last-Modified", zap.String("Last-Modified", srcHeader.Get("Last-Modified")))
                        return false, 500
                }</span>
        }
        <span class="cov8" title="1">versObjName := v.versionedObjectName(object, ts)
        path := fmt.Sprintf("/v1/%s/%s/%s", account, versionContainer, versObjName)
        _, destStatus := v.putVersionedObj(writer, request, path, srcBody, srcHeader)
        if destStatus/100 != 2 </span><span class="cov0" title="0">{
                ctx.Logger.Info("Bad status in copyCurrent PUT", zap.Int("destStatus", destStatus))
                return false, destStatus
        }</span>
        <span class="cov8" title="1">return true, destStatus</span>
}

func (v *versionedWrites) handleObjectDeleteHistory(writer http.ResponseWriter, request *http.Request, account, container, versionsContainer, object string) <span class="cov8" title="1">{
        ok, status := v.copyCurrent(writer, request, account, container, versionsContainer, object)
        if !ok &amp;&amp; returnIfStatusError(writer, status) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">versObjectName := v.versionedObjectName(object, common.GetTimestamp())
        markerPath := fmt.Sprintf("/v1/%s/%s/%s", account, versionsContainer, versObjectName)
        _, status = v.putDeletedMarker(writer, request, markerPath)
        if returnIfStatusError(writer, status) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">v.next.ServeHTTP(writer, request)</span>
}

func (v *versionedWrites) deleteObject(writer http.ResponseWriter, req *http.Request, path string) (http.Header, int) <span class="cov8" title="1">{
        ctx := GetProxyContext(req)
        request, err := ctx.newSubrequest("DELETE", common.Urlencode(path), http.NoBody, req, "VW")
        if err != nil </span><span class="cov0" title="0">{
                ctx.Logger.Error("deleteObject error", zap.Error(err))
                return nil, 500
        }</span>
        <span class="cov8" title="1">vow := NewVersionedObjectWriter()
        GetProxyContext(request).Authorize = okAuthFunc
        ctx.serveHTTPSubrequest(vow, request)
        return vow.Header(), vow.status</span>
}

func (v *versionedWrites) headObject(writer http.ResponseWriter, req *http.Request, path string) (http.Header, int) <span class="cov8" title="1">{
        ctx := GetProxyContext(req)
        request, err := ctx.newSubrequest("HEAD", common.Urlencode(path), http.NoBody, req, "VW")
        if err != nil </span><span class="cov0" title="0">{
                ctx.Logger.Error("headObject error", zap.Error(err))
                return nil, 500
        }</span>
        <span class="cov8" title="1">vow := NewVersionedObjectWriter()
        ctx.serveHTTPSubrequest(vow, request)
        return vow.Header(), vow.status</span>
}

func (v *versionedWrites) handleObjectDeleteStack(writer http.ResponseWriter, request *http.Request, account, container, versionsContainer, object string) <span class="cov8" title="1">{
        ctx := GetProxyContext(request)
        listingPath := fmt.Sprintf("/v1/%s/%s?format=json&amp;prefix=%s&amp;reverse=on", common.Urlencode(account), common.Urlencode(versionsContainer), url.QueryEscape(v.versionedObjectPrefix(object)))
        listing, err := v.containerListing(writer, request, listingPath)
        if err != nil </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(writer, 500, "Failed to get versions container listing")
                return
        }</span>
        <span class="cov8" title="1">authed := false
        headStatus := -1
        /* This is where things get weird.
           In stack mode when a delete happens, we restore the most recent version, and then delete that
           backed up version. If that fails for any reason, we loop through the versions until we can
           restore one.
           If the most recent version is a delete marker from the history type of versioning, a bunch of
           things happen. If they object getting deleted actually exists, we go ahead and delete it.
           Otherwise, we go ahead and try to restore the next possible version.
        */
        for versionIndex := 0; versionIndex &lt; len(listing); versionIndex++ </span><span class="cov8" title="1">{
                previousVersion := listing[versionIndex]
                if !authed </span><span class="cov8" title="1">{
                        ctx := GetProxyContext(request)
                        if ci, err := ctx.C.GetContainerInfo(request.Context(), account, container); err != nil </span><span class="cov0" title="0">{
                                // No container
                                srv.StandardResponse(writer, 400)
                                return
                        }</span> else<span class="cov8" title="1"> {
                                ctx.ACL = ci.WriteACL
                                if ctx.Authorize != nil </span><span class="cov0" title="0">{
                                        if ok, st := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                                                srv.StandardResponse(writer, st)
                                                return
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">authed = true</span>
                }
                <span class="cov8" title="1">if previousVersion.ContentType != DELETE_MARKER_CONTENT_TYPE </span><span class="cov8" title="1">{
                        previousVersionPath := fmt.Sprintf("/v1/%s/%s/%s", account, versionsContainer, previousVersion.Name)
                        if v.copyObject(writer, request, request.URL.Path, previousVersionPath) </span><span class="cov8" title="1">{
                                // Restored, now delete the backup.
                                request.URL.Path = previousVersionPath
                                ctx.Authorize = okAuthFunc
                                v.next.ServeHTTP(writer, request)
                                return
                        }</span> else<span class="cov0" title="0"> {
                                // Couldn't restore the previous version, so try the next one.
                                continue</span>
                        }
                } else<span class="cov8" title="1"> {
                        if headStatus == -1 </span><span class="cov8" title="1">{
                                _, headStatus = v.headObject(writer, request, request.URL.Path)
                        }</span>
                        <span class="cov8" title="1">if headStatus != http.StatusNotFound </span><span class="cov0" title="0">{
                                // Object exists, just let it get deleted.
                                break</span>
                        }
                        <span class="cov8" title="1">for versionIndex++; versionIndex &lt; len(listing); versionIndex++ </span><span class="cov8" title="1">{
                                versionToRestore := listing[versionIndex]
                                if versionToRestore.ContentType == DELETE_MARKER_CONTENT_TYPE </span><span class="cov0" title="0">{
                                        // The restore version was a delete marker, so all that happens is the
                                        // previousVersion empty marker gets deleted, and we're done restoring.
                                        break</span>
                                }
                                <span class="cov8" title="1">restorePath := fmt.Sprintf("/v1/%s/%s/%s", account, versionsContainer, versionToRestore.Name)
                                if v.copyObject(writer, request, request.URL.Path, restorePath) </span><span class="cov8" title="1">{
                                        // Successfully restored, so delete the history version
                                        _, status := v.deleteObject(writer, request, restorePath)
                                        if status != http.StatusNotFound &amp;&amp; returnIfStatusError(writer, status) </span><span class="cov0" title="0">{
                                                ctx.Logger.Info("VW deleteObject failure", zap.Int("status", status))
                                                return
                                        }</span>
                                        <span class="cov8" title="1">break</span>
                                } else<span class="cov0" title="0"> {
                                        // Couldn't restore the previous version, so try the next one.
                                        continue</span>
                                }
                        }
                        // Restored a version, delete the top delete marker.
                        <span class="cov8" title="1">request.URL.Path = fmt.Sprintf("/v1/%s/%s/%s", account, versionsContainer, previousVersion.Name)</span>
                }
                <span class="cov8" title="1">if request.Header.Get("X-If-Delete-At") != "" </span><span class="cov0" title="0">{
                        request.Header.Del("X-If-Delete-At")
                }</span>
                <span class="cov8" title="1">break</span>
        }
        <span class="cov8" title="1">v.next.ServeHTTP(writer, request)</span>
}

func (v *versionedWrites) handleObjectPut(writer http.ResponseWriter, request *http.Request, account, container, versionsContainer, object string) <span class="cov8" title="1">{
        ok, status := v.copyCurrent(writer, request, account, container, versionsContainer, object)
        if !ok &amp;&amp; returnIfStatusError(writer, status) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">v.next.ServeHTTP(writer, request)</span>
}

func (v *versionedWrites) handleObject(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        _, account, container, object := getPathParts(request)
        ctx := GetProxyContext(request)
        ci, _ := ctx.C.GetContainerInfo(request.Context(), account, container)
        if ci == nil </span><span class="cov0" title="0">{
                v.next.ServeHTTP(writer, request)
                return
        }</span>

        <span class="cov8" title="1">versionsContainer := ci.SysMetadata["Versions-Location"]
        versionsMode := ci.SysMetadata["Versions-Mode"]
        if versionsMode == "" </span><span class="cov0" title="0">{
                versionsMode = "stack"
        }</span>
        <span class="cov8" title="1">if versionsContainer == "" </span><span class="cov0" title="0">{
                v.next.ServeHTTP(writer, request)
                return
        }</span>
        <span class="cov8" title="1">if unescapedVersionsContainer, err := url.QueryUnescape(versionsContainer); err == nil </span><span class="cov8" title="1">{
                versionsContainer = strings.Split(unescapedVersionsContainer, "/")[0]
        }</span> else<span class="cov0" title="0"> {
                ctx.Logger.Info("Bad versions container", zap.String("versionsContainer", versionsContainer))
                v.next.ServeHTTP(writer, request)
                return
        }</span>

        <span class="cov8" title="1">if request.Method == "PUT" </span><span class="cov8" title="1">{
                v.handleObjectPut(writer, request, account, container, versionsContainer, object)
        }</span> else<span class="cov8" title="1"> if versionsMode == "history" </span><span class="cov8" title="1">{
                v.handleObjectDeleteHistory(writer, request, account, container, versionsContainer, object)
        }</span> else<span class="cov8" title="1"> {
                v.handleObjectDeleteStack(writer, request, account, container, versionsContainer, object)
        }</span>
}

func returnIfStatusError(writer http.ResponseWriter, status int) bool <span class="cov8" title="1">{
        if status/100 == 2 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov0" title="0">if status == 403 </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 403)
        }</span> else<span class="cov0" title="0"> if status/100 == 4 </span><span class="cov0" title="0">{
                srv.StandardResponse(writer, 412)
        }</span> else<span class="cov0" title="0"> {
                srv.StandardResponse(writer, 500)
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (v *versionedWrites) ServeHTTP(writer http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        apiReq, account, container, object := getPathParts(request)
        if container == "" &amp;&amp; object == "" </span><span class="cov0" title="0">{
                v.next.ServeHTTP(writer, request)
                return
        }</span>
        <span class="cov8" title="1">if !apiReq || account == "" </span><span class="cov0" title="0">{
                v.next.ServeHTTP(writer, request)
                return
        }</span>
        <span class="cov8" title="1">if GetProxyContext(request).Source == "VW" </span><span class="cov0" title="0">{
                v.next.ServeHTTP(writer, request)
                return
        }</span>

        <span class="cov8" title="1">if !v.enabled </span><span class="cov8" title="1">{
                // Can't set these headers if disabled
                if (request.Method == "POST" || request.Method == "PUT") &amp;&amp;
                        (request.Header.Get(CLIENT_VERSIONS_LOC) != "" ||
                                request.Header.Get(CLIENT_HISTORY_LOC) != "") </span><span class="cov8" title="1">{

                        srv.SimpleErrorResponse(writer, 412, "Versioned Writes is disabled")
                        return
                }</span>
                <span class="cov8" title="1">v.next.ServeHTTP(writer, request)
                return</span>
        }

        <span class="cov8" title="1">if object == "" </span><span class="cov8" title="1">{
                v.handleContainer(writer, request)
        }</span> else<span class="cov8" title="1"> if request.Method == "PUT" || request.Method == "DELETE" </span><span class="cov8" title="1">{
                v.handleObject(writer, request)
        }</span> else<span class="cov0" title="0"> {
                v.next.ServeHTTP(writer, request)
        }</span>
}

func NewVersionedWrites(config conf.Section, metricsScope tally.Scope) (func(http.Handler) http.Handler, error) <span class="cov0" title="0">{
        RegisterInfo("versioned_writes", map[string]interface{}{"allowed_flags": []string{strings.ToLower(CLIENT_VERSIONS_LOC), strings.ToLower(CLIENT_HISTORY_LOC)}})
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return &amp;versionedWrites{
                        next:    next,
                        enabled: config.GetBool("allowed_versioned_writes", true),
                }
        }</span>, nil
}
</pre>
		
		<pre class="file" id="file106" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package proxyserver

import (
        "mime"
        "net/http"
        "path/filepath"
        "strings"

        "go.uber.org/zap"

        "github.com/troubling/hummingbird/client"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/proxyserver/middleware"
)

func (server *ProxyServer) ObjectGetHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                server.logger.Error("could not get proxy context")
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">containerInfo, err := ctx.C.GetContainerInfo(request.Context(), vars["account"], vars["container"])
        if err != nil </span><span class="cov0" title="0">{
                ctx.ACL = ""
                if ctx.Authorize != nil </span><span class="cov0" title="0">{
                        if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                                srv.StandardResponse(writer, s)
                                return
                        }</span>
                }
                <span class="cov0" title="0">if err == client.ContainerNotFound </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, 404)
                        return
                }</span>
                <span class="cov0" title="0">ctx.Logger.Error("object GET: container error", zap.String("container", vars["container"]), zap.Error(err))
                srv.StandardResponse(writer, 500)
                return</span>
        }
        <span class="cov0" title="0">ctx.ACL = containerInfo.ReadACL
        if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">resp := ctx.C.GetObject(request.Context(), vars["account"], vars["container"], vars["obj"], request.Header)
        for k := range resp.Header </span><span class="cov0" title="0">{
                writer.Header().Set(k, resp.Header.Get(k))
        }</span>
        <span class="cov0" title="0">writer.WriteHeader(resp.StatusCode)
        common.Copy(resp.Body, writer)
        resp.Body.Close()</span>
}

func (server *ProxyServer) ObjectHeadHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                server.logger.Error("could not get proxy context")
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">containerInfo, err := ctx.C.GetContainerInfo(request.Context(), vars["account"], vars["container"])
        if err != nil </span><span class="cov0" title="0">{
                ctx.ACL = ""
                if ctx.Authorize != nil </span><span class="cov0" title="0">{
                        if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                                srv.StandardResponse(writer, s)
                                return
                        }</span>
                }
                <span class="cov0" title="0">if err == client.ContainerNotFound </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, 404)
                        return
                }</span>
                <span class="cov0" title="0">ctx.Logger.Error("object HEAD: container error", zap.String("container", vars["container"]), zap.Error(err))
                srv.StandardResponse(writer, 500)
                return</span>
        }
        <span class="cov0" title="0">ctx.ACL = containerInfo.ReadACL
        if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">resp := ctx.C.HeadObject(request.Context(), vars["account"], vars["container"], vars["obj"], request.Header)
        for k := range resp.Header </span><span class="cov0" title="0">{
                writer.Header().Set(k, resp.Header.Get(k))
        }</span>
        <span class="cov0" title="0">resp.Body.Close()
        writer.WriteHeader(resp.StatusCode)</span>
}

func (server *ProxyServer) ObjectDeleteHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                server.logger.Error("could not get proxy context")
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">containerInfo, err := ctx.C.GetContainerInfo(request.Context(), vars["account"], vars["container"])
        if err != nil </span><span class="cov0" title="0">{
                ctx.ACL = ""
                if ctx.Authorize != nil </span><span class="cov0" title="0">{
                        if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                                srv.StandardResponse(writer, s)
                                return
                        }</span>
                }
                <span class="cov0" title="0">if err == client.ContainerNotFound </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, 404)
                        return
                }</span>
                <span class="cov0" title="0">ctx.Logger.Error("object DELETE: container error", zap.String("container", vars["container"]), zap.Error(err))
                srv.StandardResponse(writer, 500)
                return</span>
        }
        <span class="cov0" title="0">ctx.ACL = containerInfo.WriteACL
        if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">resp := ctx.C.DeleteObject(request.Context(), vars["account"], vars["container"], vars["obj"], request.Header)
        resp.Body.Close()
        srv.StandardResponse(writer, resp.StatusCode)</span>
}

func (server *ProxyServer) ObjectPostHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                server.logger.Error("could not get proxy context")
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">containerInfo, err := ctx.C.GetContainerInfo(request.Context(), vars["account"], vars["container"])
        if err != nil </span><span class="cov0" title="0">{
                ctx.ACL = ""
                if ctx.Authorize != nil </span><span class="cov0" title="0">{
                        if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                                srv.StandardResponse(writer, s)
                                return
                        }</span>
                }
                <span class="cov0" title="0">if err == client.ContainerNotFound </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, 404)
                        return
                }</span>
                <span class="cov0" title="0">ctx.Logger.Error("object POST: container error", zap.String("container", vars["container"]), zap.Error(err))
                srv.StandardResponse(writer, 500)
                return</span>
        }
        <span class="cov0" title="0">ctx.ACL = containerInfo.WriteACL
        if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">if status, str := common.CheckObjPost(request, vars["obj"]); status != http.StatusOK </span><span class="cov0" title="0">{
                writer.Header().Set("Content-Type", "text/plain")
                writer.WriteHeader(status)
                writer.Write([]byte(str))
                return
        }</span>
        <span class="cov0" title="0">resp := ctx.C.PostObject(request.Context(), vars["account"], vars["container"], vars["obj"], request.Header)
        resp.Body.Close()
        srv.StandardResponse(writer, resp.StatusCode)</span>
}

func (server *ProxyServer) ObjectPutHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        vars := srv.GetVars(request)
        ctx := middleware.GetProxyContext(request)
        if ctx == nil </span><span class="cov0" title="0">{
                server.logger.Error("could not get proxy context")
                srv.StandardResponse(writer, 500)
                return
        }</span>
        <span class="cov0" title="0">if !(request.Header.Get("If-None-Match") == "" ||
                request.Header.Get("If-None-Match") == "*") </span><span class="cov0" title="0">{
                srv.SimpleErrorResponse(writer, 400, "If-None-Match only supports *")
                return
        }</span>
        <span class="cov0" title="0">containerInfo, err := ctx.C.GetContainerInfo(request.Context(), vars["account"], vars["container"])
        if err != nil </span><span class="cov0" title="0">{
                ctx.ACL = ""
                if ctx.Authorize != nil </span><span class="cov0" title="0">{
                        if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                                srv.StandardResponse(writer, s)
                                return
                        }</span>
                }
                <span class="cov0" title="0">if err == client.ContainerNotFound </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, 404)
                        return
                }</span>
                <span class="cov0" title="0">ctx.Logger.Error("object PUT: container error", zap.String("container", vars["container"]), zap.Error(err))
                srv.StandardResponse(writer, 500)
                return</span>
        }
        <span class="cov0" title="0">ctx.ACL = containerInfo.WriteACL
        if ctx.Authorize != nil </span><span class="cov0" title="0">{
                if ok, s := ctx.Authorize(request); !ok </span><span class="cov0" title="0">{
                        srv.StandardResponse(writer, s)
                        return
                }</span>
        }
        <span class="cov0" title="0">if request.Header.Get("Content-Type") == "" || common.LooksTrue(request.Header.Get("X-Detect-Content-Type")) </span><span class="cov0" title="0">{
                contentType := mime.TypeByExtension(filepath.Ext(vars["obj"]))
                contentType = strings.Split(contentType, ";")[0] // remove any charset it tried to foist on us
                if contentType == "" </span><span class="cov0" title="0">{
                        contentType = "application/octet-stream"
                }</span>
                <span class="cov0" title="0">request.Header.Set("Content-Type", contentType)</span>
        }
        <span class="cov0" title="0">if status, str := common.CheckObjPut(request, vars["obj"]); status != http.StatusOK </span><span class="cov0" title="0">{
                writer.Header().Set("Content-Type", "text/plain")
                writer.WriteHeader(status)
                writer.Write([]byte(str))
                return
        }</span>
        <span class="cov0" title="0">resp := ctx.C.PutObject(request.Context(), vars["account"], vars["container"], vars["obj"], request.Header, request.Body)
        resp.Body.Close()
        writer.Header().Set("Etag", resp.Header.Get("Etag"))
        if modified, err := common.ParseDate(request.Header.Get("X-Timestamp")); err == nil </span><span class="cov0" title="0">{
                writer.Header().Set("Last-Modified", common.FormatLastModified(modified))
        }</span>
        <span class="cov0" title="0">srv.StandardResponse(writer, resp.StatusCode)</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">package tools

import (
        "database/sql"
        "os"
        "path/filepath"
        "time"

        _ "github.com/mattn/go-sqlite3"
        "github.com/troubling/hummingbird/common/conf"
)

var DB_NAME = "andrewd.db"

type dbInstance struct {
        db                     *sql.DB
        serviceErrorExpiration time.Duration
        deviceErrorExpiration  time.Duration
}

func newDB(serverconf *conf.Config, memoryDBID string) (*dbInstance, error) <span class="cov8" title="1">{
        // nil serverconf indicates test mode / in memory db ; memoryDBID will be
        // used in this case to differentiate dbs, such as for independent tests.
        db := &amp;dbInstance{}
        var err error
        if serverconf != nil </span><span class="cov0" title="0">{
                db.serviceErrorExpiration = time.Duration(serverconf.GetInt("andrewd", "service_error_expiration", 3600)) * time.Second
                db.deviceErrorExpiration = time.Duration(serverconf.GetInt("andrewd", "device_error_expiration", 3600)) * time.Second
                sqlDir, ok := serverconf.Get("andrewd", "sql_dir")
                if !ok </span><span class="cov0" title="0">{
                        sqlDir = serverconf.GetDefault("drive_watch", "sql_dir", "/var/local/hummingbird")
                }</span>
                <span class="cov0" title="0">err = os.MkdirAll(sqlDir, 0755)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">db.db, err = sql.Open("sqlite3", filepath.Join(sqlDir, DB_NAME)+"?psow=1&amp;_txlock=immediate&amp;mode=rw")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov8" title="1"> {
                db.serviceErrorExpiration = 3600 * time.Second
                db.deviceErrorExpiration = 3600 * time.Second
                if memoryDBID == "" </span><span class="cov0" title="0">{
                        db.db, err = sql.Open("sqlite3", "file::memory:?cache=shared")
                }</span> else<span class="cov8" title="1"> {
                        db.db, err = sql.Open("sqlite3", "file:"+memoryDBID+"?mode=memory&amp;cache=shared")
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">db.db.SetMaxOpenConns(1)
        _, err = db.db.Exec(`
        PRAGMA synchronous = NORMAL;
        PRAGMA cache_size = -4096;
        PRAGMA temp_store = MEMORY;
        PRAGMA journal_mode = WAL;
        PRAGMA busy_timeout = 25000;

        CREATE TABLE IF NOT EXISTS replication_queue (
            create_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            update_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            rtype TEXT NOT NULL,          -- account, container, object
            policy INTEGER NOT NULL,      -- only used with object
            partition INTEGER NOT NULL,   -- the partition number to replicate
            reason TEXT NOT NULL,         -- ring, dispersion, quarantine
            from_device INTEGER NOT NULL, -- device id in ring to replicate from, &lt; 0 = any
            to_device INTEGER NOT NULL    -- device id in ring to replicate to, must be valid device
        );

        CREATE INDEX IF NOT EXISTS ix_replication_queue_rtype_policy_update_date ON replication_queue (rtype, policy, update_date);

        CREATE TABLE IF NOT EXISTS dispersion_scan_failure (
            create_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            rtype TEXT NOT NULL,        -- account, container, object
            policy INTEGER NOT NULL,    -- only used with object
            partition INTEGER NOT NULL, -- the partition number to replicate
            service TEXT NOT NULL,      -- ip:port of service erroring, or...
            device INTEGER NOT NULL     -- ...device id in ring of device erroring
        );

        CREATE TABLE IF NOT EXISTS process_pass (
            process TEXT NOT NULL,                      -- dispersion populate, dispersion scan, quarantine repair, ...
            rtype TEXT NOT NULL,                        -- account, container, object
            policy INTEGER NOT NULL,                    -- only used with object
            start_date TIMESTAMP DEFAULT 0,             -- when the process last started, 0 = never ran
            progress_date TIMESTAMP DEFAULT 0,          -- when the progress was last updated, 0 = never updated
            progress TEXT,                              -- depends on the process
            complete_date TIMESTAMP DEFAULT 0,          -- when the process completed, 0 = is running or never ran
            previous_progress TEXT NOT NULL DEFAULT "", -- last progress from previous run, depends on the process
            previous_complete_date TIMESTAMP DEFAULT 0  -- when the process previously completed, 0 = is running or never ran
        );

        CREATE TABLE IF NOT EXISTS ring_hash (
            create_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            update_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            rtype TEXT NOT NULL,                -- account, container, object
            policy INTEGER NOT NULL,            -- only used with object
            hash TEXT NOT NULL,                 -- MD5 of on-disk file
            next_rebalance TIMESTAMP            -- Next scheduled rebalance attempt or NULL/IsZero if stable
        );

        -- records multiple states of each server, keeping a configurable time
        -- range of entries, letting us detect how long a server has been down
        -- and if it's been "bouncing" for a while, etc.
        CREATE TABLE IF NOT EXISTS server_state (
            ip TEXT NOT NULL,
            port INTEGER NOT NULL,
            recorded TIMESTAMP NOT NULL,
            state INTEGER NOT NULL      -- 0 = down, 1 = up
        );

        CREATE INDEX IF NOT EXISTS ix_server_state_ip_port_recorded ON server_state (ip, port, recorded);

        -- similar to server_state
        CREATE TABLE IF NOT EXISTS device_state (
            ip TEXT NOT NULL,
            port INTEGER NOT NULL,
            device TEXT NOT NULL,
            recorded TIMESTAMP NOT NULL,
            state INTEGER NOT NULL      -- 0 = unmounted, 1 = mounted
        );

        CREATE INDEX IF NOT EXISTS ix_device_state_ip_port_recorded ON device_state (ip, port, recorded);

        CREATE TABLE IF NOT EXISTS ring_log (
            create_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            rtype TEXT NOT NULL,                -- account, container, object
            policy INTEGER NOT NULL,            -- only used with object
            reason TEXT NOT NULL
        );

        CREATE INDEX IF NOT EXISTS ix_ring_log_rtype_policy_create_date ON ring_log (rtype, policy, create_date);
    `)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return db, nil</span>
}

func (db *dbInstance) queuePartitionReplication(typ string, policy int, partition uint64, reason string, fromDeviceID, toDeviceID int) error <span class="cov0" title="0">{
        var tx *sql.Tx
        var rows *sql.Rows
        var err error
        defer func() </span><span class="cov0" title="0">{
                if rows != nil </span><span class="cov0" title="0">{
                        rows.Close()
                }</span>
                <span class="cov0" title="0">if tx != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()
        <span class="cov0" title="0">tx, err = db.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rows, err = tx.Query(`
        SELECT 1 FROM replication_queue
        WHERE rtype = ?
          AND policy = ?
          AND partition = ?
          AND reason = ?
          AND from_device = ?
          AND to_device = ?
    `, typ, policy, partition, reason, fromDeviceID, toDeviceID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if rows.Next() </span><span class="cov0" title="0">{ // entry already
                return nil
        }</span>
        <span class="cov0" title="0">rows.Close()
        rows = nil
        _, err = tx.Exec(`
        INSERT INTO replication_queue
        (rtype, policy, partition, reason, from_device, to_device)
        VALUES (?, ?, ?, ?, ?, ?)
    `, typ, policy, partition, reason, fromDeviceID, toDeviceID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">tx = nil
        return nil</span>
}

type queuedReplication struct {
        created      time.Time
        updated      time.Time
        typ          string
        policy       int
        partition    int
        reason       string
        fromDeviceID int
        toDeviceID   int
}

// queuedReplications returns the queued replications for the ring type
// (account, container, object), policy index, and reason. Entries will be
// sorted by oldest queued to newest. You can set typ == "" for all types,
// policy &lt; 0 for all policies, and reason == "" for all reasons.
func (db *dbInstance) queuedReplications(typ string, policy int, reason string) ([]*queuedReplication, error) <span class="cov0" title="0">{
        var qrs []*queuedReplication
        var rows *sql.Rows
        var err error
        defer func() </span><span class="cov0" title="0">{
                if rows != nil </span><span class="cov0" title="0">{
                        rows.Close()
                }</span>
        }()
        <span class="cov0" title="0">query := `
        SELECT create_date, update_date, rtype, policy, partition, reason, from_device, to_device
        FROM replication_queue
    `
        var wheres []string
        var args []interface{}
        if typ != "" </span><span class="cov0" title="0">{
                wheres = append(wheres, "rtype = ?")
                args = append(args, typ)
        }</span>
        <span class="cov0" title="0">if policy &gt;= 0 </span><span class="cov0" title="0">{
                wheres = append(wheres, "policy = ?")
                args = append(args, policy)
        }</span>
        <span class="cov0" title="0">if reason != "" </span><span class="cov0" title="0">{
                wheres = append(wheres, "reason = ?")
                args = append(args, reason)
        }</span>
        <span class="cov0" title="0">if len(wheres) &gt; 0 </span><span class="cov0" title="0">{
                query += " WHERE " + wheres[0]
                wheres = wheres[1:]
        }</span>
        <span class="cov0" title="0">for _, where := range wheres </span><span class="cov0" title="0">{
                query += " AND " + where
        }</span>
        <span class="cov0" title="0">query += " ORDER BY update_date"
        rows, err = db.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return qrs, err
        }</span>
        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                qr := &amp;queuedReplication{}
                if err = rows.Scan(&amp;qr.created, &amp;qr.updated, &amp;qr.typ, &amp;qr.policy, &amp;qr.partition, &amp;qr.reason, &amp;qr.fromDeviceID, &amp;qr.toDeviceID); err != nil </span><span class="cov0" title="0">{
                        return qrs, err
                }</span>
                <span class="cov0" title="0">qrs = append(qrs, qr)</span>
        }
        <span class="cov0" title="0">return qrs, nil</span>
}

// updateQueuedReplication will update the qr.updated field for this queue
// replication, so that it will be placed at the back of the queue for future
// retries.
func (db *dbInstance) updateQueuedReplication(qr *queuedReplication) error <span class="cov0" title="0">{
        now := time.Now()
        _, err := db.db.Exec(`
        UPDATE replication_queue
        SET update_date = ?
        WHERE rtype = ?
          AND policy = ?
          AND partition = ?
          AND reason = ?
          AND from_device = ?
          AND to_device = ?
    `, now, qr.typ, qr.policy, qr.partition, qr.reason, qr.fromDeviceID, qr.toDeviceID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">qr.updated = now
        return err</span>
}

func (db *dbInstance) clearQueuedReplication(qr *queuedReplication) error <span class="cov0" title="0">{
        _, err := db.db.Exec(`
        DELETE FROM replication_queue
        WHERE rtype = ?
          AND policy = ?
          AND partition = ?
          AND reason = ?
          AND from_device = ?
          AND to_device = ?
    `, qr.typ, qr.policy, qr.partition, qr.reason, qr.fromDeviceID, qr.toDeviceID)
        return err
}</span>

func (db *dbInstance) clearDispersionScanFailures(typ string, policy int) error <span class="cov0" title="0">{
        _, err := db.db.Exec(`
        DELETE FROM dispersion_scan_failure
        WHERE rtype = ? AND policy = ?
    `, typ, policy)
        return err
}</span>

func (db *dbInstance) recordDispersionScanFailure(typ string, policy int, partition uint64, service string, deviceID int) error <span class="cov0" title="0">{
        _, err := db.db.Exec(`
        INSERT INTO dispersion_scan_failure
        (rtype, policy, partition, service, device)
        VALUES (?, ?, ?, ?, ?)
    `, typ, policy, partition, service, deviceID)
        return err
}</span>

type dispersionScanFailure struct {
        time      time.Time
        partition int
        service   string
        deviceID  int
}

func (db *dbInstance) dispersionScanFailures(typ string, policy int) ([]*dispersionScanFailure, error) <span class="cov0" title="0">{
        var dsfs []*dispersionScanFailure
        var rows *sql.Rows
        var err error
        defer func() </span><span class="cov0" title="0">{
                if rows != nil </span><span class="cov0" title="0">{
                        rows.Close()
                }</span>
        }()
        <span class="cov0" title="0">rows, err = db.db.Query(`
        SELECT create_date, partition, service, device
        FROM dispersion_scan_failure
        WHERE rtype = ?
          AND policy = ?
        ORDER BY create_date
    `, typ, policy)
        if err != nil </span><span class="cov0" title="0">{
                return dsfs, err
        }</span>
        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                dsf := &amp;dispersionScanFailure{}
                if err = rows.Scan(&amp;dsf.time, &amp;dsf.partition, &amp;dsf.service, &amp;dsf.deviceID); err != nil </span><span class="cov0" title="0">{
                        return dsfs, err
                }</span>
                <span class="cov0" title="0">dsfs = append(dsfs, dsf)</span>
        }
        <span class="cov0" title="0">return dsfs, nil</span>
}

func (db *dbInstance) startProcessPass(process, typ string, policy int) error <span class="cov8" title="1">{
        var tx *sql.Tx
        var rows *sql.Rows
        var err error
        defer func() </span><span class="cov8" title="1">{
                if rows != nil </span><span class="cov0" title="0">{
                        rows.Close()
                }</span>
                <span class="cov8" title="1">if tx != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()
        <span class="cov8" title="1">tx, err = db.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">rows, err = tx.Query(`
        SELECT progress, complete_date FROM process_pass
        WHERE process = ?
          AND rtype = ?
          AND policy = ?
    `, process, typ, policy)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if rows.Next() </span><span class="cov0" title="0">{ // entry already
                var previousProgress string
                var previousCompleteDate time.Time
                rows.Scan(&amp;previousProgress, &amp;previousCompleteDate)
                rows.Close()
                rows = nil
                if previousProgress != "" </span><span class="cov0" title="0">{
                        _, err = tx.Exec(`
                UPDATE process_pass
                SET start_date = ?,
                    progress_date = 0,
                    progress = "",
                    complete_date = 0,
                    previous_progress = ?,
                    previous_complete_date = ?
                WHERE process = ?
                  AND rtype = ?
                  AND policy = ?
            `, time.Now(), previousProgress, previousCompleteDate, process, typ, policy)
                }</span> else<span class="cov0" title="0"> {
                        _, err = tx.Exec(`
                UPDATE process_pass
                SET start_date = ?,
                    progress_date = 0,
                    progress = "",
                    complete_date = 0
                WHERE process = ?
                  AND rtype = ?
                  AND policy = ?
            `, time.Now(), process, typ, policy)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">tx = nil
                return nil</span>
        }
        <span class="cov8" title="1">rows.Close()
        rows = nil
        if _, err = tx.Exec(`
        INSERT INTO process_pass
        (process, rtype, policy, start_date, progress_date, progress, complete_date)
        VALUES (?, ?, ?, ?, 0, "", 0)
    `, process, typ, policy, time.Now()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tx = nil
        return nil</span>
}

func (db *dbInstance) progressProcessPass(process, typ string, policy int, progress string) error <span class="cov8" title="1">{
        _, err := db.db.Exec(`
        UPDATE process_pass
        SET progress_date = ?,
            progress = ?
        WHERE process = ?
          AND rtype = ?
          AND policy = ?
    `, time.Now(), progress, process, typ, policy)
        return err
}</span>

func (db *dbInstance) completeProcessPass(process, typ string, policy int) error <span class="cov8" title="1">{
        _, err := db.db.Exec(`
        UPDATE process_pass
        SET complete_date = ?
        WHERE process = ?
          AND rtype = ?
          AND policy = ?
    `, time.Now(), process, typ, policy)
        return err
}</span>

// processPass returns start_date, progress_date, progress, and complete_date.
func (db *dbInstance) processPass(process, typ string, policy int) (time.Time, time.Time, string, time.Time, error) <span class="cov0" title="0">{
        var rows *sql.Rows
        var err error
        var start time.Time
        var progress time.Time
        var progressText string
        var complete time.Time
        defer func() </span><span class="cov0" title="0">{
                if rows != nil </span><span class="cov0" title="0">{
                        rows.Close()
                }</span>
        }()
        <span class="cov0" title="0">if rows, err = db.db.Query(`
        SELECT start_date, progress_date, progress, complete_date
        FROM process_pass
        WHERE process = ?
          AND rtype = ?
          AND policy = ?
    `, process, typ, policy); err != nil </span><span class="cov0" title="0">{
                return start, progress, progressText, complete, err
        }</span>
        <span class="cov0" title="0">if rows.Next() </span><span class="cov0" title="0">{
                err = rows.Scan(&amp;start, &amp;progress, &amp;progressText, &amp;complete)
        }</span>
        <span class="cov0" title="0">if start.UnixNano() == 0 </span><span class="cov0" title="0">{
                start = time.Time{}
        }</span>
        <span class="cov0" title="0">if complete.UnixNano() == 0 </span><span class="cov0" title="0">{
                complete = time.Time{}
        }</span>
        <span class="cov0" title="0">return start, progress, progressText, complete, err</span>
}

type processPassData struct {
        process              string
        rtype                string
        policy               int
        startDate            time.Time
        progressDate         time.Time
        progress             string
        completeDate         time.Time
        previousProgress     string
        previousCompleteDate time.Time
}

func (db *dbInstance) processPasses() ([]*processPassData, error) <span class="cov0" title="0">{
        var rows *sql.Rows
        var err error
        var data []*processPassData
        defer func() </span><span class="cov0" title="0">{
                if rows != nil </span><span class="cov0" title="0">{
                        rows.Close()
                }</span>
        }()
        <span class="cov0" title="0">if rows, err = db.db.Query(`
        SELECT process, rtype, policy, start_date, progress_date, progress, complete_date, previous_progress, previous_complete_date
        FROM process_pass
    `); err != nil </span><span class="cov0" title="0">{
                return data, err
        }</span>
        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                ppd := &amp;processPassData{}
                if err = rows.Scan(&amp;ppd.process, &amp;ppd.rtype, &amp;ppd.policy, &amp;ppd.startDate, &amp;ppd.progressDate, &amp;ppd.progress, &amp;ppd.completeDate, &amp;ppd.previousProgress, &amp;ppd.previousCompleteDate); err != nil </span><span class="cov0" title="0">{
                        return data, err
                }</span>
                <span class="cov0" title="0">if ppd.startDate.UnixNano() == 0 </span><span class="cov0" title="0">{
                        ppd.startDate = time.Time{}
                }</span>
                <span class="cov0" title="0">if ppd.progressDate.UnixNano() == 0 </span><span class="cov0" title="0">{
                        ppd.progressDate = time.Time{}
                }</span>
                <span class="cov0" title="0">if ppd.completeDate.UnixNano() == 0 </span><span class="cov0" title="0">{
                        ppd.completeDate = time.Time{}
                }</span>
                <span class="cov0" title="0">if ppd.previousCompleteDate.UnixNano() == 0 </span><span class="cov0" title="0">{
                        ppd.previousCompleteDate = time.Time{}
                }</span>
                <span class="cov0" title="0">data = append(data, ppd)</span>
        }
        <span class="cov0" title="0">return data, nil</span>
}

func (db *dbInstance) setRingHash(typ string, policy int, hsh string, nextRebalance time.Time) error <span class="cov0" title="0">{
        var tx *sql.Tx
        var rows *sql.Rows
        var err error
        defer func() </span><span class="cov0" title="0">{
                if rows != nil </span><span class="cov0" title="0">{
                        rows.Close()
                }</span>
                <span class="cov0" title="0">if tx != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()
        <span class="cov0" title="0">tx, err = db.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rows, err = tx.Query(`
        SELECT 1 FROM ring_hash
        WHERE rtype = ?
          AND policy = ?
    `, typ, policy)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if rows.Next() </span><span class="cov0" title="0">{ // entry already
                rows.Close()
                rows = nil
                if _, err = tx.Exec(`
            UPDATE ring_hash
            SET update_date = ?, hash = ?, next_rebalance = ?
            WHERE rtype = ?
              AND policy = ?
        `, time.Now(), hsh, nextRebalance, typ, policy); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">tx = nil
                return nil</span>
        }
        <span class="cov0" title="0">rows.Close()
        rows = nil
        if _, err = tx.Exec(`
        INSERT INTO ring_hash
        (update_date, rtype, policy, hash, next_rebalance)
        VALUES (?, ?, ?, ?, ?)
    `, time.Now(), typ, policy, hsh, nextRebalance); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">tx = nil
        return nil</span>
}

func (db *dbInstance) ringHash(typ string, policy int) (string, time.Time, error) <span class="cov0" title="0">{
        var rows *sql.Rows
        var err error
        var hsh string
        var nextRebalance time.Time
        defer func() </span><span class="cov0" title="0">{
                if rows != nil </span><span class="cov0" title="0">{
                        rows.Close()
                }</span>
        }()
        <span class="cov0" title="0">if rows, err = db.db.Query(`
        SELECT hash, next_rebalance
        FROM ring_hash
        WHERE rtype = ?
          AND policy = ?
    `, typ, policy); err != nil </span><span class="cov0" title="0">{
                return hsh, nextRebalance, err
        }</span>
        <span class="cov0" title="0">if rows.Next() </span><span class="cov0" title="0">{
                err = rows.Scan(&amp;hsh, &amp;nextRebalance)
        }</span>
        <span class="cov0" title="0">if nextRebalance.UnixNano() == 0 </span><span class="cov0" title="0">{
                nextRebalance = time.Time{}
        }</span>
        <span class="cov0" title="0">return hsh, nextRebalance, err</span>
}

type stateEntry struct {
        recorded time.Time
        state    bool
}

func (db *dbInstance) serverStates(ip string, port int) ([]*stateEntry, error) <span class="cov0" title="0">{
        var rows *sql.Rows
        var states []*stateEntry
        var err error
        defer func() </span><span class="cov0" title="0">{
                if rows != nil </span><span class="cov0" title="0">{
                        rows.Close()
                }</span>
        }()
        <span class="cov0" title="0">if rows, err = db.db.Query(`
        SELECT recorded, state
        FROM server_state
        WHERE ip = ?
          AND port = ?
        ORDER BY recorded DESC
    `, ip, port); err != nil </span><span class="cov0" title="0">{
                return states, err
        }</span>
        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                var recorded time.Time
                var state int
                if err = rows.Scan(&amp;recorded, &amp;state); err != nil </span><span class="cov0" title="0">{
                        return states, err
                }</span>
                <span class="cov0" title="0">states = append(states, &amp;stateEntry{recorded: recorded, state: state == 1})</span>
        }
        <span class="cov0" title="0">err = rows.Err()
        return states, err</span>
}

func (db *dbInstance) addServerState(ip string, port int, up bool, retention time.Time) error <span class="cov0" title="0">{
        state := 0
        if up </span><span class="cov0" title="0">{
                state = 1
        }</span>
        <span class="cov0" title="0">_, err := db.db.Exec(`
        INSERT INTO server_state
        (ip, port, recorded, state)
        VALUES (?, ?, ?, ?)
    `, ip, port, time.Now(), state)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = db.db.Exec(`
        DELETE FROM server_state
        WHERE recorded &lt; ?
    `, retention)
        return err</span>
}

func (db *dbInstance) deviceStates(ip string, port int, device string) ([]*stateEntry, error) <span class="cov0" title="0">{
        var rows *sql.Rows
        var states []*stateEntry
        var err error
        defer func() </span><span class="cov0" title="0">{
                if rows != nil </span><span class="cov0" title="0">{
                        rows.Close()
                }</span>
        }()
        <span class="cov0" title="0">if rows, err = db.db.Query(`
        SELECT recorded, state
        FROM device_state
        WHERE ip = ?
          AND port = ?
          AND device = ?
        ORDER BY recorded DESC
    `, ip, port, device); err != nil </span><span class="cov0" title="0">{
                return states, err
        }</span>
        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                var recorded time.Time
                var state int
                if err = rows.Scan(&amp;recorded, &amp;state); err != nil </span><span class="cov0" title="0">{
                        return states, err
                }</span>
                <span class="cov0" title="0">states = append(states, &amp;stateEntry{recorded: recorded, state: state == 1})</span>
        }
        <span class="cov0" title="0">err = rows.Err()
        return states, err</span>
}

func (db *dbInstance) addDeviceState(ip string, port int, device string, mounted bool, retention time.Time) error <span class="cov0" title="0">{
        state := 0
        if mounted </span><span class="cov0" title="0">{
                state = 1
        }</span>
        <span class="cov0" title="0">_, err := db.db.Exec(`
        INSERT INTO device_state
        (ip, port, device, recorded, state)
        VALUES (?, ?, ?, ?, ?)
    `, ip, port, device, time.Now(), state)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = db.db.Exec(`
        DELETE FROM device_state
        WHERE recorded &lt; ?
    `, retention)
        return err</span>
}

type ringLogEntry struct {
        Time   time.Time
        Reason string
}

func (db *dbInstance) ringLogs(typ string, policy int) ([]*ringLogEntry, error) <span class="cov0" title="0">{
        rows, err := db.db.Query(`
        SELECT create_date, reason
        FROM ring_log
        WHERE rtype = ? AND policy = ?
        ORDER BY create_date
    `, typ, policy)
        if rows != nil </span><span class="cov0" title="0">{
                defer rows.Close()
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var entries []*ringLogEntry
        for rows.Next() </span><span class="cov0" title="0">{
                var t time.Time
                var r string
                if err = rows.Scan(&amp;t, &amp;r); err != nil </span><span class="cov0" title="0">{
                        return entries, err
                }</span>
                <span class="cov0" title="0">entries = append(entries, &amp;ringLogEntry{Time: t, Reason: r})</span>
        }
        <span class="cov0" title="0">err = rows.Err()
        return entries, err</span>
}

func (db *dbInstance) addRingLog(typ string, policy int, reason string) error <span class="cov0" title="0">{
        _, err := db.db.Exec(`
        INSERT INTO ring_log
        (rtype, policy, reason)
        VALUES (?, ?, ?)
    `, typ, policy, reason)
        return err
}</span>
</pre>
		
		<pre class="file" id="file108" style="display: none">package tools

import (
        "flag"
        "fmt"
        "runtime"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/ring"
)

var partitionListCap = 4

type dispersionReport struct {
        Name            string
        Time            time.Time
        Pass            bool
        Errors          []string
        IssueCount      int
        ContainerReport *innerDispersionReport
        ObjectReports   map[int]*innerDispersionReport
}

func (r *dispersionReport) Passed() bool <span class="cov0" title="0">{
        return r.Pass
}</span>

func (r *dispersionReport) String() string <span class="cov0" title="0">{
        s := fmt.Sprintf(
                "[%s] %s\n",
                r.Time.Format("2006-01-02 15:04:05"),
                r.Name,
        )
        for _, e := range r.Errors </span><span class="cov0" title="0">{
                s += fmt.Sprintf("!! %s\n", e)
        }</span>
        <span class="cov0" title="0">if r.ContainerReport != nil </span><span class="cov0" title="0">{
                s += fmt.Sprintf("\nContainer Dispersion Report\n%s", r.ContainerReport.String())
        }</span>
        <span class="cov0" title="0">var policies []int
        for policy := range r.ObjectReports </span><span class="cov0" title="0">{
                policies = append(policies, policy)
        }</span>
        <span class="cov0" title="0">sort.Ints(policies)
        for policy := range policies </span><span class="cov0" title="0">{
                or := r.ObjectReports[policy]
                s += fmt.Sprintf("\nObject Dispersion Report for Policy: %d %s\n%s", policy, or.PolicyName, or.String())
        }</span>
        <span class="cov0" title="0">return s</span>
}

type innerDispersionReport struct {
        PolicyName      string
        Start           time.Time
        Complete        time.Time
        TotalPartitions int
        ReplicaCount    int
        Partitions      map[int][]*dispersionMissing
        ScanFailures    map[int][]*scanFailure
}

type scanFailure struct {
        Time     time.Time
        Service  string
        DeviceID int
}

func (r *innerDispersionReport) String() string <span class="cov0" title="0">{
        addPartitionListCap := func(s []string, p int) []string </span><span class="cov0" title="0">{
                if len(s) &lt; partitionListCap </span><span class="cov0" title="0">{
                        return append(s, fmt.Sprintf("%d", p))
                }</span>
                <span class="cov0" title="0">if len(s) == partitionListCap </span><span class="cov0" title="0">{
                        s[partitionListCap-1] = "..."
                }</span>
                <span class="cov0" title="0">return s</span>
        }
        <span class="cov0" title="0">var s string
        if r.Start.IsZero() </span><span class="cov0" title="0">{
                s += "    No known dispersion scan has been run.\n"
        }</span> else<span class="cov0" title="0"> if r.Complete.IsZero() </span><span class="cov0" title="0">{
                s += fmt.Sprintf("    Last dispersion scan started %s and has yet to complete after %s.\n", r.Start.Format("2006-01-02 15:04"), time.Since(r.Start).Truncate(time.Second))
        }</span> else<span class="cov0" title="0"> {
                s += fmt.Sprintf("    Last dispersion scan ran from %s to %s (%s ago for %s).\n", r.Start.Format("2006-01-02 15:04"), r.Complete.Format("2006-01-02 15:04"), time.Since(r.Complete).Truncate(time.Second), r.Complete.Sub(r.Start).Truncate(time.Second))
        }</span>
        <span class="cov0" title="0">s += fmt.Sprintf("    There are %d partitions configured for %d copies.\n", r.TotalPartitions, r.ReplicaCount)
        if !r.Start.IsZero() &amp;&amp; len(r.Partitions) == 0 </span><span class="cov0" title="0">{
                s += "    All partition copies were in place when last checked.\n"
        }</span> else<span class="cov0" title="0"> {
                var noCopies []string
                var oneCopies []string
                counts := map[int]int{}
                for partition, missings := range r.Partitions </span><span class="cov0" title="0">{
                        switch r.ReplicaCount - len(missings) </span>{
                        case 0:<span class="cov0" title="0">
                                noCopies = addPartitionListCap(noCopies, partition)</span>
                        case 1:<span class="cov0" title="0">
                                oneCopies = addPartitionListCap(oneCopies, partition)</span>
                        }
                        <span class="cov0" title="0">counts[len(missings)]++</span>
                }
                <span class="cov0" title="0">var keys []int
                for key := range counts </span><span class="cov0" title="0">{
                        keys = append(keys, key)
                }</span>
                <span class="cov0" title="0">sort.Ints(keys)
                for _, key := range keys </span><span class="cov0" title="0">{
                        if counts[key] == 1 </span><span class="cov0" title="0">{
                                s += "    ! 1 partition was missing "
                        }</span> else<span class="cov0" title="0"> {
                                s += fmt.Sprintf("    ! %d partitions were missing ", counts[key])
                        }</span>
                        <span class="cov0" title="0">if key == 1 </span><span class="cov0" title="0">{
                                s += "1 copy"
                        }</span> else<span class="cov0" title="0"> {
                                s += fmt.Sprintf("%d copies", key)
                        }</span>
                        <span class="cov0" title="0">if r.ReplicaCount-key == 0 </span><span class="cov0" title="0">{
                                s += fmt.Sprintf("; NO COPIES AVAILABLE! %v\n", noCopies)
                        }</span> else<span class="cov0" title="0"> if r.ReplicaCount-key == 1 </span><span class="cov0" title="0">{
                                s += fmt.Sprintf("; DOWN TO ONE COPY! %v\n", oneCopies)
                        }</span> else<span class="cov0" title="0"> {
                                s += fmt.Sprintf("; %d copies found.\n", r.ReplicaCount-key)
                        }</span>
                }
        }
        <span class="cov0" title="0">failureCount := 0
        for _, sfs := range r.ScanFailures </span><span class="cov0" title="0">{
                failureCount += len(sfs)
        }</span>
        <span class="cov0" title="0">if failureCount == 1 </span><span class="cov0" title="0">{
                s += "    !! 1 scan failure which may skew the report.\n"
        }</span> else<span class="cov0" title="0"> if failureCount &gt; 1 </span><span class="cov0" title="0">{
                s += fmt.Sprintf("    !! %d scan failures which may skew the report.\n", failureCount)
        }</span>
        <span class="cov0" title="0">if failureCount &gt; 0 </span><span class="cov0" title="0">{
                s += fmt.Sprintf("    Assuming any scan failure is equivalent to a missing copy:\n")
                var noCopies []string
                var oneCopies []string
                counts := map[int]int{}
                for partition, missings := range r.Partitions </span><span class="cov0" title="0">{
                        c := len(missings) + len(r.ScanFailures[partition])
                        if c &gt; r.ReplicaCount </span><span class="cov0" title="0">{
                                c = r.ReplicaCount
                        }</span>
                        <span class="cov0" title="0">switch r.ReplicaCount - c </span>{
                        case 0:<span class="cov0" title="0">
                                if len(noCopies) &lt;= partitionListCap </span><span class="cov0" title="0">{
                                        noCopies = append(noCopies, fmt.Sprintf("%d", partition))
                                }</span>
                        case 1:<span class="cov0" title="0">
                                if len(oneCopies) &lt;= partitionListCap </span><span class="cov0" title="0">{
                                        oneCopies = append(oneCopies, fmt.Sprintf("%d", partition))
                                }</span>
                        }
                        <span class="cov0" title="0">counts[c]++</span>
                }
                <span class="cov0" title="0">for partition, sfs := range r.ScanFailures </span><span class="cov0" title="0">{
                        // Did we already count this in loop above?
                        if r.Partitions[partition] == nil </span><span class="cov0" title="0">{
                                c := len(sfs)
                                if c &gt; r.ReplicaCount </span><span class="cov0" title="0">{
                                        c = r.ReplicaCount
                                }</span>
                                <span class="cov0" title="0">switch r.ReplicaCount - c </span>{
                                case 0:<span class="cov0" title="0">
                                        noCopies = addPartitionListCap(noCopies, partition)</span>
                                case 1:<span class="cov0" title="0">
                                        oneCopies = addPartitionListCap(oneCopies, partition)</span>
                                }
                                <span class="cov0" title="0">counts[c]++</span>
                        }
                }
                <span class="cov0" title="0">var keys []int
                for key := range counts </span><span class="cov0" title="0">{
                        keys = append(keys, key)
                }</span>
                <span class="cov0" title="0">sort.Ints(keys)
                for _, key := range keys </span><span class="cov0" title="0">{
                        if counts[key] == 1 </span><span class="cov0" title="0">{
                                s += "        ! 1 partition was missing "
                        }</span> else<span class="cov0" title="0"> {
                                s += fmt.Sprintf("        ! %d partitions were missing ", counts[key])
                        }</span>
                        <span class="cov0" title="0">if key == 1 </span><span class="cov0" title="0">{
                                s += "1 copy"
                        }</span> else<span class="cov0" title="0"> {
                                s += fmt.Sprintf("%d copies", key)
                        }</span>
                        <span class="cov0" title="0">if r.ReplicaCount-key == 0 </span><span class="cov0" title="0">{
                                s += fmt.Sprintf("; NO COPIES AVAILABLE! %v\n", noCopies)
                        }</span> else<span class="cov0" title="0"> if r.ReplicaCount-key == 1 </span><span class="cov0" title="0">{
                                s += fmt.Sprintf("; DOWN TO ONE COPY! %v\n", oneCopies)
                        }</span> else<span class="cov0" title="0"> {
                                s += fmt.Sprintf("; %d copies found.\n", r.ReplicaCount-key)
                        }</span>
                }
        }
        <span class="cov0" title="0">return s</span>
}

type dispersionMissing struct {
        Time    time.Time
        Service string
        Device  string
}

func getDispersionReport(flags *flag.FlagSet) *dispersionReport <span class="cov0" title="0">{
        report := &amp;dispersionReport{
                Name:          "Dispersion Report",
                Time:          time.Now().UTC(),
                Pass:          true,
                ObjectReports: map[int]*innerDispersionReport{},
        }
        serverconf, err := getAndrewdConf(flags)
        if err != nil </span><span class="cov0" title="0">{
                report.Errors = append(report.Errors, err.Error())
                return report
        }</span>
        <span class="cov0" title="0">db, err := newDB(serverconf, "")
        if err != nil </span><span class="cov0" title="0">{
                report.Errors = append(report.Errors, err.Error())
                return report
        }</span>
        <span class="cov0" title="0">ring, _ := getRing("", "container", 0)
        report.ContainerReport = &amp;innerDispersionReport{TotalPartitions: int(ring.PartitionCount()), ReplicaCount: int(ring.ReplicaCount()), Partitions: map[int][]*dispersionMissing{}, ScanFailures: map[int][]*scanFailure{}}
        var progress string
        report.ContainerReport.Start, _, progress, report.ContainerReport.Complete, err = db.processPass("dispersion scan", "container", 0)
        if err != nil </span><span class="cov0" title="0">{
                report.Errors = append(report.Errors, err.Error())
        }</span>
        <span class="cov0" title="0">if strings.HasSuffix(progress, "-init does not yet exist") </span><span class="cov0" title="0">{
                report.ContainerReport.Start = time.Time{}
                report.ContainerReport.Complete = time.Time{}
        }</span>
        <span class="cov0" title="0">if dsfs, err := db.dispersionScanFailures("container", 0); err != nil </span><span class="cov0" title="0">{
                report.Errors = append(report.Errors, err.Error())
        }</span> else<span class="cov0" title="0"> {
                for _, dsf := range dsfs </span><span class="cov0" title="0">{
                        report.ContainerReport.ScanFailures[dsf.partition] = append(report.ContainerReport.ScanFailures[dsf.partition], &amp;scanFailure{Time: dsf.time, Service: dsf.service, DeviceID: dsf.deviceID})
                }</span>
        }
        <span class="cov0" title="0">if qrs, err := db.queuedReplications("container", 0, "dispersion"); err != nil </span><span class="cov0" title="0">{
                report.Errors = append(report.Errors, err.Error())
        }</span> else<span class="cov0" title="0"> {
                for _, qr := range qrs </span><span class="cov0" title="0">{
                        dev := ring.AllDevices()[qr.toDeviceID]
                        if !dev.Active() </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">report.ContainerReport.Partitions[qr.partition] = append(report.ContainerReport.Partitions[qr.partition], &amp;dispersionMissing{
                                Time:    qr.created,
                                Service: fmt.Sprintf("%s:%d", dev.Ip, dev.Port),
                                Device:  dev.Device,
                        })
                        report.Pass = false</span>
                }
        }
        <span class="cov0" title="0">if policies, err := conf.GetPolicies(); err != nil </span><span class="cov0" title="0">{
                report.Errors = append(report.Errors, err.Error())
        }</span> else<span class="cov0" title="0"> {
                for _, policy := range policies </span><span class="cov0" title="0">{
                        if policy.Config["andrewd"] == "ignore" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">ring, _ := getRing("", "object", policy.Index)
                        objectReport := &amp;innerDispersionReport{TotalPartitions: int(ring.PartitionCount()), ReplicaCount: int(ring.ReplicaCount()), Partitions: map[int][]*dispersionMissing{}, ScanFailures: map[int][]*scanFailure{}}
                        var progress string
                        objectReport.Start, _, progress, objectReport.Complete, err = db.processPass("dispersion scan", "object", policy.Index)
                        if err != nil </span><span class="cov0" title="0">{
                                report.Errors = append(report.Errors, err.Error())
                                continue</span>
                        }
                        <span class="cov0" title="0">if strings.HasSuffix(progress, "-init does not yet exist") </span><span class="cov0" title="0">{
                                objectReport.Start = time.Time{}
                                objectReport.Complete = time.Time{}
                        }</span>
                        <span class="cov0" title="0">if dsfs, err := db.dispersionScanFailures("object", policy.Index); err != nil </span><span class="cov0" title="0">{
                                report.Errors = append(report.Errors, err.Error())
                        }</span> else<span class="cov0" title="0"> {
                                for _, dsf := range dsfs </span><span class="cov0" title="0">{
                                        objectReport.ScanFailures[dsf.partition] = append(objectReport.ScanFailures[dsf.partition], &amp;scanFailure{Time: dsf.time, Service: dsf.service, DeviceID: dsf.deviceID})
                                }</span>
                        }
                        <span class="cov0" title="0">objectReport.PolicyName = policy.Name
                        report.ObjectReports[policy.Index] = objectReport
                        qrs, err := db.queuedReplications("object", policy.Index, "dispersion")
                        if err != nil </span><span class="cov0" title="0">{
                                report.Errors = append(report.Errors, err.Error())
                                continue</span>
                        }
                        <span class="cov0" title="0">for _, qr := range qrs </span><span class="cov0" title="0">{
                                dev := ring.AllDevices()[qr.toDeviceID]
                                if !dev.Active() </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">objectReport.Partitions[qr.partition] = append(objectReport.Partitions[qr.partition], &amp;dispersionMissing{
                                        Time:    qr.created,
                                        Service: fmt.Sprintf("%s:%d", dev.Ip, dev.Port),
                                        Device:  dev.Device,
                                })
                                report.Pass = false</span>
                        }
                }
        }
        <span class="cov0" title="0">if len(report.Errors) &gt; 0 </span><span class="cov0" title="0">{
                report.Pass = false
        }</span>
        <span class="cov0" title="0">return report</span>
}

// generateDispersionNames will feed a name per partition into the names
// channel. The container should be an empty string if you wish to have
// container names generated. The prefix will be the start of every name. The
// cancel channel can be closed to abort the name generation. The concurrency
// value, if 0, will default to 1/4 the number of CPUs (cores).
// Usually, the container name generation is called with
// generateDispersionNames("", "disp-conts-", containerRing, containerNames, cancel, 0)
// and the object name generation is called with
// generateDispersionNames("disp-objs-&lt;POLICYINDEX&gt;", "", objectRing, objectNames, cancel, 0)
func generateDispersionNames(container, prefix string, r ring.Ring, names chan string, cancel chan struct{}, concurrency uint64) <span class="cov8" title="1">{
        // if looking for container names, send container=""
        defer close(names)
        var wg sync.WaitGroup
        if concurrency &lt; 1 </span><span class="cov8" title="1">{
                concurrency = uint64(runtime.NumCPU()) / 4
                if concurrency &lt; 1 </span><span class="cov8" title="1">{
                        concurrency = 1
                }</span>
        }
        <span class="cov8" title="1">for goroutine := uint64(0); goroutine &lt; concurrency; goroutine++ </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(funcGoroutine uint64) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        for partition := funcGoroutine; true; partition += concurrency </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-cancel:<span class="cov0" title="0">
                                        break</span>
                                default:</span><span class="cov8" title="1">
                                }
                                <span class="cov8" title="1">devs := r.GetNodes(partition)
                                if devs == nil </span><span class="cov8" title="1">{
                                        break</span>
                                }
                                <span class="cov8" title="1">for i := uint64(0); true; i++ </span><span class="cov8" title="1">{
                                        select </span>{
                                        case &lt;-cancel:<span class="cov0" title="0">
                                                break</span>
                                        default:</span><span class="cov8" title="1">
                                        }
                                        <span class="cov8" title="1">c := container
                                        o := ""
                                        n := fmt.Sprintf("%s%d-%d", prefix, partition, i)
                                        if c == "" </span><span class="cov0" title="0">{
                                                c = n
                                        }</span> else<span class="cov8" title="1"> {
                                                o = n
                                        }</span>
                                        <span class="cov8" title="1">genPart := r.GetPartition(AdminAccount, c, o)
                                        if genPart == partition </span><span class="cov8" title="1">{
                                                names &lt;- n
                                                break</span>
                                        }
                                }
                        }
                }(goroutine)
        }
        <span class="cov8" title="1">wg.Wait()</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package tools

// In /etc/hummingbird/andrewd-server.conf:
// [dispersion-populate-containers]
// retry_time = 3600     # seconds before retrying a failed populate pass
// report_interval = 600 # seconds between progress reports
// concurrency = 0       # how many cpu cores to use while populating

import (
        "context"
        "fmt"
        "io"
        "io/ioutil"
        "sync/atomic"
        "time"

        "github.com/troubling/hummingbird/common"
        "go.uber.org/zap"
)

type dispersionPopulateContainers struct {
        aa             *AutoAdmin
        retryTime      time.Duration
        reportInterval time.Duration
        concurrency    uint64
}

func newDispersionPopulateContainers(aa *AutoAdmin) *dispersionPopulateContainers <span class="cov0" title="0">{
        dpc := &amp;dispersionPopulateContainers{
                aa:             aa,
                retryTime:      time.Duration(aa.serverconf.GetInt("dispersion-populate-containers", "retry_time", 3600)) * time.Second,
                reportInterval: time.Duration(aa.serverconf.GetInt("dispersion-populate-containers", "report_interval", 600)) * time.Second,
        }
        concurrency := aa.serverconf.GetInt("dispersion-populate-containers", "concurrency", 0)
        if concurrency &lt; 1 </span><span class="cov0" title="0">{
                concurrency = 0
        }</span>
        <span class="cov0" title="0">dpc.concurrency = uint64(concurrency)
        return dpc</span>
}

func (dpc *dispersionPopulateContainers) runForever() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                sleepFor := dpc.runOnce()
                if sleepFor &lt; 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">time.Sleep(sleepFor)</span>
        }
}

func (dpc *dispersionPopulateContainers) runOnce() time.Duration <span class="cov0" title="0">{
        start := time.Now()
        logger := dpc.aa.logger.With(zap.String("process", "dispersion populate containers"))
        resp := dpc.aa.hClient.HeadContainer(context.Background(), AdminAccount, "container-init", nil)
        io.Copy(ioutil.Discard, resp.Body)
        resp.Body.Close()
        if resp.StatusCode/100 == 2 </span><span class="cov0" title="0">{
                logger.Debug("container-init already exists; no need to populate containers")
                return -1
        }</span>
        <span class="cov0" title="0">logger.Debug("starting pass")
        if err := dpc.aa.db.startProcessPass("dispersion populate", "container", 0); err != nil </span><span class="cov0" title="0">{
                logger.Error("startProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">containerRing := dpc.aa.hClient.ContainerRing()
        containerNames := make(chan string, 100)
        cancel := make(chan struct{})
        var successes int64
        var errors int64
        go generateDispersionNames("", "disp-conts-", containerRing, containerNames, cancel, dpc.concurrency)
        progressDone := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-cancel:<span class="cov0" title="0">
                                close(progressDone)
                                return</span>
                        case &lt;-time.After(dpc.reportInterval):<span class="cov0" title="0">
                                s := atomic.LoadInt64(&amp;successes)
                                e := atomic.LoadInt64(&amp;errors)
                                var eta time.Duration
                                if s+e &gt; 0 </span><span class="cov0" title="0">{
                                        eta = time.Duration(int64(time.Since(start)) / (s + e) * (int64(containerRing.PartitionCount()) - s - e))
                                }</span>
                                <span class="cov0" title="0">logger.Debug("progress", zap.Int64("successes", s), zap.Int64("errors", e), zap.String("eta", eta.String()))
                                if err := dpc.aa.db.progressProcessPass("dispersion populate", "container", 0, fmt.Sprintf("%d of %d partitions, %d successes, %d errors, %s eta", s+e, containerRing.PartitionCount(), s, e, eta)); err != nil </span><span class="cov0" title="0">{
                                        logger.Error("progressProcessPass", zap.Error(err))
                                }</span>
                        }
                }
        }()
        <span class="cov0" title="0">for container := range containerNames </span><span class="cov0" title="0">{
                resp := dpc.aa.hClient.PutContainer(
                        context.Background(),
                        AdminAccount,
                        container,
                        common.Map2Headers(map[string]string{
                                "Content-Length": "0",
                                "Content-Type":   "text",
                                "X-Timestamp":    fmt.Sprintf("%d", time.Now().Unix()),
                        }),
                )
                io.Copy(ioutil.Discard, resp.Body)
                resp.Body.Close()
                if resp.StatusCode/100 == 2 </span><span class="cov0" title="0">{
                        atomic.AddInt64(&amp;successes, 1)
                }</span> else<span class="cov0" title="0"> {
                        if atomic.AddInt64(&amp;errors, 1) &gt; 1000 </span><span class="cov0" title="0">{
                                // After 1000 errors we'll just assume "things" are broken
                                // right now and try again next pass.
                                break</span>
                        }
                        <span class="cov0" title="0">logger.Error("PUT", zap.String("account", AdminAccount), zap.String("container", container), zap.Int("status", resp.StatusCode))</span>
                }
        }
        <span class="cov0" title="0">close(cancel)
        &lt;-progressDone
        if errors == 0 </span><span class="cov0" title="0">{
                resp = dpc.aa.hClient.PutContainer(
                        context.Background(),
                        AdminAccount,
                        "container-init",
                        common.Map2Headers(map[string]string{
                                "Content-Length": "0",
                                "Content-Type":   "text",
                                "X-Timestamp":    fmt.Sprintf("%d", time.Now().Unix()),
                        }),
                )
                io.Copy(ioutil.Discard, resp.Body)
                resp.Body.Close()
                if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                        logger.Error("PUT", zap.String("account", AdminAccount), zap.String("container", "container-init"), zap.Int("status", resp.StatusCode))
                        errors++
                }</span>
        }
        <span class="cov0" title="0">if err := dpc.aa.db.progressProcessPass("dispersion populate", "container", 0, fmt.Sprintf("%d successes, %d errors", successes, errors)); err != nil </span><span class="cov0" title="0">{
                logger.Error("progressProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">if err := dpc.aa.db.completeProcessPass("dispersion populate", "container", 0); err != nil </span><span class="cov0" title="0">{
                logger.Error("completeProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">if errors == 0 </span><span class="cov0" title="0">{
                logger.Debug("pass completed successfully", zap.Int64("successes", successes), zap.Int64("errors", errors))
                return -1
        }</span>
        <span class="cov0" title="0">sleepFor := time.Until(start.Add(dpc.retryTime))
        if sleepFor &lt; 0 </span><span class="cov0" title="0">{
                sleepFor = 0
        }</span>
        <span class="cov0" title="0">logger.Debug("pass completed with errors", zap.Int64("successes", successes), zap.Int64("errors", errors), zap.String("next attempt", sleepFor.String()))
        return sleepFor</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package tools

// In /etc/hummingbird/andrewd-server.conf:
// [dispersion-populate-objects]
// retry_time = 3600     # seconds before retrying a failed populate pass
// report_interval = 600 # seconds between progress reports
// concurrency = 0       # how many cpu cores to use while populating

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "io/ioutil"
        "sync/atomic"
        "time"

        "go.uber.org/zap"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
)

type dispersionPopulateObjects struct {
        aa             *AutoAdmin
        retryTime      time.Duration
        reportInterval time.Duration
        concurrency    uint64
}

func newDispersionPopulateObjects(aa *AutoAdmin) *dispersionPopulateObjects <span class="cov8" title="1">{
        dpo := &amp;dispersionPopulateObjects{
                aa:             aa,
                retryTime:      time.Duration(aa.serverconf.GetInt("dispersion-populate-objects", "retry_time", 3600)) * time.Second,
                reportInterval: time.Duration(aa.serverconf.GetInt("dispersion-populate-objects", "report_interval", 600)) * time.Second,
        }
        concurrency := aa.serverconf.GetInt("dispersion-populate-objects", "concurrency", 0)
        if concurrency &lt; 1 </span><span class="cov8" title="1">{
                concurrency = 0
        }</span>
        <span class="cov8" title="1">dpo.concurrency = uint64(concurrency)
        return dpo</span>
}

func (dpo *dispersionPopulateObjects) runForever() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                sleepFor := dpo.runOnce()
                if sleepFor &lt; 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">time.Sleep(sleepFor)</span>
        }
}

func (dpo *dispersionPopulateObjects) runOnce() time.Duration <span class="cov8" title="1">{
        start := time.Now()
        logger := dpo.aa.logger.With(zap.String("process", "dispersion populate objects"))
        logger.Debug("starting pass")
        if err := dpo.aa.db.startProcessPass("dispersion populate", "object-overall", 0); err != nil </span><span class="cov0" title="0">{
                logger.Error("startProcessPass", zap.Error(err))
        }</span>
        <span class="cov8" title="1">failed := false
        for _, policy := range dpo.aa.policies </span><span class="cov8" title="1">{
                if !policy.Deprecated </span><span class="cov8" title="1">{
                        if !dpo.putDispersionObjects(logger, policy) </span><span class="cov0" title="0">{
                                failed = true
                        }</span>
                }
        }
        <span class="cov8" title="1">if err := dpo.aa.db.progressProcessPass("dispersion populate", "object-overall", 0, fmt.Sprintf("%d policies", len(dpo.aa.policies))); err != nil </span><span class="cov0" title="0">{
                logger.Error("progressProcessPass", zap.Error(err))
        }</span>
        <span class="cov8" title="1">if err := dpo.aa.db.completeProcessPass("dispersion populate", "object-overall", 0); err != nil </span><span class="cov0" title="0">{
                logger.Error("completeProcessPass", zap.Error(err))
        }</span>
        <span class="cov8" title="1">if !failed </span><span class="cov8" title="1">{
                logger.Debug("pass completed successfully")
                return -1
        }</span>
        <span class="cov0" title="0">sleepFor := time.Until(start.Add(dpo.retryTime))
        if sleepFor &lt; 0 </span><span class="cov0" title="0">{
                sleepFor = 0
        }</span>
        <span class="cov0" title="0">logger.Debug("pass complete but with errors", zap.String("next attempt", sleepFor.String()))
        return sleepFor</span>
}

func (dpo *dispersionPopulateObjects) putDispersionObjects(logger *zap.Logger, policy *conf.Policy) bool <span class="cov8" title="1">{
        start := time.Now()
        logger = logger.With(zap.Int("policy", policy.Index))
        container := fmt.Sprintf("disp-objs-%d", policy.Index)
        resp := dpo.aa.hClient.HeadObject(context.Background(), AdminAccount, container, "object-init", nil)
        io.Copy(ioutil.Discard, resp.Body)
        resp.Body.Close()
        if resp.StatusCode/100 == 2 </span><span class="cov0" title="0">{
                logger.Debug("object-init already exists; no need to populate objects")
                return true
        }</span>
        <span class="cov8" title="1">resp = dpo.aa.hClient.PutContainer(
                context.Background(),
                AdminAccount,
                container,
                common.Map2Headers(map[string]string{
                        "Content-Length":   "0",
                        "Content-Type":     "text",
                        "X-Timestamp":      fmt.Sprintf("%d", time.Now().Unix()),
                        "X-Storage-Policy": policy.Name,
                }),
        )
        if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                logger.Error("PUT", zap.String("account", AdminAccount), zap.String("container", container), zap.Int("status", resp.StatusCode))
                return false
        }</span>
        <span class="cov8" title="1">objectRing, resp := dpo.aa.hClient.ObjectRingFor(context.Background(), AdminAccount, container)
        if objectRing == nil || resp != nil </span><span class="cov0" title="0">{
                if resp == nil </span><span class="cov0" title="0">{
                        logger.Error("no ring")
                }</span> else<span class="cov0" title="0"> {
                        logger.Error("no ring", zap.Int("status", resp.StatusCode))
                }</span>
                <span class="cov0" title="0">return false</span>
        }
        <span class="cov8" title="1">logger.Debug("starting policy pass")
        if err := dpo.aa.db.startProcessPass("dispersion populate", "object", policy.Index); err != nil </span><span class="cov0" title="0">{
                logger.Error("startProcessPass", zap.Error(err))
        }</span>
        <span class="cov8" title="1">objectNames := make(chan string, 100)
        cancel := make(chan struct{})
        var successes int64
        var errors int64
        go generateDispersionNames(container, "", objectRing, objectNames, cancel, dpo.concurrency)
        progressDone := make(chan struct{})
        go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-cancel:<span class="cov8" title="1">
                                close(progressDone)
                                return</span>
                        case &lt;-time.After(dpo.reportInterval):<span class="cov0" title="0">
                                s := atomic.LoadInt64(&amp;successes)
                                e := atomic.LoadInt64(&amp;errors)
                                var eta time.Duration
                                if s+e &gt; 0 </span><span class="cov0" title="0">{
                                        eta = time.Duration(int64(time.Since(start)) / (s + e) * (int64(objectRing.PartitionCount()) - s - e))
                                }</span>
                                <span class="cov0" title="0">logger.Debug("progress", zap.Int64("successes", s), zap.Int64("errors", e), zap.String("eta", eta.String()))
                                if err := dpo.aa.db.progressProcessPass("dispersion populate", "object", policy.Index, fmt.Sprintf("%d of %d partitions, %d successes, %d errors, %s eta", s+e, objectRing.PartitionCount(), s, e, eta)); err != nil </span><span class="cov0" title="0">{
                                        logger.Error("progressProcessPass", zap.Error(err))
                                }</span>
                        }
                }
        }()
        <span class="cov8" title="1">for object := range objectNames </span><span class="cov8" title="1">{
                xtimestamp := time.Now()
                resp := dpo.aa.hClient.PutObject(
                        context.Background(),
                        AdminAccount,
                        container,
                        object,
                        common.Map2Headers(map[string]string{
                                "Content-Length": "0",
                                "Content-Type":   "text",
                                "X-Timestamp":    common.CanonicalTimestampFromTime(xtimestamp),
                        }),
                        bytes.NewReader([]byte{}),
                )
                io.Copy(ioutil.Discard, resp.Body)
                resp.Body.Close()
                if resp.StatusCode/100 == 2 </span><span class="cov8" title="1">{
                        atomic.AddInt64(&amp;successes, 1)
                }</span> else<span class="cov0" title="0"> {
                        if atomic.AddInt64(&amp;errors, 1) &gt; 1000 </span><span class="cov0" title="0">{
                                // After 1000 errors we'll just assume "things" are broken
                                // right now and try again next pass.
                                break</span>
                        }
                        <span class="cov0" title="0">logger.Error("PUT", zap.String("account", AdminAccount), zap.String("container", container), zap.String("object", object), zap.Int("status", resp.StatusCode))</span>
                }
        }
        <span class="cov8" title="1">close(cancel)
        &lt;-progressDone
        if errors == 0 </span><span class="cov8" title="1">{
                xtimestamp := time.Now()
                resp = dpo.aa.hClient.PutObject(
                        context.Background(),
                        AdminAccount,
                        container,
                        "object-init",
                        common.Map2Headers(map[string]string{
                                "Content-Length": "0",
                                "Content-Type":   "text",
                                "X-Timestamp":    common.CanonicalTimestampFromTime(xtimestamp),
                        }),
                        bytes.NewReader([]byte{}),
                )
                io.Copy(ioutil.Discard, resp.Body)
                resp.Body.Close()
                if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                        logger.Error("PUT", zap.String("account", AdminAccount), zap.String("container", container), zap.String("object", "object-init"), zap.Int("status", resp.StatusCode))
                        errors++
                }</span>
        }
        <span class="cov8" title="1">if err := dpo.aa.db.progressProcessPass("dispersion populate", "object", policy.Index, fmt.Sprintf("%d successes, %d errors", successes, errors)); err != nil </span><span class="cov0" title="0">{
                logger.Error("progressProcessPass", zap.Error(err))
        }</span>
        <span class="cov8" title="1">if err := dpo.aa.db.completeProcessPass("dispersion populate", "object", policy.Index); err != nil </span><span class="cov0" title="0">{
                logger.Error("completeProcessPass", zap.Error(err))
        }</span>
        <span class="cov8" title="1">if errors == 0 </span><span class="cov8" title="1">{
                logger.Debug("policy pass completed successfully", zap.Int64("successes", successes), zap.Int64("errors", errors))
                return true
        }</span>
        <span class="cov0" title="0">logger.Debug("policy pass completed with errors - will try again later", zap.Int64("successes", successes), zap.Int64("errors", errors))
        return false</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">package tools

// In /etc/hummingbird/andrewd-server.conf:
// [dispersion-scan-containers]
// initial_delay = 0        # seconds to wait between requests for the first pass
// pass_time_target = 3600  # seconds to try to make subsequent passes take
// report_interval = 600    # seconds between progress reports

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "io/ioutil"
        "net/http"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/troubling/hummingbird/accountserver"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/ring"
        "go.uber.org/zap"
)

const queuedPerDevice = 10

type dispersionScanContainers struct {
        aa *AutoAdmin
        // delay between each request; adjusted each pass to try to make passes last passTimeTarget
        delay          time.Duration
        passTimeTarget time.Duration
        reportInterval time.Duration
}

func newDispersionScanContainers(aa *AutoAdmin) *dispersionScanContainers <span class="cov0" title="0">{
        dsc := &amp;dispersionScanContainers{
                aa:             aa,
                delay:          time.Duration(aa.serverconf.GetInt("dispersion-scan-containers", "initial_delay", 0)) * time.Second,
                passTimeTarget: time.Duration(aa.serverconf.GetInt("dispersion-scan-containers", "pass_time_target", secondsInADay)) * time.Second,
                reportInterval: time.Duration(aa.serverconf.GetInt("dispersion-scan-containers", "report_interval", 600)) * time.Second,
        }
        if dsc.delay &lt; 0 </span><span class="cov0" title="0">{
                dsc.delay = time.Second
        }</span>
        <span class="cov0" title="0">if dsc.passTimeTarget &lt; 0 </span><span class="cov0" title="0">{
                dsc.passTimeTarget = time.Second
        }</span>
        <span class="cov0" title="0">return dsc</span>
}

func (dsc *dispersionScanContainers) runForever() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                sleepFor := dsc.runOnce()
                if sleepFor &lt; 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">time.Sleep(sleepFor)</span>
        }
}

type dispersionScanContainersContext struct {
        logger   *zap.Logger
        wg       sync.WaitGroup
        ring     ring.Ring
        found    int64
        notFound int64
        errored  int64
}

func (dsc *dispersionScanContainers) runOnce() time.Duration <span class="cov0" title="0">{
        start := time.Now()
        logger := dsc.aa.logger.With(zap.String("process", "dispersion scan containers"), zap.String("account", AdminAccount))
        logger.Debug("starting pass")
        if err := dsc.aa.db.startProcessPass("dispersion scan", "container", 0); err != nil </span><span class="cov0" title="0">{
                logger.Error("startProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">if err := dsc.aa.db.clearDispersionScanFailures("container", 0); err != nil </span><span class="cov0" title="0">{
                logger.Error("clearDispersionScanFailures", zap.Error(err))
        }</span>
        <span class="cov0" title="0">resp := dsc.aa.hClient.HeadContainer(context.Background(), AdminAccount, "container-init", nil)
        io.Copy(ioutil.Discard, resp.Body)
        resp.Body.Close()
        if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                logger.Debug("container-init does not yet exist")
                if err := dsc.aa.db.progressProcessPass("dispersion scan", "container", 0, "container-init does not yet exist"); err != nil </span><span class="cov0" title="0">{
                        logger.Error("progressProcessPass", zap.Error(err))
                }</span>
                <span class="cov0" title="0">if err := dsc.aa.db.completeProcessPass("dispersion scan", "container", 0); err != nil </span><span class="cov0" title="0">{
                        logger.Error("completeProcessPass", zap.Error(err))
                }</span>
                <span class="cov0" title="0">return dsc.passTimeTarget</span>
        }
        <span class="cov0" title="0">var delays int64
        serviceChans := map[string]chan *checkInfo{}
        ctx := &amp;dispersionScanContainersContext{logger: logger, ring: dsc.aa.hClient.ContainerRing()}
        cancel := make(chan struct{})
        progressDone := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-cancel:<span class="cov0" title="0">
                                close(progressDone)
                                return</span>
                        case &lt;-time.After(dsc.reportInterval):<span class="cov0" title="0">
                                d := atomic.LoadInt64(&amp;delays)
                                var eta time.Duration
                                if d &gt; 0 </span><span class="cov0" title="0">{
                                        eta = time.Duration(int64(time.Since(start)) / d * (int64(ctx.ring.PartitionCount()) - d))
                                }</span>
                                <span class="cov0" title="0">logger.Debug("progress", zap.Int64("partitions", d), zap.String("eta", eta.String()))
                                if err := dsc.aa.db.progressProcessPass("dispersion scan", "container", 0, fmt.Sprintf("%d of %d partitions, %d not found, %d errored, %s eta", d, ctx.ring.PartitionCount(), atomic.LoadInt64(&amp;ctx.notFound), atomic.LoadInt64(&amp;ctx.errored), eta)); err != nil </span><span class="cov0" title="0">{
                                        logger.Error("progressProcessPass", zap.Error(err))
                                }</span>
                        }
                }
        }()
        <span class="cov0" title="0">var marker string
        for </span><span class="cov0" title="0">{
                resp := dsc.aa.hClient.GetAccountRaw(context.Background(), AdminAccount, map[string]string{
                        "format": "json",
                        "marker": marker,
                        "prefix": "disp-conts-",
                }, http.Header{})
                if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                        logger.Error("GET", zap.String("marker", marker), zap.Int("status", resp.StatusCode))
                        io.Copy(ioutil.Discard, resp.Body)
                        resp.Body.Close()
                        break</span>
                }
                <span class="cov0" title="0">var clrs []*accountserver.ContainerListingRecord
                if err := json.NewDecoder(resp.Body).Decode(&amp;clrs); err != nil </span><span class="cov0" title="0">{
                        logger.Error("GET got bad JSON", zap.String("marker", marker), zap.Error(err))
                        io.Copy(ioutil.Discard, resp.Body)
                        resp.Body.Close()
                        break</span>
                }
                <span class="cov0" title="0">resp.Body.Close()
                for _, clr := range clrs </span><span class="cov0" title="0">{
                        clrLogger := logger.With(zap.String("container", clr.Name))
                        parts := strings.Split(clr.Name, "-")
                        if len(parts) != 4 </span><span class="cov0" title="0">{
                                clrLogger.Debug("odd container name")
                                continue</span>
                        }
                        <span class="cov0" title="0">partition, err := strconv.ParseUint(parts[2], 10, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                clrLogger.Debug("odd container name", zap.Error(err))
                                continue</span>
                        }
                        <span class="cov0" title="0">atomic.AddInt64(&amp;delays, 1)
                        time.Sleep(dsc.delay)
                        devices := ctx.ring.GetNodes(partition)
                        for _, device := range devices </span><span class="cov0" title="0">{
                                service := fmt.Sprintf("%s://%s:%d", device.Scheme, device.Ip, device.Port)
                                serviceChan := serviceChans[service]
                                if serviceChan == nil </span><span class="cov0" title="0">{
                                        serviceChan = make(chan *checkInfo, queuedPerDevice)
                                        ctx.wg.Add(1)
                                        go dsc.handleChecks(ctx, service, serviceChan)
                                        serviceChans[service] = serviceChan
                                }</span>
                                <span class="cov0" title="0">serviceChan &lt;- &amp;checkInfo{deviceID: device.Id, device: device.Device, partition: partition, name: clr.Name}</span>
                        }
                }
                <span class="cov0" title="0">if len(clrs) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">marker = clrs[len(clrs)-1].Name</span>
        }
        <span class="cov0" title="0">for _, serviceChan := range serviceChans </span><span class="cov0" title="0">{
                close(serviceChan)
        }</span>
        <span class="cov0" title="0">close(cancel)
        ctx.wg.Wait()
        &lt;-progressDone
        dsc.delay = dsc.passTimeTarget / time.Duration(delays)
        sleepFor := time.Until(start.Add(dsc.passTimeTarget))
        if sleepFor &lt; 0 </span><span class="cov0" title="0">{
                sleepFor = 0
        }</span>
        <span class="cov0" title="0">logger.Debug("pass complete", zap.Int64("found", ctx.found), zap.Int64("not found", ctx.notFound), zap.Int64("errored", ctx.errored), zap.String("next delay", dsc.delay.String()), zap.String("sleep for", sleepFor.String()))
        if err := dsc.aa.db.progressProcessPass("dispersion scan", "container", 0, fmt.Sprintf("%d of %d partitions, %d not found, %d errored", delays, ctx.ring.PartitionCount(), ctx.notFound, ctx.errored)); err != nil </span><span class="cov0" title="0">{
                logger.Error("progressProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">if err := dsc.aa.db.completeProcessPass("dispersion scan", "container", 0); err != nil </span><span class="cov0" title="0">{
                logger.Error("completeProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">return sleepFor</span>
}

func (dsc *dispersionScanContainers) handleChecks(ctx *dispersionScanContainersContext, service string, checkChan chan *checkInfo) <span class="cov0" title="0">{
        for check := range checkChan </span><span class="cov0" title="0">{
                url := fmt.Sprintf("%s/%s/%d/%s/%s", service, check.device, check.partition, common.Urlencode(AdminAccount), common.Urlencode(check.name))
                req, err := http.NewRequest("HEAD", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        atomic.AddInt64(&amp;ctx.errored, 1)
                        ctx.logger.Error("http.NewRequest(HEAD, url, nil) // likely programming error", zap.String("url", url), zap.Error(err))
                        if err = dsc.aa.db.recordDispersionScanFailure("container", 0, check.partition, service, check.deviceID); err != nil </span><span class="cov0" title="0">{
                                ctx.logger.Error("recordDispersionScanFailure", zap.Uint64("partition", check.partition), zap.String("service", service), zap.Int("deviceID", check.deviceID), zap.Error(err))
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">req.Header.Set("X-Backend-Suppress-2xx-Logging", "t")
                resp, err := dsc.aa.client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        atomic.AddInt64(&amp;ctx.errored, 1)
                        if err = dsc.aa.db.recordDispersionScanFailure("container", 0, check.partition, service, -1); err != nil </span><span class="cov0" title="0">{
                                ctx.logger.Error("recordDispersionScanFailure", zap.Uint64("partition", check.partition), zap.String("service", service), zap.Error(err))
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">io.Copy(ioutil.Discard, resp.Body)
                resp.Body.Close()
                if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        atomic.AddInt64(&amp;ctx.notFound, 1)
                        if err = dsc.aa.db.queuePartitionReplication("container", 0, check.partition, "dispersion", -1, check.deviceID); err != nil </span><span class="cov0" title="0">{
                                ctx.logger.Error("queuePartitionReplication", zap.Uint64("partition", check.partition), zap.Int("deviceID", check.deviceID), zap.Error(err))
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                        atomic.AddInt64(&amp;ctx.errored, 1)
                        if err = dsc.aa.db.recordDispersionScanFailure("container", 0, check.partition, "", check.deviceID); err != nil </span><span class="cov0" title="0">{
                                ctx.logger.Error("recordDispersionScanFailure", zap.Uint64("partition", check.partition), zap.Int("deviceID", check.deviceID), zap.Error(err))
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">atomic.AddInt64(&amp;ctx.found, 1)</span>
        }
        <span class="cov0" title="0">ctx.wg.Done()</span>
}
</pre>
		
		<pre class="file" id="file112" style="display: none">package tools

// In /etc/hummingbird/andrewd-server.conf:
// [dispersion-scan-objects]
// initial_delay = 0        # seconds to wait between requests for the first pass
// pass_time_target = 3600  # seconds to try to make subsequent passes take
// report_interval = 600    # seconds between progress reports

import (
        "context"
        "crypto/md5"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "io"
        "io/ioutil"
        "net/http"
        "path"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/containerserver"
        "go.uber.org/zap"
)

type checkInfo struct {
        deviceID  int
        device    string
        partition uint64
        name      string
        ecShard   bool
        shard     int
}

type dispersionScanObjects struct {
        aa *AutoAdmin
        // delay between each request; adjusted each pass to try to make passes last passTimeTarget
        delay          time.Duration
        passTimeTarget time.Duration
        reportInterval time.Duration
        prefix         string
        suffix         string
}

func newDispersionScanObjects(aa *AutoAdmin) *dispersionScanObjects <span class="cov0" title="0">{
        dso := &amp;dispersionScanObjects{
                aa:             aa,
                delay:          time.Duration(aa.serverconf.GetInt("dispersion-scan-objects", "initial_delay", 0)) * time.Second,
                passTimeTarget: time.Duration(aa.serverconf.GetInt("dispersion-scan-objects", "pass_time_target", secondsInADay)) * time.Second,
                reportInterval: time.Duration(aa.serverconf.GetInt("dispersion-scan-objects", "report_interval", 600)) * time.Second,
        }
        if dso.delay &lt; 0 </span><span class="cov0" title="0">{
                dso.delay = time.Second
        }</span>
        <span class="cov0" title="0">if dso.passTimeTarget &lt; 0 </span><span class="cov0" title="0">{
                dso.passTimeTarget = time.Second
        }</span>
        <span class="cov0" title="0">dso.prefix, dso.suffix = getAffixes()
        return dso</span>
}

func (dso *dispersionScanObjects) runForever() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                sleepFor := dso.runOnce()
                if sleepFor &lt; 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">time.Sleep(sleepFor)</span>
        }
}

func (dso *dispersionScanObjects) runOnce() time.Duration <span class="cov0" title="0">{
        start := time.Now()
        logger := dso.aa.logger.With(zap.String("process", "dispersion scan objects"))
        logger.Debug("starting pass")
        if err := dso.aa.db.startProcessPass("dispersion scan", "object-overall", 0); err != nil </span><span class="cov0" title="0">{
                logger.Error("startProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">delays := 0
        for _, policy := range dso.aa.policies </span><span class="cov0" title="0">{
                if !policy.Deprecated </span><span class="cov0" title="0">{
                        delays += dso.scanDispersionObjects(logger, policy)
                }</span>
        }
        <span class="cov0" title="0">if delays &gt; 0 </span><span class="cov0" title="0">{
                dso.delay = dso.passTimeTarget / time.Duration(delays)
        }</span>
        <span class="cov0" title="0">sleepFor := time.Until(start.Add(dso.passTimeTarget))
        if sleepFor &lt; 0 </span><span class="cov0" title="0">{
                sleepFor = 0
        }</span>
        <span class="cov0" title="0">logger.Debug("pass complete", zap.String("next delay", dso.delay.String()), zap.String("sleep for", sleepFor.String()))
        if err := dso.aa.db.progressProcessPass("dispersion scan", "object-overall", 0, fmt.Sprintf("%d policies", len(dso.aa.policies))); err != nil </span><span class="cov0" title="0">{
                logger.Error("progressProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">if err := dso.aa.db.completeProcessPass("dispersion scan", "object-overall", 0); err != nil </span><span class="cov0" title="0">{
                logger.Error("completeProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">return sleepFor</span>
}

type dispersionScanObjectsContext struct {
        logger    *zap.Logger
        wg        sync.WaitGroup
        policy    int
        ring      ring.Ring
        container string
        found     int64
        notFound  int64
        errored   int64
}

func (dso *dispersionScanObjects) scanDispersionObjects(logger *zap.Logger, policy *conf.Policy) int <span class="cov0" title="0">{
        start := time.Now()
        container := fmt.Sprintf("disp-objs-%d", policy.Index)
        logger = logger.With(zap.String("account", AdminAccount), zap.String("container", container), zap.Int("policy", policy.Index))
        logger.Debug("starting policy pass")
        if err := dso.aa.db.startProcessPass("dispersion scan", "object", policy.Index); err != nil </span><span class="cov0" title="0">{
                logger.Error("startProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">if err := dso.aa.db.clearDispersionScanFailures("object", policy.Index); err != nil </span><span class="cov0" title="0">{
                logger.Error("clearDispersionScanFailures", zap.Int("policy", policy.Index), zap.Error(err))
        }</span>
        <span class="cov0" title="0">resp := dso.aa.hClient.HeadObject(context.Background(), AdminAccount, container, "object-init", nil)
        io.Copy(ioutil.Discard, resp.Body)
        resp.Body.Close()
        if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                logger.Debug("object-init does not yet exist")
                if err := dso.aa.db.progressProcessPass("dispersion scan", "object", policy.Index, "object-init does not yet exist"); err != nil </span><span class="cov0" title="0">{
                        logger.Error("progressProcessPass", zap.Error(err))
                }</span>
                <span class="cov0" title="0">if err := dso.aa.db.completeProcessPass("dispersion scan", "object", policy.Index); err != nil </span><span class="cov0" title="0">{
                        logger.Error("completeProcessPass", zap.Error(err))
                }</span>
                <span class="cov0" title="0">return 0</span>
        }
        <span class="cov0" title="0">var delays int64
        serviceChans := map[string]chan *checkInfo{}
        objectRing, resp := dso.aa.hClient.ObjectRingFor(context.Background(), AdminAccount, container)
        if resp != nil </span><span class="cov0" title="0">{
                io.Copy(ioutil.Discard, resp.Body)
                resp.Body.Close()
                logger.Error("error getting object ring", zap.Int("status", resp.StatusCode))
                if err := dso.aa.db.progressProcessPass("dispersion scan", "object", policy.Index, "error getting object ring"); err != nil </span><span class="cov0" title="0">{
                        logger.Error("progressProcessPass", zap.Error(err))
                }</span>
                <span class="cov0" title="0">if err := dso.aa.db.completeProcessPass("dispersion scan", "object", policy.Index); err != nil </span><span class="cov0" title="0">{
                        logger.Error("completeProcessPass", zap.Error(err))
                }</span>
                <span class="cov0" title="0">return 0</span>
        }
        <span class="cov0" title="0">ctx := &amp;dispersionScanObjectsContext{logger: logger, policy: policy.Index, ring: objectRing, container: container}
        cancel := make(chan struct{})
        progressDone := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-cancel:<span class="cov0" title="0">
                                close(progressDone)
                                return</span>
                        case &lt;-time.After(dso.reportInterval):<span class="cov0" title="0">
                                d := atomic.LoadInt64(&amp;delays)
                                var eta time.Duration
                                if d &gt; 0 </span><span class="cov0" title="0">{
                                        eta = time.Duration(int64(time.Since(start)) / d * (int64(ctx.ring.PartitionCount()) - d))
                                }</span>
                                <span class="cov0" title="0">logger.Debug("progress", zap.Int64("partitions", d), zap.String("eta", eta.String()))
                                if err := dso.aa.db.progressProcessPass("dispersion scan", "object", policy.Index, fmt.Sprintf("%d of %d partitions, %d not found, %d errored, %s eta", d, ctx.ring.PartitionCount(), atomic.LoadInt64(&amp;ctx.notFound), atomic.LoadInt64(&amp;ctx.errored), eta)); err != nil </span><span class="cov0" title="0">{
                                        logger.Error("progressProcessPass", zap.Error(err))
                                }</span>
                        }
                }
        }()
        <span class="cov0" title="0">var marker string
        for </span><span class="cov0" title="0">{
                resp := dso.aa.hClient.GetContainerRaw(context.Background(), AdminAccount, container, map[string]string{
                        "format": "json",
                        "marker": marker,
                }, http.Header{})
                if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                        logger.Error("GET", zap.String("marker", marker), zap.Int("status", resp.StatusCode))
                        io.Copy(ioutil.Discard, resp.Body)
                        resp.Body.Close()
                        break</span>
                }
                <span class="cov0" title="0">var olrs []*containerserver.ObjectListingRecord
                if err := json.NewDecoder(resp.Body).Decode(&amp;olrs); err != nil </span><span class="cov0" title="0">{
                        logger.Error("GET got bad JSON", zap.String("marker", marker), zap.Error(err))
                        io.Copy(ioutil.Discard, resp.Body)
                        resp.Body.Close()
                        break</span>
                }
                <span class="cov0" title="0">resp.Body.Close()
                for _, olr := range olrs </span><span class="cov0" title="0">{
                        if olr.Name == "object-init" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">clrLogger := logger.With(zap.String("object", olr.Name))
                        parts := strings.Split(olr.Name, "-")
                        if len(parts) != 2 </span><span class="cov0" title="0">{
                                clrLogger.Debug("odd object name")
                                continue</span>
                        }
                        <span class="cov0" title="0">partition, err := strconv.ParseUint(parts[0], 10, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                clrLogger.Debug("odd object name", zap.Error(err))
                                continue</span>
                        }
                        <span class="cov0" title="0">atomic.AddInt64(&amp;delays, 1)
                        time.Sleep(dso.delay)
                        devices := objectRing.GetNodes(partition)
                        for shard, device := range devices </span><span class="cov0" title="0">{
                                service := fmt.Sprintf("%s://%s:%d", device.Scheme, device.Ip, device.Port)
                                serviceChan := serviceChans[service]
                                if serviceChan == nil </span><span class="cov0" title="0">{
                                        serviceChan = make(chan *checkInfo, queuedPerDevice)
                                        ctx.wg.Add(1)
                                        go dso.handleChecks(ctx, service, serviceChan)
                                        serviceChans[service] = serviceChan
                                }</span>
                                <span class="cov0" title="0">ci := &amp;checkInfo{deviceID: device.Id, device: device.Device, partition: partition, name: olr.Name}
                                if policy.Type == "hec" </span><span class="cov0" title="0">{
                                        // Note that with hec, we query just the stabilized shards.
                                        // If the dispersion populate had just run and things
                                        // hadn't stabilized yet, we'll queue up some useless
                                        // replication jobs to repair missing dispersion shards.
                                        // Shouldn't be a big deal as it will just be when a new
                                        // cluster is launched and there won't be much, if any,
                                        // real data.
                                        ci.ecShard = true
                                        ci.shard = shard
                                }</span>
                                <span class="cov0" title="0">serviceChan &lt;- ci</span>
                        }
                }
                <span class="cov0" title="0">if len(olrs) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">marker = olrs[len(olrs)-1].Name</span>
        }
        <span class="cov0" title="0">for _, serviceChan := range serviceChans </span><span class="cov0" title="0">{
                close(serviceChan)
        }</span>
        <span class="cov0" title="0">close(cancel)
        ctx.wg.Wait()
        &lt;-progressDone
        logger.Debug("policy pass complete", zap.Int64("found", ctx.found), zap.Int64("not found", ctx.notFound), zap.Int64("errored", ctx.errored))
        if err := dso.aa.db.progressProcessPass("dispersion scan", "object", policy.Index, fmt.Sprintf("%d of %d partitions, %d not found, %d errored", delays, ctx.ring.PartitionCount(), ctx.notFound, ctx.errored)); err != nil </span><span class="cov0" title="0">{
                logger.Error("progressProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">if err := dso.aa.db.completeProcessPass("dispersion scan", "object", policy.Index); err != nil </span><span class="cov0" title="0">{
                logger.Error("completeProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">return int(delays)</span>
}

func (dso *dispersionScanObjects) handleChecks(ctx *dispersionScanObjectsContext, service string, checkChan chan *checkInfo) <span class="cov0" title="0">{
        for check := range checkChan </span><span class="cov0" title="0">{
                var url string
                if check.ecShard </span><span class="cov0" title="0">{
                        h := md5.New()
                        io.WriteString(h, path.Join(dso.prefix, AdminAccount, ctx.container, check.name+dso.suffix))
                        url = fmt.Sprintf("%s/ec-shard/%s/%s/%d", service, check.device, hex.EncodeToString(h.Sum(nil)), check.shard)
                }</span> else<span class="cov0" title="0"> {
                        url = fmt.Sprintf("%s/%s/%d/%s/%s/%s", service, check.device, check.partition, common.Urlencode(AdminAccount), common.Urlencode(ctx.container), common.Urlencode(check.name))
                }</span>
                <span class="cov0" title="0">req, err := http.NewRequest("GET", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        atomic.AddInt64(&amp;ctx.errored, 1)
                        ctx.logger.Error("http.NewRequest(GET, url, nil) // likely programming error", zap.String("url", url), zap.Error(err))
                        if err = dso.aa.db.recordDispersionScanFailure("object", ctx.policy, check.partition, service, check.deviceID); err != nil </span><span class="cov0" title="0">{
                                ctx.logger.Error("recordDispersionScanFailure", zap.Int("policy", ctx.policy), zap.Uint64("partition", check.partition), zap.String("service", service), zap.Int("deviceID", check.deviceID), zap.Error(err))
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">req.Header.Set("X-Backend-Suppress-2xx-Logging", "t")
                req.Header.Set("X-Backend-Storage-Policy-Index", fmt.Sprintf("%d", ctx.policy))
                resp, err := dso.aa.client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        atomic.AddInt64(&amp;ctx.errored, 1)
                        ctx.logger.Debug("Do", zap.String("url", url), zap.Error(err))
                        if err = dso.aa.db.recordDispersionScanFailure("object", ctx.policy, check.partition, service, -1); err != nil </span><span class="cov0" title="0">{
                                ctx.logger.Error("recordDispersionScanFailure", zap.Int("policy", ctx.policy), zap.Uint64("partition", check.partition), zap.String("service", service), zap.Error(err))
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">io.Copy(ioutil.Discard, resp.Body)
                resp.Body.Close()
                if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        atomic.AddInt64(&amp;ctx.notFound, 1)
                        if err = dso.aa.db.queuePartitionReplication("object", ctx.policy, check.partition, "dispersion", -1, check.deviceID); err != nil </span><span class="cov0" title="0">{
                                ctx.logger.Error("queuePartitionReplication", zap.Uint64("partition", check.partition), zap.Int("deviceID", check.deviceID), zap.Error(err))
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                        atomic.AddInt64(&amp;ctx.errored, 1)
                        ctx.logger.Debug("StatusCode", zap.String("url", url), zap.Int("status code", resp.StatusCode))
                        if err = dso.aa.db.recordDispersionScanFailure("object", ctx.policy, check.partition, "", check.deviceID); err != nil </span><span class="cov0" title="0">{
                                ctx.logger.Error("recordDispersionScanFailure", zap.Int("policy", ctx.policy), zap.Uint64("partition", check.partition), zap.Int("deviceID", check.deviceID), zap.Error(err))
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">atomic.AddInt64(&amp;ctx.found, 1)</span>
        }
        <span class="cov0" title="0">ctx.wg.Done()</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">//  Copyright (c) 2015 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

// In /etc/hummingbird/andrewd-server.conf:
// [andrewd]
// sql_dir = /var/local/hummingbird # path to directory for andrewd data files
// bind_ip = 0.0.0.0                # ip to listen on for http requests
// bind_port = 6003                 # port to listen on for http requests
// cert_file =                      # path to tls certificate, if tls is desired
// key_file =                       # path to tls key, if tls is desired
// service_error_expiration = 3600  # seconds of no errors before error count is cleared
// device_error_expiration = 3600   # seconds of no errors before error count is cleared

package tools

import (
        "context"
        "crypto/md5"
        "encoding/hex"
        "flag"
        "fmt"
        "io"
        "io/ioutil"
        "math/bits"
        "net"
        "net/http"
        _ "net/http/pprof"
        "os"
        "path"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"
        "time"

        "golang.org/x/net/http2"

        "github.com/justinas/alice"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/troubling/hummingbird/client"
        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/common/tracing"
        "github.com/troubling/hummingbird/middleware"
        "github.com/troubling/hummingbird/objectserver"
        "github.com/uber-go/tally"
        promreporter "github.com/uber-go/tally/prometheus"
        "go.uber.org/zap"
)

const AdminAccount = ".admin"

func getAffixes() (string, string) <span class="cov0" title="0">{
        hashPathPrefix, hashPathSuffix, err := conf.GetHashPrefixAndSuffix()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Unable to get hash prefix and suffix")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">return hashPathPrefix, hashPathSuffix</span>
}

func inferRingType(account, container, object string) string <span class="cov0" title="0">{
        if object != "" </span><span class="cov0" title="0">{
                return "object"
        }</span> else<span class="cov0" title="0"> if container != "" </span><span class="cov0" title="0">{
                return "container"
        }</span> else<span class="cov0" title="0"> if account != "" </span><span class="cov0" title="0">{
                return "account"
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func getRing(ringPath, ringType string, policyNum int) (ring.Ring, string) <span class="cov0" title="0">{
        // if you have a direct path to a ring send it as ringPath. otherwise send
        // a ringType ("" defaults to 'object') and optional policy and this'll
        // try to find it in usual spots
        prefix, suffix := getAffixes()
        if ringPath != "" </span><span class="cov0" title="0">{
                r, err := ring.LoadRing(ringPath, prefix, suffix)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Unable to load ring ", ringPath)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if strings.Contains(ringPath, "account") </span><span class="cov0" title="0">{
                        return r, "account"
                }</span> else<span class="cov0" title="0"> if strings.Contains(ringPath, "container") </span><span class="cov0" title="0">{
                        return r, "container"
                }</span> else<span class="cov0" title="0"> if strings.Contains(ringPath, "object") </span><span class="cov0" title="0">{
                        return r, "object"
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("Unknown ring type", ringPath)
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">if ringType == "" </span><span class="cov0" title="0">{
                ringType = "object"
        }</span>

        <span class="cov0" title="0">r, err := ring.GetRing(ringType, prefix, suffix, policyNum)
        if err != nil </span><span class="cov0" title="0">{
                if policyNum &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("Unable to load %v-%v ring\n", ringType, policyNum)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Unable to load %v ring\n", ringType)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }
        <span class="cov0" title="0">return r, ringType</span>
}

func curlHeadCommand(scheme string, ipStr string, port int, device string, partNum uint64, target string, policy int) string <span class="cov0" title="0">{
        formatted_ip := ipStr
        ip := net.ParseIP(ipStr)
        if ip != nil &amp;&amp; strings.Contains(ipStr, ":") </span><span class="cov0" title="0">{
                formatted_ip = fmt.Sprintf("[%v]", ipStr)
        }</span>
        <span class="cov0" title="0">policyStr := ""
        if policy &gt; 0 </span><span class="cov0" title="0">{
                policyStr = fmt.Sprintf(" -H \"X-Backend-Storage-Policy-Index: %v\"", policy)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("curl -g -I -XHEAD \"%v://%v:%v/%v/%v/%v\"%v", scheme, formatted_ip, port, device, partNum, common.Urlencode(target), policyStr)</span>
}

func getPathHash(account, container, object string) string <span class="cov0" title="0">{
        prefix, suffix := getAffixes()
        if object != "" &amp;&amp; container == "" </span><span class="cov0" title="0">{
                fmt.Println("container is required if object is provided")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">paths := prefix + "/" + account
        if container != "" </span><span class="cov0" title="0">{
                paths = paths + "/" + container
        }</span>
        <span class="cov0" title="0">if object != "" </span><span class="cov0" title="0">{
                paths = paths + "/" + object
        }</span>
        <span class="cov0" title="0">paths = paths + suffix
        h := md5.New()
        fmt.Fprintf(h, "%v", paths)
        return fmt.Sprintf("%032x", h.Sum(nil))</span>
}

func printSshCommands(r ring.Ring, pathHash string, allHandoffs bool, policy *conf.Policy) error <span class="cov0" title="0">{
        fmt.Printf("\n\nUse your own device location of servers:\n")
        fmt.Printf("such as \"export DEVICE=/srv/node\"\n")

        if pathHash == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("not implemented: please supply object path")
        }</span>
        <span class="cov0" title="0">partition, err := r.PartitionForHash(pathHash)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">primaries := r.GetNodes(partition)
        handoffLimit := len(primaries)
        if allHandoffs </span><span class="cov0" title="0">{
                handoffLimit = -1
        }</span>
        <span class="cov0" title="0">ringPartPower := bits.Len64(r.PartitionCount() - 1)
        dbPartPower, err := policy.GetDbPartPower()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Error getting dbPartPower: %v", err)
        }</span>
        <span class="cov0" title="0">subdirs, err := policy.GetDbSubDirs()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Error getting subdirs: %v", err)
        }</span>
        <span class="cov0" title="0">_, _, dbPart, dirNum, err := objectserver.ValidateHash(pathHash, uint(ringPartPower), dbPartPower, subdirs)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Error in ValidateHash: %v", err)
        }</span>
        <span class="cov0" title="0">dbFileName := fmt.Sprintf("index.db.%02x", dbPart)
        odir := fmt.Sprintf("index.db.dir.%02x", dirNum)
        for _, v := range primaries </span><span class="cov0" title="0">{
                fmt.Printf("ssh %s \"sqlite3 ${DEVICE:-/srv/node*}/%v/%v/hec.db/%v \\\"SELECT * FROM objects WHERE hash = '%v'\\\"\"\n", v.Ip, v.Device, objectserver.PolicyDir(policy.Index), dbFileName, pathHash)
                fmt.Printf("ssh %s \"ls -lah ${DEVICE:-/srv/node*}/%v/%v/hec/%v/%v*\"\n\n", v.Ip, v.Device, objectserver.PolicyDir(policy.Index), odir, pathHash)
        }</span>
        <span class="cov0" title="0">handoffs := r.GetMoreNodes(partition)
        for i, v := 0, handoffs.Next(); v != nil; i, v = i+1, handoffs.Next() </span><span class="cov0" title="0">{
                if handoffLimit != -1 &amp;&amp; i == handoffLimit </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">fmt.Printf("ssh %s \"sqlite3 ${DEVICE:-/srv/node*}/%v/%v/hec.db/%v \\\"SELECT * FROM objects WHERE hash = '%v'\\\"\" #[HANDOFF]\n", v.Ip, v.Device, objectserver.PolicyDir(policy.Index), dbFileName, pathHash)
                fmt.Printf("ssh %s \"ls -lah ${DEVICE:-/srv/node*}/%v/%v/hec/%v/%v*\" #[HANDOFF]\n\n", v.Ip, v.Device, objectserver.PolicyDir(policy.Index), odir, pathHash)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func printRingLocations(r ring.Ring, ringType, datadir, account, container, object, partition string, allHandoffs bool, policy *conf.Policy) <span class="cov0" title="0">{
        if r == nil </span><span class="cov0" title="0">{
                fmt.Println("No ring specified")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if datadir == "" </span><span class="cov0" title="0">{
                fmt.Println("No datadir specified")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">var target string
        if object != "" </span><span class="cov0" title="0">{
                target = fmt.Sprintf("%v/%v/%v", account, container, object)
        }</span> else<span class="cov0" title="0"> if container != "" </span><span class="cov0" title="0">{
                target = fmt.Sprintf("%v/%v", account, container)
        }</span> else<span class="cov0" title="0"> {
                target = fmt.Sprintf("%v", account)
        }</span>
        <span class="cov0" title="0">var partNum uint64
        if partition != "" </span><span class="cov0" title="0">{
                var err error
                partNum, err = strconv.ParseUint(partition, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Invalid partition")
                        os.Exit(1)
                }</span>
        } else<span class="cov0" title="0"> {
                partNum = r.GetPartition(account, container, object)
        }</span>
        <span class="cov0" title="0">primaries := r.GetNodes(partNum)
        handoffLimit := len(primaries)
        if allHandoffs </span><span class="cov0" title="0">{
                handoffLimit = -1
        }</span>

        <span class="cov0" title="0">pathHash := ""
        if account != "" &amp;&amp; partition == "" </span><span class="cov0" title="0">{
                pathHash = getPathHash(account, container, object)
        }</span>
        <span class="cov0" title="0">fmt.Printf("Partition\t%v\n", partNum)
        fmt.Printf("Hash     \t%v\n\n", pathHash)

        for _, v := range primaries </span><span class="cov0" title="0">{
                fmt.Printf("Server:Port Device\t%v:%v %v\n", v.Ip, v.Port, v.Device)
        }</span>
        <span class="cov0" title="0">handoffs := r.GetMoreNodes(partNum)
        for i, v := 0, handoffs.Next(); v != nil; i, v = i+1, handoffs.Next() </span><span class="cov0" title="0">{
                if handoffLimit != -1 &amp;&amp; i == handoffLimit </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">fmt.Printf("Server:Port Device\t%v:%v %v\t [Handoff]\n", v.Ip, v.Port, v.Device)</span>
        }
        <span class="cov0" title="0">fmt.Printf("\n\n")
        for _, v := range primaries </span><span class="cov0" title="0">{
                cmd := curlHeadCommand(v.Scheme, v.Ip, v.Port, v.Device, partNum, target, policy.Index)
                fmt.Println(cmd)
        }</span>
        <span class="cov0" title="0">handoffs = r.GetMoreNodes(partNum)
        for i, v := 0, handoffs.Next(); v != nil; i, v = i+1, handoffs.Next() </span><span class="cov0" title="0">{
                if handoffLimit != -1 &amp;&amp; i == handoffLimit </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">cmd := curlHeadCommand(v.Scheme, v.Ip, v.Port, v.Device, partNum, target, policy.Index)
                fmt.Printf("%v # [Handoff]\n", cmd)</span>
        }

        <span class="cov0" title="0">if policy.Type == "replication" || object == "" </span><span class="cov0" title="0">{
                fmt.Printf("\n\nUse your own device location of servers:\n")
                fmt.Printf("such as \"export DEVICE=/srv/node\"\n")

                if pathHash != "" </span><span class="cov0" title="0">{
                        stDir := filepath.Join(datadir, strconv.Itoa(int(partNum)), pathHash[len(pathHash)-3:], pathHash)
                        for _, v := range primaries </span><span class="cov0" title="0">{
                                fmt.Printf("ssh %s \"ls -lah ${DEVICE:-/srv/node*}/%v/%v\"\n", v.Ip, v.Device, stDir)
                        }</span>
                        <span class="cov0" title="0">handoffs = r.GetMoreNodes(partNum)
                        for i, v := 0, handoffs.Next(); v != nil; i, v = i+1, handoffs.Next() </span><span class="cov0" title="0">{
                                if handoffLimit != -1 &amp;&amp; i == handoffLimit </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">fmt.Printf("ssh %s \"ls -lah ${DEVICE:-/srv/node*}/%v/%v\" # [Handoff]\n", v.Ip, v.Device, stDir)</span>
                        }
                } else<span class="cov0" title="0"> {
                        for _, v := range primaries </span><span class="cov0" title="0">{
                                fmt.Printf("ssh %s \"ls -lah ${DEVICE:-/srv/node*}/%v/%v/%v\"\n", v.Ip, v.Device, datadir, partNum)
                        }</span>
                        <span class="cov0" title="0">handoffs = r.GetMoreNodes(partNum)
                        for i, v := 0, handoffs.Next(); v != nil; i, v = i+1, handoffs.Next() </span><span class="cov0" title="0">{
                                if handoffLimit != -1 &amp;&amp; i == handoffLimit </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">fmt.Printf("ssh %s \"ls -lah ${DEVICE:-/srv/node*}/%v/%v/%v\" # [Handoff]\n", v.Ip, v.Device, datadir, partNum)</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                if err := printSshCommands(r, pathHash, allHandoffs, policy); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err.Error())
                        return
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("\nnote: `/srv/node*` is used as default value of `devices`, the real value is set in the config file on each storage node.\n")</span>
}

func printItemLocations(r ring.Ring, ringType, account, container, object, partition string, allHandoffs bool, policy *conf.Policy) <span class="cov0" title="0">{
        location := ""
        if policy.Index &gt; 0 </span><span class="cov0" title="0">{
                location = fmt.Sprintf("%vs-%d", ringType, policy.Index)
        }</span> else<span class="cov0" title="0"> {
                location = fmt.Sprintf("%vs", ringType)
        }</span>

        <span class="cov0" title="0">printRingLocations(r, ringType, location, account, container, object, partition, allHandoffs, policy)</span>
}

func parseArg0(arg0 string) (string, string, string) <span class="cov8" title="1">{
        arg0 = strings.TrimPrefix(arg0, "/v1/")
        parts := strings.SplitN(arg0, "/", 3)
        if len(parts) == 1 </span><span class="cov8" title="1">{
                return parts[0], "", ""
        }</span> else<span class="cov8" title="1"> if len(parts) == 2 </span><span class="cov8" title="1">{
                return parts[0], parts[1], ""
        }</span> else<span class="cov8" title="1"> if len(parts) == 3 </span><span class="cov8" title="1">{
                return parts[0], parts[1], parts[2]
        }</span>
        <span class="cov0" title="0">return arg0, "", ""</span>
}

func Nodes(flags *flag.FlagSet, cnf srv.ConfigLoader) <span class="cov0" title="0">{
        var account, container, object string
        ohsh := flags.Lookup("objhash").Value.(flag.Getter).Get().(string)
        if flags.NArg() == 1 </span><span class="cov0" title="0">{
                account, container, object = parseArg0(flags.Arg(0))
        }</span> else<span class="cov0" title="0"> {
                if ohsh == "" </span><span class="cov0" title="0">{
                        account = flags.Arg(0)
                        container = flags.Arg(1)
                        object = flags.Arg(2)
                }</span>
        }
        <span class="cov0" title="0">partition := flags.Lookup("p").Value.(flag.Getter).Get().(string)
        policyName := flags.Lookup("P").Value.(flag.Getter).Get().(string)
        allHandoffs := flags.Lookup("a").Value.(flag.Getter).Get().(bool)

        policies, err := cnf.GetPolicies()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Unable to load policies:", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">policy := policyByName(policyName, policies)

        var r ring.Ring
        var ringType string
        inferredType := inferRingType(account, container, object)
        if ohsh != "" </span><span class="cov0" title="0">{
                inferredType = "object"
        }</span>
        <span class="cov0" title="0">ringPath := flags.Lookup("r").Value.(flag.Getter).Get().(string)
        if ringPath != "" </span><span class="cov0" title="0">{
                r, ringType = getRing(ringPath, "", policy.Index)
                if inferredType != "" &amp;&amp; ringType != inferredType </span><span class="cov0" title="0">{
                        fmt.Printf("Error %v specified but ring type: %v\n", inferredType, ringType)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if ringType == "object" &amp;&amp; policy.Index == 0 </span><span class="cov0" title="0">{
                        _, ringFileName := path.Split(ringPath)
                        if strings.HasPrefix(ringFileName, "object") &amp;&amp; strings.Contains(ringFileName, "-") </span><span class="cov0" title="0">{
                                polSuff := strings.Split(ringFileName, "-")[1]
                                if polN, err := strconv.ParseInt(polSuff[:(len(polSuff)-len(".ring.gz"))], 10, 64); err == nil </span><span class="cov0" title="0">{
                                        policy = policies[int(polN)]
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                r, ringType = getRing("", inferredType, policy.Index)
        }</span>

        <span class="cov0" title="0">if partition != "" || ohsh != "" </span><span class="cov0" title="0">{
                account = ""
                container = ""
                object = ""
        }</span> else<span class="cov0" title="0"> {
                if account == "" &amp;&amp; (container != "" || object != "") </span><span class="cov0" title="0">{
                        fmt.Println("No account specified")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if container == "" &amp;&amp; object != "" </span><span class="cov0" title="0">{
                        fmt.Println("No container specified")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if account == "" </span><span class="cov0" title="0">{
                        fmt.Println("No target specified")
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">if ohsh == "" </span><span class="cov0" title="0">{
                fmt.Printf("\nAccount  \t%v\n", account)
                fmt.Printf("Container\t%v\n", container)
                fmt.Printf("Object   \t%v\n", object)
                printItemLocations(r, ringType, account, container, object, partition, allHandoffs, policy)
        }</span> else<span class="cov0" title="0"> {
                if err := printSshCommands(r, ohsh, allHandoffs, policy); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err.Error())
                }</span>
        }
}

func getACO(path string) (account, container, object string) <span class="cov0" title="0">{
        stuff := strings.SplitN(path, "/", 4)
        if len(stuff) != 4 </span><span class="cov0" title="0">{
                fmt.Printf("Path is invalid for object %v\n", path)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">return stuff[1], stuff[2], stuff[3]</span>
}

func printObjMeta(metadata map[string]string) <span class="cov0" title="0">{
        userMetadata := make(map[string]string)
        sysMetadata := make(map[string]string)
        transientSysMetadata := make(map[string]string)
        otherMetadata := make(map[string]string)

        path := metadata["name"]
        delete(metadata, "name")
        if path != "" </span><span class="cov0" title="0">{
                account, container, object := getACO(path)
                objHash := getPathHash(account, container, object)
                fmt.Printf("Path: %s\n", path)
                fmt.Printf("  Account: %s\n", account)
                fmt.Printf("  Container: %s\n", container)
                fmt.Printf("  Object: %s\n", object)
                fmt.Printf("  Object hash: %s\n", objHash)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Path: Not found in metadata\n")
        }</span>
        <span class="cov0" title="0">contentType := metadata["Content-Type"]
        delete(metadata, "Content-Type")
        if contentType != "" </span><span class="cov0" title="0">{
                fmt.Printf("Content-Type: %v\n", contentType)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Content-Type: Not found in metadata\n")
        }</span>
        <span class="cov0" title="0">timestamp := metadata["X-Timestamp"]
        delete(metadata, "X-Timestamp")
        if timestamp != "" </span><span class="cov0" title="0">{
                t, timeErr := common.ParseDate(timestamp)
                if timeErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Timestamp error: %v\n", timeErr)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">fmt.Printf("Timestamp: %s (%s)\n", t.Format(time.RFC3339), timestamp)</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("Timestamp: Not found in metadata\n")
        }</span>

        <span class="cov0" title="0">for key, value := range metadata </span><span class="cov0" title="0">{
                if strings.HasPrefix(key, "X-Object-Meta-") </span><span class="cov0" title="0">{
                        userMetadata[key] = value
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(key, "X-Object-SysMeta-") </span><span class="cov0" title="0">{
                        sysMetadata[key] = value
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(key, "X-Object-Transient-Sysmeta-") </span><span class="cov0" title="0">{
                        transientSysMetadata[key] = value
                }</span> else<span class="cov0" title="0"> {
                        otherMetadata[key] = value
                }</span>
        }
        <span class="cov0" title="0">printMetadata := func(title string, items map[string]string) </span><span class="cov0" title="0">{
                fmt.Printf("%s\n", title)
                if len(items) &gt; 0 </span><span class="cov0" title="0">{
                        for key, value := range items </span><span class="cov0" title="0">{
                                fmt.Printf("  %s: %s\n", key, value)
                        }</span>
                } else<span class="cov0" title="0"> {
                        fmt.Printf("  No metadata found\n")
                }</span>
        }

        <span class="cov0" title="0">printMetadata("System Metadata:", sysMetadata)
        printMetadata("Transient System Metadata:", transientSysMetadata)
        printMetadata("User Metadata:", userMetadata)
        printMetadata("Other Metadata:", otherMetadata)</span>
}

func policyByName(name string, policies conf.PolicyList) *conf.Policy <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return policies[0]
        }</span>
        <span class="cov0" title="0">for _, v := range policies </span><span class="cov0" title="0">{
                if v.Name == name </span><span class="cov0" title="0">{
                        return v
                }</span>
        }
        <span class="cov0" title="0">fmt.Println("No policy named ", name)
        os.Exit(1)
        return nil</span>
}

func ObjectInfo(flags *flag.FlagSet, cnf srv.ConfigLoader) <span class="cov0" title="0">{
        object := flags.Arg(0)
        noEtag := flags.Lookup("n").Value.(flag.Getter).Get().(bool)
        policyName := flags.Lookup("P").Value.(flag.Getter).Get().(string)

        policies, err := cnf.GetPolicies()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Unable to load policies:", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">namedPolicy := policyByName(policyName, policies)

        stat, statErr := os.Stat(object)
        if statErr != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error statting file: %v\n", statErr)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fullPath, pathErr := filepath.Abs(object)
        if pathErr != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error getting abs path: %v\n", pathErr)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">re := regexp.MustCompile(`objects-(\d*)`)
        match := re.FindStringSubmatch(fullPath)
        var policy *conf.Policy
        if match == nil </span><span class="cov0" title="0">{
                policy = policies[0]
        }</span> else<span class="cov0" title="0"> {
                policyIdx, convErr := strconv.Atoi(match[1])
                if convErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Invalid policy index: %v\n", match[1])
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">policy = policies[policyIdx]</span>
        }
        <span class="cov0" title="0">if namedPolicy != nil &amp;&amp; namedPolicy != policy </span><span class="cov0" title="0">{
                fmt.Printf("Warning: Ring does not match policy!\n")
                fmt.Printf("Double check your policy name!\n")
        }</span>

        <span class="cov0" title="0">ring, _ := getRing("", "object", policy.Index)

        hashDir := filepath.Dir(fullPath)
        dataFile, metaFile := objectserver.ObjectFiles(hashDir)
        metadata, metaErr := objectserver.ObjectMetadata(dataFile, metaFile)
        if metaErr != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error fetching metadata: %v\n", metaErr)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">etag := metadata["ETag"]
        delete(metadata, "ETag")
        length := metadata["Content-Length"]
        delete(metadata, "Content-Length")
        path := metadata["name"]

        printObjMeta(metadata)

        if noEtag == false </span><span class="cov0" title="0">{
                fp, openErr := os.Open(fullPath)
                if openErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error opening file (%v): %v\n", fullPath, openErr)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">hasher := md5.New()
                if _, err := io.Copy(hasher, fp); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error copying file: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">hash := hex.EncodeToString(hasher.Sum(nil))
                if etag != "" </span><span class="cov0" title="0">{
                        if etag == hash </span><span class="cov0" title="0">{
                                fmt.Printf("ETag: %v (valid)\n", etag)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("ETag: %v doesn't match file hash of %v!\n", etag, hash)
                        }</span>
                } else<span class="cov0" title="0"> {
                        fmt.Printf("ETag: Not found in metadata\n")
                }</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("ETag: %v (not checked)\n", etag)
        }</span>
        <span class="cov0" title="0">if length != "" </span><span class="cov0" title="0">{
                l, convErr := strconv.Atoi(length)
                if convErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Invalid length: %v\n", length)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if int64(l) == stat.Size() </span><span class="cov0" title="0">{
                        fmt.Printf("Content-Length: %v (valid)\n", length)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Content-Length: %v doesn't match file length of %v\n", length, stat.Size())
                }</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("Content-Length: Not found in metadata\n")
        }</span>

        <span class="cov0" title="0">account, container, object := getACO(path)
        printItemLocations(ring, "object", account, container, object, "", false, policy)</span>
}

type AutoAdmin struct {
        serverconf        conf.Config
        logger            srv.LowLevelLogger
        logLevel          zap.AtomicLevel
        port              int
        bindIp            string
        client            common.HTTPClient
        hClient           client.RequestClient
        policies          conf.PolicyList
        metricsScope      tally.Scope
        metricsCloser     io.Closer
        pdcCloser         io.Closer
        clientTraceCloser io.Closer
        runningForever    bool
        db                *dbInstance
        fastRingScan      chan struct{}
}

func (server *AutoAdmin) Type() string <span class="cov0" title="0">{
        return "andrewd"
}</span>

func (server *AutoAdmin) Background(flags *flag.FlagSet) chan struct{} <span class="cov0" title="0">{
        once := false
        if f := flags.Lookup("once"); f != nil </span><span class="cov0" title="0">{
                once = f.Value.(flag.Getter).Get() == true
        }</span>
        <span class="cov0" title="0">if once </span><span class="cov0" title="0">{
                ch := make(chan struct{})
                go func() </span><span class="cov0" title="0">{
                        defer close(ch)
                        server.Run()
                }</span>()
                <span class="cov0" title="0">return ch</span>
        }
        <span class="cov0" title="0">go server.RunForever()
        return nil</span>
}

func (server *AutoAdmin) GetHandler(config conf.Config, metricsPrefix string) http.Handler <span class="cov0" title="0">{
        var metricsScope tally.Scope
        metricsScope, server.metricsCloser = tally.NewRootScope(tally.ScopeOptions{
                Prefix:         metricsPrefix,
                Tags:           map[string]string{},
                CachedReporter: promreporter.NewReporter(promreporter.Options{}),
                Separator:      promreporter.DefaultSeparator,
        }, time.Second)
        commonHandlers := alice.New(
                middleware.NewDebugResponses(config.GetBool("debug", "debug_x_source_code", false)),
                server.LogRequest,
                middleware.RecoverHandler,
                middleware.ValidateRequest,
        )
        router := srv.NewRouter()
        router.Get("/metrics", prometheus.Handler())
        router.Get("/loglevel", server.logLevel)
        router.Put("/loglevel", server.logLevel)
        router.Get("/healthcheck", commonHandlers.ThenFunc(server.HealthcheckHandler))
        router.Get("/debug/pprof/:parm", http.DefaultServeMux)
        router.Post("/debug/pprof/:parm", http.DefaultServeMux)
        return alice.New(middleware.Metrics(metricsScope)).Then(router)
}</span>

func (server *AutoAdmin) Finalize() <span class="cov0" title="0">{
        if server.metricsCloser != nil </span><span class="cov0" title="0">{
                server.metricsCloser.Close()
        }</span>
        <span class="cov0" title="0">if server.clientTraceCloser != nil </span><span class="cov0" title="0">{
                server.clientTraceCloser.Close()
        }</span>
        <span class="cov0" title="0">if server.pdcCloser != nil </span><span class="cov0" title="0">{
                server.pdcCloser.Close()
        }</span>
}

func (server *AutoAdmin) HealthcheckHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        writer.Header().Set("Content-Length", "2")
        writer.WriteHeader(http.StatusOK)
        writer.Write([]byte("OK"))
}</span>

func (server *AutoAdmin) LogRequest(next http.Handler) http.Handler <span class="cov0" title="0">{
        return srv.LogRequest(server.logger, next)
}</span>

func (a *AutoAdmin) Run() {<span class="cov0" title="0">
        // TODO: Reimplement run once.
}</span>

func (a *AutoAdmin) RunForever() <span class="cov0" title="0">{
        go newDispersionPopulateContainers(a).runForever()
        go newDispersionPopulateObjects(a).runForever()
        go newDispersionScanContainers(a).runForever()
        go newDispersionScanObjects(a).runForever()
        go newQuarantineHistory(a).runForever()
        go newQuarantineRepair(a).runForever()
        go newUnmountedMonitor(a).runForever()
        go newReplication(a).runForever()
        go newRingMonitor(a).runForever()
        go newRingScan(a).runForever()
}</span>

func NewAdmin(serverconf conf.Config, flags *flag.FlagSet, cnf srv.ConfigLoader) (ipPort *srv.IpPort, server srv.Server, logger srv.LowLevelLogger, err error) <span class="cov0" title="0">{
        if !serverconf.HasSection("andrewd") </span><span class="cov0" title="0">{
                return ipPort, nil, nil, fmt.Errorf("Unable to find andrewd config section")
        }</span>
        <span class="cov0" title="0">logLevelString := serverconf.GetDefault("andrewd", "log_level", "INFO")
        logLevel := zap.NewAtomicLevel()
        logLevel.UnmarshalText([]byte(strings.ToLower(logLevelString)))
        logger, err = srv.SetupLogger("andrewd", &amp;logLevel, flags)
        if err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, fmt.Errorf("Error setting up logger: %v", err)
        }</span>
        <span class="cov0" title="0">policies, err := cnf.GetPolicies()
        if err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, err
        }</span>
        <span class="cov0" title="0">ip := serverconf.GetDefault("andrewd", "bind_ip", "0.0.0.0")
        port := int(serverconf.GetInt("andrewd", "bind_port", common.DefaultAndrewdPort))
        certFile := serverconf.GetDefault("andrewd", "cert_file", "")
        keyFile := serverconf.GetDefault("andrewd", "key_file", "")
        pdc, pdcerr := client.NewProxyClient(policies, srv.DefaultConfigLoader{}, logger, certFile, keyFile, "", "", "", serverconf)
        if pdcerr != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, fmt.Errorf("Could not make client: %v", pdcerr)
        }</span>
        <span class="cov0" title="0">pl := conf.PolicyList{}
        for _, p := range policies </span><span class="cov0" title="0">{
                if p.Config["andrewd"] == "ignore" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">pl[p.Index] = p</span>
        }
        <span class="cov0" title="0">transport := &amp;http.Transport{
                MaxIdleConnsPerHost: 100,
                MaxIdleConns:        0,
        }
        if certFile != "" &amp;&amp; keyFile != "" </span><span class="cov0" title="0">{
                tlsConf, err := common.NewClientTLSConfig(certFile, keyFile)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("Error getting TLS config: %v", err))</span>
                }
                <span class="cov0" title="0">transport.TLSClientConfig = tlsConf
                if err = http2.ConfigureTransport(transport); err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("Error setting up http2: %v", err))</span>
                }
        }
        <span class="cov0" title="0">httpClient := &amp;http.Client{
                Transport: transport,
                Timeout:   10 * time.Second,
        }
        a := &amp;AutoAdmin{
                serverconf:     serverconf,
                client:         httpClient,
                hClient:        pdc.NewRequestClient(nil, nil, logger),
                port:           port,
                bindIp:         ip,
                policies:       pl,
                runningForever: false,
                //containerDispersionGauge: []tally.Gauge{}, TODO- add container disp
                logger:       logger,
                logLevel:     logLevel,
                fastRingScan: make(chan struct{}, 32), // 32 just "because"; gives some room for a bunch of ring changes to get queued up before blocking.
        }
        a.db, err = newDB(&amp;serverconf, "")
        if err != nil </span><span class="cov0" title="0">{
                return ipPort, nil, nil, err
        }</span>
        <span class="cov0" title="0">if serverconf.HasSection("tracing") </span><span class="cov0" title="0">{
                clientTracer, clientTraceCloser, err := tracing.Init("andrewd", zap.NewNop(), serverconf.GetSection("tracing"))
                if err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error setting up tracer: %v", err)
                }</span>
                <span class="cov0" title="0">a.clientTraceCloser = clientTraceCloser
                a.pdcCloser = pdc
                enableHTTPTrace := serverconf.GetBool("tracing", "enable_httptrace", true)
                a.client, err = client.NewTracingClient(clientTracer, httpClient, enableHTTPTrace)
                if err != nil </span><span class="cov0" title="0">{
                        return ipPort, nil, nil, fmt.Errorf("Error setting up tracing client: %v", err)
                }</span>
        }

        <span class="cov0" title="0">a.metricsScope, a.metricsCloser = tally.NewRootScope(tally.ScopeOptions{
                Prefix:         "hb_andrewd",
                Tags:           map[string]string{},
                CachedReporter: promreporter.NewReporter(promreporter.Options{}),
                Separator:      promreporter.DefaultSeparator,
        }, time.Second)

        ipPort = &amp;srv.IpPort{Ip: ip, Port: port, CertFile: certFile, KeyFile: keyFile}
        resp := a.hClient.PutAccount(
                context.Background(),
                AdminAccount,
                common.Map2Headers(map[string]string{
                        "Content-Length": "0",
                        "Content-Type":   "text",
                        "X-Timestamp":    fmt.Sprintf("%d", time.Now().Unix()),
                }),
        )
        io.Copy(ioutil.Discard, resp.Body)
        resp.Body.Close()
        if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                return ipPort, nil, nil, fmt.Errorf("could not establish admin account: PUT %s gave status code %d", AdminAccount, resp.StatusCode)
        }</span>
        <span class="cov0" title="0">return ipPort, a, a.logger, nil</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package tools

import (
        "flag"
        "fmt"
        "sort"
        "time"

        "github.com/gholt/brimtext"
)

type progressReport struct {
        Name      string
        Time      time.Time
        Pass      bool
        Errors    []string
        Processes map[string]*processReport
}

func (r *progressReport) Passed() bool <span class="cov0" title="0">{
        return r.Pass
}</span>

func (r *progressReport) String() string <span class="cov0" title="0">{
        s := fmt.Sprintf(
                "[%s] %s\n",
                r.Time.Format("2006-01-02 15:04:05"),
                r.Name,
        )
        for _, e := range r.Errors </span><span class="cov0" title="0">{
                s += fmt.Sprintf("!! %s\n", e)
        }</span>
        <span class="cov0" title="0">data := [][]string{{
                "Process",
                "Ago",
                "Status",
                "Detail",
        }}
        var processes []string
        for process := range r.Processes </span><span class="cov0" title="0">{
                processes = append(processes, process)
        }</span>
        <span class="cov0" title="0">sort.Strings(processes)
        for _, process := range processes </span><span class="cov0" title="0">{
                report := r.Processes[process]
                var ago string
                var status string
                var detail string
                if report.Started.IsZero() </span><span class="cov0" title="0">{
                        status = "Never Run"
                }</span> else<span class="cov0" title="0"> if report.Completed.IsZero() </span><span class="cov0" title="0">{
                        ago = time.Since(report.Started).Truncate(time.Second).String()
                        status = "Running"
                        if report.Progress != "" </span><span class="cov0" title="0">{
                                detail = fmt.Sprintf("%s ago: %s", time.Since(report.ProgressUpdated).Truncate(time.Second), report.Progress)
                        }</span>
                } else<span class="cov0" title="0"> {
                        ago = time.Since(report.Completed).Truncate(time.Second).String()
                        status = "Completed"
                        detail = report.Progress
                }</span>
                <span class="cov0" title="0">data = append(data, nil)
                data = append(data, []string{process, ago, status, detail})
                if report.PreviousProgress != "" </span><span class="cov0" title="0">{
                        if report.PreviousCompleted.IsZero() </span><span class="cov0" title="0">{
                                data = append(data, []string{"", "", "", fmt.Sprintf("Previous pass did not complete: %s", report.PreviousProgress)})
                        }</span> else<span class="cov0" title="0"> {
                                data = append(data, []string{"", "", "", fmt.Sprintf("Previous pass completed %s ago: %s", time.Since(report.PreviousCompleted).Truncate(time.Second), report.PreviousProgress)})
                        }</span>
                }
        }
        <span class="cov0" title="0">opts := brimtext.NewUnicodeBoxedAlignOptions()
        opts.NilBetweenEveryRow = false
        opts.Alignments = []brimtext.Alignment{brimtext.Right, brimtext.Center, brimtext.Left, brimtext.Left}
        opts.Widths = []int{30, 7, 10}
        w := brimtext.GetTTYWidth() - 3
        for _, x := range opts.Widths </span><span class="cov0" title="0">{
                w -= x + 3
        }</span>
        <span class="cov0" title="0">if w &lt; 0 </span><span class="cov0" title="0">{
                w = 0
        }</span>
        <span class="cov0" title="0">opts.Widths = append(opts.Widths, w)
        s += brimtext.Align(data, opts)
        return s</span>
}

type processReport struct {
        Started           time.Time
        ProgressUpdated   time.Time
        Progress          string
        Completed         time.Time
        PreviousProgress  string
        PreviousCompleted time.Time
}

func getProgressReport(flags *flag.FlagSet) *progressReport <span class="cov0" title="0">{
        report := &amp;progressReport{
                Name:      "Progress Report",
                Time:      time.Now().UTC(),
                Pass:      true,
                Processes: map[string]*processReport{},
        }
        serverconf, err := getAndrewdConf(flags)
        if err != nil </span><span class="cov0" title="0">{
                report.Errors = append(report.Errors, err.Error())
                return report
        }</span>
        <span class="cov0" title="0">db, err := newDB(serverconf, "")
        if err != nil </span><span class="cov0" title="0">{
                report.Errors = append(report.Errors, err.Error())
                return report
        }</span>
        <span class="cov0" title="0">ppds, err := db.processPasses()
        if err != nil </span><span class="cov0" title="0">{
                report.Errors = append(report.Errors, err.Error())
                return report
        }</span>
        <span class="cov0" title="0">for _, ppd := range ppds </span><span class="cov0" title="0">{
                process := ppd.process
                if ppd.rtype != "" </span><span class="cov0" title="0">{
                        if ppd.rtype == "object-overall" </span><span class="cov0" title="0">{
                                process += " object"
                        }</span> else<span class="cov0" title="0"> {
                                process += " " + ppd.rtype
                        }</span>
                }
                <span class="cov0" title="0">if ppd.policy != 0 || ppd.rtype == "object" </span><span class="cov0" title="0">{
                        process += fmt.Sprintf("-%d", ppd.policy)
                }</span>
                <span class="cov0" title="0">report.Processes[process] = &amp;processReport{
                        Started:           ppd.startDate,
                        ProgressUpdated:   ppd.progressDate,
                        Progress:          ppd.progress,
                        Completed:         ppd.completeDate,
                        PreviousProgress:  ppd.previousProgress,
                        PreviousCompleted: ppd.previousCompleteDate,
                }</span>
        }
        <span class="cov0" title="0">return report</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package tools

// In /etc/hummingbird/andrewd-server.conf:
// [quarantine-history]
// initial_delay = 10       # seconds to wait between requests for the first pass
// pass_time_target = 86400 # seconds to try to make subsequent passes take
// keep_history = 2592000   # seconds to keep quarantined items
// report_interval = 600    # seconds between progress reports

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "sync/atomic"
        "time"

        "go.uber.org/zap"
)

type quarantineHistory struct {
        aa *AutoAdmin
        // delay between each request; adjusted each pass to try to make passes last passTimeTarget
        delay           time.Duration
        passTimeTarget  time.Duration
        keepHistoryDays int
        reportInterval  time.Duration
}

const secondsInADay = 60 * 60 * 24

func newQuarantineHistory(aa *AutoAdmin) *quarantineHistory <span class="cov0" title="0">{
        qh := &amp;quarantineHistory{
                aa:              aa,
                delay:           time.Duration(aa.serverconf.GetInt("quarantine-history", "initial_delay", 10)) * time.Second,
                passTimeTarget:  time.Duration(aa.serverconf.GetInt("quarantine-history", "pass_time_target", secondsInADay)) * time.Second,
                keepHistoryDays: int(aa.serverconf.GetInt("quarantine-history", "keep_history", secondsInADay*30) / secondsInADay),
                reportInterval:  time.Duration(aa.serverconf.GetInt("quarantine-history", "report_interval", 600)) * time.Second,
        }
        if qh.delay &lt; 0 </span><span class="cov0" title="0">{
                qh.delay = time.Second
        }</span>
        <span class="cov0" title="0">if qh.passTimeTarget &lt; 0 </span><span class="cov0" title="0">{
                qh.passTimeTarget = time.Second
        }</span>
        <span class="cov0" title="0">if qh.keepHistoryDays &lt; 1 </span><span class="cov0" title="0">{
                qh.keepHistoryDays = 1
        }</span>
        <span class="cov0" title="0">return qh</span>
}

func (qh *quarantineHistory) runForever() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                sleepFor := qh.runOnce()
                if sleepFor &lt; 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">time.Sleep(sleepFor)</span>
        }
}

func (qh *quarantineHistory) runOnce() time.Duration <span class="cov0" title="0">{
        responseBody := &amp;struct {
                Message     string `json:"message"`
                Days        int    `json:"days"`
                ItemsPurged int    `json:"items_purged"`
                ItemsLeft   int    `json:"items_left"`
        }{}
        start := time.Now()
        logger := qh.aa.logger.With(zap.String("process", "quarantine history"))
        logger.Debug("starting pass")
        if err := qh.aa.db.startProcessPass("quarantine history", "", 0); err != nil </span><span class="cov0" title="0">{
                logger.Error("startProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">var delays int64
        var errors int64
        var itemsPurged int64
        var itemsLeft int64
        urls := qh.quarantineHistoryDeleteURLs()
        cancel := make(chan struct{})
        progressDone := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-cancel:<span class="cov0" title="0">
                                close(progressDone)
                                return</span>
                        case &lt;-time.After(qh.reportInterval):<span class="cov0" title="0">
                                d := atomic.LoadInt64(&amp;delays)
                                e := atomic.LoadInt64(&amp;errors)
                                p := atomic.LoadInt64(&amp;itemsPurged)
                                l := atomic.LoadInt64(&amp;itemsLeft)
                                var eta time.Duration
                                if d &gt; 0 </span><span class="cov0" title="0">{
                                        eta = time.Duration(int64(time.Since(start)) / d * (int64(len(urls)) - d))
                                }</span>
                                <span class="cov0" title="0">logger.Debug("progress", zap.Int64("urls so far", d), zap.Int("total urls", len(urls)), zap.String("eta", eta.String()))
                                if err := qh.aa.db.progressProcessPass("quarantine history", "", 0, fmt.Sprintf("%d of %d urls, %d errors, %d purged, %d left for next pass, eta %s", d, len(urls), e, p, l, eta)); err != nil </span><span class="cov0" title="0">{
                                        logger.Error("progressProcessPass", zap.Error(err))
                                }</span>
                        }
                }
        }()
        <span class="cov0" title="0">for _, url := range urls </span><span class="cov0" title="0">{
                atomic.AddInt64(&amp;delays, 1)
                time.Sleep(qh.delay)
                deleteLogger := logger.With(zap.String("method", "DELETE"), zap.String("url", url))
                req, err := http.NewRequest("DELETE", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        deleteLogger.Error("http.NewRequest", zap.Error(err))
                        atomic.AddInt64(&amp;errors, 1)
                        continue</span>
                }
                <span class="cov0" title="0">resp, err := qh.aa.client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        deleteLogger.Error("Do", zap.Error(err))
                        atomic.AddInt64(&amp;errors, 1)
                        continue</span>
                }
                <span class="cov0" title="0">body, err := ioutil.ReadAll(resp.Body)
                resp.Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        deleteLogger.Error("Body", zap.Int("StatusCode", resp.StatusCode), zap.Error(err))
                        atomic.AddInt64(&amp;errors, 1)
                        continue</span>
                }
                <span class="cov0" title="0">if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                        deleteLogger.Error("StatusCode", zap.Int("StatusCode", resp.StatusCode), zap.Error(err))
                        atomic.AddInt64(&amp;errors, 1)
                        continue</span>
                }
                <span class="cov0" title="0">if err := json.Unmarshal(body, &amp;responseBody); err != nil </span><span class="cov0" title="0">{
                        deleteLogger.Error("JSON", zap.String("JSON", string(body)), zap.Error(err))
                        atomic.AddInt64(&amp;errors, 1)
                        continue</span>
                }
                <span class="cov0" title="0">deleteLogger.Debug("response", zap.String("Message", responseBody.Message), zap.Int("Days", responseBody.Days), zap.Int("ItemsPurged", responseBody.ItemsPurged), zap.Int("ItemsLeft", responseBody.ItemsLeft))
                atomic.AddInt64(&amp;itemsPurged, int64(responseBody.ItemsPurged))
                atomic.AddInt64(&amp;itemsLeft, int64(responseBody.ItemsLeft))</span>
        }
        <span class="cov0" title="0">close(cancel)
        &lt;-progressDone
        qh.delay = qh.passTimeTarget / time.Duration(delays)
        sleepFor := time.Until(start.Add(qh.passTimeTarget))
        if sleepFor &lt; 0 </span><span class="cov0" title="0">{
                sleepFor = 0
        }</span>
        <span class="cov0" title="0">logger.Debug("pass complete", zap.Int64("errors", errors), zap.Int64("items purged", itemsPurged), zap.Int64("items left", itemsLeft), zap.String("next delay", qh.delay.String()), zap.String("sleep for", sleepFor.String()))
        if err := qh.aa.db.progressProcessPass("quarantine history", "", 0, fmt.Sprintf("%d of %d urls, %d errors, %d purged, %d left for next pass", delays, len(urls), errors, itemsPurged, itemsLeft)); err != nil </span><span class="cov0" title="0">{
                logger.Error("progressProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">if err := qh.aa.db.completeProcessPass("quarantine history", "", 0); err != nil </span><span class="cov0" title="0">{
                logger.Error("completeProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">return sleepFor</span>
}

// quarantineHistoryDeleteURLs returns a list of urls used to purge older
// quarantined history items, based on all the devices on all the servers in
// all the rings for the hummingbird configuration.
func (qh *quarantineHistory) quarantineHistoryDeleteURLs() []string <span class="cov0" title="0">{
        urlMap := map[string]struct{}{}
        for _, typ := range []string{"account", "container", "object"} </span><span class="cov0" title="0">{
                if typ == "object" </span><span class="cov0" title="0">{
                        for _, policy := range qh.aa.policies </span><span class="cov0" title="0">{
                                ringg, _ := getRing("", typ, policy.Index)
                                for _, dev := range ringg.AllDevices() </span><span class="cov0" title="0">{
                                        if !dev.Active() </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">urlMap[fmt.Sprintf("%s://%s:%d/recon/%s/quarantinedhistory/%ss/%d", dev.Scheme, dev.Ip, dev.Port, dev.Device, typ, qh.keepHistoryDays)] = struct{}{}</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        ringg, _ := getRing("", typ, 0)
                        for _, dev := range ringg.AllDevices() </span><span class="cov0" title="0">{
                                if !dev.Active() </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">urlMap[fmt.Sprintf("%s://%s:%d/recon/%s/quarantinedhistory/%ss/%d", dev.Scheme, dev.Ip, dev.Port, dev.Device, typ, qh.keepHistoryDays)] = struct{}{}</span>
                        }
                }
        }
        <span class="cov0" title="0">urls := make([]string, 0, len(urlMap))
        for url := range urlMap </span><span class="cov0" title="0">{
                urls = append(urls, url)
        }</span>
        <span class="cov0" title="0">return urls</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">package tools

// In /etc/hummingbird/andrewd-server.conf:
// [quarantine-repair]
// initial_delay = 1       # seconds to wait between requests for the first pass
// pass_time_target = 3600 # seconds to try to make subsequent passes take
// report_interval = 600    # seconds between progress reports

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "path"
        "strconv"
        "strings"
        "sync/atomic"
        "time"

        "github.com/troubling/hummingbird/common/ring"
        "go.uber.org/zap"
)

type quarantineRepair struct {
        aa *AutoAdmin
        // delay between each request; adjusted each pass to try to make passes last passTimeTarget
        delay          time.Duration
        passTimeTarget time.Duration
        reportInterval time.Duration
}

func newQuarantineRepair(aa *AutoAdmin) *quarantineRepair <span class="cov0" title="0">{
        qr := &amp;quarantineRepair{
                aa:             aa,
                delay:          time.Duration(aa.serverconf.GetInt("quarantine-repair", "initial_delay", 1)) * time.Second,
                passTimeTarget: time.Duration(aa.serverconf.GetInt("quarantine-repair", "pass_time_target", 60*60)) * time.Second,
                reportInterval: time.Duration(aa.serverconf.GetInt("quarantine-repair", "report_interval", 600)) * time.Second,
        }
        if qr.delay &lt; 0 </span><span class="cov0" title="0">{
                qr.delay = time.Second
        }</span>
        <span class="cov0" title="0">if qr.passTimeTarget &lt; 0 </span><span class="cov0" title="0">{
                qr.passTimeTarget = time.Second
        }</span>
        <span class="cov0" title="0">return qr</span>
}

func (qr *quarantineRepair) runForever() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                sleepFor := qr.runOnce()
                if sleepFor &lt; 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">time.Sleep(sleepFor)</span>
        }
}

func (qr *quarantineRepair) runOnce() time.Duration <span class="cov0" title="0">{
        start := time.Now()
        logger := qr.aa.logger.With(zap.String("process", "quarantine repair"))
        logger.Debug("starting pass")
        if err := qr.aa.db.startProcessPass("quarantine repair", "", 0); err != nil </span><span class="cov0" title="0">{
                logger.Error("startProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">var delays int64
        var repairsMade int64
        var partitionReplicationsQueued int64
        urls := qr.quarantineDetailURLs()
        cancel := make(chan struct{})
        progressDone := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-cancel:<span class="cov0" title="0">
                                close(progressDone)
                                return</span>
                        case &lt;-time.After(qr.reportInterval):<span class="cov0" title="0">
                                d := atomic.LoadInt64(&amp;delays)
                                r := atomic.LoadInt64(&amp;repairsMade)
                                p := atomic.LoadInt64(&amp;partitionReplicationsQueued)
                                var eta time.Duration
                                if d &gt; 0 </span><span class="cov0" title="0">{
                                        eta = time.Duration(int64(time.Since(start)) / d * (int64(len(urls)) - d))
                                }</span>
                                <span class="cov0" title="0">logger.Debug("progress", zap.Int64("urls so far", d), zap.Int("total urls", len(urls)), zap.String("eta", eta.String()))
                                if err := qr.aa.db.progressProcessPass("quarantine repair", "", 0, fmt.Sprintf("%d of %d urls, %d repairs made, %d partition replications queued, eta %s", d, len(urls), r, p, eta)); err != nil </span><span class="cov0" title="0">{
                                        logger.Error("progressProcessPass", zap.Error(err))
                                }</span>
                        }
                }
        }()
        <span class="cov0" title="0">for url, ipp := range urls </span><span class="cov0" title="0">{
                atomic.AddInt64(&amp;delays, 1)
                time.Sleep(qr.delay)
                getLogger := logger.With(zap.String("method", "GET"), zap.String("url", url))
                for typ, deviceToEntries := range qr.retrieveTypeToDeviceToEntries(getLogger, url) </span><span class="cov0" title="0">{
                        for device, entries := range deviceToEntries </span><span class="cov0" title="0">{
                                policy := 0
                                if typ == "accounts" </span><span class="cov0" title="0">{
                                        typ = "account"
                                }</span> else<span class="cov0" title="0"> if typ == "containers" </span><span class="cov0" title="0">{
                                        typ = "container"
                                }</span> else<span class="cov0" title="0"> if typ == "objects" </span><span class="cov0" title="0">{
                                        typ = "object"
                                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(typ, "objects-") </span><span class="cov0" title="0">{
                                        var err error
                                        policy, err = strconv.Atoi(typ[len("objects-"):])
                                        if err != nil </span><span class="cov0" title="0">{
                                                getLogger.Debug("weird type in entries", zap.String("type", typ), zap.Error(err))
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">typ = "object"</span>
                                } else<span class="cov0" title="0"> {
                                        getLogger.Debug("weird type in entries", zap.String("type", typ))
                                        continue</span>
                                }
                                <span class="cov0" title="0">ringg, _ := getRing("", typ, policy)
                                deviceID := -1
                                for _, dev := range ringg.AllDevices() </span><span class="cov0" title="0">{
                                        if !dev.Active() </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">if dev.Ip == ipp.ip &amp;&amp; dev.Port == ipp.port &amp;&amp; dev.Device == device </span><span class="cov0" title="0">{
                                                deviceID = dev.Id
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">deviceLogger := logger.With(zap.String("type", typ), zap.Int("policy", policy), zap.String("ip", ipp.ip), zap.Int("port", ipp.port), zap.String("device", device), zap.Int("deviceID", deviceID))
                                for _, entry := range entries </span><span class="cov0" title="0">{
                                        if typ == "object" &amp;&amp; entry.NameInURL != "" </span><span class="cov0" title="0">{
                                                if !qr.repairObject(deviceLogger, typ, policy, ringg, entry.NameInURL) </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                        } else<span class="cov0" title="0"> { // entry.NameOnDevice
                                                if !qr.queuePartitionReplication(deviceLogger, typ, policy, ringg, deviceID, entry.NameOnDevice) </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov0" title="0">qr.clearQuarantine(deviceLogger, ipp, device, typ, policy, entry.NameOnDevice)</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">close(cancel)
        &lt;-progressDone
        qr.delay = qr.passTimeTarget / time.Duration(delays)
        sleepFor := time.Until(start.Add(qr.passTimeTarget))
        if sleepFor &lt; 0 </span><span class="cov0" title="0">{
                sleepFor = 0
        }</span>
        <span class="cov0" title="0">logger.Debug("pass complete", zap.String("next delay", qr.delay.String()), zap.String("sleep for", sleepFor.String()))
        if err := qr.aa.db.progressProcessPass("quarantine repair", "", 0, fmt.Sprintf("%d of %d urls, %d repairs made, %d partition replications queued", delays, len(urls), repairsMade, partitionReplicationsQueued)); err != nil </span><span class="cov0" title="0">{
                logger.Error("progressProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">if err := qr.aa.db.completeProcessPass("quarantine repair", "", 0); err != nil </span><span class="cov0" title="0">{
                logger.Error("completeProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">return sleepFor</span>
}

// quarantineDetailURLs returns a map of urls to ip-port structures based on
// all the servers in all the rings for the hummingbird configuration.
func (qr *quarantineRepair) quarantineDetailURLs() map[string]*ippInstance <span class="cov0" title="0">{
        urls := map[string]*ippInstance{}
        for _, typ := range []string{"account", "container", "object"} </span><span class="cov0" title="0">{
                if typ == "object" </span><span class="cov0" title="0">{
                        for _, policy := range qr.aa.policies </span><span class="cov0" title="0">{
                                ringg, _ := getRing("", typ, policy.Index)
                                for _, dev := range ringg.AllDevices() </span><span class="cov0" title="0">{
                                        if !dev.Active() </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">urls[fmt.Sprintf("%s://%s:%d/recon/quarantineddetail", dev.Scheme, dev.Ip, dev.Port)] = &amp;ippInstance{scheme: dev.Scheme, ip: dev.Ip, port: dev.Port}</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        ringg, _ := getRing("", typ, 0)
                        for _, dev := range ringg.AllDevices() </span><span class="cov0" title="0">{
                                if !dev.Active() </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">urls[fmt.Sprintf("%s://%s:%d/recon/quarantineddetail", dev.Scheme, dev.Ip, dev.Port)] = &amp;ippInstance{scheme: dev.Scheme, ip: dev.Ip, port: dev.Port}</span>
                        }
                }
        }
        <span class="cov0" title="0">return urls</span>
}

// retrieveTypeToDeviceToEntries performs an HTTP GET request to the url and
// translates the response into a map[string]map[string][]*entryInstance giving
// the types-to-devices-to-entries of quarantined items that server has; any
// errors will be logged and an empty map returned.
func (qr *quarantineRepair) retrieveTypeToDeviceToEntries(logger *zap.Logger, url string) map[string]map[string][]*entryInstance <span class="cov0" title="0">{
        // type is accounts, containers, objects, objects-1, etc.
        typeToDeviceToEntries := map[string]map[string][]*entryInstance{}
        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("http.NewRequest", zap.Error(err))
                return typeToDeviceToEntries
        }</span>
        <span class="cov0" title="0">resp, err := qr.aa.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug("Do", zap.Error(err))
                return typeToDeviceToEntries
        }</span>
        <span class="cov0" title="0">body, err := ioutil.ReadAll(resp.Body)
        resp.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug("Body", zap.Int("StatusCode", resp.StatusCode), zap.Error(err))
                return typeToDeviceToEntries
        }</span>
        <span class="cov0" title="0">if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                logger.Debug("StatusCode", zap.Int("StatusCode", resp.StatusCode), zap.Error(err))
                return typeToDeviceToEntries
        }</span>
        <span class="cov0" title="0">if err := json.Unmarshal(body, &amp;typeToDeviceToEntries); err != nil </span><span class="cov0" title="0">{
                logger.Debug("JSON", zap.String("JSON", string(body)), zap.Error(err))
                return typeToDeviceToEntries
        }</span>
        <span class="cov0" title="0">return typeToDeviceToEntries</span>
}

func (qr *quarantineRepair) repairHECObject(logger *zap.Logger, policy int, ringg ring.Ring, entryNameInURL, account, container, object string) bool <span class="cov0" title="0">{
        partition := ringg.GetPartition(account, container, object)
        logger = logger.With(zap.Uint64("partition", partition))
        for _, device := range ringg.GetNodes(partition) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("%s://%s:%d/ec-reconstruct/%s/%s/%s/%s", device.Scheme, device.Ip, device.Port, device.Device, account, container, object)
                logger.Debug("Trying reconstruct", zap.String("url", url))
                req, err := http.NewRequest("PUT", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("repair HEC http.NewRequest", zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">req.Header.Set("X-Backend-Storage-Policy-Index", fmt.Sprintf("%d", policy))
                resp, err := qr.aa.client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("repair HEC client.Do", zap.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">resp.Body.Close()
                if resp.StatusCode/100 == 2 </span><span class="cov0" title="0">{
                        logger.Debug("Reconstruct successful", zap.String("url", url))
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// repairObject tries to ensure all replicas are in place for the quarantined
// entry and returns true if the entry should be deleted as it has been handled
// as best as is possible.
func (qr *quarantineRepair) repairObject(logger *zap.Logger, typ string, policy int, ringg ring.Ring, entryNameInURL string) bool <span class="cov0" title="0">{
        logger = logger.With(zap.String("name in URL", entryNameInURL))
        parts := strings.SplitN(entryNameInURL, "/", 4)
        var account, container, object string
        switch len(parts) </span>{
        case 2:<span class="cov0" title="0">
                account = parts[1]</span>
        case 3:<span class="cov0" title="0">
                account = parts[1]
                container = parts[2]</span>
        case 4:<span class="cov0" title="0">
                account = parts[1]
                container = parts[2]
                object = parts[3]</span>
        default:<span class="cov0" title="0">
                logger.Debug("oddball quarantined item")
                return true</span>
        }
        <span class="cov0" title="0">if account == "" || (container == "" &amp;&amp; object != "") </span><span class="cov0" title="0">{
                logger.Debug("oddball quarantined item")
                return true
        }</span>
        <span class="cov0" title="0">switch typ </span>{
        case "account":<span class="cov0" title="0">
                if container != "" || object != "" </span><span class="cov0" title="0">{
                        logger.Debug("skipping item since it doesn't match type 'account'")
                        return false
                }</span>
        case "container":<span class="cov0" title="0">
                if container == "" || object != "" </span><span class="cov0" title="0">{
                        logger.Debug("skipping item since it doesn't match type 'container'")
                        return false
                }</span>
        case "object":<span class="cov0" title="0">
                if container == "" || object == "" </span><span class="cov0" title="0">{
                        logger.Debug("skipping item since it doesn't match type 'object'")
                        return false
                }</span>
        }

        <span class="cov0" title="0">policyObj := qr.aa.policies[policy]
        if policyObj.Type == "hec" </span><span class="cov0" title="0">{
                return qr.repairHECObject(logger, policy, ringg, entryNameInURL, account, container, object)
        }</span>

        <span class="cov0" title="0">partition := ringg.GetPartition(account, container, object)
        logger = logger.With(zap.Uint64("partition", partition))
        var have, notfound, unsure []*ring.Device
        for _, device := range ringg.GetNodes(partition) </span><span class="cov0" title="0">{
                url := fmt.Sprintf("%s://%s:%d/%s/%d/%s", device.Scheme, device.Ip, device.Port, device.Device, partition, account)
                if container != "" </span><span class="cov0" title="0">{
                        url += "/" + container
                        if object != "" </span><span class="cov0" title="0">{
                                url += "/" + object
                        }</span>
                }
                <span class="cov0" title="0">logger = logger.With(zap.String("method", "HEAD"), zap.String("url", url))
                req, err := http.NewRequest("HEAD", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("http.NewRequest", zap.Error(err))
                        return false
                }</span>
                <span class="cov0" title="0">resp, err := qr.aa.client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Do", zap.Error(err))
                        return false
                }</span>
                <span class="cov0" title="0">resp.Body.Close()
                if resp.StatusCode/100 == 2 </span><span class="cov0" title="0">{
                        have = append(have, device)
                }</span> else<span class="cov0" title="0"> if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        notfound = append(notfound, device)
                }</span> else<span class="cov0" title="0"> {
                        logger.Debug("StatusCode", zap.Int("StatusCode", resp.StatusCode), zap.Error(err))
                        unsure = append(unsure, device)
                }</span>
        }
        <span class="cov0" title="0">if uint64(len(notfound)) == ringg.ReplicaCount() </span><span class="cov0" title="0">{
                logger.Debug("none of the primary devices had the item so we'll just assume it was deleted after it got quarantined")
                return true
        }</span>
        <span class="cov0" title="0">if len(have) == 0 </span><span class="cov0" title="0">{
                logger.Debug("couldn't find anyone with the item yet, but not everyone reported in, so just skip for now")
                return false
        }</span>
        <span class="cov0" title="0">fromURL := fmt.Sprintf("%s://%s:%d/%s/%d/%s", have[0].Scheme, have[0].Ip, have[0].Port, have[0].Device, partition, account)
        if container != "" </span><span class="cov0" title="0">{
                fromURL += "/" + container
                if object != "" </span><span class="cov0" title="0">{
                        fromURL += "/" + object
                }</span>
        }
        <span class="cov0" title="0">logger = logger.With(zap.String("fromURL", fromURL))
        putCopy := func(device *ring.Device) bool </span><span class="cov0" title="0">{
                fromReq, err := http.NewRequest("GET", fromURL, nil)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("http.NewRequest", zap.Error(err))
                        return false
                }</span>
                <span class="cov0" title="0">fromResp, err := qr.aa.client.Do(fromReq)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Do", zap.Error(err))
                        return false
                }</span>
                <span class="cov0" title="0">defer fromResp.Body.Close()
                if fromResp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                        logger.Debug("StatusCode", zap.Int("StatusCode", fromResp.StatusCode), zap.Error(err))
                        return false
                }</span>
                <span class="cov0" title="0">toURL := fmt.Sprintf("%s://%s:%d/%s/%d/%s", device.Scheme, device.Ip, device.Port, device.Device, partition, account)
                if container != "" </span><span class="cov0" title="0">{
                        toURL += "/" + container
                        if object != "" </span><span class="cov0" title="0">{
                                toURL += "/" + object
                        }</span>
                }
                <span class="cov0" title="0">logger = logger.With(zap.String("toURL", toURL))
                toReq, err := http.NewRequest("PUT", toURL, fromResp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("http.NewRequest", zap.Error(err))
                        return false
                }</span>
                <span class="cov0" title="0">toReq.Header = fromResp.Header
                toResp, err := qr.aa.client.Do(toReq)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Debug("Do", zap.Error(err))
                        return false
                }</span>
                <span class="cov0" title="0">toResp.Body.Close()
                if toResp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                        logger.Debug("StatusCode", zap.Int("StatusCode", toResp.StatusCode), zap.Error(err))
                        return false
                }</span>
                <span class="cov0" title="0">return true</span>
        }
        <span class="cov0" title="0">for _, device := range notfound </span><span class="cov0" title="0">{
                if !putCopy(device) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">for _, device := range unsure </span><span class="cov0" title="0">{
                if !putCopy(device) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// queuePartitionReplication tries to figure out the partition for the
// quarantined entry and queue replication of that partition; returns true if
// the entry should be deleted as it has been handled as best as is possible.
func (qr *quarantineRepair) queuePartitionReplication(logger *zap.Logger, typ string, policy int, ringg ring.Ring, deviceID int, entryNameOnDevice string) bool <span class="cov0" title="0">{
        logger = logger.With(zap.String("name on device", entryNameOnDevice))
        if typ == "account" || typ == "container" </span><span class="cov0" title="0">{
                logger.Debug("skipping accounts and containers since they do not have priority replication, for now. There hasn't been a need for it yet because their replication passes have been so quick.")
                return true
        }</span>
        <span class="cov0" title="0">if deviceID &lt; 0 </span><span class="cov0" title="0">{
                logger.Debug("skipping since deviceID could not be resolved; likely the service we got the report from isn't actually in charge of the device and it's instead another service on the same server using the same device root")
                return false
        }</span>
        <span class="cov0" title="0">if len(entryNameOnDevice) &lt; 8 </span><span class="cov0" title="0">{
                logger.Debug("oddball quarantined item")
                return true
        }</span>
        <span class="cov0" title="0">partition, err := ringg.PartitionForHash(entryNameOnDevice)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug("oddball quarantined item", zap.Error(err))
                return true
        }</span>
        <span class="cov0" title="0">if err = qr.aa.db.queuePartitionReplication(typ, policy, partition, "quarantine", -1, deviceID); err != nil </span><span class="cov0" title="0">{
                logger.Error("could not queue partition for replication", zap.Uint64("partition", partition), zap.Error(err))
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

type ippInstance struct {
        scheme string
        ip     string
        port   int
}

type entryInstance struct {
        NameOnDevice string
        NameInURL    string
}

func (qr *quarantineRepair) clearQuarantine(logger *zap.Logger, ipp *ippInstance, device, typ string, policy int, nameOnDevice string) error <span class="cov0" title="0">{
        reconType := typ + "s"
        if policy != 0 </span><span class="cov0" title="0">{
                reconType += fmt.Sprintf("-%d", policy)
        }</span>
        <span class="cov0" title="0">url := fmt.Sprintf("%s://%s:%d/", ipp.scheme, ipp.ip, ipp.port) + path.Join("recon", device, "quarantined", reconType, nameOnDevice)
        logger = logger.With(zap.String("method", "DELETE"), zap.String("url", url))
        req, err := http.NewRequest("DELETE", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("http.NewRequest", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">resp, err := qr.aa.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug("Do", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">resp.Body.Close()
        if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                logger.Debug("StatusCode", zap.Int("StatusCode", resp.StatusCode), zap.Error(err))
                return fmt.Errorf("bad response status code %d", resp.StatusCode)
        }</span>
        <span class="cov0" title="0">logger.Debug("cleared")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package tools

import (
        "encoding/json"
        "flag"
        "fmt"
        "io/ioutil"
        "math"
        "net/http"
        "os"
        "path/filepath"
        "sort"
        "time"

        "github.com/troubling/hummingbird/common"
        "github.com/troubling/hummingbird/common/conf"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/common/srv"
        "github.com/troubling/hummingbird/objectserver"
        "golang.org/x/net/http2"
)

type ipPort struct {
        ip, scheme      string
        port            int
        replicationPort int
}

func (v *ipPort) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s://%s:%d|%d", v.scheme, v.ip, v.port, v.replicationPort)
}</span>

func serverId(ip string, port int) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%d", ip, port)
}</span>

func deviceId(ip string, port int, device string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d/%s", ip, port, device)
}</span>

func queryHostRecon(client common.HTTPClient, s *ipPort, endpoint string) ([]byte, error) <span class="cov8" title="1">{
        serverUrl := fmt.Sprintf("%s://%s:%d/recon/%s", s.scheme, s.ip, s.port, endpoint)
        req, err := http.NewRequest("GET", serverUrl, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">data, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

func queryHostReplication(client common.HTTPClient, s *ipPort) (map[string]objectserver.DeviceStats, error) <span class="cov0" title="0">{
        serverUrl := fmt.Sprintf("http://%s:%d/progress/object-replicator", s.ip, s.replicationPort)
        req, err := http.NewRequest("GET", serverUrl, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">data, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var stats map[string]objectserver.DeviceStats
        if err = json.Unmarshal(data, &amp;stats); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return stats, nil</span>
}

type passable interface {
        Passed() bool
}

type ringMD5Report struct {
        Name      string
        Time      time.Time
        Pass      bool
        Servers   int
        Successes int
        Errors    []string
}

func (r *ringMD5Report) Passed() bool <span class="cov8" title="1">{
        return r.Pass
}</span>

func (r *ringMD5Report) String() string <span class="cov0" title="0">{
        s := fmt.Sprintf(
                "[%s] %s\n",
                r.Time.Format("2006-01-02 15:04:05"),
                r.Name,
        )
        for _, e := range r.Errors </span><span class="cov0" title="0">{
                s += fmt.Sprintf("!! %s\n", e)
        }</span>
        <span class="cov0" title="0">s += fmt.Sprintf(
                "%d/%d hosts matched, %d error[s] while checking hosts.\n",
                r.Successes, r.Servers, len(r.Errors),
        )
        return s</span>
}

func getRingMD5Report(client common.HTTPClient, servers []*ipPort, ringMap map[string]string) *ringMD5Report <span class="cov8" title="1">{
        report := &amp;ringMD5Report{
                Name:    "Ring MD5 Report",
                Time:    time.Now().UTC(),
                Servers: len(servers),
                Pass:    true,
        }
        if ringMap == nil </span><span class="cov0" title="0">{
                var err error
                ringMap, err = common.GetAllRingFileMd5s()
                if err != nil </span><span class="cov0" title="0">{
                        report.Errors = append(report.Errors, fmt.Sprintf("Unrecoverable error on ringmd5 report: %v", err))
                        report.Pass = false
                        return report
                }</span>
        }
        <span class="cov8" title="1">for _, server := range servers </span><span class="cov8" title="1">{
                rBytes, err := queryHostRecon(client, server, "ringmd5")
                if err != nil </span><span class="cov0" title="0">{
                        report.Errors = append(report.Errors, fmt.Sprintf("%s: %s", server, err))
                        report.Pass = false
                        continue</span>
                }
                <span class="cov8" title="1">var rData map[string]string
                if err := json.Unmarshal(rBytes, &amp;rData); err != nil </span><span class="cov0" title="0">{
                        report.Errors = append(report.Errors, fmt.Sprintf("%s: %s - %q", server, err, string(rBytes)))
                        report.Pass = false
                        continue</span>
                }
                <span class="cov8" title="1">allMatch := true
                for fName, md5sum := range ringMap </span><span class="cov8" title="1">{
                        if rData[fName] != md5sum </span><span class="cov8" title="1">{
                                report.Errors = append(report.Errors, fmt.Sprintf("%s://%s:%d/recon/ringmd5 (%s =&gt; %s) doesn't match on disk md5sum %s", server.scheme, server.ip, server.port, filepath.Base(fName), rData[fName], md5sum))
                                report.Pass = false
                                allMatch = false
                        }</span>
                }
                <span class="cov8" title="1">if allMatch </span><span class="cov8" title="1">{
                        report.Successes++
                }</span>
        }
        <span class="cov8" title="1">report.Pass = report.Successes == report.Servers
        return report</span>
}

type mainConfMD5Report struct {
        Name      string
        Time      time.Time
        Pass      bool
        Servers   int
        Successes int
        Errors    []string
}

func (r *mainConfMD5Report) Passed() bool <span class="cov0" title="0">{
        return r.Pass
}</span>

func (r *mainConfMD5Report) String() string <span class="cov0" title="0">{
        s := fmt.Sprintf(
                "[%s] %s\n",
                r.Time.Format("2006-01-02 15:04:05"),
                r.Name,
        )
        for _, e := range r.Errors </span><span class="cov0" title="0">{
                s += fmt.Sprintf("!! %s\n", e)
        }</span>
        <span class="cov0" title="0">s += fmt.Sprintf(
                "%d/%d hosts matched, %d error[s] while checking hosts.\n",
                r.Successes, r.Servers, len(r.Errors),
        )
        return s</span>
}

func getMainConfMD5Report(client common.HTTPClient, servers []*ipPort) *mainConfMD5Report <span class="cov0" title="0">{
        report := &amp;mainConfMD5Report{
                Name:    "hummingbird.conf MD5 Report",
                Time:    time.Now().UTC(),
                Servers: len(servers),
                Pass:    true,
        }
        md5Map, err := common.FileMD5("/etc/hummingbird/hummingbird.conf")
        if err != nil </span><span class="cov0" title="0">{
                md5Map, err = common.FileMD5("/etc/swift/swift.conf")
                if err != nil </span><span class="cov0" title="0">{
                        report.Errors = append(report.Errors, fmt.Sprintf("Unrecoverable error on confmd5 report: %v", err))
                        report.Pass = false
                        return report
                }</span>
        }
        <span class="cov0" title="0">for _, server := range servers </span><span class="cov0" title="0">{
                rBytes, err := queryHostRecon(client, server, "hummingbirdconfmd5")
                if err != nil </span><span class="cov0" title="0">{
                        report.Errors = append(report.Errors, fmt.Sprintf("%s: %s", server, err))
                        report.Pass = false
                        continue</span>
                }
                <span class="cov0" title="0">var rData map[string]string
                if err := json.Unmarshal(rBytes, &amp;rData); err != nil </span><span class="cov0" title="0">{
                        report.Errors = append(report.Errors, fmt.Sprintf("%s: %s - %q", server, err, string(rBytes)))
                        report.Pass = false
                        continue</span>
                }
                <span class="cov0" title="0">allMatch := true
                for fName, md5sum := range md5Map </span><span class="cov0" title="0">{
                        if rData[fName] != md5sum </span><span class="cov0" title="0">{
                                report.Errors = append(report.Errors, fmt.Sprintf("%s://%s:%d/recon/hummingbirdconfmd5 (%s =&gt; %s) doesn't match on disk md5sum %s", server.scheme, server.ip, server.port, filepath.Base(fName), rData[fName], md5sum))
                                report.Pass = false
                                allMatch = false
                        }</span>
                }
                <span class="cov0" title="0">if allMatch </span><span class="cov0" title="0">{
                        report.Successes++
                }</span>
        }
        <span class="cov0" title="0">report.Pass = report.Successes == report.Servers
        return report</span>
}

type hummingbirdMD5Report struct {
        Name      string
        Time      time.Time
        Pass      bool
        Servers   int
        Successes int
        Errors    []string
}

func (r *hummingbirdMD5Report) Passed() bool <span class="cov0" title="0">{
        return r.Pass
}</span>

func (r *hummingbirdMD5Report) String() string <span class="cov0" title="0">{
        s := fmt.Sprintf(
                "[%s] %s\n",
                r.Time.Format("2006-01-02 15:04:05"),
                r.Name,
        )
        for _, e := range r.Errors </span><span class="cov0" title="0">{
                s += fmt.Sprintf("!! %s\n", e)
        }</span>
        <span class="cov0" title="0">s += fmt.Sprintf(
                "%d/%d hosts matched, %d error[s] while checking hosts.\n",
                r.Successes, r.Servers, len(r.Errors),
        )
        return s</span>
}

func getHummingbirdMD5Report(client common.HTTPClient, servers []*ipPort) *hummingbirdMD5Report <span class="cov0" title="0">{
        report := &amp;hummingbirdMD5Report{
                Name:    "hummingbird MD5 Report",
                Time:    time.Now().UTC(),
                Servers: len(servers),
                Pass:    true,
        }
        var md5Map map[string]string
        if exePath, err := os.Executable(); err != nil </span><span class="cov0" title="0">{
                report.Errors = append(report.Errors, err.Error())
                report.Pass = false
                return report
        }</span> else<span class="cov0" title="0"> if md5Map, err = common.FileMD5(exePath); err != nil </span><span class="cov0" title="0">{
                report.Errors = append(report.Errors, err.Error())
                report.Pass = false
                return report
        }</span>
        <span class="cov0" title="0">for _, server := range servers </span><span class="cov0" title="0">{
                rBytes, err := queryHostRecon(client, server, "hummingbirdmd5")
                if err != nil </span><span class="cov0" title="0">{
                        report.Errors = append(report.Errors, fmt.Sprintf("%s: %s", server, err))
                        report.Pass = false
                        continue</span>
                }
                <span class="cov0" title="0">var rData map[string]string
                if err := json.Unmarshal(rBytes, &amp;rData); err != nil </span><span class="cov0" title="0">{
                        report.Errors = append(report.Errors, fmt.Sprintf("%s: %s - %q", server, err, string(rBytes)))
                        report.Pass = false
                        continue</span>
                }
                <span class="cov0" title="0">allMatch := true
                for fName, md5sum := range md5Map </span><span class="cov0" title="0">{
                        if rData[fName] != md5sum </span><span class="cov0" title="0">{
                                report.Errors = append(report.Errors, fmt.Sprintf("%s://%s:%d/recon/hummingbirdmd5 (%s =&gt; %s) doesn't match on disk md5sum %s", server.scheme, server.ip, server.port, filepath.Base(fName), rData[fName], md5sum))
                                report.Pass = false
                                allMatch = false
                        }</span>
                }
                <span class="cov0" title="0">if allMatch </span><span class="cov0" title="0">{
                        report.Successes++
                }</span>
        }
        <span class="cov0" title="0">report.Pass = report.Successes == report.Servers
        return report</span>
}

type timeReport struct {
        Name      string
        Time      time.Time
        Pass      bool
        Servers   int
        Successes int
        Errors    []string
}

func (r *timeReport) Passed() bool <span class="cov8" title="1">{
        return r.Pass
}</span>

func (r *timeReport) String() string <span class="cov0" title="0">{
        s := fmt.Sprintf(
                "[%s] %s\n",
                r.Time.Format("2006-01-02 15:04:05"),
                r.Name,
        )
        for _, e := range r.Errors </span><span class="cov0" title="0">{
                s += fmt.Sprintf("!! %s\n", e)
        }</span>
        <span class="cov0" title="0">s += fmt.Sprintf(
                "%d/%d hosts matched, %d error[s] while checking hosts.\n",
                r.Successes, r.Servers, len(r.Errors),
        )
        return s</span>
}

func getTimeReport(client common.HTTPClient, servers []*ipPort) *timeReport <span class="cov8" title="1">{
        report := &amp;timeReport{
                Name:    "Time Sync Report",
                Time:    time.Now().UTC(),
                Servers: len(servers),
        }
        for _, server := range servers </span><span class="cov8" title="1">{
                preCall := time.Now().Round(time.Microsecond)
                rBytes, err := queryHostRecon(client, server, "hummingbirdtime")
                if err != nil </span><span class="cov8" title="1">{
                        report.Errors = append(report.Errors, fmt.Sprintf("%s: %s", server, err))
                        continue</span>
                }
                <span class="cov8" title="1">postCall := time.Now().Round(time.Microsecond)
                var rData map[string]time.Time
                if err := json.Unmarshal(rBytes, &amp;rData); err != nil </span><span class="cov0" title="0">{
                        report.Errors = append(report.Errors, fmt.Sprintf("%s: %s - %q", server, err, string(rBytes)))
                        continue</span>
                }
                <span class="cov8" title="1">if rData["time"].IsZero() </span><span class="cov0" title="0">{
                        report.Errors = append(report.Errors, fmt.Sprintf("%s: time was zeroed", server))
                        continue</span>
                }
                <span class="cov8" title="1">remoteTime := rData["time"].Round(time.Microsecond)
                if remoteTime.Before(preCall) || remoteTime.After(postCall) </span><span class="cov0" title="0">{
                        report.Errors = append(report.Errors, fmt.Sprintf(
                                "%s://%s:%d/recon/hummingbirdtime current time is %s but remote time is %s, differs by %.2f nsecs",
                                server.scheme,
                                server.ip,
                                server.port,
                                postCall.Format(time.StampMicro),
                                remoteTime.Format(time.StampMicro),
                                float64(postCall.Sub(remoteTime)),
                        ))
                }</span> else<span class="cov8" title="1"> {
                        report.Successes++
                }</span>
        }
        <span class="cov8" title="1">report.Pass = report.Successes == report.Servers
        return report</span>
}

type quarData struct {
        Accounts   int                       `json:"accounts"`
        Containers int                       `json:"containers"`
        Objects    int                       `json:"objects"`
        Policies   map[string]map[string]int `json:"policies"`
}

type quarReconStats struct {
        Accounts   map[string]int
        Containers map[string]int
        Objects    map[string]int
        Policies   map[string]map[string]int
}

func statsLine(tag string, stats map[string]int) string <span class="cov8" title="1">{
        low, high, total, reported, num_none := 0, 0, 0, 0, 0
        init := true
        for _, v := range stats </span><span class="cov8" title="1">{
                if init </span><span class="cov8" title="1">{
                        low, high = v, v
                        init = false
                }</span>
                <span class="cov8" title="1">if v &lt; low </span><span class="cov0" title="0">{
                        low = v
                }</span>
                <span class="cov8" title="1">if v &gt; high </span><span class="cov8" title="1">{
                        high = v
                }</span>
                <span class="cov8" title="1">reported++
                if v == -1 </span><span class="cov0" title="0">{
                        num_none++ // these might not be none- just zero. also, i dont think i care
                }</span> else<span class="cov8" title="1"> {
                        total += v
                }</span>
        }
        <span class="cov8" title="1">ave, pFail := float64(0), float64(0)
        if reported &gt; 0 </span><span class="cov8" title="1">{
                ave = float64(total) / float64(reported)
                pFail = float64(num_none) / float64(reported) * 100
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("[%s] low: %d, high: %d, avg: %.1f, total: %d, Failed: %.1f%%, no_result: %d, reported: %d",
                tag, low, high, ave, total, pFail, num_none, reported)</span>
}

func statsLineF(tag string, stats map[string]float64) string <span class="cov0" title="0">{
        low, high, total, reported, num_none := float64(0), float64(0), float64(0), int(0), int(0)
        init := true
        for _, v := range stats </span><span class="cov0" title="0">{
                if init </span><span class="cov0" title="0">{
                        low, high = v, v
                        init = false
                }</span>
                <span class="cov0" title="0">if v &lt; low </span><span class="cov0" title="0">{
                        low = v
                }</span>
                <span class="cov0" title="0">if v &gt; high </span><span class="cov0" title="0">{
                        high = v
                }</span>
                <span class="cov0" title="0">reported++
                if v == -1 </span><span class="cov0" title="0">{
                        num_none++ // these might not be none- just zero. also, i dont think i care
                }</span> else<span class="cov0" title="0"> {
                        total += v
                }</span>
        }
        <span class="cov0" title="0">ave, pFail := float64(0), float64(0)
        if reported &gt; 0 </span><span class="cov0" title="0">{
                ave = float64(total) / float64(reported)
                pFail = float64(num_none) / float64(reported) * 100
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("[%s] low: %.3f, high: %.3f, avg: %.3f, Failed: %.1f%%, no_result: %d, reported: %d",
                tag, low, high, ave, pFail, num_none, reported)</span>
}

type quarantineReport struct {
        Name      string
        Time      time.Time
        Pass      bool
        Servers   int
        Successes int
        Errors    []string
        Stats     *quarReconStats
}

func (r *quarantineReport) Passed() bool <span class="cov8" title="1">{
        return r.Pass
}</span>

func (r *quarantineReport) String() string <span class="cov8" title="1">{
        s := fmt.Sprintf(
                "[%s] %s\n",
                r.Time.Format("2006-01-02 15:04:05"),
                r.Name,
        )
        for _, e := range r.Errors </span><span class="cov0" title="0">{
                s += fmt.Sprintf("!! %s\n", e)
        }</span>
        <span class="cov8" title="1">s += statsLine("quarantined_account", r.Stats.Accounts) + "\n"
        s += statsLine("quarantined_container", r.Stats.Containers) + "\n"
        s += statsLine("quarantined_objects", r.Stats.Objects) + "\n"
        for pid, pmap := range r.Stats.Policies </span><span class="cov0" title="0">{
                s += statsLine(fmt.Sprintf("quarantined_objects_%s", pid), pmap) + "\n"
        }</span>
        <span class="cov8" title="1">return s</span>
}

func getQuarantineReport(client common.HTTPClient, servers []*ipPort) *quarantineReport <span class="cov8" title="1">{
        report := &amp;quarantineReport{
                Name:    "Quarantine Report",
                Time:    time.Now().UTC(),
                Servers: len(servers),
                Stats: &amp;quarReconStats{
                        Accounts:   map[string]int{},
                        Containers: map[string]int{},
                        Objects:    map[string]int{},
                        Policies:   map[string]map[string]int{},
                },
        }
        for _, server := range servers </span><span class="cov8" title="1">{
                rBytes, err := queryHostRecon(client, server, "quarantined")
                report.Stats.Accounts[serverId(server.ip, server.port)] = -1
                report.Stats.Containers[serverId(server.ip, server.port)] = -1
                report.Stats.Objects[serverId(server.ip, server.port)] = -1
                if err != nil </span><span class="cov0" title="0">{
                        report.Errors = append(report.Errors, fmt.Sprintf("%s: %s", server, err))
                        continue</span>
                }
                <span class="cov8" title="1">var rData quarData
                if err := json.Unmarshal(rBytes, &amp;rData); err != nil </span><span class="cov0" title="0">{
                        report.Errors = append(report.Errors, fmt.Sprintf("%s: %s - %q", server, err, string(rBytes)))
                        continue</span>
                }
                <span class="cov8" title="1">report.Stats.Accounts[serverId(server.ip, server.port)] = rData.Accounts
                report.Stats.Containers[serverId(server.ip, server.port)] = rData.Containers
                report.Stats.Objects[serverId(server.ip, server.port)] = rData.Objects
                for pIndex, v := range rData.Policies </span><span class="cov0" title="0">{
                        if _, ok := report.Stats.Policies[pIndex]; !ok </span><span class="cov0" title="0">{
                                report.Stats.Policies[pIndex] = map[string]int{}
                        }</span>
                        <span class="cov0" title="0">report.Stats.Policies[pIndex][serverId(server.ip, server.port)] = v["objects"]</span>
                }
                <span class="cov8" title="1">report.Successes++</span>
        }
        <span class="cov8" title="1">report.Pass = report.Successes == report.Servers
        return report</span>
}

type quarantineDetailReport struct {
        Name                        string
        Time                        time.Time
        Pass                        bool
        Servers                     int
        Successes                   int
        Errors                      []string
        TypeToServerToDeviceToItems map[string]map[string]map[string][]*quarantineDetailItem
}

func (r *quarantineDetailReport) Passed() bool <span class="cov8" title="1">{
        return r.Pass
}</span>

func (r *quarantineDetailReport) String() string <span class="cov8" title="1">{
        s := fmt.Sprintf(
                "[%s] %s\n",
                r.Time.Format("2006-01-02 15:04:05"),
                r.Name,
        )
        for _, e := range r.Errors </span><span class="cov0" title="0">{
                s += fmt.Sprintf("!! %s\n", e)
        }</span>
        <span class="cov8" title="1">s += fmt.Sprintf(
                "%d/%d hosts matched, %d error[s] while checking hosts.\n",
                r.Successes, r.Servers, len(r.Errors),
        )
        var types []string
        for typ := range r.TypeToServerToDeviceToItems </span><span class="cov8" title="1">{
                types = append(types, typ)
        }</span>
        <span class="cov8" title="1">sort.Strings(types)
        for _, typ := range types </span><span class="cov8" title="1">{
                s += fmt.Sprintln(typ)
                var servers []string
                for server := range r.TypeToServerToDeviceToItems[typ] </span><span class="cov8" title="1">{
                        servers = append(servers, server)
                }</span>
                <span class="cov8" title="1">sort.Strings(servers)
                for _, server := range servers </span><span class="cov8" title="1">{
                        s += fmt.Sprintln(" ", server)
                        var devices []string
                        for device := range r.TypeToServerToDeviceToItems[typ][server] </span><span class="cov8" title="1">{
                                devices = append(devices, device)
                        }</span>
                        <span class="cov8" title="1">sort.Strings(devices)
                        for _, device := range devices </span><span class="cov8" title="1">{
                                s += fmt.Sprintln("   ", device)
                                items := r.TypeToServerToDeviceToItems[typ][server][device]
                                sort.Slice(items, func(i, j int) bool </span><span class="cov8" title="1">{
                                        if items[i].NameOnDevice &lt; items[j].NameOnDevice </span><span class="cov8" title="1">{
                                                return true
                                        }</span>
                                        <span class="cov8" title="1">if items[i].NameOnDevice == items[j].NameOnDevice </span><span class="cov0" title="0">{
                                                if items[i].NameInURL &lt; items[j].NameInURL </span><span class="cov0" title="0">{
                                                        return true
                                                }</span>
                                        }
                                        <span class="cov8" title="1">return false</span>
                                })
                                <span class="cov8" title="1">for _, item := range items </span><span class="cov8" title="1">{
                                        s += fmt.Sprintln("     ", item.NameOnDevice, item.NameInURL)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return s</span>
}

type quarantineDetailItem struct {
        NameOnDevice string
        NameInURL    string
}

func getQuarantineDetailReport(client common.HTTPClient, servers []*ipPort) *quarantineDetailReport <span class="cov8" title="1">{
        report := &amp;quarantineDetailReport{
                Name:                        "Quarantine Detail Report",
                Time:                        time.Now().UTC(),
                Servers:                     len(servers),
                TypeToServerToDeviceToItems: map[string]map[string]map[string][]*quarantineDetailItem{},
        }
        for _, server := range servers </span><span class="cov8" title="1">{
                jsonBytes, err := queryHostRecon(client, server, "quarantineddetail")
                if err != nil </span><span class="cov0" title="0">{
                        report.Errors = append(report.Errors, fmt.Sprintf("%s: %s", server, err))
                        continue</span>
                }
                <span class="cov8" title="1">var serverReport map[string]map[string][]*quarantineDetailItem
                if err := json.Unmarshal(jsonBytes, &amp;serverReport); err != nil </span><span class="cov0" title="0">{
                        report.Errors = append(report.Errors, fmt.Sprintf("%s: %s - %q", server, err, string(jsonBytes)))
                        continue</span>
                }
                <span class="cov8" title="1">serverFmt := fmt.Sprintf("%s:%d", server.ip, server.port)
                for typ, deviceToItems := range serverReport </span><span class="cov8" title="1">{
                        for device, items := range deviceToItems </span><span class="cov8" title="1">{
                                if len(items) &gt; 0 </span><span class="cov8" title="1">{
                                        if report.TypeToServerToDeviceToItems[typ] == nil </span><span class="cov8" title="1">{
                                                report.TypeToServerToDeviceToItems[typ] = map[string]map[string][]*quarantineDetailItem{}
                                        }</span>
                                        <span class="cov8" title="1">if report.TypeToServerToDeviceToItems[typ][serverFmt] == nil </span><span class="cov8" title="1">{
                                                report.TypeToServerToDeviceToItems[typ][serverFmt] = map[string][]*quarantineDetailItem{}
                                        }</span>
                                        <span class="cov8" title="1">report.TypeToServerToDeviceToItems[typ][serverFmt][device] = items</span>
                                }
                        }
                }
                <span class="cov8" title="1">report.Successes++</span>
        }
        <span class="cov8" title="1">report.Pass = report.Successes == report.Servers
        return report</span>
}

type asyncReport struct {
        Name      string
        Time      time.Time
        Pass      bool
        Servers   int
        Successes int
        Errors    []string
        Stats     map[string]int
}

func (r *asyncReport) Passed() bool <span class="cov8" title="1">{
        return r.Pass
}</span>

func (r *asyncReport) String() string <span class="cov8" title="1">{
        s := fmt.Sprintf(
                "[%s] %s\n",
                r.Time.Format("2006-01-02 15:04:05"),
                r.Name,
        )
        for _, e := range r.Errors </span><span class="cov0" title="0">{
                s += fmt.Sprintf("!! %s\n", e)
        }</span>
        <span class="cov8" title="1">s += statsLine("async_pending", r.Stats) + "\n"
        return s</span>
}

func getAsyncReport(client common.HTTPClient, servers []*ipPort) *asyncReport <span class="cov8" title="1">{
        report := &amp;asyncReport{
                Name:    "Async Pending Report",
                Time:    time.Now().UTC(),
                Servers: len(servers),
                Stats:   map[string]int{},
        }
        for _, server := range servers </span><span class="cov8" title="1">{
                rBytes, err := queryHostRecon(client, server, "async")
                report.Stats[serverId(server.ip, server.port)] = -1
                if err != nil </span><span class="cov0" title="0">{
                        report.Errors = append(report.Errors, fmt.Sprintf("%s: %s", server, err))
                        continue</span>
                }
                <span class="cov8" title="1">var rData map[string]int
                if err := json.Unmarshal(rBytes, &amp;rData); err != nil </span><span class="cov0" title="0">{
                        report.Errors = append(report.Errors, fmt.Sprintf("%s: %s - %q", server, err, string(rBytes)))
                        continue</span>
                }
                <span class="cov8" title="1">report.Stats[serverId(server.ip, server.port)] = rData["async_pending"]
                report.Successes++</span>
        }
        <span class="cov8" title="1">report.Pass = report.Successes == report.Servers
        return report</span>
}

type replicationDurationReport struct {
        Name           string
        Time           time.Time
        Pass           bool
        Servers        int
        Successes      int
        Errors         []string
        Stats          map[string]float64
        TotalDriveZero int
}

func (r *replicationDurationReport) Passed() bool <span class="cov0" title="0">{
        return r.Pass
}</span>

func (r *replicationDurationReport) String() string <span class="cov0" title="0">{
        s := fmt.Sprintf(
                "[%s] %s\n",
                r.Time.Format("2006-01-02 15:04:05"),
                r.Name,
        )
        for _, e := range r.Errors </span><span class="cov0" title="0">{
                s += fmt.Sprintf("!! %s\n", e)
        }</span>
        <span class="cov0" title="0">s += statsLineF("replication_duration_secs", r.Stats) + "\n"
        s += fmt.Sprintf("Number of drives not completed a pass: %d\n", r.TotalDriveZero)
        return s</span>
}

func getReplicationDurationReport(client common.HTTPClient, servers []*ipPort) *replicationDurationReport <span class="cov0" title="0">{
        report := &amp;replicationDurationReport{
                Name:    "Replication Duration Report",
                Time:    time.Now().UTC(),
                Servers: len(servers),
                Stats:   map[string]float64{},
        }
        for _, server := range servers </span><span class="cov0" title="0">{
                data, err := queryHostReplication(client, server)
                if err != nil </span><span class="cov0" title="0">{
                        report.Errors = append(report.Errors, fmt.Sprintf("%s: %s", server, err))
                        continue</span>
                }
                <span class="cov0" title="0">totalDuration := time.Duration(0)
                totalSet := float64(0)
                for _, dStats := range data </span><span class="cov0" title="0">{
                        if dStats.LastPassDuration &gt; 0 </span><span class="cov0" title="0">{
                                totalDuration += dStats.LastPassDuration
                                totalSet++
                        }</span> else<span class="cov0" title="0"> {
                                report.TotalDriveZero++
                        }</span>
                }
                <span class="cov0" title="0">if totalSet &gt; 0 </span><span class="cov0" title="0">{
                        report.Stats[serverId(server.ip, server.port)] = totalDuration.Seconds() / totalSet
                }</span> else<span class="cov0" title="0"> {
                        report.Stats[serverId(server.ip, server.port)] = 0
                }</span>
                <span class="cov0" title="0">report.Successes++</span>
        }
        <span class="cov0" title="0">report.Pass = report.Successes == report.Servers
        return report</span>
}

type replicationPartsSecReport struct {
        Name           string
        Time           time.Time
        Pass           bool
        Servers        int
        Successes      int
        Errors         []string
        Warnings       []string
        Stats          map[string]float64
        DriveSpeeds    map[string]float64
        OverallAverage float64
        TotalDriveZero int
}

func (r *replicationPartsSecReport) Passed() bool <span class="cov0" title="0">{
        return r.Pass
}</span>

func (r *replicationPartsSecReport) String() string <span class="cov0" title="0">{
        s := fmt.Sprintf(
                "[%s] %s\n",
                r.Time.Format("2006-01-02 15:04:05"),
                r.Name,
        )
        for _, e := range r.Errors </span><span class="cov0" title="0">{
                s += fmt.Sprintf("!! %s\n", e)
        }</span>
        <span class="cov0" title="0">for _, w := range r.Warnings </span><span class="cov0" title="0">{
                s += fmt.Sprintf("! %s\n", w)
        }</span>
        <span class="cov0" title="0">s += statsLineF("replication_srv_parts_per_sec", r.Stats) + "\n"
        s += fmt.Sprintf("Number drives with no partitions completed: %d\n", r.TotalDriveZero)
        s += fmt.Sprintf("Cluster wide parts/sec: %.3f\n", r.OverallAverage)
        return s</span>
}

func getReplicationPartsSecReport(client common.HTTPClient, servers []*ipPort) *replicationPartsSecReport <span class="cov0" title="0">{
        report := &amp;replicationPartsSecReport{
                Name:        "Replication Partitions Per Second Report",
                Time:        time.Now().UTC(),
                Servers:     len(servers),
                Stats:       map[string]float64{},
                DriveSpeeds: map[string]float64{},
        }
        allDur := time.Duration(0)
        allPartsDone := int64(0)
        for _, server := range servers </span><span class="cov0" title="0">{
                report.Stats[serverId(server.ip, server.port)] = -1
                data, err := queryHostReplication(client, server)
                if err != nil </span><span class="cov0" title="0">{
                        report.Errors = append(report.Errors, fmt.Sprintf("%s: %s", server, err))
                        continue</span>
                }
                <span class="cov0" title="0">serverDuration := time.Duration(0)
                serverPartsDone := int64(0)
                for d, dStats := range data </span><span class="cov0" title="0">{
                        driveDur := dStats.LastPassFinishDate.Sub(dStats.PassStarted)
                        if dStats.LastPassFinishDate.IsZero() </span><span class="cov0" title="0">{
                                // is in middle of run
                                driveDur = time.Since(dStats.PassStarted)
                        }</span>
                        <span class="cov0" title="0">serverDuration += driveDur
                        serverPartsDone += dStats.PartitionsDone
                        allDur += driveDur
                        allPartsDone += dStats.PartitionsDone
                        if dStats.PartitionsTotal == 0 </span><span class="cov0" title="0">{
                                report.Warnings = append(report.Warnings, fmt.Sprintf("%s has no partitions\n", deviceId(server.ip, server.port, d)))
                        }</span> else<span class="cov0" title="0"> {
                                if dStats.PartitionsDone == 0 &amp;&amp; driveDur &gt; time.Hour </span><span class="cov0" title="0">{
                                        report.Warnings = append(report.Warnings, fmt.Sprintf("%s has no partitions processed\n", deviceId(server.ip, server.port, d)))
                                }</span>
                        }
                        <span class="cov0" title="0">report.DriveSpeeds[deviceId(server.ip, server.port, d)] = float64(dStats.PartitionsDone) / driveDur.Seconds()</span>
                }
                <span class="cov0" title="0">if serverPartsDone &gt; 0 </span><span class="cov0" title="0">{
                        report.Stats[serverId(server.ip, server.port)] = float64(serverPartsDone) / serverDuration.Seconds()
                }</span> else<span class="cov0" title="0"> {
                        report.Stats[serverId(server.ip, server.port)] = 0
                        report.TotalDriveZero++
                }</span>
                <span class="cov0" title="0">report.Successes++</span>
        }
        <span class="cov0" title="0">report.OverallAverage = float64(allPartsDone) / allDur.Seconds()
        if math.IsNaN(report.OverallAverage) </span><span class="cov0" title="0">{
                report.OverallAverage = 0
        }</span>
        <span class="cov0" title="0">for dId, speed := range report.DriveSpeeds </span><span class="cov0" title="0">{
                if speed &gt; 0 &amp;&amp; speed*2 &lt; report.OverallAverage </span><span class="cov0" title="0">{
                        report.Warnings = append(report.Warnings, fmt.Sprintf("%s @ %.3f parts/sec is %.2fx slower than cluster parts/sec: %.3f\n", dId, speed, report.OverallAverage/speed, report.OverallAverage))
                }</span>
        }
        <span class="cov0" title="0">report.Pass = report.Successes == report.Servers
        return report</span>
}

type replicationCanceledReport struct {
        Name      string
        Time      time.Time
        Pass      bool
        Servers   int
        Successes int
        Errors    []string
        Warnings  []string
        Stats     map[string]int
}

func (r *replicationCanceledReport) Passed() bool <span class="cov0" title="0">{
        return r.Pass
}</span>

func (r *replicationCanceledReport) String() string <span class="cov0" title="0">{
        s := fmt.Sprintf(
                "[%s] %s\n",
                r.Time.Format("2006-01-02 15:04:05"),
                r.Name,
        )
        for _, e := range r.Errors </span><span class="cov0" title="0">{
                s += fmt.Sprintf("!! %s\n", e)
        }</span>
        <span class="cov0" title="0">for _, w := range r.Warnings </span><span class="cov0" title="0">{
                s += fmt.Sprintf("! %s\n", w)
        }</span>
        <span class="cov0" title="0">s += statsLine("replication_device_cancelations", r.Stats) + "\n"
        return s</span>
}

func getReplicationCanceledReport(client common.HTTPClient, servers []*ipPort) *replicationCanceledReport <span class="cov0" title="0">{
        report := &amp;replicationCanceledReport{
                Name:    "Stalled Replicators Report",
                Time:    time.Now().UTC(),
                Servers: len(servers),
                Stats:   map[string]int{},
        }
        for _, server := range servers </span><span class="cov0" title="0">{
                data, err := queryHostReplication(client, server)
                if err != nil </span><span class="cov0" title="0">{
                        report.Errors = append(report.Errors, fmt.Sprintf("%s: %s", server, err))
                        continue</span>
                }
                <span class="cov0" title="0">for d, dStats := range data </span><span class="cov0" title="0">{
                        report.Stats[deviceId(server.ip, server.port, d)] = int(dStats.CancelCount)
                        if dStats.CancelCount &gt; 0 </span><span class="cov0" title="0">{
                                report.Warnings = append(report.Warnings, fmt.Sprintf("%s has had to restart its replicator %d times.\n", deviceId(server.ip, server.port, d), dStats.CancelCount))
                        }</span>
                }
                <span class="cov0" title="0">report.Successes++</span>
        }
        <span class="cov0" title="0">report.Pass = report.Successes == report.Servers
        return report</span>
}

type ringActionReport struct {
        Name            string
        Time            time.Time
        Pass            bool
        Errors          []string
        Warnings        []string
        AccountReport   []*ringLogEntry
        ContainerReport []*ringLogEntry
        ObjectReports   map[int][]*ringLogEntry
}

func (r *ringActionReport) Passed() bool <span class="cov0" title="0">{
        return r.Pass
}</span>

func (r *ringActionReport) String() string <span class="cov0" title="0">{
        s := fmt.Sprintf(
                "[%s] %s\n",
                r.Time.Format("2006-01-02 15:04:05"),
                r.Name,
        )
        for _, e := range r.Errors </span><span class="cov0" title="0">{
                s += fmt.Sprintf("!! %s\n", e)
        }</span>
        <span class="cov0" title="0">for _, w := range r.Warnings </span><span class="cov0" title="0">{
                s += fmt.Sprintf("! %s\n", w)
        }</span>
        <span class="cov0" title="0">if len(r.AccountReport) &gt; 0 </span><span class="cov0" title="0">{
                s += "Account Ring:\n"
                i := 0
                if len(r.AccountReport) &gt; 10 </span><span class="cov0" title="0">{
                        i = len(r.AccountReport) - 10
                        s += fmt.Sprintf("    %d older entries; use -json for full report\n", len(r.AccountReport)-10)
                }</span>
                <span class="cov0" title="0">for _, entry := range r.AccountReport[i:] </span><span class="cov0" title="0">{
                        s += fmt.Sprintf("    %s %s\n", entry.Time.Format("2006-01-02 15:04"), entry.Reason)
                }</span>
        }
        <span class="cov0" title="0">if len(r.ContainerReport) &gt; 0 </span><span class="cov0" title="0">{
                s += "Container Ring:\n"
                i := 0
                if len(r.ContainerReport) &gt; 10 </span><span class="cov0" title="0">{
                        i = len(r.ContainerReport) - 10
                        s += fmt.Sprintf("    %d older entries; use -json for full report\n", len(r.ContainerReport)-10)
                }</span>
                <span class="cov0" title="0">for _, entry := range r.ContainerReport[i:] </span><span class="cov0" title="0">{
                        s += fmt.Sprintf("    %s %s\n", entry.Time.Format("2006-01-02 15:04"), entry.Reason)
                }</span>
        }
        <span class="cov0" title="0">var policies []int
        for policy := range r.ObjectReports </span><span class="cov0" title="0">{
                policies = append(policies, policy)
        }</span>
        <span class="cov0" title="0">sort.Ints(policies)
        for policy := range policies </span><span class="cov0" title="0">{
                if len(r.ObjectReports[policy]) &gt; 0 </span><span class="cov0" title="0">{
                        s += fmt.Sprintf("Object Ring %d:\n", policy)
                        i := 0
                        if len(r.ObjectReports[policy]) &gt; 10 </span><span class="cov0" title="0">{
                                i = len(r.ObjectReports[policy]) - 10
                                s += fmt.Sprintf("    %d older entries; use -json for full report\n", len(r.ObjectReports[policy])-10)
                        }</span>
                        <span class="cov0" title="0">for _, entry := range r.ObjectReports[policy][i:] </span><span class="cov0" title="0">{
                                s += fmt.Sprintf("    %s %s\n", entry.Time.Format("2006-01-02 15:04"), entry.Reason)
                        }</span>
                }
        }
        <span class="cov0" title="0">return s</span>
}

func getRingActionReport(flags *flag.FlagSet) *ringActionReport <span class="cov0" title="0">{
        report := &amp;ringActionReport{
                Name:          "Ring Action Report",
                Time:          time.Now().UTC(),
                ObjectReports: map[int][]*ringLogEntry{},
        }
        serverconf, err := getAndrewdConf(flags)
        if err != nil </span><span class="cov0" title="0">{
                report.Errors = append(report.Errors, err.Error())
                return report
        }</span>
        <span class="cov0" title="0">db, err := newDB(serverconf, "")
        if err != nil </span><span class="cov0" title="0">{
                report.Errors = append(report.Errors, err.Error())
                return report
        }</span>
        <span class="cov0" title="0">report.AccountReport, err = db.ringLogs("account", 0)
        if err != nil </span><span class="cov0" title="0">{
                report.Errors = append(report.Errors, err.Error())
        }</span>
        <span class="cov0" title="0">report.ContainerReport, err = db.ringLogs("container", 0)
        if err != nil </span><span class="cov0" title="0">{
                report.Errors = append(report.Errors, err.Error())
        }</span>
        <span class="cov0" title="0">if policies, err := conf.GetPolicies(); err != nil </span><span class="cov0" title="0">{
                report.Errors = append(report.Errors, err.Error())
        }</span> else<span class="cov0" title="0"> {
                for _, policy := range policies </span><span class="cov0" title="0">{
                        report.ObjectReports[policy.Index], err = db.ringLogs("object", policy.Index)
                        if err != nil </span><span class="cov0" title="0">{
                                report.Errors = append(report.Errors, err.Error())
                        }</span>
                }
        }
        <span class="cov0" title="0">report.Pass = len(report.Errors) == 0
        return report</span>
}

func getAndrewdConf(flags *flag.FlagSet) (*conf.Config, error) <span class="cov0" title="0">{
        configFile := flags.Lookup("c").Value.(flag.Getter).Get().(string)
        if configs, err := conf.LoadConfigs(configFile); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Error finding configs: %v", err)
        }</span> else<span class="cov0" title="0"> if len(configs) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("please supply single andrewd config")
        }</span> else<span class="cov0" title="0"> {
                return &amp;configs[0], nil
        }</span>
}

func ReconClient(flags *flag.FlagSet, cnf srv.ConfigLoader) bool <span class="cov0" title="0">{
        prefix, suffix := getAffixes()
        oring, err := ring.GetRing("object", prefix, suffix, 0)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Unrecoverable error on recon: %v\n", err)
                return false
        }</span>
        <span class="cov0" title="0">transport := &amp;http.Transport{
                MaxIdleConnsPerHost: 100,
                MaxIdleConns:        0,
        }
        certFile := flags.Lookup("certfile").Value.(flag.Getter).Get().(string)
        keyFile := flags.Lookup("keyfile").Value.(flag.Getter).Get().(string)
        if certFile != "" &amp;&amp; keyFile != "" </span><span class="cov0" title="0">{
                tlsConf, err := common.NewClientTLSConfig(certFile, keyFile)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error getting TLS config: %v\n", err)
                        return false
                }</span>
                <span class="cov0" title="0">transport.TLSClientConfig = tlsConf
                if err = http2.ConfigureTransport(transport); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error setting up http2: %v\n", err)
                        return false
                }</span>
        }
        // TODO: Do we want to trace requests from this client?
        <span class="cov0" title="0">client := &amp;http.Client{Timeout: 10 * time.Second, Transport: transport}
        activeServerMap := make(map[string]*ipPort)
        for _, dev := range oring.AllDevices() </span><span class="cov0" title="0">{
                if dev == nil || dev.Weight &lt; 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">sId := serverId(dev.Ip, dev.Port)
                if _, ok := activeServerMap[sId]; !ok </span><span class="cov0" title="0">{
                        activeServerMap[sId] = &amp;ipPort{ip: dev.Ip, port: dev.Port, scheme: dev.Scheme, replicationPort: dev.ReplicationPort}
                }</span>
        }
        <span class="cov0" title="0">activeServers := make([]*ipPort, 0, len(activeServerMap))
        for _, server := range activeServerMap </span><span class="cov0" title="0">{
                activeServers = append(activeServers, server)
        }</span>
        <span class="cov0" title="0">var reports []passable
        if flags.Lookup("progress").Value.(flag.Getter).Get().(bool) </span><span class="cov0" title="0">{
                reports = append(reports, getProgressReport(flags))
        }</span>
        <span class="cov0" title="0">if flags.Lookup("md5").Value.(flag.Getter).Get().(bool) </span><span class="cov0" title="0">{
                reports = append(reports, getRingMD5Report(client, activeServers, nil))
                reports = append(reports, getMainConfMD5Report(client, activeServers))
                reports = append(reports, getHummingbirdMD5Report(client, activeServers))
        }</span>
        <span class="cov0" title="0">if flags.Lookup("time").Value.(flag.Getter).Get().(bool) </span><span class="cov0" title="0">{
                reports = append(reports, getTimeReport(client, activeServers))
        }</span>
        <span class="cov0" title="0">if flags.Lookup("q").Value.(flag.Getter).Get().(bool) </span><span class="cov0" title="0">{
                reports = append(reports, getQuarantineReport(client, activeServers))
        }</span>
        <span class="cov0" title="0">if flags.Lookup("qd").Value.(flag.Getter).Get().(bool) </span><span class="cov0" title="0">{
                reports = append(reports, getQuarantineDetailReport(client, activeServers))
        }</span>
        <span class="cov0" title="0">if flags.Lookup("a").Value.(flag.Getter).Get().(bool) </span><span class="cov0" title="0">{
                reports = append(reports, getAsyncReport(client, activeServers))
        }</span>
        <span class="cov0" title="0">if flags.Lookup("rd").Value.(flag.Getter).Get().(bool) </span><span class="cov0" title="0">{
                reports = append(reports, getReplicationDurationReport(client, activeServers))
        }</span>
        <span class="cov0" title="0">if flags.Lookup("rp").Value.(flag.Getter).Get().(bool) </span><span class="cov0" title="0">{
                reports = append(reports, getReplicationPartsSecReport(client, activeServers))
        }</span>
        <span class="cov0" title="0">if flags.Lookup("rc").Value.(flag.Getter).Get().(bool) </span><span class="cov0" title="0">{
                reports = append(reports, getReplicationCanceledReport(client, activeServers))
        }</span>
        <span class="cov0" title="0">if flags.Lookup("d").Value.(flag.Getter).Get().(bool) </span><span class="cov0" title="0">{
                reports = append(reports, getDispersionReport(flags))
        }</span>
        <span class="cov0" title="0">if flags.Lookup("ds").Value.(flag.Getter).Get().(bool) </span>{<span class="cov0" title="0">
                // TODO: reports = append(reports, getDriveReport(flags))
        }</span>
        <span class="cov0" title="0">if flags.Lookup("rar").Value.(flag.Getter).Get().(bool) </span><span class="cov0" title="0">{
                reports = append(reports, getRingActionReport(flags))
        }</span>
        <span class="cov0" title="0">if len(reports) == 0 </span><span class="cov0" title="0">{
                flags.Usage()
        }</span>
        <span class="cov0" title="0">allPassed := true
        for _, report := range reports </span><span class="cov0" title="0">{
                if flags.Lookup("json").Value.(flag.Getter).Get().(bool) </span><span class="cov0" title="0">{
                        if byts, err := json.MarshalIndent(report, "", "    "); err != nil </span><span class="cov0" title="0">{
                                fmt.Println(err)
                                return false
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println(string(byts))
                        }</span>
                } else<span class="cov0" title="0"> {
                        fmt.Print(report)
                }</span>
                <span class="cov0" title="0">allPassed = allPassed &amp;&amp; report.Passed()</span>
        }
        <span class="cov0" title="0">return allPassed</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">package tools

// In /etc/hummingbird/andrewd-server.conf:
// [replication]
// jobs_per_device = 5      # max jobs per device
// minimum_pass_time = 60   # seconds each pass needs to take, at a minimum
// report_interval = 600    # seconds between progress reports
// db_poll_interval = 10    # seconds between database polls

import (
        "fmt"
        "sync"
        "sync/atomic"
        "time"

        "github.com/troubling/hummingbird/accountserver"
        "github.com/troubling/hummingbird/common/ring"
        "github.com/troubling/hummingbird/containerserver"
        "github.com/troubling/hummingbird/objectserver"
        "go.uber.org/zap"
)

type replication struct {
        aa              *AutoAdmin
        jobsPerDevice   int
        minimumPassTime time.Duration
        reportInterval  time.Duration
        dbPollInterval  time.Duration
}

func newReplication(aa *AutoAdmin) *replication <span class="cov0" title="0">{
        r := &amp;replication{
                aa:              aa,
                jobsPerDevice:   int(aa.serverconf.GetInt("replication", "jobs_per_device", 5)),
                minimumPassTime: time.Duration(aa.serverconf.GetInt("replication", "minimum_pass_time", 60)) * time.Second,
                reportInterval:  time.Duration(aa.serverconf.GetInt("replication", "report_interval", 600)) * time.Second,
                dbPollInterval:  time.Duration(aa.serverconf.GetInt("replication", "db_poll_interval", 10)) * time.Second,
        }
        return r
}</span>

func (r *replication) runForever() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                sleepFor := r.runOnce()
                if sleepFor &lt; 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">time.Sleep(sleepFor)</span>
        }
}

type replicationContext struct {
        start           time.Time
        logger          *zap.Logger
        wg              sync.WaitGroup
        cancel          chan struct{}
        progressDone    chan struct{}
        countLeft       int64
        countDone       int64
        ipDevsInUseLock sync.Mutex
        ipDevsInUse     map[string]int
}

func (r *replication) runOnce() time.Duration <span class="cov0" title="0">{
        ctx := &amp;replicationContext{
                start:        time.Now(),
                logger:       r.aa.logger.With(zap.String("process", "replication")),
                cancel:       make(chan struct{}),
                progressDone: make(chan struct{}),
        }
        ctx.logger.Debug("starting pass")
        if err := r.aa.db.startProcessPass("replication", "", 0); err != nil </span><span class="cov0" title="0">{
                ctx.logger.Error("startProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">ctx.ipDevsInUse = map[string]int{}
        go r.progress(ctx)
        for </span><span class="cov0" title="0">{
                // We gather jobs from the db and keep trying to have them handled
                // until there are no more left or the ones left have all been requeued
                // due to errors and shouldn't be retried until next pass.
                dbQRs, err := r.aa.db.queuedReplications("", -1, "")
                if err != nil </span><span class="cov0" title="0">{
                        ctx.logger.Error("queuedReplications", zap.Error(err))
                        break</span>
                }
                <span class="cov0" title="0">qrs := make([]*queuedReplication, 0, len(dbQRs))
                now := time.Now()
                for _, qr := range dbQRs </span><span class="cov0" title="0">{
                        // The After(now) is just to catch anything that queued with a
                        // strange time; it'll get reset to a regular time later on with a
                        // updateQueuedReplication call in handleQueuedReplication/runJob.
                        if qr.updated.Before(ctx.start) || qr.updated.After(now) </span><span class="cov0" title="0">{
                                qrs = append(qrs, qr)
                        }</span>
                }
                <span class="cov0" title="0">if len(qrs) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">atomic.StoreInt64(&amp;ctx.countLeft, int64(len(qrs)))
                for _, qr := range qrs </span><span class="cov0" title="0">{
                        r.handleQueuedReplication(ctx, qr)
                }</span>
                <span class="cov0" title="0">time.Sleep(r.dbPollInterval)</span>
        }
        <span class="cov0" title="0">ctx.wg.Wait()
        close(ctx.cancel)
        &lt;-ctx.progressDone
        sleepFor := time.Until(ctx.start.Add(r.minimumPassTime))
        if sleepFor &lt; 0 </span><span class="cov0" title="0">{
                sleepFor = 0
        }</span>
        <span class="cov0" title="0">ctx.logger.Debug("pass complete")
        if err := r.aa.db.progressProcessPass("replication", "", 0, fmt.Sprintf("%d jobs done", ctx.countDone)); err != nil </span><span class="cov0" title="0">{
                ctx.logger.Error("progressProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">if err := r.aa.db.completeProcessPass("replication", "", 0); err != nil </span><span class="cov0" title="0">{
                ctx.logger.Error("completeProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">return sleepFor</span>
}

func (r *replication) progress(ctx *replicationContext) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.cancel:<span class="cov0" title="0">
                        close(ctx.progressDone)
                        return</span>
                case &lt;-time.After(r.reportInterval):<span class="cov0" title="0">
                        activeDevs := 0
                        ctx.ipDevsInUseLock.Lock()
                        for _, count := range ctx.ipDevsInUse </span><span class="cov0" title="0">{
                                if count &gt; 0 </span><span class="cov0" title="0">{
                                        activeDevs++
                                }</span>
                        }
                        <span class="cov0" title="0">ctx.ipDevsInUseLock.Unlock()
                        countLeft := atomic.LoadInt64(&amp;ctx.countLeft)
                        countDone := atomic.LoadInt64(&amp;ctx.countDone)
                        var eta time.Duration
                        if countDone &gt; 0 </span><span class="cov0" title="0">{
                                eta = time.Duration(int64(time.Since(ctx.start)) / countDone * countLeft)
                        }</span>
                        <span class="cov0" title="0">ctx.logger.Debug("progress", zap.Int64("jobs done", countDone), zap.Int64("jobs left", countLeft), zap.Int("active devices", activeDevs), zap.String("eta", eta.String()))
                        if err := r.aa.db.progressProcessPass("replication", "", 0, fmt.Sprintf("%d jobs done, %d jobs left, %d active devices, %s eta", countDone, countLeft, activeDevs, eta)); err != nil </span><span class="cov0" title="0">{
                                ctx.logger.Error("progressProcessPass", zap.Error(err))
                        }</span>
                }
        }
}

func (r *replication) handleQueuedReplication(ctx *replicationContext, qr *queuedReplication) <span class="cov0" title="0">{
        logger := ctx.logger.With(zap.Time("queued", qr.created), zap.String("type", qr.typ), zap.Int("policy", qr.policy), zap.Int("partition", qr.partition), zap.String("reason", qr.reason), zap.Int("from device", qr.fromDeviceID), zap.Int("to device", qr.toDeviceID))
        logger.Debug("trying to handle")
        ryng, _ := getRing("", qr.typ, qr.policy)
        if qr.toDeviceID &lt; 0 </span><span class="cov0" title="0">{
                logger.Error("programming error; the to-device is invalid")
                return
        }</span>
        <span class="cov0" title="0">toDev := ryng.AllDevices()[qr.toDeviceID]
        if toDev != nil &amp;&amp; !toDev.Active() </span><span class="cov0" title="0">{
                toDev = nil
        }</span>
        <span class="cov0" title="0">if toDev == nil </span><span class="cov0" title="0">{
                logger.Debug("the to-device was removed from the ring since it had been queued")
                if err := r.aa.db.clearQueuedReplication(qr); err != nil </span><span class="cov0" title="0">{
                        logger.Error("clearQueuedReplication", zap.Error(err))
                }</span>
        }
        <span class="cov0" title="0">var fromDev *ring.Device
        if qr.fromDeviceID &gt;= 0 </span><span class="cov0" title="0">{
                fromDev = ryng.AllDevices()[qr.fromDeviceID]
                if fromDev != nil &amp;&amp; !fromDev.Active() </span><span class="cov0" title="0">{
                        fromDev = nil
                }</span>
        }
        <span class="cov0" title="0">ctx.wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer ctx.wg.Done()
                if fromDev != nil </span><span class="cov0" title="0">{
                        r.runJob(ctx, logger, qr, fromDev, toDev)
                }</span> else<span class="cov0" title="0"> {
                        for _, fromDev := range ryng.GetNodes(uint64(qr.partition)) </span><span class="cov0" title="0">{
                                if fromDev.Id == toDev.Id </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">if r.runJob(ctx, logger, qr, fromDev, toDev) </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                }
        }()
}

func (r *replication) runJob(ctx *replicationContext, logger *zap.Logger, qr *queuedReplication, fromDev, toDev *ring.Device) bool <span class="cov0" title="0">{
        fromIPDevice := fmt.Sprintf("%s/%s", fromDev.Ip, fromDev.Device)
        toIPDevice := fmt.Sprintf("%s/%s", toDev.Ip, toDev.Device)
        ctx.ipDevsInUseLock.Lock()
        if ctx.ipDevsInUse[fromIPDevice] &gt;= r.jobsPerDevice </span><span class="cov0" title="0">{
                ctx.ipDevsInUseLock.Unlock()
                logger.Debug("skipping as from-device is already at maximum usage")
                return false
        }</span>
        <span class="cov0" title="0">if ctx.ipDevsInUse[toIPDevice] &gt;= r.jobsPerDevice </span><span class="cov0" title="0">{
                ctx.ipDevsInUseLock.Unlock()
                logger.Debug("skipping as to-device is already at maximum usage")
                return false
        }</span>
        <span class="cov0" title="0">ctx.ipDevsInUse[fromIPDevice]++
        ctx.ipDevsInUse[toIPDevice]++
        ctx.ipDevsInUseLock.Unlock()
        logger.Debug("starting job", zap.Int("job from device", fromDev.Id), zap.Int("job to device", toDev.Id))
        // sends this to the back of the queue in case of future retries
        if err := r.aa.db.updateQueuedReplication(qr); err != nil </span><span class="cov0" title="0">{
                logger.Error("updateQueuedReplication", zap.Error(err))
        }</span>
        <span class="cov0" title="0">var msg string
        var success bool
        switch qr.typ </span>{
        case "account":<span class="cov0" title="0">
                msg, success = accountserver.SendPriRepJob(
                        &amp;accountserver.PriorityRepJob{
                                Partition:  uint64(qr.partition),
                                FromDevice: fromDev,
                                ToDevice:   toDev,
                        },
                        r.aa.client,
                )</span>
        case "container":<span class="cov0" title="0">
                msg, success = containerserver.SendPriRepJob(
                        &amp;containerserver.PriorityRepJob{
                                Partition:  uint64(qr.partition),
                                FromDevice: fromDev,
                                ToDevice:   toDev,
                        },
                        r.aa.client,
                )</span>
        case "object":<span class="cov0" title="0">
                msg, success = objectserver.SendPriRepJob(
                        &amp;objectserver.PriorityRepJob{
                                Partition:  uint64(qr.partition),
                                FromDevice: fromDev,
                                ToDevice:   toDev,
                                Policy:     qr.policy,
                        },
                        r.aa.client,
                )</span>
        }
        <span class="cov0" title="0">logger.Debug(msg)
        if success </span><span class="cov0" title="0">{
                if err := r.aa.db.clearQueuedReplication(qr); err != nil </span><span class="cov0" title="0">{
                        logger.Error("clearQueuedReplication", zap.Error(err))
                }</span>
                <span class="cov0" title="0">ctx.ipDevsInUseLock.Lock()
                ctx.ipDevsInUse[fromIPDevice]--
                ctx.ipDevsInUse[toIPDevice]--
                ctx.ipDevsInUseLock.Unlock()
                atomic.AddInt64(&amp;ctx.countDone, 1)</span>
        } else<span class="cov0" title="0"> {
                ctx.ipDevsInUseLock.Lock()
                ctx.ipDevsInUse[fromIPDevice]--
                ctx.ipDevsInUse[toIPDevice]--
                ctx.ipDevsInUseLock.Unlock()
        }</span>
        <span class="cov0" title="0">return success</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">//  Copyright (c) 2017 Rackspace
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//  implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package tools

import (
        "bufio"
        "encoding/json"
        "flag"
        "fmt"
        "os"
        "regexp"
        "strconv"
        "time"

        "github.com/gholt/brimtext"
        "github.com/troubling/hummingbird/common/ring"
)

func PrintDevs(devs []*ring.RingBuilderDevice) <span class="cov0" title="0">{
        data := make([][]string, 0)
        data = append(data, []string{"ID", "REGION", "ZONE", "SCHEME", "IP ADDRESS", "PORT", "REPLICATION IP", "REPLICATION PORT", "NAME", "WEIGHT", "PARTITIONS", "META"})
        data = append(data, nil)
        for _, dev := range devs </span><span class="cov0" title="0">{
                if dev != nil </span><span class="cov0" title="0">{
                        data = append(data, []string{strconv.FormatInt(dev.Id, 10), strconv.FormatInt(dev.Region, 10), strconv.FormatInt(dev.Zone, 10), dev.Scheme, dev.Ip, strconv.FormatInt(dev.Port, 10), dev.ReplicationIp, strconv.FormatInt(dev.ReplicationPort, 10), dev.Device, strconv.FormatFloat(dev.Weight, 'f', -1, 64), strconv.FormatInt(dev.Parts, 10), dev.Meta})
                }</span>
        }
        <span class="cov0" title="0">fmt.Println(brimtext.Align(data, brimtext.NewSimpleAlignOptions()))</span>
}

func RingBuildCmd(flags *flag.FlagSet) <span class="cov0" title="0">{
        args := flags.Args()
        if len(args) &lt; 1 || args[0] == "help" </span><span class="cov0" title="0">{
                flags.Usage()
                return
        }</span>
        <span class="cov0" title="0">debug := flags.Lookup("debug").Value.String() == "true"
        jsonOut := flags.Lookup("json").Value.String() == "true"
        pth := args[0]
        cmd := ""
        if len(args) == 1 </span><span class="cov0" title="0">{
                cmd = "info"
        }</span> else<span class="cov0" title="0"> {
                cmd = args[1]
        }</span>
        <span class="cov0" title="0">builderLock, err := ring.LockBuilderPath(pth)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer builderLock.Close()
        switch cmd </span>{
        case "create":<span class="cov0" title="0">
                if len(args) &lt; 5 </span><span class="cov0" title="0">{
                        flags.Usage()
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">partPower, err := strconv.Atoi(args[2])
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">replicas, err := strconv.ParseFloat(args[3], 64)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">minPartHours, err := strconv.Atoi(args[4])
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">err = ring.CreateRing(pth, partPower, replicas, minPartHours, debug)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>

        case "rebalance":<span class="cov0" title="0">
                rebalanceFlags := flag.NewFlagSet("rebalance", flag.ExitOnError)
                dryrun := rebalanceFlags.Bool("dryrun", false, "A dry run will rebalance but not save the results.")
                if err := rebalanceFlags.Parse(args[2:]); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">_, _, _, err := ring.Rebalance(pth, debug, *dryrun, false)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">return</span>

        case "pretend_min_part_hours_passed":<span class="cov0" title="0">
                ring.PretendMinPartHoursPassed(pth)
                return</span>

        case "search":<span class="cov0" title="0">
                searchFlags := flag.NewFlagSet("search", flag.ExitOnError)
                region := searchFlags.Int64("region", -1, "Device region.")
                zone := searchFlags.Int64("zone", -1, "Device zone.")
                ip := searchFlags.String("ip", "", "Device ip address.")
                port := searchFlags.Int64("port", -1, "Device port.")
                repIp := searchFlags.String("replication-ip", "", "Device replication address.")
                repPort := searchFlags.Int64("replication-port", -1, "Device replication port.")
                device := searchFlags.String("device", "", "Device name.")
                weight := searchFlags.Float64("weight", -1.0, "Device weight.")
                meta := searchFlags.String("meta", "", "Metadata.")
                scheme := searchFlags.String("scheme", "", "URI scheme(http/https).")
                if err := searchFlags.Parse(args[2:]); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">devs, err := ring.Search(pth, *region, *zone, *ip, *port, *repIp, *repPort, *device, *weight, *meta, *scheme)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if jsonOut </span><span class="cov0" title="0">{
                        b, err := json.Marshal(devs)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println(err)
                                os.Exit(1)
                        }</span>
                        <span class="cov0" title="0">os.Stdout.Write(b)
                        os.Stdout.Write([]byte("\n"))</span>
                } else<span class="cov0" title="0"> {
                        if len(devs) == 0 </span><span class="cov0" title="0">{
                                fmt.Println("No matching devices found.")
                                return
                        }</span>
                        <span class="cov0" title="0">PrintDevs(devs)</span>
                }
                <span class="cov0" title="0">return</span>

        case "set_info":<span class="cov0" title="0">
                changeFlags := flag.NewFlagSet("search", flag.ExitOnError)
                region := changeFlags.Int64("region", -1, "Device region.")
                zone := changeFlags.Int64("zone", -1, "Device zone.")
                ip := changeFlags.String("ip", "", "Device ip address.")
                port := changeFlags.Int64("port", -1, "Device port.")
                repIp := changeFlags.String("replication-ip", "", "Device replication address.")
                repPort := changeFlags.Int64("replication-port", -1, "Device replication port.")
                device := changeFlags.String("device", "", "Device name.")
                weight := changeFlags.Float64("weight", -1.0, "Device weight.")
                meta := changeFlags.String("meta", "", "Metadata.")
                scheme := changeFlags.String("scheme", "", "URI scheme(http/https).")
                yes := changeFlags.Bool("yes", false, "Force yes.")
                newScheme := changeFlags.String("change-scheme", "", "New URI scheme(http/https).")
                newIp := changeFlags.String("change-ip", "", "New ip address.")
                newPort := changeFlags.Int64("change-port", -1, "New port.")
                newRepIp := changeFlags.String("change-replication-ip", "", "New replication ip address.")
                newRepPort := changeFlags.Int64("change-replication-port", -1, "New replication port.")
                newDevice := changeFlags.String("change-device", "", "New device name.")
                newMeta := changeFlags.String("change-meta", "", "New meta data.")
                if err := changeFlags.Parse(args[2:]); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">devs, err := ring.Search(pth, *region, *zone, *ip, *port, *repIp, *repPort, *device, *weight, *meta, *scheme)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if len(devs) == 0 </span><span class="cov0" title="0">{
                        fmt.Println("No matching devices found.")
                        return
                }</span> else<span class="cov0" title="0"> {
                        reader := bufio.NewReader(os.Stdin)
                        fmt.Println("Search matched the following devices:")
                        PrintDevs(devs)
                        if !*yes </span><span class="cov0" title="0">{
                                fmt.Printf("Are you sure you want to update the info for these %d devices (y/n)? ", len(devs))
                                resp, err := reader.ReadString('\n')
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Println(err)
                                        os.Exit(1)
                                }</span>
                                <span class="cov0" title="0">if resp[0] != 'y' &amp;&amp; resp[0] != 'Y' </span><span class="cov0" title="0">{
                                        fmt.Println("No devices updated.")
                                        return
                                }</span>
                        }
                        <span class="cov0" title="0">err := ring.SetInfo(pth, devs, *newIp, *newPort, *newRepIp, *newRepPort, *newDevice, *newMeta, *newScheme)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println(err)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("Devices updated successfully.")
                        }</span>
                }

        case "set_weight":<span class="cov0" title="0">
                weightFlags := flag.NewFlagSet("set_weight", flag.ExitOnError)
                region := weightFlags.Int64("region", -1, "Device region.")
                zone := weightFlags.Int64("zone", -1, "Device zone.")
                scheme := weightFlags.String("scheme", "", "URI scheme(http/https)")
                ip := weightFlags.String("ip", "", "Device ip address.")
                port := weightFlags.Int64("port", -1, "Device port.")
                repIp := weightFlags.String("replication-ip", "", "Device replication address.")
                repPort := weightFlags.Int64("replication-port", -1, "Device replication port.")
                device := weightFlags.String("device", "", "Device name.")
                weight := weightFlags.Float64("weight", -1.0, "Device weight.")
                meta := weightFlags.String("meta", "", "Metadata.")
                yes := weightFlags.Bool("yes", false, "Force yes.")
                if err := weightFlags.Parse(args[2:]); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">args := weightFlags.Args()
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        weightFlags.Usage()
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">newWeight, err := strconv.ParseFloat(args[0], 64)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">devs, err := ring.Search(pth, *region, *zone, *ip, *port, *repIp, *repPort, *device, *weight, *meta, *scheme)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if len(devs) == 0 </span><span class="cov0" title="0">{
                        fmt.Println("No matching devices found.")
                        return
                }</span> else<span class="cov0" title="0"> {
                        reader := bufio.NewReader(os.Stdin)
                        fmt.Println("Search matched the following devices:")
                        PrintDevs(devs)
                        if !*yes </span><span class="cov0" title="0">{
                                fmt.Printf("Are you sure you want to update the weight to %.2f for these %d devices (y/n)? ", newWeight, len(devs))
                                resp, err := reader.ReadString('\n')
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Println(err)
                                        os.Exit(1)
                                }</span>
                                <span class="cov0" title="0">if resp[0] != 'y' &amp;&amp; resp[0] != 'Y' </span><span class="cov0" title="0">{
                                        fmt.Println("No devices updated.")
                                        return
                                }</span>
                        }
                        <span class="cov0" title="0">err := ring.SetWeight(pth, devs, newWeight)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println(err)
                                os.Exit(1)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("Weight updated successfully.")
                        }</span>
                }

        case "remove":<span class="cov0" title="0">
                removeFlags := flag.NewFlagSet("set_weight", flag.ExitOnError)
                region := removeFlags.Int64("region", -1, "Device region.")
                zone := removeFlags.Int64("zone", -1, "Device zone.")
                ip := removeFlags.String("ip", "", "Device ip address.")
                port := removeFlags.Int64("port", -1, "Device port.")
                repIp := removeFlags.String("replication-ip", "", "Device replication address.")
                repPort := removeFlags.Int64("replication-port", -1, "Device replication port.")
                device := removeFlags.String("device", "", "Device name.")
                weight := removeFlags.Float64("weight", -1.0, "Device weight.")
                meta := removeFlags.String("meta", "", "Metadata.")
                scheme := removeFlags.String("scheme", "", "URI scheme(http/https).")
                purge := removeFlags.Bool("purge", false, "Purge device from the ring rather than leaving it but with a weight of -1.")
                yes := removeFlags.Bool("yes", false, "Force yes.")
                if err := removeFlags.Parse(args[2:]); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">devs, err := ring.Search(pth, *region, *zone, *ip, *port, *repIp, *repPort, *device, *weight, *meta, *scheme)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if len(devs) == 0 </span><span class="cov0" title="0">{
                        fmt.Println("No matching devices found.")
                        return
                }</span> else<span class="cov0" title="0"> {
                        reader := bufio.NewReader(os.Stdin)
                        fmt.Println("Search matched the following devices:")
                        PrintDevs(devs)
                        if !*yes </span><span class="cov0" title="0">{
                                fmt.Printf("Are you sure you want to remove these %d devices (y/n)? ", len(devs))
                                resp, err := reader.ReadString('\n')
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Println(err)
                                        os.Exit(1)
                                }</span>
                                <span class="cov0" title="0">if resp[0] != 'y' &amp;&amp; resp[0] != 'Y' </span><span class="cov0" title="0">{
                                        fmt.Println("No devices removed.")
                                        return
                                }</span>
                        }
                        <span class="cov0" title="0">err := ring.RemoveDevs(pth, devs, *purge)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println(err)
                                os.Exit(1)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("Devices removed successfully.")
                        }</span>
                }
        case "write_ring":<span class="cov0" title="0">
                if err := ring.WriteRing(pth); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>
        case "add":<span class="cov0" title="0">
                // TODO: Add config option version of add function
                // TODO: Add support for multiple adds in a single command
                var err error
                var region, zone, port, replicationPort int64
                var ip, replicationIp, device, scheme string
                var weight float64

                if len(args) &lt; 4 </span><span class="cov0" title="0">{
                        flags.Usage()
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">deviceStr := args[2]
                rx := regexp.MustCompile(`^(?:r(?P&lt;region&gt;\d+))?z(?P&lt;zone&gt;\d+)(?:s(?P&lt;scheme&gt;http|https))?-(?P&lt;ip&gt;[\d\.]+):(?P&lt;port&gt;\d+)(?:R(?P&lt;replication_ip&gt;[\d\.]+):(?P&lt;replication_port&gt;\d+))?\/(?P&lt;device&gt;[^_]+)(?:_(?P&lt;metadata&gt;.+))?$`)
                matches := rx.FindAllStringSubmatch(deviceStr, -1)
                if len(matches) == 0 </span><span class="cov0" title="0">{
                        flags.Usage()
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if matches[0][1] != "" </span><span class="cov0" title="0">{
                        region, err = strconv.ParseInt(matches[0][1], 0, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println(err)
                                os.Exit(1)
                        }</span>
                } else<span class="cov0" title="0"> {
                        region = 0
                }</span>
                <span class="cov0" title="0">zone, err = strconv.ParseInt(matches[0][2], 0, 64)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if matches[0][3] != "" </span><span class="cov0" title="0">{
                        scheme = matches[0][3]
                }</span> else<span class="cov0" title="0"> {
                        scheme = "http"
                }</span>
                <span class="cov0" title="0">ip = matches[0][4]
                port, err = strconv.ParseInt(matches[0][5], 0, 64)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">if matches[0][6] != "" </span><span class="cov0" title="0">{
                        replicationIp = matches[0][6]
                        replicationPort, err = strconv.ParseInt(matches[0][7], 0, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println(err)
                                os.Exit(1)
                        }</span>
                } else<span class="cov0" title="0"> {
                        replicationIp = ""
                        replicationPort = 0
                }</span>
                <span class="cov0" title="0">device = matches[0][8]
                weight, err = strconv.ParseFloat(args[3], 64)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">id, err := ring.AddDevice(pth, -1, region, zone, scheme, ip, port, replicationIp, replicationPort, device, weight, debug)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Device %s with %.2f weight added with id %d\n", device, weight, id)
                }</span>
        case "load":<span class="cov0" title="0">
                builder, err := ring.NewRingBuilderFromFile(pth, debug)
                fmt.Printf("%+v\n", builder)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>
        case "info":<span class="cov0" title="0">
                // Show info about the ring
                builder, err := ring.NewRingBuilderFromFile(pth, debug)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">regions := 0
                zones := 0
                devCount := 0
                balance := 0.0
                if len(builder.Devs) &gt; 0 </span><span class="cov0" title="0">{
                        regionSet := make(map[int64]bool)
                        zoneSet := make(map[string]bool)
                        for _, dev := range builder.Devs </span><span class="cov0" title="0">{
                                if dev != nil </span><span class="cov0" title="0">{
                                        regionSet[dev.Region] = true
                                        zoneSet[fmt.Sprintf("%d,%d", dev.Region, dev.Zone)] = true
                                        devCount += 1
                                }</span>
                        }
                        <span class="cov0" title="0">regions = len(regionSet)
                        zones = len(zoneSet)
                        balance = builder.GetBalance()</span>
                }
                <span class="cov0" title="0">if jsonOut </span><span class="cov0" title="0">{
                        b, err := json.Marshal(builder)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println(err)
                                os.Exit(1)
                        }</span>
                        <span class="cov0" title="0">os.Stdout.Write(b)
                        os.Stdout.Write([]byte("\n"))</span>
                } else<span class="cov0" title="0"> {
                        fmt.Printf("%s, build version %d, %d partitions, %.6f replicas, %d regions, %d zones, %d devices, %.02f balance\n", pth, builder.Version, builder.Parts, builder.Replicas, regions, zones, devCount, balance)
                        fmt.Printf("The minimum number of hours before a partition can be reassigned is %v (%v remaining)\n", builder.MinPartHours, time.Duration(builder.MinPartSecondsLeft())*time.Second)
                        fmt.Printf("The overload factor is %0.2f%% (%.6f)\n", builder.Overload*100, builder.Overload)

                        // Compare ring file against builder file
                        // TODO: Figure out how to do ring comparisons

                        PrintDevs(builder.Devs)
                }</span>

        case "analyze":<span class="cov0" title="0">
                epsilon := func(a, b float64) float64 </span><span class="cov0" title="0">{
                        // returns the ratio of the difference between two numbers to their average.
                        // this gives you a vague idea of how close two numbers are.
                        if a &gt; b </span><span class="cov0" title="0">{
                                return (a - b) / ((a + b) / 2.0)
                        }</span>
                        <span class="cov0" title="0">return (b - a) / ((a + b) / 2.0)</span>
                }
                <span class="cov0" title="0">builder, err := ring.NewRingBuilderFromFile(pth, debug)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">fmt.Printf("Analyzing %s...\n", pth)
                ring := builder.GetRing()
                fmt.Println("Total Partitions: ", ring.PartitionCount())
                replicas := int(ring.ReplicaCount())
                devs := ring.AllDevices()
                fmt.Println("Total Devices: ", len(devs))
                totalWeight := float64(0)
                devPartitions := make([]map[uint64]bool, len(devs))
                for i, dev := range devs </span><span class="cov0" title="0">{
                        if dev.Active() </span><span class="cov0" title="0">{
                                totalWeight += dev.Weight
                                devPartitions[i] = make(map[uint64]bool)
                        }</span>
                }
                <span class="cov0" title="0">partCounts := make([]int64, len(devs))
                for part := uint64(0); part &lt; ring.PartitionCount(); part++ </span><span class="cov0" title="0">{
                        for _, node := range ring.GetNodes(part) </span><span class="cov0" title="0">{
                                devPartitions[node.Id][part] = true
                                partCounts[node.Id]++
                        }</span>
                }

                <span class="cov0" title="0">for i, dev := range devs </span><span class="cov0" title="0">{
                        if dev.Active() </span><span class="cov0" title="0">{
                                want := (dev.Weight / totalWeight) * float64(ring.PartitionCount()) * float64(replicas)
                                if epsilon(float64(partCounts[i]), want) &gt; 0.02 </span><span class="cov0" title="0">{
                                        fmt.Println("Device", dev.Id, "partition count &gt;1% off its want:", partCounts[i], "vs", want)
                                }</span>
                        }
                }

                <span class="cov0" title="0">totalPairings := int64(0)
                for i, dev1 := range devs </span><span class="cov0" title="0">{
                        if dev1.Active() </span><span class="cov0" title="0">{
                                for _, dev2 := range devs[i:] </span><span class="cov0" title="0">{
                                        if dev2.Active() &amp;&amp; dev1.Id != dev2.Id </span><span class="cov0" title="0">{
                                                totalPairings += partCounts[dev1.Id] * partCounts[dev2.Id]
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">totalSharesRequired := ring.PartitionCount() * (ring.ReplicaCount() * ((ring.ReplicaCount() - 1) / 2))
                if ring.ReplicaCount() == 2 </span><span class="cov0" title="0">{
                        totalSharesRequired = ring.PartitionCount()
                }</span>
                <span class="cov0" title="0">for i, dev1 := range devs </span><span class="cov0" title="0">{
                        if dev1.Active() </span><span class="cov0" title="0">{
                                for _, dev2 := range devs[i:] </span><span class="cov0" title="0">{
                                        if dev2.Active() &amp;&amp; dev1.Id != dev2.Id </span><span class="cov0" title="0">{
                                                shouldShare := float64(partCounts[dev1.Id]*partCounts[dev2.Id]) *
                                                        (float64(totalSharesRequired) / float64(totalPairings))
                                                shared := float64(0)
                                                for part := range devPartitions[dev1.Id] </span><span class="cov0" title="0">{
                                                        if devPartitions[dev2.Id][part] </span><span class="cov0" title="0">{
                                                                shared++
                                                        }</span>
                                                }
                                                <span class="cov0" title="0">if epsilon(shared, shouldShare) &gt; 0.02 </span><span class="cov0" title="0">{
                                                        fmt.Println(dev1.Id, "and", dev2.Id, "should share", shouldShare, "partitions, but share", shared)
                                                }</span>
                                        }
                                }
                        }
                }

                <span class="cov0" title="0">regions := make(map[int]bool)
                zones := make(map[int]bool)
                ips := make(map[string]bool)
                devices := make(map[string]bool)
                primaryCounts := make(map[int][]int, len(devs))
                for _, dev := range devs </span><span class="cov0" title="0">{
                        if dev.Active() </span><span class="cov0" title="0">{
                                regions[dev.Region] = true
                                ips[dev.Ip] = true
                                zones[dev.Zone] = true
                                devices[fmt.Sprintf("%s:%s", dev.Ip, dev.Device)] = true
                                primaryCounts[dev.Id] = make([]int, replicas)
                        }</span>
                }
                <span class="cov0" title="0">for part := uint64(0); part &lt; ring.PartitionCount(); part++ </span><span class="cov0" title="0">{
                        partRegions := make(map[int]bool)
                        partZones := make(map[int]bool)
                        partIps := make(map[string]bool)
                        partDevices := make(map[string]bool)
                        for _, dev := range ring.GetNodes(part) </span><span class="cov0" title="0">{
                                partRegions[dev.Region] = true
                                partZones[dev.Zone] = true
                                partIps[dev.Ip] = true
                                partDevices[fmt.Sprintf("%s:%s", dev.Ip, dev.Device)] = true
                        }</span>
                        <span class="cov0" title="0">if len(partRegions) &lt; len(regions) &amp;&amp; len(partRegions) &lt; replicas </span><span class="cov0" title="0">{
                                fmt.Printf("Partition %d uses %d/%d available regions.\n", part, len(partRegions), len(regions))
                        }</span>
                        <span class="cov0" title="0">if len(partZones) &lt; len(zones) &amp;&amp; len(partZones) &lt; replicas </span><span class="cov0" title="0">{
                                fmt.Printf("Partition %d uses %d/%d available zones.\n", part, len(partZones), len(zones))
                        }</span>
                        <span class="cov0" title="0">if len(partIps) &lt; len(ips) &amp;&amp; len(partIps) &lt; replicas </span><span class="cov0" title="0">{
                                fmt.Printf("Partition %d uses %d/%d available IPs.\n", part, len(partIps), len(ips))
                        }</span>
                        <span class="cov0" title="0">if len(partDevices) &lt; len(devices) &amp;&amp; len(partDevices) &lt; replicas </span><span class="cov0" title="0">{
                                fmt.Printf("Partition %d uses %d/%d available devices.", part, len(partDevices), len(devices))
                        }</span>

                        <span class="cov0" title="0">for i, node := range ring.GetNodes(part) </span><span class="cov0" title="0">{
                                primaryCounts[node.Id][i]++
                        }</span>
                }
                <span class="cov0" title="0">for _, dev := range devs </span><span class="cov0" title="0">{
                        if dev.Active() </span><span class="cov0" title="0">{
                                expectedParts := float64(ring.PartitionCount()) * float64(dev.Weight) / totalWeight
                                for i, parts := range primaryCounts[dev.Id] </span><span class="cov0" title="0">{
                                        if epsilon(float64(parts), float64(expectedParts)) &gt; 0.02 </span><span class="cov0" title="0">{
                                                fmt.Println(dev.Id, "is primary number", i, "for", parts, "partitions, but that should be", int(expectedParts))
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">fmt.Println("Done!")</span>

        case "validate":<span class="cov0" title="0">
                err := ring.Validate(pth)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        os.Exit(1)
                }</span>
        default:<span class="cov0" title="0">
                fmt.Printf("Unknown command: %s\n", cmd)
                flags.Usage()
                os.Exit(1)</span>
        }

}
</pre>
		
		<pre class="file" id="file120" style="display: none">package tools

// The ring monitor will constantly scan the on-disk rings to detect when they
// change or need to be rebalanced. It will queue replication jobs when it
// detects changes by comparing the new and old rings. It will also trigger a
// fast-scan for the ring scan process to send out new rings.
//
// In /etc/hummingbird/andrewd-server.conf:
// [ring-monitor]
// initial_delay = 1      # seconds to wait between ring checks for the first pass
// pass_time_target = 60  # seconds to try to make subsequent passes take
// report_interval = 600  # seconds between progress reports

import (
        "fmt"
        "math/rand"
        "sync"
        "sync/atomic"
        "time"

        "github.com/troubling/hummingbird/common/ring"
        "go.uber.org/zap"
)

type ringMonitor struct {
        aa *AutoAdmin
        // delay between each ring check; adjusted each pass to try to make passes last passTimeTarget
        delay            time.Duration
        passTimeTarget   time.Duration
        reportInterval   time.Duration
        prefix           string
        suffix           string
        ringMD5CacheLock sync.Mutex
        ringMD5Cache     map[string]map[int]ring.RingMD5
}

func newRingMonitor(aa *AutoAdmin) *ringMonitor <span class="cov0" title="0">{
        rm := &amp;ringMonitor{
                aa:             aa,
                delay:          time.Duration(aa.serverconf.GetInt("ring-monitor", "initial_delay", 1)) * time.Second,
                passTimeTarget: time.Duration(aa.serverconf.GetInt("ring-monitor", "pass_time_target", 60)) * time.Second,
                reportInterval: time.Duration(aa.serverconf.GetInt("ring-monitor", "report_interval", 600)) * time.Second,
                ringMD5Cache:   map[string]map[int]ring.RingMD5{},
        }
        if rm.delay &lt; 0 </span><span class="cov0" title="0">{
                rm.delay = time.Second
        }</span>
        <span class="cov0" title="0">if rm.passTimeTarget &lt; 0 </span><span class="cov0" title="0">{
                rm.passTimeTarget = time.Second
        }</span>
        <span class="cov0" title="0">if rm.reportInterval &lt; 0 </span><span class="cov0" title="0">{
                rm.reportInterval = time.Second
        }</span>
        <span class="cov0" title="0">rm.prefix, rm.suffix = getAffixes()
        rm.ringMD5Cache["account"] = map[int]ring.RingMD5{}
        rm.ringMD5Cache["container"] = map[int]ring.RingMD5{}
        rm.ringMD5Cache["object"] = map[int]ring.RingMD5{}
        return rm</span>
}

func (rm *ringMonitor) runForever() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                sleepFor := rm.runOnce()
                if sleepFor &lt; 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">time.Sleep(sleepFor)</span>
        }
}

type ringTaskInstance struct {
        typ           string
        policy        int
        ring          ring.RingMD5
        previousMD5   string
        nextRebalance time.Time
}

func (rm *ringMonitor) runOnce() time.Duration <span class="cov0" title="0">{
        start := time.Now()
        logger := rm.aa.logger.With(zap.String("process", "ring monitor"))
        logger.Debug("starting pass")
        if err := rm.aa.db.startProcessPass("ring monitor", "", 0); err != nil </span><span class="cov0" title="0">{
                logger.Error("startProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">var delays int64
        var errors int64
        var partitionCopiesChanged int64
        var ringTasks []*ringTaskInstance
        ryng, err := rm.GetRingMD5("account", 0)
        if err != nil </span><span class="cov0" title="0">{
                errors++
                logger.Error("could not load ring", zap.String("type", "account"), zap.Int("policy", 0), zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                ringTasks = append(ringTasks, &amp;ringTaskInstance{
                        typ:  "account",
                        ring: ryng,
                })
        }</span>
        <span class="cov0" title="0">ryng, err = rm.GetRingMD5("container", 0)
        if err != nil </span><span class="cov0" title="0">{
                errors++
                logger.Error("could not load ring", zap.String("type", "container"), zap.Int("policy", 0), zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                ringTasks = append(ringTasks, &amp;ringTaskInstance{
                        typ:  "container",
                        ring: ryng,
                })
        }</span>
        <span class="cov0" title="0">for _, policy := range rm.aa.policies </span><span class="cov0" title="0">{
                if !policy.Deprecated </span><span class="cov0" title="0">{
                        ryng, err = rm.GetRingMD5("object", policy.Index)
                        if err != nil </span><span class="cov0" title="0">{
                                errors++
                                logger.Error("could not load ring", zap.String("type", "object"), zap.Int("policy", policy.Index), zap.Error(err))
                                continue</span>
                        }
                        <span class="cov0" title="0">ringTasks = append(ringTasks, &amp;ringTaskInstance{
                                typ:    "object",
                                policy: policy.Index,
                                ring:   ryng,
                        })</span>
                }
        }
        <span class="cov0" title="0">cancel := make(chan struct{})
        progressDone := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-cancel:<span class="cov0" title="0">
                                close(progressDone)
                                return</span>
                        case &lt;-time.After(rm.reportInterval):<span class="cov0" title="0">
                                d := atomic.LoadInt64(&amp;delays)
                                e := atomic.LoadInt64(&amp;errors)
                                p := atomic.LoadInt64(&amp;partitionCopiesChanged)
                                var eta time.Duration
                                if d &gt; 0 </span><span class="cov0" title="0">{
                                        eta = time.Duration(int64(time.Since(start)) / d * (int64(len(ringTasks)) - d))
                                }</span>
                                <span class="cov0" title="0">logger.Debug("progress", zap.Int64("rings so far", d), zap.Int("total rings", len(ringTasks)), zap.Int64("errors", e), zap.Int64("partition copies changed", p), zap.String("eta", eta.String()))
                                if err := rm.aa.db.progressProcessPass("ring monitor", "", 0, fmt.Sprintf("%d of %d rings, %d errors, %d partition copies changed, eta %s", d, len(ringTasks), e, p, eta)); err != nil </span><span class="cov0" title="0">{
                                        logger.Error("progressProcessPass", zap.Error(err))
                                }</span>
                        }
                }
        }()
        <span class="cov0" title="0">for _, ringTask := range ringTasks </span><span class="cov0" title="0">{
                atomic.AddInt64(&amp;delays, 1)
                time.Sleep(rm.delay)
                taskLogger := logger.With(zap.String("type", ringTask.typ), zap.Int("policy", ringTask.policy))
                if ringTask.previousMD5 == "" </span><span class="cov0" title="0">{
                        ringTask.previousMD5, ringTask.nextRebalance, err = rm.aa.db.ringHash(ringTask.typ, ringTask.policy)
                        if err != nil </span><span class="cov0" title="0">{
                                atomic.AddInt64(&amp;errors, 1)
                                taskLogger.Error("couldn't retreive previous hash", zap.Error(err))
                                continue</span>
                        }
                }
                <span class="cov0" title="0">if ringTask.ring.MD5() == ringTask.previousMD5 &amp;&amp; !ringTask.nextRebalance.IsZero() &amp;&amp; time.Now().After(ringTask.nextRebalance) </span><span class="cov0" title="0">{
                        if !rm.rebalance(taskLogger, ringTask) </span><span class="cov0" title="0">{
                                atomic.AddInt64(&amp;errors, 1)
                                continue</span>
                        }
                }
                <span class="cov0" title="0">if ringTask.ring.MD5() == ringTask.previousMD5 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">rm.aa.fastRingScan &lt;- struct{}{}
                if ringTask.previousMD5 == "" </span><span class="cov0" title="0">{
                        // First time seeing this ring
                        rm.aa.db.setRingHash(ringTask.typ, ringTask.policy, ringTask.ring.MD5(), time.Now().Add(randomDuration(time.Minute*30, time.Hour)))
                        continue</span>
                }
                <span class="cov0" title="0">changeTaskLogger := taskLogger.With(zap.String("previous md5", ringTask.previousMD5), zap.String("current md5", ringTask.ring.MD5()))
                changeTaskLogger.Debug("ring md5 changed")
                previousRing := ringTask.ring.RingMatching(ringTask.previousMD5)
                if previousRing == nil </span><span class="cov0" title="0">{
                        atomic.AddInt64(&amp;errors, 1)
                        changeTaskLogger.Error("can't find previous ring; assuming nothing changed")
                        rm.aa.db.setRingHash(ringTask.typ, ringTask.policy, ringTask.ring.MD5(), time.Now().Add(randomDuration(time.Minute*30, time.Hour)))
                        continue</span>
                }
                <span class="cov0" title="0">partitionCount := previousRing.PartitionCount()
                if partitionCount != ringTask.ring.PartitionCount() </span><span class="cov0" title="0">{
                        atomic.AddInt64(&amp;errors, 1)
                        changeTaskLogger.Error(
                                "cannot handle changing partition counts; assuming new ring as if no previous ring ever existed",
                                zap.Uint64("previous partition count", previousRing.PartitionCount()),
                                zap.Uint64("current partition count", ringTask.ring.PartitionCount()),
                        )
                        rm.aa.db.setRingHash(ringTask.typ, ringTask.policy, ringTask.ring.MD5(), time.Now().Add(randomDuration(time.Minute*30, time.Hour)))
                        continue</span>
                }
                <span class="cov0" title="0">replicaCount := previousRing.ReplicaCount()
                if replicaCount != ringTask.ring.ReplicaCount() </span><span class="cov0" title="0">{
                        atomic.AddInt64(&amp;errors, 1)
                        changeTaskLogger.Error(
                                "cannot handle changing replica counts; assuming new ring as if no previous ring ever existed",
                                zap.Uint64("previous replica count", previousRing.ReplicaCount()),
                                zap.Uint64("current replica count", ringTask.ring.ReplicaCount()),
                        )
                        rm.aa.db.setRingHash(ringTask.typ, ringTask.policy, ringTask.ring.MD5(), time.Now().Add(randomDuration(time.Minute*30, time.Hour)))
                        continue</span>
                }
                <span class="cov0" title="0">failed := false
                for partition := uint64(0); partition &lt; partitionCount &amp;&amp; !failed; partition++ </span><span class="cov0" title="0">{
                        previousDev := previousRing.GetNodes(partition)
                        currentDev := ringTask.ring.GetNodes(partition)
                        for replica := uint64(0); replica &lt; replicaCount; replica++ </span><span class="cov0" title="0">{
                                if previousDev[replica].Id != currentDev[replica].Id </span><span class="cov0" title="0">{
                                        if err := rm.aa.db.queuePartitionReplication(
                                                ringTask.typ,
                                                ringTask.policy,
                                                partition,
                                                "ring change",
                                                previousDev[replica].Id,
                                                currentDev[replica].Id,
                                        ); err != nil </span><span class="cov0" title="0">{
                                                atomic.AddInt64(&amp;errors, 1)
                                                changeTaskLogger.Error(
                                                        "could not queue ring change; will try again next pass",
                                                        zap.Uint64("partition", partition),
                                                        zap.Uint64("replica", replica),
                                                        zap.Int("previous id", previousDev[replica].Id),
                                                        zap.Int("current id", currentDev[replica].Id),
                                                        zap.Error(err),
                                                )
                                                failed = true
                                                break</span>
                                        } else<span class="cov0" title="0"> {
                                                atomic.AddInt64(&amp;partitionCopiesChanged, 1)
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">if !failed </span><span class="cov0" title="0">{
                        if err = rm.aa.db.setRingHash(ringTask.typ, ringTask.policy, ringTask.ring.MD5(), time.Now().Add(randomDuration(time.Minute*30, time.Hour))); err != nil </span><span class="cov0" title="0">{
                                atomic.AddInt64(&amp;errors, 1)
                                changeTaskLogger.Error(
                                        "could not record the new ring hash; will try again next pass",
                                        zap.Error(err),
                                )
                        }</span>
                }
        }
        <span class="cov0" title="0">close(cancel)
        &lt;-progressDone
        if delays &gt; 0 </span><span class="cov0" title="0">{
                rm.delay = rm.passTimeTarget / time.Duration(delays)
        }</span>
        <span class="cov0" title="0">sleepFor := time.Until(start.Add(rm.passTimeTarget))
        if sleepFor &lt; 0 </span><span class="cov0" title="0">{
                sleepFor = 0
        }</span>
        <span class="cov0" title="0">logger.Debug("pass complete", zap.Int("total rings", len(ringTasks)), zap.Int64("errors", errors), zap.Int64("partition copies changed", partitionCopiesChanged), zap.String("next delay", rm.delay.String()), zap.String("sleep for", sleepFor.String()))
        if err := rm.aa.db.progressProcessPass("ring monitor", "", 0, fmt.Sprintf("%d of %d rings, %d errors, %d partition copies changed", delays, len(ringTasks), errors, partitionCopiesChanged)); err != nil </span><span class="cov0" title="0">{
                logger.Error("progressProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">if err := rm.aa.db.completeProcessPass("ring monitor", "", 0); err != nil </span><span class="cov0" title="0">{
                logger.Error("completeProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">return sleepFor</span>
}

func (rm *ringMonitor) GetRingMD5(typ string, policy int) (ring.RingMD5, error) <span class="cov0" title="0">{
        rm.ringMD5CacheLock.Lock()
        defer rm.ringMD5CacheLock.Unlock()
        if ryng, ok := rm.ringMD5Cache[typ][policy]; ok </span><span class="cov0" title="0">{
                return ryng, ryng.Reload()
        }</span>
        <span class="cov0" title="0">ryng, err := ring.GetRingMD5(typ, rm.prefix, rm.suffix, policy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">rm.ringMD5Cache[typ][policy] = ryng
        return ryng, nil</span>
}

func (rm *ringMonitor) rebalance(logger *zap.Logger, ringTask *ringTaskInstance) bool <span class="cov0" title="0">{
        ringBuilder, ringBuilderFilePath, err := ring.GetRingBuilder(ringTask.typ, ringTask.policy)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Could not find builder", zap.Error(err))
                return false
        }</span>
        <span class="cov0" title="0">ringBuilderLock, err := ring.LockBuilderPath(ringBuilderFilePath)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Could not lock builder path", zap.String("ring builder file path", ringBuilderFilePath), zap.Error(err))
                return false
        }</span>
        <span class="cov0" title="0">defer ringBuilderLock.Close()
        ringBuilder, ringBuilderFilePath, err = ring.GetRingBuilder(ringTask.typ, ringTask.policy)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Could not find builder after lock", zap.Error(err))
                return false
        }</span>
        <span class="cov0" title="0">var changedReplicas int
        changedReplicas, _, _, err = ring.Rebalance(ringBuilderFilePath, false, false, true)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error while rebalancing", zap.String("path", ringBuilderFilePath), zap.Error(err))
                return false
        }</span>
        <span class="cov0" title="0">md5BeforeRebalance := ringTask.ring.MD5()
        if ringTask.ring, err = rm.GetRingMD5(ringTask.typ, ringTask.policy); err != nil </span><span class="cov0" title="0">{
                logger.Error("could not load modified ring", zap.Error(err))
                return false
        }</span>
        // So we don't get stuck rebalancing a ring by tiny amounts for forever:
        <span class="cov0" title="0">settled := float64(changedReplicas)/(float64(ringBuilder.Parts)*ringBuilder.Replicas) &lt; 0.01
        if settled </span><span class="cov0" title="0">{
                for _, dev := range ringTask.ring.AllDevices() </span><span class="cov0" title="0">{
                        if dev == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if dev.Weight == 0 &amp;&amp; ringTask.ring.AssignmentCount(dev.Id) &gt; 0 </span><span class="cov0" title="0">{
                                settled = false
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">if settled </span><span class="cov0" title="0">{
                rm.aa.db.addRingLog(ringTask.typ, ringTask.policy, fmt.Sprintf("rebalanced due to schedule; now settled"))
                rm.aa.db.setRingHash(ringTask.typ, ringTask.policy, md5BeforeRebalance, time.Time{})
        }</span> else<span class="cov0" title="0"> {
                rm.aa.db.addRingLog(ringTask.typ, ringTask.policy, fmt.Sprintf("rebalanced due to schedule"))
                rm.aa.db.setRingHash(ringTask.typ, ringTask.policy, md5BeforeRebalance, time.Now().Add(time.Hour*time.Duration(ringBuilder.MinPartHours)+randomDuration(time.Minute, 15*time.Minute)))
        }</span>
        <span class="cov0" title="0">return true</span>
}

func randomDuration(min, max time.Duration) time.Duration <span class="cov0" title="0">{
        return time.Duration(int64(min) + rand.Int63n(int64(max)-int64(min)+1))
}</span>
</pre>
		
		<pre class="file" id="file121" style="display: none">package tools

// The ring scan process will constantly compare the rings servers have with
// the local rings and send out new rings as needed. By default, it will lazily
// scan servers, trying to hit each one about every ten minutes. But, if a
// fast-scan is triggered because a ring just changed locally, the ring scan
// process will go as quickly as it can to send out the new rings.
//
// In /etc/hummingbird/andrewd-server.conf:
// [ring-scan]
// initial_delay = 1            # seconds to wait between ring checks for the first pass
// pass_time_target = 600       # seconds to try to make subsequent passes take
// report_interval = 600        # seconds between progress reports
// fast_scan_concurrency = 25   # number of concurrent ring transfers allowed

// Example from recon:
// $ curl http://localhost:6010/recon/ringmd5
// {
//   "/etc/hummingbird/account.ring.gz": "50637e9e0eac3b5d085d21950b697f6b",
//   "/etc/hummingbird/container.ring.gz": "488602c6c8f0aa7c48c389524a8ec22b",
//   "/etc/hummingbird/object-1.ring.gz": "a16b7943bfe21cba5e0b42f811b67fba",
//   "/etc/hummingbird/object-2.ring.gz": "3529ce642ff99b724140f7af92a7f014",
//   "/etc/hummingbird/object.ring.gz": "94744009e53c8c4d1895b534285cd78c"
// }

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "net/url"
        "os"
        "path"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/troubling/hummingbird/common/ring"
        "go.uber.org/zap"
)

type ringScan struct {
        aa *AutoAdmin
        // delay between each ring check; adjusted each pass to try to make passes last passTimeTarget
        delay               time.Duration
        passTimeTarget      time.Duration
        reportInterval      time.Duration
        fastScanConcurrency int
        fastScan            bool
        prefix              string
        suffix              string
        ringMD5CacheLock    sync.Mutex
        ringMD5Cache        map[string]map[int]ring.RingMD5
}

func newRingScan(aa *AutoAdmin) *ringScan <span class="cov0" title="0">{
        rs := &amp;ringScan{
                aa:                  aa,
                delay:               time.Duration(aa.serverconf.GetInt("ring-scan", "initial_delay", 1)) * time.Second,
                passTimeTarget:      time.Duration(aa.serverconf.GetInt("ring-scan", "pass_time_target", 600)) * time.Second,
                reportInterval:      time.Duration(aa.serverconf.GetInt("ring-scan", "report_interval", 600)) * time.Second,
                fastScanConcurrency: int(aa.serverconf.GetInt("ring-scan", "fast_scan_concurrency", 25)),
                ringMD5Cache:        map[string]map[int]ring.RingMD5{},
        }
        if rs.delay &lt; 0 </span><span class="cov0" title="0">{
                rs.delay = time.Second
        }</span>
        <span class="cov0" title="0">if rs.passTimeTarget &lt; 0 </span><span class="cov0" title="0">{
                rs.passTimeTarget = time.Second
        }</span>
        <span class="cov0" title="0">if rs.reportInterval &lt; 0 </span><span class="cov0" title="0">{
                rs.reportInterval = time.Second
        }</span>
        <span class="cov0" title="0">if rs.fastScanConcurrency &lt; 1 </span><span class="cov0" title="0">{
                rs.fastScanConcurrency = 1
        }</span>
        <span class="cov0" title="0">rs.fastScan = true
        rs.prefix, rs.suffix = getAffixes()
        rs.ringMD5Cache["account"] = map[int]ring.RingMD5{}
        rs.ringMD5Cache["container"] = map[int]ring.RingMD5{}
        rs.ringMD5Cache["object"] = map[int]ring.RingMD5{}
        return rs</span>
}

func (rs *ringScan) runForever() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                sleepFor := rs.runOnce()
                if sleepFor &lt; 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">select </span>{
                case &lt;-rs.aa.fastRingScan:<span class="cov0" title="0">
                CLEAR:
                        for </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-rs.aa.fastRingScan:</span><span class="cov0" title="0">
                                default:<span class="cov0" title="0">
                                        break CLEAR</span>
                                }
                        }
                        <span class="cov0" title="0">rs.fastScan = true
                        rs.runOnce()
                        rs.fastScan = false</span>
                case &lt;-time.After(sleepFor):</span><span class="cov0" title="0">
                }
        }
}

func (rs *ringScan) runOnce() time.Duration <span class="cov0" title="0">{
        start := time.Now()
        logger := rs.aa.logger.With(zap.String("process", "ring scan"))
        if rs.fastScan </span><span class="cov0" title="0">{
                logger.Debug("starting fast scan")
                if err := rs.aa.db.startProcessPass("ring scan", "", 0); err != nil </span><span class="cov0" title="0">{
                        logger.Error("startProcessPass", zap.Error(err))
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Debug("starting pass")
                if err := rs.aa.db.startProcessPass("ring scan", "", 0); err != nil </span><span class="cov0" title="0">{
                        logger.Error("startProcessPass", zap.Error(err))
                }</span>
        }
        <span class="cov0" title="0">var delays int64
        var errors int64
        urls := rs.ringMD5URLs()
        cancel := make(chan struct{})
        progressDone := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-cancel:<span class="cov0" title="0">
                                close(progressDone)
                                return</span>
                        case &lt;-time.After(rs.reportInterval):<span class="cov0" title="0">
                                d := atomic.LoadInt64(&amp;delays)
                                e := atomic.LoadInt64(&amp;errors)
                                var eta time.Duration
                                if d &gt; 0 </span><span class="cov0" title="0">{
                                        eta = time.Duration(int64(time.Since(start)) / d * (int64(len(urls)) - d))
                                }</span>
                                <span class="cov0" title="0">logger.Debug("progress", zap.Int64("urls so far", d), zap.Int("total urls", len(urls)), zap.String("eta", eta.String()))
                                if err := rs.aa.db.progressProcessPass("ring scan", "", 0, fmt.Sprintf("%d of %d urls, %d errors, eta %s", d, len(urls), e, eta)); err != nil </span><span class="cov0" title="0">{
                                        logger.Error("progressProcessPass", zap.Error(err))
                                }</span>
                        }
                }
        }()
        <span class="cov0" title="0">reconURL := func(getURL string) </span><span class="cov0" title="0">{
                atomic.AddInt64(&amp;delays, 1)
                getLogger := logger.With(zap.String("method", "GET"), zap.String("url", getURL))
                req, err := http.NewRequest("GET", getURL, nil)
                if err != nil </span><span class="cov0" title="0">{
                        getLogger.Error("http.NewRequest", zap.Error(err))
                        atomic.AddInt64(&amp;errors, 1)
                        return
                }</span>
                <span class="cov0" title="0">resp, err := rs.aa.client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        getLogger.Error("Do", zap.Error(err))
                        atomic.AddInt64(&amp;errors, 1)
                        return
                }</span>
                <span class="cov0" title="0">body, err := ioutil.ReadAll(resp.Body)
                resp.Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        getLogger.Error("Body", zap.Int("StatusCode", resp.StatusCode), zap.Error(err))
                        atomic.AddInt64(&amp;errors, 1)
                        return
                }</span>
                <span class="cov0" title="0">if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                        getLogger.Error("StatusCode", zap.Int("StatusCode", resp.StatusCode), zap.Error(err))
                        atomic.AddInt64(&amp;errors, 1)
                        return
                }</span>
                <span class="cov0" title="0">ringMD5s := map[string]string{}
                if err := json.Unmarshal(body, &amp;ringMD5s); err != nil </span><span class="cov0" title="0">{
                        getLogger.Error("JSON", zap.String("JSON", string(body)), zap.Error(err))
                        atomic.AddInt64(&amp;errors, 1)
                        return
                }</span>
                <span class="cov0" title="0">getLogger.Debug("response", zap.Any("ring md5s", ringMD5s))
                for ringPath, md5 := range ringMD5s </span><span class="cov0" title="0">{
                        if !strings.HasSuffix(ringPath, ".ring.gz") </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">parts := strings.SplitN(strings.SplitN(path.Base(ringPath), ".", 2)[0], "-", 2)
                        typ := parts[0]
                        policy := 0
                        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                                policy, err = strconv.Atoi(parts[1])
                                if err != nil </span><span class="cov0" title="0">{
                                        getLogger.Error("policy parsing error", zap.String("ring path", ringPath), zap.Error(err))
                                        atomic.AddInt64(&amp;errors, 1)
                                        continue</span>
                                }
                        }
                        <span class="cov0" title="0">getLogger.Debug("parsed", zap.String("type", typ), zap.Int("policy", policy), zap.String("md5", md5))
                        ryng, err := rs.GetRingMD5(typ, policy)
                        if err != nil </span><span class="cov0" title="0">{
                                getLogger.Error("error getting ring", zap.String("type", typ), zap.Int("policy", policy), zap.String("md5", md5), zap.Error(err))
                                atomic.AddInt64(&amp;errors, 1)
                                continue</span>
                        }
                        <span class="cov0" title="0">if md5 != ryng.MD5() </span><span class="cov0" title="0">{
                                getLogger.Debug("pushing ring", zap.String("type", typ), zap.Int("policy", policy), zap.String("previous md5", md5), zap.String("new md5", ryng.MD5()))
                                u, err := url.Parse(getURL)
                                if err != nil </span><span class="cov0" title="0">{
                                        getLogger.Error("url.Parse", zap.String("url", getURL), zap.Error(err))
                                        atomic.AddInt64(&amp;errors, 1)
                                        continue</span>
                                }
                                <span class="cov0" title="0">putURL := fmt.Sprintf("%s://%s/ring%s", u.Scheme, u.Host, ringPath)
                                putLogger := logger.With(zap.String("method", "PUT"), zap.String("url", putURL))
                                fp, err := os.Open(ryng.DiskPath())
                                if err != nil </span><span class="cov0" title="0">{
                                        getLogger.Error("os.Open", zap.String("disk path", ryng.DiskPath()), zap.Error(err))
                                        atomic.AddInt64(&amp;errors, 1)
                                        continue</span>
                                }
                                <span class="cov0" title="0">func() </span><span class="cov0" title="0">{ // sub func so we can have the defer
                                        defer fp.Close()
                                        req, err := http.NewRequest("PUT", putURL, fp)
                                        if err != nil </span><span class="cov0" title="0">{
                                                putLogger.Error("http.NewRequest", zap.Error(err))
                                                atomic.AddInt64(&amp;errors, 1)
                                                return
                                        }</span>
                                        <span class="cov0" title="0">req.Header.Set("Etag", ryng.MD5())
                                        resp, err := rs.aa.client.Do(req)
                                        if err != nil </span><span class="cov0" title="0">{
                                                putLogger.Error("Do", zap.Error(err))
                                                atomic.AddInt64(&amp;errors, 1)
                                                return
                                        }</span>
                                        <span class="cov0" title="0">resp.Body.Close()
                                        if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                                                putLogger.Error("StatusCode", zap.Int("StatusCode", resp.StatusCode), zap.Error(err))
                                                atomic.AddInt64(&amp;errors, 1)
                                                return
                                        }</span>
                                }()
                        }
                }
        }
        <span class="cov0" title="0">fullpass := true
        if rs.fastScan </span><span class="cov0" title="0">{
                var wg sync.WaitGroup
                fastScanURLs := make(chan string, rs.fastScanConcurrency)
                for i := 0; i &lt; rs.fastScanConcurrency; i++ </span><span class="cov0" title="0">{
                        wg.Add(1)
                        go func() </span><span class="cov0" title="0">{
                                defer wg.Done()
                                for </span><span class="cov0" title="0">{
                                        url := &lt;-fastScanURLs
                                        if url == "" </span><span class="cov0" title="0">{
                                                return
                                        }</span>
                                        <span class="cov0" title="0">reconURL(url)</span>
                                }
                        }()
                }
                <span class="cov0" title="0">for _, url := range urls </span><span class="cov0" title="0">{
                        fastScanURLs &lt;- url
                }</span>
                <span class="cov0" title="0">close(fastScanURLs)
                wg.Wait()</span>
        } else<span class="cov0" title="0"> {
        STANDARDSCAN:
                for _, url := range urls </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-rs.aa.fastRingScan:<span class="cov0" title="0">
                                fullpass = false
                                rs.aa.fastRingScan &lt;- struct{}{}
                                break STANDARDSCAN</span>
                        case &lt;-time.After(rs.delay):<span class="cov0" title="0">
                                reconURL(url)</span>
                        }
                }
        }
        <span class="cov0" title="0">close(cancel)
        &lt;-progressDone
        if !rs.fastScan &amp;&amp; fullpass &amp;&amp; delays &gt; 0 </span><span class="cov0" title="0">{
                rs.delay = rs.passTimeTarget / time.Duration(delays)
        }</span>
        <span class="cov0" title="0">sleepFor := time.Until(start.Add(rs.passTimeTarget))
        if sleepFor &lt; 0 </span><span class="cov0" title="0">{
                sleepFor = 0
        }</span>
        <span class="cov0" title="0">if rs.fastScan </span><span class="cov0" title="0">{
                logger.Debug("fast scan complete", zap.Int64("errors", errors))
        }</span> else<span class="cov0" title="0"> {
                logger.Debug("pass complete", zap.Int64("errors", errors), zap.String("next delay", rs.delay.String()), zap.String("sleep for", sleepFor.String()))
        }</span>
        <span class="cov0" title="0">if err := rs.aa.db.progressProcessPass("ring scan", "", 0, fmt.Sprintf("%d of %d urls, %d errors", delays, len(urls), errors)); err != nil </span><span class="cov0" title="0">{
                logger.Error("progressProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">if err := rs.aa.db.completeProcessPass("ring scan", "", 0); err != nil </span><span class="cov0" title="0">{
                logger.Error("completeProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">return sleepFor</span>
}

// ringMD5URLs returns a list of urls used to obtain the MD5s of the rings on
// that server, based on all the devices on all the servers in all the rings
// for the hummingbird configuration. Note that this distills down to one per
// IP destination. If there are account, container, and object servers running
// on the same IP, it is assumed they all share the same /etc/hummingbird or
// /etc/swift directory, and the recon/ringmd5 call will return the MD5s for
// all the ring files in that directory.
func (rs *ringScan) ringMD5URLs() []string <span class="cov0" title="0">{
        urlMap := map[string]string{}
        for _, typ := range []string{"account", "container", "object"} </span><span class="cov0" title="0">{
                if typ == "object" </span><span class="cov0" title="0">{
                        for _, policy := range rs.aa.policies </span><span class="cov0" title="0">{
                                ryng, _ := getRing("", typ, policy.Index)
                                for _, dev := range ryng.AllDevices() </span><span class="cov0" title="0">{
                                        if !dev.Active() </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">urlMap[dev.Ip] = fmt.Sprintf("%s://%s:%d/recon/ringmd5", dev.Scheme, dev.Ip, dev.Port)</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        ryng, _ := getRing("", typ, 0)
                        for _, dev := range ryng.AllDevices() </span><span class="cov0" title="0">{
                                if !dev.Active() </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">urlMap[dev.Ip] = fmt.Sprintf("%s://%s:%d/recon/ringmd5", dev.Scheme, dev.Ip, dev.Port)</span>
                        }
                }
        }
        <span class="cov0" title="0">urls := make([]string, 0, len(urlMap))
        for _, url := range urlMap </span><span class="cov0" title="0">{
                urls = append(urls, url)
        }</span>
        <span class="cov0" title="0">return urls</span>
}

func (rs *ringScan) GetRingMD5(typ string, policy int) (ring.RingMD5, error) <span class="cov0" title="0">{
        rs.ringMD5CacheLock.Lock()
        defer rs.ringMD5CacheLock.Unlock()
        if ryng, ok := rs.ringMD5Cache[typ][policy]; ok </span><span class="cov0" title="0">{
                return ryng, ryng.Reload()
        }</span>
        <span class="cov0" title="0">ryng, err := ring.GetRingMD5(typ, rs.prefix, rs.suffix, policy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">rs.ringMD5Cache[typ][policy] = ryng
        return ryng, nil</span>
}
</pre>
		
		<pre class="file" id="file122" style="display: none">package tools

// In /etc/hummingbird/andrewd-server.conf:
// [unmounted-monitor]
// initial_delay = 1                # seconds to wait between requests for the first pass
// pass_time_target = 600           # seconds to try to make subsequent passes take
// report_interval = 60             # seconds between progress reports
// state_retention = 86400          # seconds to retain state entries
// server_down_limit = 14400        # seconds a server can be down before removal
// device_unmounted_limit = 3600    # seconds a device can be unmounted before removal
// ignore_duration = 14400          # seconds to ignore a device's state change after updating its state in a ring

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "sync/atomic"
        "time"

        "github.com/troubling/hummingbird/common/ring"
        "go.uber.org/zap"
)

type unmountedMonitor struct {
        aa *AutoAdmin
        // delay between each request; adjusted each pass to try to make passes last passTimeTarget
        delay                time.Duration
        passTimeTarget       time.Duration
        reportInterval       time.Duration
        stateRetention       time.Duration
        serverDownLimit      time.Duration
        deviceUnmountedLimit time.Duration
        ignoreDuration       time.Duration
        ignore               map[string]time.Time
}

func newUnmountedMonitor(aa *AutoAdmin) *unmountedMonitor <span class="cov0" title="0">{
        um := &amp;unmountedMonitor{
                aa:                   aa,
                delay:                time.Duration(aa.serverconf.GetInt("unmounted-monitor", "initial_delay", 10)) * time.Second,
                passTimeTarget:       time.Duration(aa.serverconf.GetInt("unmounted-monitor", "pass_time_target", 600)) * time.Second,
                reportInterval:       time.Duration(aa.serverconf.GetInt("unmounted-monitor", "report_interval", 60)) * time.Second,
                stateRetention:       time.Duration(aa.serverconf.GetInt("unmounted-monitor", "state_retention", 86400)) * time.Second,
                serverDownLimit:      time.Duration(aa.serverconf.GetInt("unmounted-monitor", "server_down_limit", 14400)) * time.Second,
                deviceUnmountedLimit: time.Duration(aa.serverconf.GetInt("unmounted-monitor", "device_unmounted_limit", 3600)) * time.Second,
                ignoreDuration:       time.Duration(aa.serverconf.GetInt("unmounted-monitor", "ignore_duration", 14400)) * time.Second,
                ignore:               map[string]time.Time{},
        }
        if um.delay &lt; 0 </span><span class="cov0" title="0">{
                um.delay = time.Second
        }</span>
        <span class="cov0" title="0">if um.passTimeTarget &lt; 0 </span><span class="cov0" title="0">{
                um.passTimeTarget = time.Second
        }</span>
        <span class="cov0" title="0">if um.reportInterval &lt; 0 </span><span class="cov0" title="0">{
                um.reportInterval = time.Second
        }</span>
        <span class="cov0" title="0">return um</span>
}

func (um *unmountedMonitor) runForever() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                sleepFor := um.runOnce()
                if sleepFor &lt; 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">time.Sleep(sleepFor)</span>
        }
}

func (um *unmountedMonitor) runOnce() time.Duration <span class="cov0" title="0">{
        type reconData struct {
                Device  string
                Mounted bool
        }
        start := time.Now()
        logger := um.aa.logger.With(zap.String("process", "unmounted monitor"))
        logger.Debug("starting pass")
        if err := um.aa.db.startProcessPass("unmounted monitor", "", 0); err != nil </span><span class="cov0" title="0">{
                logger.Error("startProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">var delays int64
        var errors int64
        var serversUp int64
        var serversDown int64
        var devicesMounted int64
        var devicesUnmounted int64
        endpoints := um.reconUnmountedEndpoints()
        cancel := make(chan struct{})
        progressDone := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-cancel:<span class="cov0" title="0">
                                close(progressDone)
                                return</span>
                        case &lt;-time.After(um.reportInterval):<span class="cov0" title="0">
                                d := atomic.LoadInt64(&amp;delays)
                                e := atomic.LoadInt64(&amp;errors)
                                up := atomic.LoadInt64(&amp;serversUp)
                                down := atomic.LoadInt64(&amp;serversDown)
                                mounted := atomic.LoadInt64(&amp;devicesMounted)
                                unmounted := atomic.LoadInt64(&amp;devicesUnmounted)
                                var eta time.Duration
                                if d &gt; 0 </span><span class="cov0" title="0">{
                                        eta = time.Duration(int64(time.Since(start)) / d * (int64(len(endpoints)) - d))
                                }</span>
                                <span class="cov0" title="0">logger.Debug("progress", zap.Int64("endpoints so far", d), zap.Int("total endpoints", len(endpoints)), zap.Int64("errors", e), zap.Int64("servers up", up), zap.Int64("servers down", down), zap.Int64("mounted devices", mounted), zap.Int64("unmounted devices", unmounted), zap.String("eta", eta.String()))
                                if err := um.aa.db.progressProcessPass("unmounted monitor", "", 0, fmt.Sprintf("%d of %d endpoints, %d errors, %d/%d servers up/down, %d/%d devices mounted/unmounted, eta %s", d, len(endpoints), e, up, down, mounted, unmounted, eta)); err != nil </span><span class="cov0" title="0">{
                                        logger.Error("progressProcessPass", zap.Error(err))
                                }</span>
                        }
                }
        }()
        <span class="cov0" title="0">for url, endpoint := range endpoints </span><span class="cov0" title="0">{
                atomic.AddInt64(&amp;delays, 1)
                time.Sleep(um.delay)
                reconLogger := logger.With(zap.String("method", "GET"), zap.String("url", url))
                req, err := http.NewRequest("GET", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        reconLogger.Error("http.NewRequest", zap.Error(err))
                        atomic.AddInt64(&amp;errors, 1)
                        continue</span>
                }
                <span class="cov0" title="0">resp, err := um.aa.client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        reconLogger.Error("Do", zap.Error(err))
                        atomic.AddInt64(&amp;serversDown, 1)
                        um.serverDown(reconLogger, endpoint.ip, endpoint.port)
                        continue</span>
                }
                <span class="cov0" title="0">body, err := ioutil.ReadAll(resp.Body)
                resp.Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        reconLogger.Error("Body", zap.Int("StatusCode", resp.StatusCode), zap.Error(err))
                        atomic.AddInt64(&amp;serversDown, 1)
                        um.serverDown(reconLogger, endpoint.ip, endpoint.port)
                        continue</span>
                }
                <span class="cov0" title="0">if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                        reconLogger.Error("StatusCode", zap.Int("StatusCode", resp.StatusCode), zap.Error(err))
                        atomic.AddInt64(&amp;serversDown, 1)
                        um.serverDown(reconLogger, endpoint.ip, endpoint.port)
                        continue</span>
                }
                <span class="cov0" title="0">var items []*reconData
                if err := json.Unmarshal(body, &amp;items); err != nil </span><span class="cov0" title="0">{
                        reconLogger.Error("JSON", zap.String("JSON", string(body)), zap.Error(err))
                        atomic.AddInt64(&amp;serversDown, 1)
                        um.serverDown(reconLogger, endpoint.ip, endpoint.port)
                        continue</span>
                }
                <span class="cov0" title="0">atomic.AddInt64(&amp;serversUp, 1)
                um.serverUp(reconLogger, endpoint.ip, endpoint.port)
                for _, item := range items </span><span class="cov0" title="0">{
                        devLogger := reconLogger.With(zap.String("device", item.Device))
                        if item.Mounted </span><span class="cov0" title="0">{
                                atomic.AddInt64(&amp;devicesMounted, 1)
                                um.deviceMounted(devLogger, endpoint.ip, endpoint.port, item.Device)
                        }</span> else<span class="cov0" title="0"> {
                                atomic.AddInt64(&amp;devicesUnmounted, 1)
                                um.deviceUnmounted(devLogger, endpoint.ip, endpoint.port, item.Device)
                        }</span>
                }
        }
        <span class="cov0" title="0">close(cancel)
        &lt;-progressDone
        um.delay = um.passTimeTarget / time.Duration(delays)
        sleepFor := time.Until(start.Add(um.passTimeTarget))
        if sleepFor &lt; 0 </span><span class="cov0" title="0">{
                sleepFor = 0
        }</span>
        <span class="cov0" title="0">logger.Debug("pass complete", zap.Int64("errors", errors), zap.Int64("servers up", serversUp), zap.Int64("servers down", serversDown), zap.Int64("devices mounted", devicesMounted), zap.Int64("devices unmounted", devicesUnmounted), zap.String("next delay", um.delay.String()), zap.String("sleep for", sleepFor.String()))
        if err := um.aa.db.progressProcessPass("unmounted monitor", "", 0, fmt.Sprintf("%d of %d endpoints, %d errors, %d/%d servers up/down, %d/%d devices mounted/unmounted", delays, len(endpoints), errors, serversUp, serversDown, devicesMounted, devicesUnmounted)); err != nil </span><span class="cov0" title="0">{
                logger.Error("progressProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">if err := um.aa.db.completeProcessPass("unmounted monitor", "", 0); err != nil </span><span class="cov0" title="0">{
                logger.Error("completeProcessPass", zap.Error(err))
        }</span>
        <span class="cov0" title="0">return sleepFor</span>
}

type endpointIPPort struct {
        ip   string
        port int
}

func (um *unmountedMonitor) reconUnmountedEndpoints() map[string]*endpointIPPort <span class="cov0" title="0">{
        endpointMap := map[string]*endpointIPPort{}
        for _, typ := range []string{"account", "container", "object"} </span><span class="cov0" title="0">{
                if typ == "object" </span><span class="cov0" title="0">{
                        for _, policy := range um.aa.policies </span><span class="cov0" title="0">{
                                ryng, _ := getRing("", typ, policy.Index)
                                for _, dev := range ryng.AllDevices() </span><span class="cov0" title="0">{
                                        if dev == nil || dev.Weight &lt; 0 </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">endpointMap[fmt.Sprintf("%s://%s:%d/recon/diskusage", dev.Scheme, dev.Ip, dev.Port)] = &amp;endpointIPPort{ip: dev.Ip, port: dev.Port}</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        ryng, _ := getRing("", typ, 0)
                        for _, dev := range ryng.AllDevices() </span><span class="cov0" title="0">{
                                if dev == nil || dev.Weight &lt; 0 </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">endpointMap[fmt.Sprintf("%s://%s:%d/recon/diskusage", dev.Scheme, dev.Ip, dev.Port)] = &amp;endpointIPPort{ip: dev.Ip, port: dev.Port}</span>
                        }
                }
        }
        <span class="cov0" title="0">return endpointMap</span>
}

func (um *unmountedMonitor) serverUp(logger *zap.Logger, ip string, port int) <span class="cov0" title="0">{
        if err := um.aa.db.addServerState(ip, port, true, time.Now().Add(-um.stateRetention)); err != nil </span><span class="cov0" title="0">{
                logger.Error("could not add server up state", zap.Error(err))
        }</span>
}

func (um *unmountedMonitor) serverDown(logger *zap.Logger, ip string, port int) <span class="cov0" title="0">{
        if err := um.aa.db.addServerState(ip, port, false, time.Now().Add(-um.stateRetention)); err != nil </span><span class="cov0" title="0">{
                logger.Error("could not add server down state", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">var lastUp time.Time
        states, err := um.aa.db.serverStates(ip, port)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("could not retrieve server states", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">for _, entry := range states </span><span class="cov0" title="0">{
                if entry.state </span><span class="cov0" title="0">{
                        lastUp = entry.recorded
                        break</span>
                }
        }
        // If there were no "up" entries...
        <span class="cov0" title="0">if lastUp.IsZero() </span><span class="cov0" title="0">{
                if len(states) &gt; 0 </span><span class="cov0" title="0">{
                        // Just pretend it was last "up" at the time of the oldest entry.
                        lastUp = states[len(states)-1].recorded
                }</span> else<span class="cov0" title="0"> {
                        // It would be weird if there are no entries, since we supposedly
                        // just added one. But, in that case, just get outta here.
                        return
                }</span>
        }
        <span class="cov0" title="0">if time.Since(lastUp) &lt; um.serverDownLimit </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">um.removeFromBuilders(logger, ip, port, "")</span>
}

func (um *unmountedMonitor) deviceMounted(logger *zap.Logger, ip string, port int, device string) <span class="cov0" title="0">{
        logger.Debug("device mounted")
        if err := um.aa.db.addDeviceState(ip, port, device, true, time.Now().Add(-um.stateRetention)); err != nil </span><span class="cov0" title="0">{
                logger.Error("could not add device mounted state", zap.Error(err))
        }</span>
}

func (um *unmountedMonitor) deviceUnmounted(logger *zap.Logger, ip string, port int, device string) <span class="cov0" title="0">{
        logger.Debug("device unmounted")
        if err := um.aa.db.addDeviceState(ip, port, device, false, time.Now().Add(-um.stateRetention)); err != nil </span><span class="cov0" title="0">{
                logger.Error("could not add device unmounted state", zap.Error(err))
        }</span>
        <span class="cov0" title="0">var lastUp time.Time
        states, err := um.aa.db.deviceStates(ip, port, device)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("could not retrieve device states", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">for _, entry := range states </span><span class="cov0" title="0">{
                if entry.state </span><span class="cov0" title="0">{
                        lastUp = entry.recorded
                        break</span>
                }
        }
        <span class="cov0" title="0">logger.Debug("device unmounted, last up initially", zap.String("last up", lastUp.String()))
        // If there were no "up" entries...
        if lastUp.IsZero() </span><span class="cov0" title="0">{
                if len(states) &gt; 0 </span><span class="cov0" title="0">{
                        // Just pretend it was last "up" at the time of the oldest entry.
                        lastUp = states[len(states)-1].recorded
                        logger.Debug("device unmounted, last up assumed", zap.String("last up", lastUp.String()))
                }</span> else<span class="cov0" title="0"> {
                        // It would be weird if there are no entries, since we supposedly
                        // just added one. But, in that case, just get outta here.
                        logger.Error("device unmounted, NO ENTRIES!")
                        return
                }</span>
        }
        <span class="cov0" title="0">logger.Debug("device unmounted, duration check", zap.String("last up", lastUp.String()), zap.String("limit", um.deviceUnmountedLimit.String()), zap.String("elapsed", time.Since(lastUp).String()))
        if time.Since(lastUp) &lt; um.deviceUnmountedLimit </span><span class="cov0" title="0">{
                logger.Debug("device unmounted, but not long enough yet")
                return
        }</span>
        <span class="cov0" title="0">logger.Debug("device unmounted, it's time to remove it")
        um.removeFromBuilders(logger, ip, port, device)
        logger.Debug("device unmounted, done trying to remove it")</span>
}

func (um *unmountedMonitor) removeFromBuilders(logger *zap.Logger, ip string, port int, device string) <span class="cov0" title="0">{
        for _, typ := range []string{"account", "container", "object"} </span><span class="cov0" title="0">{
                if typ == "object" </span><span class="cov0" title="0">{
                        for _, policy := range um.aa.policies </span><span class="cov0" title="0">{
                                um.removeFromBuilder(logger, ip, port, device, typ, policy.Index)
                        }</span>
                } else<span class="cov0" title="0"> {
                        um.removeFromBuilder(logger, ip, port, device, typ, 0)
                }</span>
        }
}

func (um *unmountedMonitor) removeFromBuilder(logger *zap.Logger, ip string, port int, device, typ string, policy int) <span class="cov0" title="0">{
        ignoreKey := fmt.Sprintf("%s:%d/%s/%s/%d", ip, port, device, typ, policy)
        if time.Now().Before(um.ignore[ignoreKey]) </span><span class="cov0" title="0">{
                logger.Debug("ignoring", zap.String("ignore key", ignoreKey), zap.String("until", um.ignore[ignoreKey].String()))
                return
        }</span>
        <span class="cov0" title="0">ringBuilder, ringBuilderFilePath, err := ring.GetRingBuilder(typ, policy)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Could not find builder", zap.String("type", typ), zap.Int("policy", policy), zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">ringBuilderLock, err := ring.LockBuilderPath(ringBuilderFilePath)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Could not lock builder path", zap.String("type", typ), zap.Int("policy", policy), zap.String("ring builder file path", ringBuilderFilePath), zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">defer ringBuilderLock.Close()
        ringBuilder, ringBuilderFilePath, err = ring.GetRingBuilder(typ, policy)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Could not find builder after lock", zap.String("type", typ), zap.Int("policy", policy), zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">changed := false
        for _, dev := range ringBuilder.SearchDevs(-1, -1, ip, int64(port), "", -1, device, -1, "", "") </span><span class="cov0" title="0">{
                if dev.Weight &gt;= 0 </span><span class="cov0" title="0">{
                        ringBuilder.RemoveDev(dev.Id, false)
                        changed = true
                        if device == "" </span><span class="cov0" title="0">{
                                um.aa.db.addRingLog(typ, policy, fmt.Sprintf("server %s:%d down; removed device %s id:%d", ip, port, dev.Device, dev.Id))
                        }</span> else<span class="cov0" title="0"> {
                                um.aa.db.addRingLog(typ, policy, fmt.Sprintf("removed unmounted device %s id:%d on server %s:%d", dev.Device, dev.Id, ip, port))
                        }</span>
                }
        }
        <span class="cov0" title="0">if !changed </span><span class="cov0" title="0">{
                um.ignore[ignoreKey] = time.Now().Add(um.ignoreDuration)
                logger.Debug("not changed; now ignoring", zap.String("ignore key", ignoreKey), zap.String("until", um.ignore[ignoreKey].String()))
                return
        }</span>
        <span class="cov0" title="0">err = ringBuilder.Save(ringBuilderFilePath)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error while saving builder", zap.String("type", typ), zap.Int("policy", policy), zap.String("path", ringBuilderFilePath), zap.Error(err))
        }</span>
        <span class="cov0" title="0">_, _, _, err = ring.Rebalance(ringBuilderFilePath, false, false, true)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error while rebalancing", zap.String("type", typ), zap.Int("policy", policy), zap.String("path", ringBuilderFilePath), zap.Error(err))
        }</span>
        <span class="cov0" title="0">if device == "" </span><span class="cov0" title="0">{
                um.aa.db.addRingLog(typ, policy, fmt.Sprintf("rebalanced due to downed server %s:%d", ip, port))
        }</span> else<span class="cov0" title="0"> {
                um.aa.db.addRingLog(typ, policy, fmt.Sprintf("rebalanced due to downed device %s on %s:%d", device, ip, port))
        }</span>
        // NOTE: The ringmonitor.go will detect the above ring changes on disk and
        // initiate a fastscan for ringscan.go to push out the new rings.
        <span class="cov0" title="0">um.ignore[ignoreKey] = time.Now().Add(um.ignoreDuration)
        logger.Debug("changed; will now ignore", zap.String("ignore key", ignoreKey), zap.String("until", um.ignore[ignoreKey].String()))</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
